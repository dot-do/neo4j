{"id":"neo4j-00x","title":"REFACTOR: MATCH Clause Translation","description":"## Overview\nRefactor MATCH clause translation for cleanliness and extensibility.\n\n## Refactoring Tasks\n\n### 1. Query Builder Pattern\n- Fluent API for building SELECT queries\n- Chainable methods for FROM, JOIN, WHERE\n\n### 2. Join Type Abstraction\n- INNER JOIN, LEFT JOIN, CROSS JOIN strategies\n- Clean interface for join generation\n\n### 3. Variable Scope Manager\n- Track variable visibility across clauses\n- Handle shadowing and rebinding\n\n### 4. Pattern Combination Logic\n- Extract pattern connection detection\n- Optimize join order\n\n## Quality Improvements\n- No code duplication\n- Single responsibility per function\n- Comprehensive type definitions\n- Performance profiling\n\n## Acceptance Criteria\n- All tests still pass after refactoring\n- Code is more readable and maintainable\n- No new technical debt\n\n## TDD Phase\nREFACTOR - Improve code quality while keeping tests green\n\n## Dependencies\n- Depends on: GREEN: MATCH Clause Translation","status":"closed","priority":1,"issue_type":"task","created_at":"2026-01-05T06:38:07.355028-06:00","updated_at":"2026-01-05T08:57:46.158051-06:00","closed_at":"2026-01-05T08:57:46.158051-06:00","close_reason":"Translation and session tests passing"}
{"id":"neo4j-03qw","title":"RED: Record.entries() - Write failing tests for key-value pairs","description":"## Overview\nWrite failing tests for the Record.entries() method that returns array of [key, value] pairs.\n\n## Test Cases to Write\n\n```typescript\ndescribe('Record.entries()', () =\u003e {\n  it('should return array of [key, value] pairs', () =\u003e {\n    const record = new Record(['name', 'age'], ['Alice', 30]);\n    expect(record.entries()).toEqual([\n      ['name', 'Alice'],\n      ['age', 30]\n    ]);\n  });\n\n  it('should return empty array for empty record', () =\u003e {\n    const record = new Record([], []);\n    expect(record.entries()).toEqual([]);\n  });\n\n  it('should preserve field order', () =\u003e {\n    const record = new Record(['c', 'a', 'b'], [3, 1, 2]);\n    expect(record.entries()).toEqual([\n      ['c', 3],\n      ['a', 1],\n      ['b', 2]\n    ]);\n  });\n\n  it('should handle null and undefined values', () =\u003e {\n    const record = new Record(['a', 'b'], [null, undefined]);\n    expect(record.entries()).toEqual([\n      ['a', null],\n      ['b', undefined]\n    ]);\n  });\n\n  it('should return new array each time', () =\u003e {\n    const record = new Record(['name'], ['Alice']);\n    const e1 = record.entries();\n    const e2 = record.entries();\n    expect(e1).not.toBe(e2);\n    expect(e1).toEqual(e2);\n  });\n\n  it('should be iterable with for-of', () =\u003e {\n    const record = new Record(['a', 'b'], [1, 2]);\n    const pairs: Array\u003c[string, any]\u003e = [];\n    for (const [key, value] of record.entries()) {\n      pairs.push([key, value]);\n    }\n    expect(pairs).toEqual([['a', 1], ['b', 2]]);\n  });\n});\n```\n\n## Acceptance Criteria\n- [ ] All tests written and failing (RED phase)\n- [ ] Tests verify [key, value] tuple format\n- [ ] Tests verify iteration compatibility\n- [ ] Test file created at src/result/__tests__/record-entries.test.ts\n\n## TDD Phase\nRED - Tests should fail because entries method does not exist yet","status":"closed","priority":1,"issue_type":"task","created_at":"2026-01-05T06:41:00.872834-06:00","updated_at":"2026-01-05T08:55:15.889256-06:00","closed_at":"2026-01-05T08:55:15.889256-06:00","close_reason":"Record methods already implemented with tests"}
{"id":"neo4j-041x","title":"GREEN: Implement rxTx.isOpen() method","description":"## Overview\nImplement rxTx.isOpen() to make all RED tests pass.\n\n## Implementation Requirements\n\n### Method Signature\n```typescript\ninterface RxTransaction {\n  isOpen(): boolean\n}\n```\n\n### Implementation Details\n- Return current transaction state\n- Synchronous access (not Observable)\n- Track state through lifecycle\n- Update on commit/rollback/error\n\n### State Management\n- Initialize as open\n- Close on commit/rollback\n- Close on error\n- Thread-safe updates\n\n## Acceptance Criteria\n- All RED tests now pass (GREEN phase)\n- Returns correct boolean state\n- State properly tracked\n- Synchronous access works","status":"open","priority":2,"issue_type":"task","created_at":"2026-01-05T06:40:18.582095-06:00","updated_at":"2026-01-05T06:40:18.582095-06:00"}
{"id":"neo4j-04d","title":"RED: Write failing tests for rxSession.executeRead() method","description":"## Overview\nWrite failing tests for rxSession.executeRead() transaction function for read operations.\n\n## Test Cases to Write\n\n### Basic Transaction Function Tests\n- executeRead(work) returns Observable\n- Work function receives RxManagedTransaction\n- Work function can run queries\n- Returns result of work function\n\n### Transaction Behavior Tests\n- Transaction auto-commits on success\n- Transaction auto-rollbacks on error\n- Read access mode is enforced\n- Bookmarks are respected\n\n### Observable Semantics Tests\n- Cold observable (lazy execution)\n- Proper completion on success\n- Error emission on failure\n- Supports async work functions\n\n### Retry Behavior Tests\n- Retries on transient errors\n- Respects retry configuration\n- Non-retriable errors propagate immediately\n\n## Acceptance Criteria\n- All tests written and failing (RED phase)\n- Tests cover transaction lifecycle\n- Tests verify Observable behavior\n- Tests cover retry scenarios","status":"open","priority":2,"issue_type":"task","created_at":"2026-01-05T06:36:04.311815-06:00","updated_at":"2026-01-05T06:36:04.311815-06:00"}
{"id":"neo4j-070","title":"[RED] AST: Visitor Pattern Tests","description":"## Overview\nWrite failing tests for AST visitor pattern implementation.\n\n## Test Cases to Write\n\n### Visitor Interface\n```typescript\ninterface ASTVisitor\u003cT\u003e {\n  visitQuery(node: Query): T\n  visitMatchClause(node: MatchClause): T\n  visitReturnClause(node: ReturnClause): T\n  visitNodePattern(node: NodePattern): T\n  visitBinaryExpression(node: BinaryExpression): T\n  // ... all node types\n}\n```\n\n### Base Visitor\n- Test default visit behavior (visit children)\n- Test visit method dispatching\n- Test pre/post visit hooks\n\n### Walk Function\n```typescript\nfunction walk(node: ASTNode, visitor: ASTVisitor): void\nfunction walkExpression(node: Expression, visitor: ASTVisitor): void\n```\n\n### Test Scenarios\n- Count all nodes of a specific type\n- Collect all identifiers\n- Transform expressions\n- Validate patterns\n\n### Enter/Exit Pattern\n```typescript\ninterface ASTVisitor {\n  enter?(node: ASTNode): void\n  exit?(node: ASTNode): void\n  enterMatchClause?(node: MatchClause): void\n  exitMatchClause?(node: MatchClause): void\n}\n```\n\n## Acceptance Criteria\n- [ ] All visitor tests written\n- [ ] Tests cover visitor dispatch\n- [ ] Tests verify traversal order\n- [ ] Transform use case tested\n\n## TDD Phase: RED","status":"closed","priority":1,"issue_type":"task","created_at":"2026-01-05T06:38:51.020059-06:00","updated_at":"2026-01-05T08:58:01.75404-06:00","closed_at":"2026-01-05T08:58:01.75404-06:00","close_reason":"AST, lexer and types tests passing"}
{"id":"neo4j-0be","title":"REFACTOR: Driver Lifecycle Methods Optimization","description":"## Overview\nRefactor Driver lifecycle methods for robustness and edge case handling.\n\n## Refactoring Goals\n\n### Concurrency Safety\n- Thread-safe session tracking\n- Atomic close operation\n- Race condition prevention\n\n### Resource Management\n- WeakRef for session tracking (memory efficiency)\n- Proper cleanup on unexpected errors\n- Timeout handling for stuck sessions\n\n### Edge Cases\n```typescript\ndescribe('Driver Lifecycle Edge Cases', () =\u003e {\n  it('should handle concurrent session creation')\n  it('should handle session close during driver close')\n  it('should handle executeQuery during driver close')\n  it('should timeout waiting for sessions on close')\n  it('should handle rapid open/close cycles')\n  it('should recover from partial initialization')\n  it('should handle getServerInfo with network partition')\n})\n```\n\n### Observability\n- Add telemetry hooks\n- Session lifecycle logging\n- Connection pool metrics\n\n## TDD Phase\n**REFACTOR** - Improve without breaking tests.\n\n## Dependencies\n- Depends on: GREEN: Driver Lifecycle Methods Implementation\n\n## Acceptance Criteria\n- [ ] All tests pass\n- [ ] Concurrent operations are safe\n- [ ] Memory leaks eliminated\n- [ ] Graceful degradation on errors","status":"open","priority":2,"issue_type":"task","created_at":"2026-01-05T06:35:57.587463-06:00","updated_at":"2026-01-05T06:35:57.587463-06:00"}
{"id":"neo4j-0bw","title":"GREEN: CREATE/MERGE Translation","description":"## Overview\nImplement CREATE and MERGE clause translation to make RED tests pass.\n\n## Implementation Tasks\n\n### 1. CreateClauseTranslator\n- translateCreateNode(): Generate INSERT INTO nodes\n- translateCreateRelationship(): Generate INSERT INTO relationships\n- generateId(): UUID generation for new entities\n\n### 2. MergeClauseTranslator\n- translateMergeNode(): INSERT OR IGNORE pattern\n- translateMergeRelationship(): Upsert with conflict handling\n- handleOnCreate(): Conditional SET for new entities\n- handleOnMatch(): Conditional SET for existing entities\n\n### 3. Property Serialization\n- Serialize property maps to JSON\n- Handle nested objects and arrays\n\n### 4. Variable Binding for Created Entities\n- Return created IDs for later use\n- Bind variables to new entities\n\n## Files to Create/Modify\n- src/cypher/translator/create-clause-translator.ts\n- src/cypher/translator/merge-clause-translator.ts\n- src/cypher/translator/id-generator.ts\n\n## Acceptance Criteria\n- All RED phase tests pass\n- MERGE correctly uses INSERT OR IGNORE\n- ON CREATE/ON MATCH conditions work\n\n## TDD Phase\nGREEN - Make tests pass with minimal code\n\n## Dependencies\n- Depends on: RED: CREATE/MERGE Translation","status":"closed","priority":1,"issue_type":"task","created_at":"2026-01-05T06:38:42.427213-06:00","updated_at":"2026-01-05T08:57:46.157069-06:00","closed_at":"2026-01-05T08:57:46.157069-06:00","close_reason":"Translation and session tests passing"}
{"id":"neo4j-0d9","title":"[RED] Lexer: Numeric Literal Tests","description":"## Overview\nWrite failing tests for numeric literal tokenization.\n\n## Test Cases to Write\n\n### Integer Literals\n- Simple: `0`, `1`, `123`, `999999`\n- Negative: `-1`, `-123` (may be operator + integer)\n- Leading zeros: `007` (should be valid integer)\n\n### Floating Point Literals\n- Simple: `1.0`, `3.14`, `0.5`\n- No leading digit: `.5` (if supported)\n- No trailing digit: `5.` (if supported)\n- Negative: `-1.5`\n\n### Scientific Notation\n- Lowercase: `1e10`, `1e-10`, `1e+10`\n- Uppercase: `1E10`, `1E-10`\n- With decimal: `1.5e10`, `3.14e-5`\n\n### Hexadecimal Literals\n- Lowercase: `0x1a`, `0xff`\n- Uppercase: `0X1A`, `0xFF`\n- Mixed: `0xDeAdBeEf`\n\n### Octal Literals (if supported)\n- `0o777`, `0O123`\n\n### Edge Cases\n- Number at end of input\n- Number followed by identifier (should be two tokens)\n- Invalid number formats (error cases)\n\n## Acceptance Criteria\n- [ ] All tests written and failing\n- [ ] Tests cover integers, floats, scientific, hex\n- [ ] Edge cases documented\n- [ ] Error cases have proper messages\n\n## TDD Phase: RED","status":"closed","priority":1,"issue_type":"task","created_at":"2026-01-05T06:35:42.892714-06:00","updated_at":"2026-01-05T08:48:00.960618-06:00","closed_at":"2026-01-05T08:48:00.960618-06:00","close_reason":"Tests passing - implementation complete"}
{"id":"neo4j-0h4","title":"GREEN: Record.length - Implement column count property","description":"## Overview\nImplement the Record.length property to make all RED phase tests pass.\n\n## Implementation\n\n```typescript\nget length(): number {\n  return this._keys.length;\n}\n```\n\n## Acceptance Criteria\n- [ ] All RED phase tests now pass (GREEN phase)\n- [ ] Returns correct column count\n- [ ] Property is read-only\n- [ ] Implementation is minimal\n\n## TDD Phase\nGREEN - Minimal implementation to pass tests\n\n## Dependencies\n- neo4j-gjj (RED phase tests)","status":"closed","priority":1,"issue_type":"task","created_at":"2026-01-05T06:38:29.570807-06:00","updated_at":"2026-01-05T08:57:33.737736-06:00","closed_at":"2026-01-05T08:57:33.737736-06:00","close_reason":"Record methods already implemented with tests"}
{"id":"neo4j-0jw","title":"REFACTOR: Improve rxSession.close() implementation","description":"## Overview\nRefactor rxSession.close() for robust resource management.\n\n## Refactoring Tasks\n\n### Code Quality\n- Extract cleanup logic\n- Improve error handling during cleanup\n- Add proper state management\n- Document cleanup order\n\n### Resource Safety\n- Ensure cleanup happens even on errors\n- Handle partial cleanup failures\n- Add cleanup timeout handling\n- Consider finalize operator usage\n\n### Integration\n- Align with sync session.close()\n- Share cleanup logic where possible\n- Consistent logging of cleanup\n\n## Acceptance Criteria\n- All tests still pass\n- Robust cleanup handling\n- Clear error reporting\n- Well-documented cleanup process","status":"open","priority":2,"issue_type":"task","created_at":"2026-01-05T06:38:10.38188-06:00","updated_at":"2026-01-05T06:38:10.38188-06:00"}
{"id":"neo4j-0qoe","title":"RED: Query Optimization - Predicate Pushdown","description":"## Overview\nWrite failing tests for query optimization through predicate pushdown.\n\n## Test Cases to Write\n\n### Test 1: Push WHERE to Pattern\n- MATCH (n) WHERE n.name = 'Alice' should filter early\n\n### Test 2: Push Filter Before JOIN\n- Filter should happen before expensive JOINs\n\n### Test 3: Label Filter Pushdown\n- (n:Person) filter applied at scan time\n\n### Test 4: Relationship Type Pushdown\n- [:KNOWS] filter applied during relationship scan\n\n### Test 5: Combined Predicate Pushdown\n- Multiple filters pushed to optimal positions\n\n### Test 6: Cannot Push After Aggregation\n- Predicates on aggregates stay in HAVING\n\n### Test 7: Index Hint Usage\n- USING INDEX hint translates to query hint\n\n### Test 8: Property Existence Push\n- WHERE EXISTS(n.email) -\u003e Optimized check\n\n## Acceptance Criteria\n- All tests written and failing\n- Pushdown cases identified\n- Optimization opportunities detected\n\n## TDD Phase\nRED - Write failing tests first","status":"open","priority":2,"issue_type":"task","created_at":"2026-01-05T06:44:09.218375-06:00","updated_at":"2026-01-05T06:44:09.218375-06:00"}
{"id":"neo4j-0v86","title":"[RED] Performance Benchmark: Memory Usage","description":"# [RED] Performance Benchmark: Memory Usage\n\n## Overview\nBenchmark memory usage patterns for neo4j.do, critical for Cloudflare Workers' 128MB memory limit.\n\n## Memory Benchmarks\n\n### Baseline Memory Usage\n```typescript\ndescribe('Baseline Memory Benchmarks', () =\u003e {\n  it('should measure idle memory footprint', async () =\u003e {\n    // Get baseline before any operations\n    const baseline = process.memoryUsage()\n    \n    // Initialize driver\n    const driver = neo4j.driver('bolt://localhost', auth)\n    const afterInit = process.memoryUsage()\n    \n    console.log('Memory after driver init:', {\n      heapUsed: `${((afterInit.heapUsed - baseline.heapUsed) / 1024 / 1024).toFixed(2)}MB`,\n      heapTotal: `${(afterInit.heapTotal / 1024 / 1024).toFixed(2)}MB`\n    })\n    \n    // Create session\n    const session = driver.session()\n    const afterSession = process.memoryUsage()\n    \n    console.log('Memory after session:', {\n      heapUsed: `${((afterSession.heapUsed - baseline.heapUsed) / 1024 / 1024).toFixed(2)}MB`\n    })\n    \n    await session.close()\n    await driver.close()\n  })\n\n  it('should measure memory per active session', async () =\u003e {\n    const driver = neo4j.driver('bolt://localhost', auth)\n    const baseline = process.memoryUsage()\n    \n    const sessions = []\n    for (let i = 0; i \u003c 10; i++) {\n      sessions.push(driver.session())\n    }\n    \n    const afterSessions = process.memoryUsage()\n    const memPerSession = (afterSessions.heapUsed - baseline.heapUsed) / 10 / 1024\n    \n    console.log(`Memory per session: ${memPerSession.toFixed(2)}KB`)\n    expect(memPerSession).toBeLessThan(100) // Target: \u003c100KB per session\n    \n    await Promise.all(sessions.map(s =\u003e s.close()))\n    await driver.close()\n  })\n})\n```\n\n### Query Result Memory\n```typescript\ndescribe('Query Result Memory Benchmarks', () =\u003e {\n  beforeAll(async () =\u003e {\n    // Create test data\n    await session.run(`\n      UNWIND range(1, 10000) AS i\n      CREATE (n:MemTest {\n        id: i,\n        data: repeat('x', 100)\n      })\n    `)\n  })\n\n  it('should measure memory for large result set', async () =\u003e {\n    const baseline = process.memoryUsage()\n    \n    const result = await session.run('MATCH (n:MemTest) RETURN n')\n    \n    const afterQuery = process.memoryUsage()\n    const memUsed = (afterQuery.heapUsed - baseline.heapUsed) / 1024 / 1024\n    \n    console.log(`Memory for 10k records: ${memUsed.toFixed(2)}MB`)\n    console.log(`Memory per record: ${(memUsed * 1024 / 10000).toFixed(2)}KB`)\n  })\n\n  it('should measure streaming vs buffered memory', async () =\u003e {\n    // Buffered approach\n    const bufferedBaseline = process.memoryUsage()\n    const bufferedResult = await session.run('MATCH (n:MemTest) RETURN n')\n    const allRecords = bufferedResult.records\n    const bufferedMem = process.memoryUsage().heapUsed - bufferedBaseline.heapUsed\n    \n    // Streaming approach\n    const streamBaseline = process.memoryUsage()\n    const streamResult = session.run('MATCH (n:MemTest) RETURN n')\n    let count = 0\n    for await (const record of streamResult) {\n      count++\n      // Process and discard immediately\n    }\n    const streamMem = process.memoryUsage().heapUsed - streamBaseline.heapUsed\n    \n    console.log(`Buffered memory: ${(bufferedMem / 1024 / 1024).toFixed(2)}MB`)\n    console.log(`Streaming memory: ${(streamMem / 1024 / 1024).toFixed(2)}MB`)\n    \n    expect(streamMem).toBeLessThan(bufferedMem * 0.5) // Streaming should use much less\n  })\n})\n```\n\n### Transaction Memory\n```typescript\ndescribe('Transaction Memory Benchmarks', () =\u003e {\n  it('should measure memory during large transaction', async () =\u003e {\n    const baseline = process.memoryUsage()\n    \n    await session.executeWrite(async tx =\u003e {\n      for (let i = 0; i \u003c 1000; i++) {\n        await tx.run('CREATE (n:TxMem {id: $id, data: $data})', {\n          id: i,\n          data: 'x'.repeat(100)\n        })\n      }\n    })\n    \n    const afterTx = process.memoryUsage()\n    console.log(`Transaction memory: ${((afterTx.heapUsed - baseline.heapUsed) / 1024 / 1024).toFixed(2)}MB`)\n  })\n\n  it('should release memory after transaction completion', async () =\u003e {\n    const baseline = process.memoryUsage()\n    \n    for (let i = 0; i \u003c 10; i++) {\n      await session.executeWrite(async tx =\u003e {\n        await tx.run(`\n          UNWIND range(1, 100) AS j\n          CREATE (n:TxRelease {batch: $batch, item: j})\n        `, { batch: i })\n      })\n      \n      // Force GC if available\n      if (global.gc) global.gc()\n    }\n    \n    const afterAll = process.memoryUsage()\n    console.log(`Memory after 10 transactions: ${((afterAll.heapUsed - baseline.heapUsed) / 1024 / 1024).toFixed(2)}MB`)\n    \n    // Should not grow linearly with transactions\n    expect(afterAll.heapUsed - baseline.heapUsed).toBeLessThan(50 * 1024 * 1024) // \u003c50MB\n  })\n})\n```\n\n### Memory Leak Detection\n```typescript\ndescribe('Memory Leak Detection', () =\u003e {\n  it('should not leak memory on repeated operations', async () =\u003e {\n    const measurements: number[] = []\n    \n    for (let round = 0; round \u003c 10; round++) {\n      // Do a batch of operations\n      for (let i = 0; i \u003c 100; i++) {\n        await session.run('CREATE (n:LeakTest) DELETE n')\n      }\n      \n      // Force GC\n      if (global.gc) global.gc()\n      await new Promise(r =\u003e setTimeout(r, 100))\n      \n      measurements.push(process.memoryUsage().heapUsed)\n    }\n    \n    // Memory should be relatively stable (not growing)\n    const firstHalf = measurements.slice(0, 5).reduce((a, b) =\u003e a + b, 0) / 5\n    const secondHalf = measurements.slice(5).reduce((a, b) =\u003e a + b, 0) / 5\n    const growth = (secondHalf - firstHalf) / firstHalf\n    \n    console.log(`Memory growth over iterations: ${(growth * 100).toFixed(2)}%`)\n    expect(growth).toBeLessThan(0.1) // \u003c10% growth indicates no major leak\n  })\n\n  it('should not leak sessions', async () =\u003e {\n    const baseline = process.memoryUsage()\n    \n    for (let i = 0; i \u003c 100; i++) {\n      const s = driver.session()\n      await s.run('RETURN 1')\n      await s.close()\n    }\n    \n    if (global.gc) global.gc()\n    await new Promise(r =\u003e setTimeout(r, 100))\n    \n    const afterClose = process.memoryUsage()\n    const growth = (afterClose.heapUsed - baseline.heapUsed) / 1024 / 1024\n    \n    console.log(`Memory after 100 session cycles: ${growth.toFixed(2)}MB`)\n    expect(growth).toBeLessThan(10) // \u003c10MB growth\n  })\n})\n```\n\n### Cloudflare Workers Memory Simulation\n```typescript\ndescribe('Workers Memory Constraints', () =\u003e {\n  const WORKER_MEMORY_LIMIT = 128 * 1024 * 1024 // 128MB\n\n  it('should operate within Workers memory limit', async () =\u003e {\n    const baseline = process.memoryUsage()\n    \n    // Simulate typical request workload\n    for (let i = 0; i \u003c 100; i++) {\n      await session.run(`\n        UNWIND range(1, 100) AS j\n        CREATE (n:WorkerTest {id: $batch * 100 + j})\n        RETURN n\n      `, { batch: i })\n    }\n    \n    const peak = process.memoryUsage()\n    const used = peak.heapUsed\n    \n    console.log(`Peak memory: ${(used / 1024 / 1024).toFixed(2)}MB / 128MB limit`)\n    console.log(`Headroom: ${((WORKER_MEMORY_LIMIT - used) / 1024 / 1024).toFixed(2)}MB`)\n    \n    expect(used).toBeLessThan(WORKER_MEMORY_LIMIT * 0.8) // Stay under 80% of limit\n  })\n})\n```\n\n## Memory Targets\n| Metric | Target | Notes |\n|--------|--------|-------|\n| Driver + Session init | \u003c5MB | Baseline footprint |\n| Per active session | \u003c100KB | Allow many sessions |\n| Per 1000 result records | \u003c10MB | Buffered |\n| Streaming overhead | \u003c1MB | Constant regardless of size |\n| Transaction overhead | \u003c5MB | For write buffer |\n| Memory growth (leak) | \u003c10% | Over 1000 operations |\n| Peak usage | \u003c100MB | Under Workers 128MB limit |\n\n## Acceptance Criteria\n- [ ] Baseline memory benchmarks created\n- [ ] Result memory benchmarks created\n- [ ] Transaction memory benchmarks created\n- [ ] Leak detection tests created\n- [ ] Workers memory simulation created\n- [ ] Memory targets documented\n- [ ] CI integration for tracking","status":"open","priority":3,"issue_type":"task","created_at":"2026-01-05T06:50:06.679598-06:00","updated_at":"2026-01-05T06:50:06.679598-06:00"}
{"id":"neo4j-0wy","title":"[GREEN] Lexer: Implement Numeric Literal Parsing","description":"## Overview\nImplement numeric literal tokenization to pass all numeric tests.\n\n## Implementation Tasks\n\n### Integer Scanner\n```typescript\nprivate scanInteger(): Token {\n  // Scan consecutive digits\n  // Check for hex prefix 0x/0X\n  // Check for octal prefix 0o/0O\n  // Return INTEGER token with value\n}\n```\n\n### Float Scanner\n```typescript\nprivate scanFloat(integerPart: string): Token {\n  // Scan decimal point\n  // Scan fractional part\n  // Check for exponent e/E\n  // Scan exponent sign and digits\n  // Return FLOAT token\n}\n```\n\n### Number Type Detection\n- Determine if integer or float\n- Handle scientific notation\n- Parse hex/octal values\n\n## Acceptance Criteria\n- [ ] All numeric literal tests pass\n- [ ] Correct token type (INTEGER vs FLOAT)\n- [ ] Values correctly parsed\n- [ ] Hex and scientific notation work\n\n## TDD Phase: GREEN\n## Depends On: neo4j-0d9","status":"closed","priority":1,"issue_type":"task","created_at":"2026-01-05T06:35:57.701712-06:00","updated_at":"2026-01-05T08:48:00.961028-06:00","closed_at":"2026-01-05T08:48:00.961028-06:00","close_reason":"Tests passing - implementation complete"}
{"id":"neo4j-0yo","title":"GREEN: Record.has(key) - Implement column existence check","description":"## Overview\nImplement the Record.has(key) method to make all RED phase tests pass.\n\n## Implementation\n\n```typescript\nhas(key: string): boolean {\n  return this._fieldLookup.has(key);\n}\n```\n\n## Acceptance Criteria\n- [ ] All RED phase tests now pass (GREEN phase)\n- [ ] Uses existing field lookup Map\n- [ ] O(1) lookup performance\n- [ ] Implementation is minimal\n\n## TDD Phase\nGREEN - Minimal implementation to pass tests\n\n## Dependencies\n- neo4j-w5n (RED phase tests)","status":"closed","priority":1,"issue_type":"task","created_at":"2026-01-05T06:39:10.026625-06:00","updated_at":"2026-01-05T08:55:15.892274-06:00","closed_at":"2026-01-05T08:55:15.892274-06:00","close_reason":"Record methods already implemented with tests"}
{"id":"neo4j-11c","title":"RED: Write failing tests for rxTx.run() method","description":"## Overview\nWrite failing tests for rxTx.run() query execution within reactive transaction.\n\n## Test Cases to Write\n\n### Basic Query Tests\n- rxTx.run(cypher) returns RxResult\n- rxTx.run(cypher, params) accepts parameters\n- Query executes within transaction context\n- Multiple queries share transaction\n\n### Parameter Tests\n- All Neo4j types supported as parameters\n- Handles null and undefined correctly\n- Complex nested objects work\n\n### Transaction Context Tests\n- Query sees uncommitted changes from same tx\n- Query isolated from other transactions\n- Transaction state affects query behavior\n\n### Observable Behavior Tests\n- Cold observable (lazy execution)\n- Proper error propagation\n- Query cancelled on unsubscription\n\n## Acceptance Criteria\n- All tests written and failing (RED phase)\n- Tests verify transaction context\n- Tests cover parameter handling\n- Tests verify Observable semantics","status":"open","priority":2,"issue_type":"task","created_at":"2026-01-05T06:38:38.301249-06:00","updated_at":"2026-01-05T06:38:38.301249-06:00"}
{"id":"neo4j-11uj","title":"RED: Write failing tests for error recovery patterns","description":"## Overview\nWrite failing tests for error recovery patterns in reactive streams.\n\n## Test Cases to Write\n\n### catchError Tests\n- catchError() intercepts errors\n- Can return fallback Observable\n- Can rethrow different error\n- Recovery continues stream\n\n### onErrorResumeNext Tests\n- Continue with fallback on error\n- Multiple fallback sources\n- Complete after fallbacks exhausted\n\n### Error Recovery Scenarios\n- Database temporarily unavailable\n- Query timeout recovery\n- Connection lost recovery\n- Transaction failure recovery\n\n### Resource Cleanup\n- Resources cleaned on error\n- Resources cleaned on recovery\n- No leaks during recovery\n- Connection pool maintained\n\n## Acceptance Criteria\n- All tests written and failing (RED phase)\n- Tests verify recovery patterns\n- Tests cover common scenarios\n- Tests verify resource cleanup","status":"open","priority":2,"issue_type":"task","created_at":"2026-01-05T06:48:11.631854-06:00","updated_at":"2026-01-05T06:48:11.631854-06:00"}
{"id":"neo4j-12oh","title":"GREEN: Implement Authentication mechanisms","description":"## Test-Driven Development: GREEN Phase\n\n### Component\nHTTP Client SDK - Authentication\n\n### Implementation Requirements\n\nImplement `src/client/auth.ts`:\n\n```typescript\nexport interface AuthProvider {\n  getAuthHeader(): string\n  getHeaders(): Record\u003cstring, string\u003e\n  isExpired?: boolean\n}\n\n// Basic Authentication\nexport class BasicAuth implements AuthProvider {\n  private encoded: string\n\n  constructor(username: string, password: string) {\n    this.encoded = btoa(`${username}:${password}`)\n  }\n\n  getAuthHeader(): string {\n    return `Basic ${this.encoded}`\n  }\n\n  getHeaders(): Record\u003cstring, string\u003e {\n    return { Authorization: this.getAuthHeader() }\n  }\n}\n\n// Bearer Token Authentication\nexport interface BearerAuthOptions {\n  refresh?: () =\u003e Promise\u003cstring\u003e\n  expiresIn?: number\n}\n\nexport class BearerAuth implements AuthProvider {\n  private token: string\n  private refreshFn?: () =\u003e Promise\u003cstring\u003e\n  private expiresAt?: number\n\n  constructor(token: string, options?: BearerAuthOptions) {\n    this.token = token\n    this.refreshFn = options?.refresh\n    if (options?.expiresIn) {\n      this.expiresAt = Date.now() + options.expiresIn * 1000\n    }\n  }\n\n  get isExpired(): boolean {\n    return this.expiresAt ? Date.now() \u003e= this.expiresAt : false\n  }\n\n  getAuthHeader(): string {\n    return `Bearer ${this.token}`\n  }\n\n  getHeaders(): Record\u003cstring, string\u003e {\n    return { Authorization: this.getAuthHeader() }\n  }\n\n  async refreshToken(): Promise\u003cvoid\u003e {\n    if (!this.refreshFn) {\n      throw new Error('No refresh function configured')\n    }\n    this.token = await this.refreshFn()\n  }\n}\n\n// Custom Authentication\nexport class CustomAuth implements AuthProvider {\n  private headers: Record\u003cstring, string\u003e\n\n  constructor(headerOrHeaders: string | Record\u003cstring, string\u003e, value?: string) {\n    if (typeof headerOrHeaders === 'string') {\n      this.headers = { [headerOrHeaders]: value! }\n    } else {\n      this.headers = headerOrHeaders\n    }\n  }\n\n  getAuthHeader(): string {\n    return Object.values(this.headers)[0] ?? ''\n  }\n\n  getHeaders(): Record\u003cstring, string\u003e {\n    return { ...this.headers }\n  }\n}\n\n// Auth Manager\nexport class AuthManager {\n  private auth?: AuthProvider\n\n  get isAuthenticated(): boolean {\n    return !!this.auth\n  }\n\n  get isExpired(): boolean {\n    return this.auth?.isExpired ?? false\n  }\n\n  setAuth(auth: AuthProvider): void {\n    this.auth = auth\n  }\n\n  clearAuth(): void {\n    this.auth = undefined\n  }\n\n  getAuthHeaders(): Record\u003cstring, string\u003e {\n    return this.auth?.getHeaders() ?? {}\n  }\n}\n\n// Token Refresh Handler\ntype EventHandler = (token: string) =\u003e void\n\nexport interface TokenRefreshConfig {\n  refresh: () =\u003e Promise\u003cstring\u003e\n  expiresIn?: number\n  refreshBuffer?: number\n  maxRetries?: number\n}\n\nexport class TokenRefreshHandler {\n  private config: Required\u003cTokenRefreshConfig\u003e\n  private timerId?: ReturnType\u003ctypeof setTimeout\u003e\n  private listeners: Map\u003cstring, EventHandler[]\u003e = new Map()\n\n  constructor(config: TokenRefreshConfig) {\n    this.config = {\n      expiresIn: 3600,\n      refreshBuffer: 300,\n      maxRetries: 3,\n      ...config\n    }\n  }\n\n  start(): void {\n    const refreshIn = (this.config.expiresIn - this.config.refreshBuffer) * 1000\n    this.timerId = setTimeout(() =\u003e this.refreshNow(), refreshIn)\n  }\n\n  stop(): void {\n    if (this.timerId) {\n      clearTimeout(this.timerId)\n    }\n  }\n\n  async refreshNow(): Promise\u003cstring\u003e {\n    let lastError: Error | undefined\n    \n    for (let attempt = 0; attempt \u003c this.config.maxRetries; attempt++) {\n      try {\n        const token = await this.config.refresh()\n        this.emit('refresh', token)\n        return token\n      } catch (error) {\n        lastError = error as Error\n        await this.delay(Math.pow(2, attempt) * 100)\n      }\n    }\n    \n    throw lastError\n  }\n\n  on(event: string, handler: EventHandler): void {\n    const handlers = this.listeners.get(event) ?? []\n    handlers.push(handler)\n    this.listeners.set(event, handlers)\n  }\n\n  private emit(event: string, token: string): void {\n    const handlers = this.listeners.get(event) ?? []\n    handlers.forEach(h =\u003e h(token))\n  }\n\n  private delay(ms: number): Promise\u003cvoid\u003e {\n    return new Promise(resolve =\u003e setTimeout(resolve, ms))\n  }\n}\n```\n\n### Acceptance Criteria\n- [ ] All RED phase tests pass\n- [ ] Basic auth properly encodes credentials\n- [ ] Bearer auth supports token refresh\n- [ ] Custom auth allows arbitrary headers\n- [ ] AuthManager tracks auth state\n- [ ] TokenRefreshHandler auto-refreshes\n\n### Dependencies\n- RED: Authentication mechanisms fail without implementation\n\n### TDD Cycle\nThis is the GREEN phase. Next: REFACTOR phase.","status":"open","priority":2,"issue_type":"task","created_at":"2026-01-05T06:41:10.942541-06:00","updated_at":"2026-01-05T06:41:10.942541-06:00"}
{"id":"neo4j-147","title":"[RED] Neo4j Driver Error Message Compatibility Tests","description":"# [RED] Neo4j Driver Error Message Compatibility Tests\n\n## Overview\nCreate tests that verify neo4j.do produces compatible error messages and error types with neo4j-driver.\n\n## Error Categories to Test\n\n### Syntax Errors\n```typescript\ndescribe('Syntax Error Compatibility', () =\u003e {\n  it('should produce similar error for invalid Cypher', async () =\u003e {\n    await expect(session.run('INVALID CYPHER')).rejects.toMatchObject({\n      code: expect.stringMatching(/SyntaxError/),\n      message: expect.stringContaining('Invalid')\n    })\n  })\n\n  it('should indicate error position', async () =\u003e {\n    try {\n      await session.run('MATCH (n) RETRUN n')\n    } catch (error) {\n      expect(error.message).toContain('RETRUN')\n      // Error should indicate position of syntax error\n    }\n  })\n})\n```\n\n### Constraint Errors\n```typescript\ndescribe('Constraint Error Compatibility', () =\u003e {\n  it('should produce unique constraint violation error', async () =\u003e {\n    await session.run('CREATE CONSTRAINT IF NOT EXISTS FOR (p:Person) REQUIRE p.id IS UNIQUE')\n    await session.run('CREATE (p:Person {id: 1})')\n    \n    await expect(session.run('CREATE (p:Person {id: 1})')).rejects.toMatchObject({\n      code: expect.stringMatching(/ConstraintValidation/),\n      message: expect.stringContaining('unique')\n    })\n  })\n})\n```\n\n### Authentication Errors\n```typescript\ndescribe('Authentication Error Compatibility', () =\u003e {\n  it('should produce auth failure error', async () =\u003e {\n    const d = driver('bolt://localhost', auth.basic('wrong', 'credentials'))\n    \n    await expect(d.verifyConnectivity()).rejects.toMatchObject({\n      code: expect.stringMatching(/AuthenticationError|Unauthorized/),\n    })\n  })\n})\n```\n\n### Transaction Errors\n```typescript\ndescribe('Transaction Error Compatibility', () =\u003e {\n  it('should produce transaction terminated error', async () =\u003e {\n    const tx = session.beginTransaction()\n    await tx.run('CREATE (n:Test)')\n    await tx.rollback()\n    \n    await expect(tx.run('CREATE (n:AfterRollback)')).rejects.toMatchObject({\n      code: expect.stringMatching(/TransactionTerminated/),\n    })\n  })\n\n  it('should produce deadlock error format', async () =\u003e {\n    // Setup deadlock scenario\n    // Verify error format matches neo4j-driver\n  })\n})\n```\n\n### Connection Errors\n```typescript\ndescribe('Connection Error Compatibility', () =\u003e {\n  it('should produce service unavailable error', async () =\u003e {\n    const d = driver('bolt://non-existent:7687', auth.basic('u', 'p'))\n    \n    await expect(d.verifyConnectivity()).rejects.toMatchObject({\n      code: expect.stringMatching(/ServiceUnavailable/),\n    })\n  })\n\n  it('should produce session expired error', async () =\u003e {\n    // Simulate session expiration\n    // Verify error format\n  })\n})\n```\n\n## Error Type Mapping\n| neo4j-driver Error Code | neo4j.do Error Code |\n|-------------------------|---------------------|\n| Neo.ClientError.Statement.SyntaxError | Same |\n| Neo.ClientError.Schema.ConstraintValidationFailed | Same |\n| Neo.ClientError.Security.Unauthorized | Same |\n| ServiceUnavailable | Same |\n| SessionExpired | Same |\n\n## Acceptance Criteria\n- [ ] All error type tests written\n- [ ] Error code format matches\n- [ ] Error message structure compatible\n- [ ] Tests fail initially (RED phase)","status":"open","priority":2,"issue_type":"task","created_at":"2026-01-05T06:38:02.742573-06:00","updated_at":"2026-01-05T06:38:02.742573-06:00"}
{"id":"neo4j-14s","title":"GREEN: Vector Search - Implement vector query procedures with Vectorize","description":"## Overview\nImplement vector search procedures to make all RED tests pass.\n\n## Implementation Requirements\n\n### Core Components\n\n#### 1. Vector Index Manager\n```typescript\ninterface VectorIndex {\n  name: string;\n  entityType: 'node' | 'relationship';\n  labelOrType: string;\n  embeddingField: string;\n  dimensions: number;\n  metric: 'cosine' | 'euclidean' | 'dot_product';\n  vectorizeIndex?: VectorizeIndex;\n}\n\nclass VectorIndexManager {\n  async createIndex(config: VectorIndex): Promise\u003cvoid\u003e;\n  async dropIndex(name: string): Promise\u003cvoid\u003e;\n  async listIndexes(): Promise\u003cVectorIndex[]\u003e;\n  async getIndex(name: string): Promise\u003cVectorIndex | null\u003e;\n  \n  // Sync with Vectorize\n  async syncToVectorize(name: string): Promise\u003cvoid\u003e;\n  async rebuildIndex(name: string): Promise\u003cvoid\u003e;\n}\n```\n\n#### 2. Vector Search Service\n```typescript\ninterface VectorSearchOptions {\n  metric?: 'cosine' | 'euclidean' | 'dot_product';\n  minScore?: number;\n  filter?: Record\u003cstring, any\u003e;\n}\n\ninterface VectorSearchResult {\n  entityId: string;\n  score: number;\n  vector?: number[];\n}\n\nclass VectorSearchService {\n  constructor(\n    private vectorize: VectorizeIndex,\n    private db: D1Database\n  ) {}\n\n  async queryNodes(\n    indexName: string,\n    k: number,\n    queryVector: number[],\n    options?: VectorSearchOptions\n  ): Promise\u003cVectorSearchResult[]\u003e;\n\n  async queryRelationships(\n    indexName: string,\n    k: number,\n    queryVector: number[],\n    options?: VectorSearchOptions\n  ): Promise\u003cVectorSearchResult[]\u003e;\n\n  async searchText(\n    indexName: string,\n    text: string,\n    k: number,\n    options?: VectorSearchOptions\n  ): Promise\u003cVectorSearchResult[]\u003e;\n}\n```\n\n#### 3. Procedure Implementations\n```typescript\n// db.index.vector.create\nasync function createVectorIndex(\n  indexName: string,\n  labelOrType: string,\n  embeddingField: string,\n  dimensions: number,\n  metric: string\n): Promise\u003cvoid\u003e;\n\n// db.index.vector.queryNodes\nasync function* queryNodes(\n  indexName: string,\n  k: number,\n  queryVector: number[],\n  options?: VectorSearchOptions\n): AsyncGenerator\u003c{ node: Node; score: number }\u003e;\n\n// db.index.vector.queryRelationships\nasync function* queryRelationships(\n  indexName: string,\n  k: number,\n  queryVector: number[],\n  options?: VectorSearchOptions\n): AsyncGenerator\u003c{ relationship: Relationship; score: number }\u003e;\n\n// db.index.vector.searchText\nasync function* searchText(\n  indexName: string,\n  text: string,\n  k: number,\n  options?: VectorSearchOptions\n): AsyncGenerator\u003c{ node: Node; score: number }\u003e;\n```\n\n### SQL Schema\n```sql\nCREATE TABLE vector_indexes (\n  id TEXT PRIMARY KEY,\n  name TEXT NOT NULL UNIQUE,\n  entity_type TEXT NOT NULL CHECK (entity_type IN ('node', 'relationship')),\n  label_or_type TEXT NOT NULL,\n  embedding_field TEXT NOT NULL,\n  dimensions INTEGER NOT NULL,\n  metric TEXT NOT NULL DEFAULT 'cosine',\n  vectorize_index_id TEXT,\n  created_at TEXT DEFAULT (datetime('now')),\n  updated_at TEXT DEFAULT (datetime('now'))\n);\n\n-- Node embeddings stored in properties, but indexed in Vectorize\n-- Relationship embeddings similarly\n```\n\n### Vectorize Integration\n```typescript\ninterface VectorizeSync {\n  // Called when nodes/relationships are created/updated\n  async upsertVector(indexName: string, id: string, vector: number[], metadata?: Record\u003cstring, any\u003e): Promise\u003cvoid\u003e;\n  \n  // Called when nodes/relationships are deleted\n  async deleteVector(indexName: string, id: string): Promise\u003cvoid\u003e;\n  \n  // Bulk sync for existing data\n  async syncAll(indexName: string): Promise\u003c{ synced: number; failed: number }\u003e;\n}\n```\n\n## Acceptance Criteria\n- [ ] All RED phase tests passing\n- [ ] Vectorize index creation working\n- [ ] Vector queries returning correct results\n- [ ] Hybrid search with filters working\n- [ ] Text-to-vector search working\n\n## Dependencies\n- RED: Vector Search tests\n- Vectorize binding configuration\n- Auto Vector Embeddings (optional)\n\n## Tags\nsuperset, vector-search, vectorize, tdd-green","status":"open","priority":2,"issue_type":"task","created_at":"2026-01-05T06:36:23.5907-06:00","updated_at":"2026-01-05T06:36:23.5907-06:00"}
{"id":"neo4j-16n9","title":"REFACTOR: EagerResult - Add TypeScript generics and utilities","description":"## Overview\nRefactor EagerResult with proper TypeScript generics and utility methods.\n\n## Refactoring Tasks\n\n1. **Type Safety**\n   - Add proper generic type parameter\n   - Ensure Record type flows through\n\n2. **Utilities**\n   - Consider adding toJSON method\n   - Consider destructuring support\n\n3. **Documentation**\n   - Add JSDoc comments\n   - Document relationship to executeQuery\n\n## Acceptance Criteria\n- [ ] All tests still pass after refactoring\n- [ ] TypeScript generics properly defined\n- [ ] Well documented\n\n## TDD Phase\nREFACTOR - Improve code without changing behavior\n\n## Dependencies\n- neo4j-pxyj (GREEN phase implementation)","status":"closed","priority":1,"issue_type":"task","created_at":"2026-01-05T06:51:34.812804-06:00","updated_at":"2026-01-05T07:19:22.171153-06:00","closed_at":"2026-01-05T07:19:22.171153-06:00","close_reason":"Implemented in this Ralph Wiggum session - 662 tests pass"}
{"id":"neo4j-19fo","title":"RED: Write failing tests for test schedulers support","description":"## Overview\nWrite failing tests for RxJS test scheduler support.\n\n## Test Cases to Write\n\n### TestScheduler Integration\n- Observables work with TestScheduler\n- Time can be controlled\n- Async operations virtualizable\n- Flush advances time\n\n### Virtual Time Tests\n- delay() respects virtual time\n- timeout() respects virtual time\n- debounce() respects virtual time\n- throttle() respects virtual time\n\n### Scheduler Injection Tests\n- Can inject custom scheduler\n- Default uses async scheduler\n- Test scheduler injectable\n- Scheduler propagates through chain\n\n### Test Pattern Tests\n- Marble testing works\n- Cold observable testing\n- Hot observable testing\n- Error timing testing\n\n## Acceptance Criteria\n- All tests written and failing (RED phase)\n- Tests verify scheduler support\n- Tests verify virtual time\n- Tests verify test patterns","status":"open","priority":2,"issue_type":"task","created_at":"2026-01-05T06:49:14.73307-06:00","updated_at":"2026-01-05T06:49:14.73307-06:00"}
{"id":"neo4j-19p","title":"REFACTOR: Auto Vector Embeddings - Optimize embedding pipeline","description":"## Overview\nRefactor auto vector embedding implementation for production quality.\n\n## Refactoring Goals\n\n### 1. Performance Optimization\n- Implement embedding queue with batching\n- Add request deduplication for identical texts\n- Cache embeddings for unchanged content (hash-based)\n- Parallel embedding generation for independent nodes\n\n### 2. Reliability Improvements\n- Circuit breaker for Workers AI failures\n- Exponential backoff retry strategy\n- Dead letter queue for failed embeddings\n- Async embedding with eventual consistency option\n\n### 3. Code Quality\n- Extract embedding strategies (different models)\n- Add comprehensive logging and metrics\n- Implement proper TypeScript interfaces\n- Add JSDoc documentation\n\n### 4. Configuration Enhancements\n```typescript\ninterface AdvancedEmbeddingConfig {\n  // ... base config\n  preprocessing?: {\n    lowercase?: boolean;\n    stripHtml?: boolean;\n    maxLength?: number;\n    template?: string; // e.g., \"title: {title}\\ncontent: {content}\"\n  };\n  caching?: {\n    enabled: boolean;\n    ttl: number;\n  };\n  async?: {\n    enabled: boolean;\n    webhook?: string;\n  };\n}\n```\n\n### 5. Monitoring\n- Add embedding latency metrics\n- Track embedding cache hit rate\n- Monitor Workers AI quota usage\n- Alert on embedding backlogs\n\n## Tasks\n- [ ] Implement embedding request batching\n- [ ] Add content hash caching\n- [ ] Create circuit breaker\n- [ ] Add retry with backoff\n- [ ] Extract strategy pattern\n- [ ] Add metrics collection\n- [ ] Write integration tests\n- [ ] Performance benchmark suite\n\n## Acceptance Criteria\n- [ ] All tests still passing\n- [ ] 50%+ reduction in Workers AI calls via caching\n- [ ] \u003c 100ms p99 latency for cached embeddings\n- [ ] Graceful degradation on AI failures\n\n## Tags\nsuperset, embeddings, workers-ai, tdd-refactor, performance","status":"open","priority":3,"issue_type":"task","created_at":"2026-01-05T06:35:25.265623-06:00","updated_at":"2026-01-05T06:35:25.265623-06:00"}
{"id":"neo4j-1avw","title":"REFACTOR: Harden unsubscription cleanup","description":"## Overview\nRefactor unsubscription cleanup for maximum reliability.\n\n## Refactoring Tasks\n\n### Code Quality\n- Extract cleanup manager\n- Standardize teardown patterns\n- Add cleanup tracking\n- Document cleanup order\n\n### Robustness\n- Handle cleanup errors gracefully\n- Ensure cleanup in all paths\n- Add cleanup timeouts\n- Test cleanup edge cases\n\n### Performance\n- Optimize cleanup speed\n- Minimize cleanup overhead\n- Batch cleanup operations\n- Consider async cleanup\n\n## Acceptance Criteria\n- All tests still pass\n- Robust cleanup handling\n- No cleanup failures\n- Well-documented cleanup","status":"open","priority":2,"issue_type":"task","created_at":"2026-01-05T06:44:35.718301-06:00","updated_at":"2026-01-05T06:44:35.718301-06:00"}
{"id":"neo4j-1cg","title":"[RED] ID Generation - Write failing tests for internal and element IDs","description":"## Overview\nWrite failing tests for ID generation and encoding before implementation.\n\n## Test Cases to Write\n\n### Internal ID Tests\n- `test_internal_id_is_integer`\n- `test_internal_id_is_positive`\n- `test_internal_id_auto_increments`\n- `test_internal_id_unique_across_creations`\n- `test_internal_id_persists_after_restart`\n\n### Element ID Format Tests\n- `test_element_id_matches_neo4j_format` - '4:xxx:123'\n- `test_element_id_contains_database_uuid`\n- `test_element_id_contains_internal_id`\n- `test_node_element_id_prefix_is_4`\n- `test_relationship_element_id_prefix_is_5`\n\n### ID Encoding Tests\n- `test_encode_node_id`\n- `test_encode_relationship_id`\n- `test_decode_element_id_extracts_internal_id`\n- `test_decode_element_id_validates_format`\n- `test_decode_invalid_element_id_throws`\n\n### ID Mapping Tests\n- `test_internal_to_element_id_bijection`\n- `test_element_to_internal_id_bijection`\n- `test_id_mapping_consistent_across_queries`\n\n### Edge Cases\n- `test_very_large_internal_id`\n- `test_element_id_special_characters_handled`\n- `test_concurrent_id_generation_safe`\n\n## Acceptance Criteria\n- [ ] All tests written and failing\n- [ ] Neo4j element ID format tested\n- [ ] Encoding/decoding tested\n- [ ] Edge cases covered\n\n## TDD Phase\n**RED** - Write failing tests first","status":"closed","priority":1,"issue_type":"task","created_at":"2026-01-05T06:38:33.766018-06:00","updated_at":"2026-01-05T08:58:13.609062-06:00","closed_at":"2026-01-05T08:58:13.609062-06:00","close_reason":"Implementation complete with tests"}
{"id":"neo4j-1dbg","title":"RED: RETURN/WITH Clause Translation","description":"## Overview\nWrite failing tests for RETURN and WITH clause translation.\n\n## Test Cases to Write\n\n### Test 1: Simple RETURN\n- RETURN n -\u003e SELECT with node columns\n\n### Test 2: RETURN with Aliases\n- RETURN n.name AS name -\u003e SELECT json_extract AS name\n\n### Test 3: RETURN DISTINCT\n- RETURN DISTINCT n.label -\u003e SELECT DISTINCT\n\n### Test 4: RETURN with Aggregation\n- RETURN count(n) -\u003e SELECT COUNT() with GROUP BY inference\n\n### Test 5: ORDER BY\n- RETURN n ORDER BY n.name -\u003e SQL ORDER BY\n\n### Test 6: ORDER BY DESC\n- ORDER BY n.age DESC -\u003e SQL DESC\n\n### Test 7: SKIP/LIMIT\n- RETURN n SKIP 10 LIMIT 5 -\u003e LIMIT 5 OFFSET 10\n\n### Test 8: WITH Clause (Pipeline)\n- WITH n.name AS name RETURN name -\u003e Subquery or CTE\n\n### Test 9: WITH Aggregation\n- WITH count(n) AS c WHERE c \u003e 5 -\u003e HAVING equivalent\n\n### Test 10: Multiple ORDER BY\n- ORDER BY n.lastName, n.firstName\n\n## Acceptance Criteria\n- All tests written and failing\n- Aggregation triggers GROUP BY\n- WITH creates proper scoping\n\n## TDD Phase\nRED - Write failing tests first","status":"closed","priority":1,"issue_type":"task","created_at":"2026-01-05T06:40:46.243035-06:00","updated_at":"2026-01-05T08:55:39.252796-06:00","closed_at":"2026-01-05T08:55:39.252796-06:00","close_reason":"Translation already implemented with tests"}
{"id":"neo4j-1du","title":"[RED] Durable Object Implementation - Write failing tests for Neo4jDatabase class","description":"## Overview\nWrite failing tests for the Neo4jDatabase Durable Object before implementation.\n\n## Test Cases to Write\n\n### Initialization Tests\n- `test_durable_object_can_be_instantiated`\n- `test_sqlite_initialized_on_first_request`\n- `test_schema_applied_on_initialization`\n- `test_schema_version_recorded`\n\n### Request Routing Tests\n- `test_fetch_handles_query_requests`\n- `test_fetch_handles_transaction_requests`\n- `test_fetch_rejects_invalid_methods`\n- `test_fetch_returns_proper_json_responses`\n- `test_fetch_handles_errors_gracefully`\n\n### Query Handling Tests\n- `test_execute_cypher_query`\n- `test_execute_parameterized_query`\n- `test_query_returns_results_array`\n- `test_query_handles_syntax_errors`\n\n### Transaction Handling Tests\n- `test_begin_transaction_returns_tx_id`\n- `test_commit_transaction`\n- `test_rollback_transaction`\n- `test_transaction_isolation`\n\n### Connection Management Tests\n- `test_websocket_upgrade_supported`\n- `test_concurrent_requests_handled`\n- `test_request_timeout_handling`\n- `test_alarm_for_cleanup`\n\n## Acceptance Criteria\n- [ ] All tests written and failing\n- [ ] Tests cover DO lifecycle\n- [ ] Tests cover all request types\n- [ ] Error handling tests included\n- [ ] Concurrency tests included\n\n## TDD Phase\n**RED** - Write failing tests first","status":"closed","priority":1,"issue_type":"task","created_at":"2026-01-05T06:36:02.082377-06:00","updated_at":"2026-01-05T08:53:44.634956-06:00","closed_at":"2026-01-05T08:53:44.634956-06:00","close_reason":"Tests passing - implementation complete"}
{"id":"neo4j-1euz","title":"REFACTOR: MCP Server - Add advanced capabilities and optimize for AI agents","description":"## Overview\nRefactor MCP server for production use with AI agents.\n\n## Refactoring Goals\n\n### 1. Advanced Tools\n```typescript\n// Graph traversal tool\n{\n  name: 'traverse_graph',\n  description: 'Traverse graph from starting node',\n  inputSchema: {\n    properties: {\n      startNodeId: { type: 'string' },\n      direction: { enum: ['outgoing', 'incoming', 'both'] },\n      relationshipTypes: { type: 'array', items: { type: 'string' } },\n      maxDepth: { type: 'number', default: 3 },\n      returnFormat: { enum: ['tree', 'flat', 'paths'] }\n    }\n  }\n}\n\n// Subgraph extraction\n{\n  name: 'extract_subgraph',\n  description: 'Extract connected subgraph around nodes',\n  inputSchema: {\n    properties: {\n      centerNodeIds: { type: 'array', items: { type: 'string' } },\n      radius: { type: 'number', default: 2 },\n      includeProperties: { type: 'boolean', default: true }\n    }\n  }\n}\n\n// Pattern matching\n{\n  name: 'find_patterns',\n  description: 'Find graph patterns matching description',\n  inputSchema: {\n    properties: {\n      pattern: { type: 'string', description: 'Natural language pattern description' }\n    }\n  }\n}\n```\n\n### 2. Context Management\n- Session state for multi-turn interactions\n- Query history within session\n- Result caching for follow-up queries\n- Cursor-based pagination for large results\n\n### 3. Security Enhancements\n```typescript\ninterface MCPSecurityConfig {\n  allowedTools: string[];\n  maxResultSize: number;\n  queryTimeout: number;\n  writePermissions: {\n    enabled: boolean;\n    allowedLabels?: string[];\n    allowedRelTypes?: string[];\n  };\n  rateLimits: {\n    queriesPerMinute: number;\n    tokensPerMinute: number;\n  };\n}\n```\n\n### 4. Observability\n- Request/response logging\n- Tool usage analytics\n- Error tracking\n- Performance metrics\n\n### 5. Documentation\n- Auto-generated tool documentation\n- Example queries for each tool\n- Schema-aware suggestions\n\n## Tasks\n- [ ] Implement graph traversal tool\n- [ ] Add subgraph extraction\n- [ ] Create session management\n- [ ] Build security layer\n- [ ] Add comprehensive logging\n- [ ] Auto-generate documentation\n- [ ] Create example prompts\n\n## Acceptance Criteria\n- [ ] All tests still passing\n- [ ] Advanced tools working\n- [ ] Security controls enforced\n- [ ] Full observability\n\n## Tags\nsuperset, mcp, model-context-protocol, tdd-refactor, security","status":"open","priority":3,"issue_type":"task","created_at":"2026-01-05T06:40:53.664048-06:00","updated_at":"2026-01-05T06:40:53.664048-06:00"}
{"id":"neo4j-1ly","title":"GREEN: Driver Lifecycle Methods Implementation","description":"## Overview\nImplement Driver lifecycle methods to pass all RED phase tests.\n\n## Implementation Requirements\n\n### Session Creation\n```typescript\nclass Driver {\n  private sessions: Set\u003cSession\u003e = new Set()\n  private closed: boolean = false\n\n  session(config?: SessionConfig): Session {\n    if (this.closed) {\n      throw new ServiceUnavailable('Driver has been closed')\n    }\n    const session = new Session(this, config)\n    this.sessions.add(session)\n    return session\n  }\n\n  rxSession(config?: SessionConfig): RxSession {\n    return new RxSession(this.session(config))\n  }\n}\n\ninterface SessionConfig {\n  database?: string\n  defaultAccessMode?: 'READ' | 'WRITE'\n  bookmarks?: string | string[]\n  fetchSize?: number\n  impersonatedUser?: string\n}\n```\n\n### Execute Query\n```typescript\ninterface QueryConfig {\n  routing?: 'READ' | 'WRITE'\n  database?: string\n  impersonatedUser?: string\n  bookmarkManager?: BookmarkManager\n}\n\ninterface EagerResult\u003cT = Record\u003cstring, any\u003e\u003e {\n  keys: string[]\n  records: Record\u003cT\u003e[]\n  summary: ResultSummary\n}\n\nasync executeQuery\u003cT\u003e(\n  cypher: string,\n  params?: Record\u003cstring, any\u003e,\n  config?: QueryConfig\n): Promise\u003cEagerResult\u003cT\u003e\u003e\n```\n\n### Server Info \u0026 Connectivity\n```typescript\ninterface ServerInfo {\n  address: string\n  agent: string\n  protocolVersion: number\n}\n\nasync getServerInfo(): Promise\u003cServerInfo\u003e\nasync verifyConnectivity(): Promise\u003cServerInfo\u003e\n```\n\n### Close \u0026 Cleanup\n```typescript\nasync close(): Promise\u003cvoid\u003e {\n  if (this.closed) return\n  this.closed = true\n  \n  const closePromises = Array.from(this.sessions).map(s =\u003e s.close())\n  await Promise.all(closePromises)\n  this.sessions.clear()\n}\n```\n\n## Files to Create/Modify\n- `src/driver/driver.ts`\n- `src/driver/types.ts`\n- `src/session/session.ts` (stub)\n\n## TDD Phase\n**GREEN** - Implement to pass tests.\n\n## Dependencies\n- Depends on: RED: Driver Lifecycle Methods Tests\n- Depends on: GREEN: Driver Class Factory \u0026 URI Parsing Implementation\n\n## Acceptance Criteria\n- [ ] All RED phase tests pass\n- [ ] Session tracking works correctly\n- [ ] Resource cleanup is complete\n- [ ] API matches neo4j-driver","status":"closed","priority":1,"issue_type":"task","created_at":"2026-01-05T06:35:43.787537-06:00","updated_at":"2026-01-05T08:47:39.631117-06:00","closed_at":"2026-01-05T08:47:39.631117-06:00","close_reason":"Tests passing - implementation complete"}
{"id":"neo4j-1qno","title":"REFACTOR: Bookmark Manager \u0026 Causal Consistency Optimization","description":"## Overview\nRefactor BookmarkManager and causal consistency for advanced scenarios and edge cases.\n\n## Refactoring Goals\n\n### Advanced Features\n- Bookmark clustering for efficiency\n- Cross-cluster bookmark federation\n- Bookmark persistence for restart recovery\n- Async bookmark notification\n\n### Edge Cases\n```typescript\ndescribe('Bookmark Edge Cases', () =\u003e {\n  it('should handle bookmark overflow')\n  it('should handle corrupt bookmark format')\n  it('should handle bookmarks from old schema version')\n  it('should handle database rename')\n  it('should handle database delete and recreate')\n  it('should handle concurrent bookmark updates')\n  it('should handle listener exceptions')\n  it('should handle supplier timeout')\n  it('should handle consumer failure')\n})\n```\n\n### Consistency Edge Cases\n```typescript\ndescribe('Causal Consistency Edge Cases', () =\u003e {\n  it('should handle stale bookmarks gracefully')\n  it('should handle partition during bookmark wait')\n  it('should handle bookmark from failed transaction')\n  it('should handle bookmark manager swap')\n  it('should handle session outliving bookmark manager')\n})\n```\n\n### Performance\n- Bookmark deduplication\n- Lazy bookmark resolution\n- Bookmark cache with TTL\n- Efficient multi-database tracking\n\n### Observability\n- Bookmark propagation tracing\n- Consistency verification logs\n- Wait time metrics\n\n## TDD Phase\n**REFACTOR** - Improve without breaking tests.\n\n## Dependencies\n- Depends on: GREEN: Bookmark Manager \u0026 Causal Consistency Implementation\n\n## Acceptance Criteria\n- [ ] All tests pass\n- [ ] Advanced scenarios handled\n- [ ] Performance optimized\n- [ ] Edge cases covered","status":"open","priority":2,"issue_type":"task","created_at":"2026-01-05T06:40:35.652323-06:00","updated_at":"2026-01-05T06:40:35.652323-06:00"}
{"id":"neo4j-1rt","title":"GREEN: Implement driver.rxSession() factory method","description":"## Overview\nImplement the `driver.rxSession()` factory method to make all RED tests pass.\n\n## Implementation Requirements\n\n### Factory Method\n```typescript\ninterface Driver {\n  rxSession(config?: RxSessionConfig): RxSession\n}\n\ninterface RxSessionConfig {\n  database?: string\n  defaultAccessMode?: 'READ' | 'WRITE'\n  bookmarks?: string[]\n  fetchSize?: number\n}\n```\n\n### Implementation Details\n- Create RxSession instance with provided config\n- Share underlying connection pool with sync sessions\n- Initialize reactive session state\n- Wire up to existing driver infrastructure\n\n## Acceptance Criteria\n- [ ] All RED tests now pass (GREEN phase)\n- [ ] No existing tests broken\n- [ ] Implementation is minimal (just enough to pass)\n- [ ] Factory properly creates RxSession instances","status":"open","priority":2,"issue_type":"task","created_at":"2026-01-05T06:34:39.486559-06:00","updated_at":"2026-01-05T06:34:39.486559-06:00"}
{"id":"neo4j-1uc","title":"[RED] Lexer: Identifier and Keyword Tests","description":"## Overview\nWrite failing tests for identifier and keyword tokenization.\n\n## Test Cases to Write\n\n### Regular Identifiers\n- Simple: `n`, `node`, `myVar`\n- With numbers: `node1`, `n2`, `var123`\n- With underscores: `my_var`, `_private`, `__dunder__`\n- Unicode identifiers (if supported)\n\n### Backtick-Quoted Identifiers\n- Simple: \\`my identifier\\`\n- With spaces: \\`has spaces\\`\n- With special chars: \\`has-dashes\\`, \\`has.dots\\`\n- Reserved word escape: \\`match\\`, \\`return\\`\n- With backtick inside: \\`has\\\\\\`tick\\`\n\n### Keywords (Case-Insensitive)\n- Uppercase: `MATCH`, `RETURN`, `WHERE`\n- Lowercase: `match`, `return`, `where`\n- Mixed: `Match`, `ReTuRn`, `WhErE`\n- All keywords tested\n\n### Keyword List\n```\nMATCH, OPTIONAL, WHERE, RETURN, WITH, UNWIND, CREATE, MERGE,\nDELETE, DETACH, SET, REMOVE, ORDER, BY, ASC, DESC, ASCENDING,\nDESCENDING, SKIP, LIMIT, UNION, ALL, CALL, YIELD, IN, STARTS,\nENDS, CONTAINS, NOT, AND, OR, XOR, IS, NULL, TRUE, FALSE, AS,\nDISTINCT, CASE, WHEN, THEN, ELSE, END, EXISTS, COUNT, COLLECT,\nFOREACH, LOAD, CSV, FROM, HEADERS, EXPLAIN, PROFILE, USING,\nINDEX, CONSTRAINT, ON, ASSERT, UNIQUE, NODE, KEY, DROP, CREATE\n```\n\n## Acceptance Criteria\n- [ ] All tests written and failing\n- [ ] Keyword vs identifier distinction clear\n- [ ] Backtick escaping works\n- [ ] Case insensitivity verified\n\n## TDD Phase: RED","status":"closed","priority":1,"issue_type":"task","created_at":"2026-01-05T06:36:16.056533-06:00","updated_at":"2026-01-05T08:53:44.636013-06:00","closed_at":"2026-01-05T08:53:44.636013-06:00","close_reason":"Tests passing - implementation complete"}
{"id":"neo4j-1un","title":"Vitest configuration","description":"# Vitest Configuration\n\n## Overview\nSet up Vitest for testing the neo4j.do project with support for unit tests, integration tests, and E2E tests.\n\n## Configuration Requirements\n- TypeScript support\n- Cloudflare Workers environment simulation\n- Coverage reporting\n- Watch mode\n- Test file patterns\n\n## Configuration File\n```typescript\n// vitest.config.ts\nimport { defineConfig } from 'vitest/config'\n\nexport default defineConfig({\n  test: {\n    globals: true,\n    environment: 'miniflare', // Cloudflare Workers simulation\n    include: [\n      'src/**/*.test.ts',\n      'tests/**/*.test.ts'\n    ],\n    exclude: ['node_modules', 'dist'],\n    coverage: {\n      provider: 'v8',\n      reporter: ['text', 'json', 'html'],\n      include: ['src/**/*.ts'],\n      exclude: ['src/**/*.test.ts', 'src/**/*.d.ts']\n    },\n    testTimeout: 10000,\n    hookTimeout: 10000,\n    setupFiles: ['./tests/setup.ts'],\n    pool: 'forks',\n    poolOptions: {\n      forks: {\n        singleFork: true\n      }\n    }\n  }\n})\n```\n\n## Test Directory Structure\n```\ntests/\n setup.ts           # Global test setup\n unit/              # Unit tests\n integration/       # Integration tests\n e2e/               # End-to-end tests\n fixtures/          # Test fixtures\n```\n\n## Acceptance Criteria\n- [ ] vitest.config.ts created\n- [ ] Test discovery works\n- [ ] Coverage reporting works\n- [ ] Miniflare environment configured\n- [ ] Watch mode functional","status":"closed","priority":1,"issue_type":"task","created_at":"2026-01-05T06:35:17.766204-06:00","updated_at":"2026-01-05T08:46:57.51526-06:00","closed_at":"2026-01-05T08:46:57.51526-06:00","close_reason":"Tests passing - implementation complete"}
{"id":"neo4j-2586","title":"RED: Dual-Mode Support (URI vs Env) Tests","description":"## Overview\nWrite comprehensive failing tests for dual-mode support: URI-based in-memory mode and env-based Durable Object mode.\n\n## Test Cases\n\n### Mode Detection Tests\n```typescript\ndescribe('Mode Detection', () =\u003e {\n  it('should detect URI mode with neo4j:// scheme')\n  it('should detect URI mode with bolt:// scheme')\n  it('should detect env mode with Cloudflare env object')\n  it('should detect env mode with GRAPH_DO binding')\n  it('should throw on ambiguous configuration')\n  it('should throw on missing configuration')\n})\n```\n\n### URI Mode (In-Memory) Tests\n```typescript\ndescribe('URI Mode - In-Memory', () =\u003e {\n  it('should create in-memory driver from URI')\n  it('should support neo4j://localhost')\n  it('should support bolt://localhost')\n  it('should ignore auth token in in-memory mode')\n  it('should ignore connection settings in in-memory mode')\n  it('should share graph across sessions')\n  it('should reset on driver.close()')\n})\n```\n\n### Env Mode (Durable Object) Tests\n```typescript\ndescribe('Env Mode - Durable Object', () =\u003e {\n  it('should create DO-backed driver from env')\n  it('should connect to GRAPH_DO binding')\n  it('should support database selection via DO ID')\n  it('should persist data across requests')\n  it('should handle DO hibernation')\n  it('should handle DO migration')\n})\n```\n\n### Factory Signature Tests\n```typescript\ndescribe('Driver Factory Signatures', () =\u003e {\n  // URI mode\n  it('should accept driver(uri)')\n  it('should accept driver(uri, authToken)')\n  it('should accept driver(uri, authToken, config)')\n  \n  // Env mode\n  it('should accept driver(env)')\n  it('should accept driver(env, config)')\n  it('should accept driver({ env, database })')\n})\n```\n\n### Behavior Parity Tests\n```typescript\ndescribe('Behavior Parity', () =\u003e {\n  it('should have same session API in both modes')\n  it('should have same transaction API in both modes')\n  it('should have same result API in both modes')\n  it('should have same error types in both modes')\n  it('should support bookmarks in both modes')\n})\n```\n\n## TDD Phase\n**RED** - All tests should fail initially.\n\n## Acceptance Criteria\n- [ ] Mode detection tests written\n- [ ] In-memory mode tests complete\n- [ ] Durable Object mode tests complete\n- [ ] API parity verified","status":"closed","priority":1,"issue_type":"task","created_at":"2026-01-05T06:40:53.60357-06:00","updated_at":"2026-01-05T08:56:54.3927-06:00","closed_at":"2026-01-05T08:56:54.3927-06:00","close_reason":"Features implemented with tests"}
{"id":"neo4j-2b64","title":"[RED] Parser: List Comprehension Tests","description":"## Overview\nWrite failing tests for list comprehension parsing.\n\n## Test Cases to Write\n\n### Basic List Comprehension\n- Simple: [x IN list | x * 2]\n- No transform: [x IN list]\n- With filter: [x IN list WHERE x \u003e 0]\n- With filter and transform: [x IN list WHERE x \u003e 0 | x * 2]\n\n### Complex Expressions\n- Nested property: [n IN nodes | n.name]\n- Function calls: [s IN strings | lower(s)]\n- Complex filter: [x IN list WHERE x \u003e 0 AND x \u003c 100 | x * 2]\n\n### Pattern Comprehensions\n- Basic: [(n)--\u003e(m) | m.name]\n- With WHERE: [(n)-[:KNOWS]-\u003e(m) WHERE m.age \u003e 21 | m.name]\n\n### In Context\n- RETURN: RETURN [x IN n.items | x * 2]\n- WHERE: WHERE size([x IN n.items WHERE x \u003e 0]) \u003e 5\n\n## Acceptance Criteria\n- [ ] All comprehension tests written and failing\n- [ ] Filter (WHERE) tested\n- [ ] Transform (|) tested\n- [ ] Pattern comprehensions tested\n\n## TDD Phase: RED","status":"open","priority":2,"issue_type":"task","created_at":"2026-01-05T06:49:33.399549-06:00","updated_at":"2026-01-05T06:49:33.399549-06:00"}
{"id":"neo4j-2bt9","title":"GREEN: MCP Server - Implement Model Context Protocol server","description":"## Overview\nImplement MCP server to expose graph database capabilities to AI agents.\n\n## Implementation Requirements\n\n### Core Components\n\n#### 1. MCP Server Setup\n```typescript\nimport { Server, StdioServerTransport } from '@modelcontextprotocol/sdk/server';\n\nclass Neo4jMCPServer {\n  private server: Server;\n  \n  constructor(private graphService: GraphService) {\n    this.server = new Server({\n      name: 'neo4j-graph-server',\n      version: '1.0.0'\n    }, {\n      capabilities: {\n        tools: {},\n        resources: {},\n        prompts: {}\n      }\n    });\n    \n    this.registerTools();\n    this.registerResources();\n    this.registerPrompts();\n  }\n\n  async start(): Promise\u003cvoid\u003e {\n    const transport = new StdioServerTransport();\n    await this.server.connect(transport);\n  }\n}\n```\n\n#### 2. Tools Implementation\n```typescript\n// Schema introspection\nthis.server.setRequestHandler(ListToolsRequestSchema, async () =\u003e ({\n  tools: [\n    {\n      name: 'graph_schema',\n      description: 'Get graph database schema information',\n      inputSchema: {\n        type: 'object',\n        properties: {\n          type: { \n            type: 'string', \n            enum: ['labels', 'relationships', 'properties', 'full'] \n          },\n          label: { type: 'string' }\n        },\n        required: ['type']\n      }\n    },\n    {\n      name: 'execute_cypher',\n      description: 'Execute a Cypher query against the graph database',\n      inputSchema: {\n        type: 'object',\n        properties: {\n          query: { type: 'string', description: 'Cypher query to execute' },\n          parameters: { type: 'object', description: 'Query parameters' },\n          allowWrites: { type: 'boolean', default: false }\n        },\n        required: ['query']\n      }\n    },\n    {\n      name: 'create_node',\n      description: 'Create a new node in the graph',\n      inputSchema: {\n        type: 'object',\n        properties: {\n          labels: { type: 'array', items: { type: 'string' } },\n          properties: { type: 'object' }\n        },\n        required: ['labels']\n      }\n    },\n    // ... more tools\n  ]\n}));\n\nthis.server.setRequestHandler(CallToolRequestSchema, async (request) =\u003e {\n  const { name, arguments: args } = request.params;\n  \n  switch (name) {\n    case 'graph_schema':\n      return this.handleSchemaQuery(args);\n    case 'execute_cypher':\n      return this.handleCypherQuery(args);\n    case 'create_node':\n      return this.handleCreateNode(args);\n    // ... more handlers\n  }\n});\n```\n\n#### 3. Resources Implementation\n```typescript\nthis.server.setRequestHandler(ListResourcesRequestSchema, async () =\u003e ({\n  resources: [\n    {\n      uri: 'neo4j://schema',\n      name: 'Graph Schema',\n      description: 'Complete graph database schema',\n      mimeType: 'application/json'\n    },\n    {\n      uri: 'neo4j://nodes/{label}',\n      name: 'Node Collection',\n      description: 'Collection of nodes with given label',\n      mimeType: 'application/json'\n    }\n  ]\n}));\n\nthis.server.setRequestHandler(ReadResourceRequestSchema, async (request) =\u003e {\n  const { uri } = request.params;\n  \n  if (uri === 'neo4j://schema') {\n    const schema = await this.graphService.getFullSchema();\n    return {\n      contents: [{\n        uri,\n        mimeType: 'application/json',\n        text: JSON.stringify(schema, null, 2)\n      }]\n    };\n  }\n  \n  const labelMatch = uri.match(/neo4j:\\/\\/nodes\\/(.+)/);\n  if (labelMatch) {\n    const nodes = await this.graphService.findNodes(labelMatch[1], {}, 100);\n    return {\n      contents: [{\n        uri,\n        mimeType: 'application/json',\n        text: JSON.stringify(nodes, null, 2)\n      }]\n    };\n  }\n});\n```\n\n#### 4. Prompts Implementation\n```typescript\nthis.server.setRequestHandler(ListPromptsRequestSchema, async () =\u003e ({\n  prompts: [\n    {\n      name: 'generate_cypher',\n      description: 'Generate Cypher query from natural language',\n      arguments: [\n        { name: 'question', description: 'Natural language question', required: true }\n      ]\n    },\n    {\n      name: 'explain_schema',\n      description: 'Explain the graph schema in natural language'\n    }\n  ]\n}));\n\nthis.server.setRequestHandler(GetPromptRequestSchema, async (request) =\u003e {\n  const { name, arguments: args } = request.params;\n  \n  if (name === 'generate_cypher') {\n    const schema = await this.graphService.getFullSchema();\n    return {\n      messages: [\n        {\n          role: 'user',\n          content: {\n            type: 'text',\n            text: `Given this graph schema:\n${JSON.stringify(schema, null, 2)}\n\nGenerate a Cypher query for: ${args.question}\n\nReturn only the Cypher query, no explanation.`\n          }\n        }\n      ]\n    };\n  }\n});\n```\n\n#### 5. HTTP Transport for Workers\n```typescript\n// For Cloudflare Workers, implement HTTP-SSE transport\nclass HTTPSSETransport {\n  async handleRequest(request: Request): Promise\u003cResponse\u003e {\n    // Handle MCP protocol over HTTP with SSE\n  }\n}\n\n// Route handler\napp.post('/mcp', async (c) =\u003e {\n  const mcpServer = new Neo4jMCPServer(c.env.graphService);\n  return mcpServer.handleHTTPRequest(c.req.raw);\n});\n```\n\n## Acceptance Criteria\n- [ ] All RED phase tests passing\n- [ ] All tools working correctly\n- [ ] Resources exposed properly\n- [ ] Prompts returning useful content\n- [ ] HTTP transport working for Workers\n\n## Dependencies\n- RED: MCP Server tests\n- @modelcontextprotocol/sdk\n\n## Tags\nsuperset, mcp, model-context-protocol, ai-agents, tdd-green","status":"open","priority":2,"issue_type":"task","created_at":"2026-01-05T06:40:30.182939-06:00","updated_at":"2026-01-05T06:40:30.182939-06:00"}
{"id":"neo4j-2hbv","title":"GREEN: Result.subscribe(observer) - Implement streaming observer","description":"## Overview\nImplement the Result.subscribe(observer) method to make all RED phase tests pass.\n\n## Implementation\n\n```typescript\ninterface ResultObserver\u003cR extends Record = Record\u003e {\n  onKeys?: (keys: string[]) =\u003e void;\n  onNext?: (record: R) =\u003e void;\n  onCompleted?: (summary: ResultSummary) =\u003e void;\n  onError?: (error: Error) =\u003e void;\n}\n\nsubscribe(observer: ResultObserver\u003cR\u003e): void {\n  (async () =\u003e {\n    try {\n      if (observer.onKeys) {\n        const keys = await this.keys;\n        observer.onKeys(keys);\n      }\n      \n      for await (const record of this) {\n        observer.onNext?.(record);\n      }\n      \n      const summary = await this.summary;\n      observer.onCompleted?.(summary);\n    } catch (error) {\n      observer.onError?.(error as Error);\n    }\n  })();\n}\n```\n\n## Acceptance Criteria\n- [ ] All RED phase tests now pass (GREEN phase)\n- [ ] Calls observer methods appropriately\n- [ ] Handles errors properly\n- [ ] Implementation is minimal\n\n## TDD Phase\nGREEN - Minimal implementation to pass tests\n\n## Dependencies\n- neo4j-86d2 (RED phase tests)","status":"open","priority":2,"issue_type":"task","created_at":"2026-01-05T06:50:23.757779-06:00","updated_at":"2026-01-05T06:50:23.757779-06:00"}
{"id":"neo4j-2im","title":"[REFACTOR] Durable Object Implementation - Improve architecture and error handling","description":"## Overview\nRefactor the Durable Object implementation for production readiness.\n\n## Refactoring Tasks\n\n### Architecture Improvements\n- Extract request routing to separate module\n- Implement middleware pattern for common logic\n- Add request validation layer\n- Create typed request/response interfaces\n\n### Error Handling\n```typescript\nclass Neo4jError extends Error {\n  constructor(\n    public code: string,\n    message: string,\n    public details?: unknown\n  ) {\n    super(message);\n  }\n}\n\n// Error codes matching Neo4j\nconst ErrorCodes = {\n  SYNTAX_ERROR: 'Neo.ClientError.Statement.SyntaxError',\n  CONSTRAINT_VIOLATION: 'Neo.ClientError.Schema.ConstraintValidationFailed',\n  ENTITY_NOT_FOUND: 'Neo.ClientError.Statement.EntityNotFound',\n};\n```\n\n### Performance Optimizations\n- Connection pooling for WebSocket\n- Query plan caching\n- Prepared statement reuse\n- Batch request support\n\n### Monitoring \u0026 Observability\n- Add request logging\n- Add metrics collection\n- Add trace context propagation\n- Add health check endpoint\n\n### Code Quality\n- Comprehensive JSDoc\n- Integration test suite\n- Load testing setup\n- Documentation\n\n## Acceptance Criteria\n- [ ] All tests still pass\n- [ ] Error handling is comprehensive\n- [ ] Performance is optimized\n- [ ] Code is well-documented\n- [ ] Production-ready state\n\n## TDD Phase\n**REFACTOR** - Improve without changing behavior","status":"open","priority":2,"issue_type":"task","created_at":"2026-01-05T06:36:15.64421-06:00","updated_at":"2026-01-05T06:36:15.64421-06:00"}
{"id":"neo4j-2jqo","title":"REFACTOR: Result.subscribe(observer) - Add cancellation support","description":"## Overview\nRefactor Result.subscribe() to support subscription cancellation.\n\n## Refactoring Tasks\n\n1. **Cancellation**\n   - Return subscription object with cancel method\n   - Stop iteration on cancel\n\n2. **Type Safety**\n   - Define ResultObserver interface properly\n   - Export for external use\n\n## Acceptance Criteria\n- [ ] All tests still pass after refactoring\n- [ ] Cancellation support added\n- [ ] TypeScript interfaces exported\n\n## TDD Phase\nREFACTOR - Improve code without changing behavior\n\n## Dependencies\n- neo4j-2hbv (GREEN phase implementation)","status":"open","priority":2,"issue_type":"task","created_at":"2026-01-05T06:50:35.063983-06:00","updated_at":"2026-01-05T06:50:35.063983-06:00"}
{"id":"neo4j-2m40","title":"RED: Retry logic fails without implementation","description":"## Test-Driven Development: RED Phase\n\n### Component\nHTTP Client SDK - Retry Logic\n\n### Test Cases to Write (Expected to FAIL)\n\n```typescript\nimport { describe, it, expect, vi, beforeEach, afterEach } from 'vitest'\nimport { \n  RetryHandler,\n  ExponentialBackoff,\n  RetryPolicy,\n  isRetryableError\n} from '../src/client/retry'\nimport { Neo4jHttpDriver } from '../src/client/http-driver'\n\ndescribe('Retry Logic - RED', () =\u003e {\n  beforeEach(() =\u003e {\n    vi.useFakeTimers()\n  })\n\n  afterEach(() =\u003e {\n    vi.useRealTimers()\n  })\n\n  describe('isRetryableError()', () =\u003e {\n    it('should identify 5xx errors as retryable', () =\u003e {\n      expect(isRetryableError(new Error(), 500)).toBe(true)\n      expect(isRetryableError(new Error(), 502)).toBe(true)\n      expect(isRetryableError(new Error(), 503)).toBe(true)\n      expect(isRetryableError(new Error(), 504)).toBe(true)\n    })\n\n    it('should not retry 4xx errors', () =\u003e {\n      expect(isRetryableError(new Error(), 400)).toBe(false)\n      expect(isRetryableError(new Error(), 401)).toBe(false)\n      expect(isRetryableError(new Error(), 404)).toBe(false)\n    })\n\n    it('should retry connection failures', () =\u003e {\n      const error = new TypeError('Failed to fetch')\n      expect(isRetryableError(error)).toBe(true)\n    })\n\n    it('should retry timeout errors', () =\u003e {\n      const error = new Error('The operation timed out')\n      error.name = 'AbortError'\n      expect(isRetryableError(error)).toBe(true)\n    })\n\n    it('should retry Neo4j transient errors', () =\u003e {\n      const error = { code: 'Neo.TransientError.Transaction.LockClient' }\n      expect(isRetryableError(error)).toBe(true)\n    })\n  })\n\n  describe('ExponentialBackoff', () =\u003e {\n    it('should calculate exponential delays', () =\u003e {\n      const backoff = new ExponentialBackoff({ initialDelay: 100, maxDelay: 10000 })\n      \n      expect(backoff.getDelay(0)).toBe(100)\n      expect(backoff.getDelay(1)).toBe(200)\n      expect(backoff.getDelay(2)).toBe(400)\n      expect(backoff.getDelay(3)).toBe(800)\n    })\n\n    it('should cap at maxDelay', () =\u003e {\n      const backoff = new ExponentialBackoff({ initialDelay: 100, maxDelay: 500 })\n      \n      expect(backoff.getDelay(10)).toBe(500)\n    })\n\n    it('should add jitter when configured', () =\u003e {\n      const backoff = new ExponentialBackoff({ \n        initialDelay: 100, \n        jitter: true,\n        jitterFactor: 0.2\n      })\n      \n      const delays = Array.from({ length: 10 }, () =\u003e backoff.getDelay(0))\n      const uniqueDelays = new Set(delays)\n      \n      // With jitter, delays should vary\n      expect(uniqueDelays.size).toBeGreaterThan(1)\n    })\n  })\n\n  describe('RetryPolicy', () =\u003e {\n    it('should retry up to maxRetries', async () =\u003e {\n      const operation = vi.fn()\n        .mockRejectedValueOnce(new Error('fail 1'))\n        .mockRejectedValueOnce(new Error('fail 2'))\n        .mockResolvedValueOnce('success')\n      \n      const policy = new RetryPolicy({ maxRetries: 3 })\n      const result = await policy.execute(operation)\n      \n      expect(result).toBe('success')\n      expect(operation).toHaveBeenCalledTimes(3)\n    })\n\n    it('should throw after maxRetries exceeded', async () =\u003e {\n      const operation = vi.fn().mockRejectedValue(new Error('always fails'))\n      \n      const policy = new RetryPolicy({ maxRetries: 2 })\n      \n      await expect(policy.execute(operation)).rejects.toThrow('always fails')\n      expect(operation).toHaveBeenCalledTimes(3) // 1 initial + 2 retries\n    })\n\n    it('should wait between retries', async () =\u003e {\n      const operation = vi.fn()\n        .mockRejectedValueOnce(new Error('fail'))\n        .mockResolvedValueOnce('success')\n      \n      const policy = new RetryPolicy({ \n        maxRetries: 3,\n        backoff: new ExponentialBackoff({ initialDelay: 1000 })\n      })\n      \n      const promise = policy.execute(operation)\n      \n      expect(operation).toHaveBeenCalledTimes(1)\n      \n      await vi.advanceTimersByTimeAsync(1000)\n      \n      expect(operation).toHaveBeenCalledTimes(2)\n      await promise\n    })\n\n    it('should call onRetry callback', async () =\u003e {\n      const onRetry = vi.fn()\n      const operation = vi.fn()\n        .mockRejectedValueOnce(new Error('fail'))\n        .mockResolvedValueOnce('success')\n      \n      const policy = new RetryPolicy({ maxRetries: 3, onRetry })\n      await policy.execute(operation)\n      \n      expect(onRetry).toHaveBeenCalledWith(\n        expect.any(Error),\n        1, // attempt number\n        expect.any(Number) // delay\n      )\n    })\n\n    it('should not retry non-retryable errors', async () =\u003e {\n      const operation = vi.fn().mockRejectedValue({ \n        code: 'Neo.ClientError.Statement.SyntaxError' \n      })\n      \n      const policy = new RetryPolicy({ maxRetries: 3 })\n      \n      await expect(policy.execute(operation)).rejects.toMatchObject({\n        code: 'Neo.ClientError.Statement.SyntaxError'\n      })\n      expect(operation).toHaveBeenCalledTimes(1)\n    })\n  })\n\n  describe('RetryHandler', () =\u003e {\n    it('should wrap fetch with retry logic', async () =\u003e {\n      const mockFetch = vi.fn()\n        .mockResolvedValueOnce({ ok: false, status: 503 })\n        .mockResolvedValueOnce({ ok: true, json: () =\u003e Promise.resolve({}) })\n      \n      const handler = new RetryHandler(mockFetch, { maxRetries: 3 })\n      const response = await handler.fetch('https://example.com')\n      \n      expect(response.ok).toBe(true)\n      expect(mockFetch).toHaveBeenCalledTimes(2)\n    })\n\n    it('should respect retry-after header', async () =\u003e {\n      const mockFetch = vi.fn()\n        .mockResolvedValueOnce({ \n          ok: false, \n          status: 503,\n          headers: new Headers({ 'Retry-After': '2' })\n        })\n        .mockResolvedValueOnce({ ok: true, json: () =\u003e Promise.resolve({}) })\n      \n      const handler = new RetryHandler(mockFetch, { maxRetries: 3 })\n      const promise = handler.fetch('https://example.com')\n      \n      await vi.advanceTimersByTimeAsync(2000)\n      \n      await promise\n      expect(mockFetch).toHaveBeenCalledTimes(2)\n    })\n  })\n\n  describe('Driver with retry', () =\u003e {\n    it('should retry failed queries', async () =\u003e {\n      const mockFetch = vi.fn()\n        .mockResolvedValueOnce({ ok: false, status: 500 })\n        .mockResolvedValueOnce({ \n          ok: true, \n          json: () =\u003e Promise.resolve({ records: [{ n: 1 }] })\n        })\n      \n      const driver = new Neo4jHttpDriver('https://neo4j.do/db/test', {\n        fetch: mockFetch,\n        retry: { maxRetries: 3 }\n      })\n      \n      const result = await driver.executeQuery('RETURN 1 as n')\n      \n      expect(result.records).toHaveLength(1)\n      expect(mockFetch).toHaveBeenCalledTimes(2)\n    })\n  })\n})\n```\n\n### Acceptance Criteria\n- [ ] Test file created at `tests/client/retry.test.ts`\n- [ ] All tests fail with expected errors\n- [ ] Tests cover: retryable errors, backoff, policies, retry-after header\n\n### TDD Cycle\nThis is the RED phase. Next: GREEN phase implementation.","status":"open","priority":2,"issue_type":"task","created_at":"2026-01-05T06:42:06.853043-06:00","updated_at":"2026-01-05T06:42:06.853043-06:00"}
{"id":"neo4j-2ps","title":"[GREEN] AST: Implement Expression Node Types","description":"## Overview\nImplement all expression AST node types.\n\n## Implementation Tasks\n\n### Literal Types (src/parser/ast/expressions.ts)\n```typescript\nexport interface StringLiteral extends ASTNode {\n  type: 'StringLiteral'\n  value: string\n  quote: '\"' | \"'\"\n}\n\nexport interface IntegerLiteral extends ASTNode {\n  type: 'IntegerLiteral'\n  value: number\n  raw: string\n}\n\nexport interface FloatLiteral extends ASTNode {\n  type: 'FloatLiteral'\n  value: number\n  raw: string\n}\n\nexport interface BooleanLiteral extends ASTNode {\n  type: 'BooleanLiteral'\n  value: boolean\n}\n\nexport interface NullLiteral extends ASTNode {\n  type: 'NullLiteral'\n}\n\nexport interface ListLiteral extends ASTNode {\n  type: 'ListLiteral'\n  elements: Expression[]\n}\n\nexport interface MapLiteral extends ASTNode {\n  type: 'MapLiteral'\n  entries: MapEntry[]\n}\n\nexport interface MapEntry {\n  key: string | Expression\n  value: Expression\n}\n```\n\n### Operator Types\n```typescript\nexport type BinaryOperator =\n  | '+' | '-' | '*' | '/' | '%' | '^'  // arithmetic\n  | '=' | '\u003c\u003e' | '\u003c' | '\u003e' | '\u003c=' | '\u003e='  // comparison\n  | 'AND' | 'OR' | 'XOR'  // logical\n  | 'IN' | 'STARTS WITH' | 'ENDS WITH' | 'CONTAINS' | '=~'  // string/list\n```\n\n## Acceptance Criteria\n- [ ] All expression type tests pass\n- [ ] All operators defined\n- [ ] Types are composable\n- [ ] Proper type narrowing works\n\n## TDD Phase: GREEN\n## Depends On: neo4j-ucp","status":"closed","priority":1,"issue_type":"task","created_at":"2026-01-05T06:38:05.152566-06:00","updated_at":"2026-01-05T08:58:01.75549-06:00","closed_at":"2026-01-05T08:58:01.75549-06:00","close_reason":"AST, lexer and types tests passing"}
{"id":"neo4j-2sr","title":"GREEN: Implement rxSession.executeWrite() method","description":"## Overview\nImplement rxSession.executeWrite() to make all RED tests pass.\n\n## Implementation Requirements\n\n### Method Signature\n```typescript\ninterface RxSession {\n  executeWrite\u003cT\u003e(\n    work: (tx: RxManagedTransaction) =\u003e Observable\u003cT\u003e\n  ): Observable\u003cT\u003e\n}\n```\n\n### Implementation Details\n- Create managed transaction with WRITE mode\n- Execute work function with transaction\n- Auto-commit on successful completion\n- Auto-rollback on error\n- Update bookmarks on commit\n- Handle retry logic for transient errors\n\n### Observable Chain\n- Wrap transaction lifecycle in Observable\n- Chain work function result\n- Proper error handling\n\n## Acceptance Criteria\n- All RED tests now pass (GREEN phase)\n- Write mode enforced\n- Bookmarks updated on commit\n- Retry logic works correctly","status":"open","priority":2,"issue_type":"task","created_at":"2026-01-05T06:36:29.992301-06:00","updated_at":"2026-01-05T06:36:29.992301-06:00"}
{"id":"neo4j-2vg","title":"[RED] Relationship Operations - Write failing tests for relationship CRUD","description":"## Overview\nWrite failing tests for all relationship CRUD operations before implementation.\n\n## Test Cases to Write\n\n### createRelationship Tests\n- `test_create_relationship_returns_relationship_with_id`\n- `test_create_relationship_with_type`\n- `test_create_relationship_connects_nodes`\n- `test_create_relationship_with_properties`\n- `test_create_relationship_invalid_start_node_throws`\n- `test_create_relationship_invalid_end_node_throws`\n- `test_create_self_referencing_relationship`\n\n### getRelationship Tests\n- `test_get_relationship_returns_existing`\n- `test_get_relationship_returns_null_for_missing`\n- `test_get_relationship_includes_start_end_ids`\n- `test_get_relationship_includes_properties`\n\n### updateRelationship Tests\n- `test_update_relationship_changes_properties`\n- `test_update_relationship_merges_properties`\n- `test_update_relationship_removes_null_properties`\n- `test_update_nonexistent_relationship_throws`\n- `test_cannot_update_relationship_type`\n- `test_cannot_update_start_end_nodes`\n\n### deleteRelationship Tests\n- `test_delete_relationship_removes_from_storage`\n- `test_delete_nonexistent_returns_false`\n- `test_delete_updates_adjacency_lists`\n\n### getRelationshipsByType Tests\n- `test_get_by_type_returns_matching`\n- `test_get_by_type_empty_for_unknown`\n- `test_get_by_type_multiple_results`\n\n### getRelationshipsForNode Tests\n- `test_get_outgoing_relationships`\n- `test_get_incoming_relationships`\n- `test_get_both_direction_relationships`\n- `test_get_relationships_empty_for_isolated_node`\n- `test_get_relationships_with_type_filter`\n\n## Acceptance Criteria\n- [ ] All tests written and failing\n- [ ] Direction handling tested\n- [ ] Type filtering tested\n- [ ] Error cases covered\n\n## TDD Phase\n**RED** - Write failing tests first","status":"closed","priority":1,"issue_type":"task","created_at":"2026-01-05T06:37:36.902338-06:00","updated_at":"2026-01-05T08:58:13.609909-06:00","closed_at":"2026-01-05T08:58:13.609909-06:00","close_reason":"Implementation complete with tests"}
{"id":"neo4j-2wa","title":"GREEN: Implement Neo4jHttpDriver class","description":"## Test-Driven Development: GREEN Phase\n\n### Component\nHTTP Client SDK - Neo4jHttpDriver Class\n\n### Implementation Requirements\n\nImplement `src/client/http-driver.ts`:\n\n```typescript\nexport interface HttpDriverConfig {\n  auth?: { username: string; password: string } | { token: string }\n  maxConnectionPoolSize?: number\n  connectionTimeout?: number\n  fetch?: typeof fetch\n  headers?: Record\u003cstring, string\u003e\n}\n\nexport class Neo4jHttpDriver {\n  readonly baseUrl: string\n  readonly config: HttpDriverConfig\n  private _closed = false\n\n  constructor(baseUrl: string, config?: HttpDriverConfig) {\n    this.baseUrl = baseUrl.replace(/\\/$/, '')\n    this.config = config ?? {}\n  }\n\n  get isAuthenticated(): boolean {\n    return \\!\\!this.config.auth\n  }\n\n  get isClosed(): boolean {\n    return this._closed\n  }\n\n  session(config?: SessionConfig): HttpSession {\n    if (this._closed) throw new Error('Driver is closed')\n    return new HttpSession(this, config)\n  }\n\n  async executeQuery\u003cT = Record\u003cstring, unknown\u003e\u003e(\n    query: string,\n    params?: Record\u003cstring, unknown\u003e,\n    config?: QueryConfig\n  ): Promise\u003cQueryResult\u003cT\u003e\u003e {\n    const session = this.session()\n    try {\n      return await session.run\u003cT\u003e(query, params)\n    } finally {\n      await session.close()\n    }\n  }\n\n  async getServerInfo(): Promise\u003cServerInfo\u003e {\n    const response = await this.fetch('/server-info')\n    return response.json()\n  }\n\n  async close(): Promise\u003cvoid\u003e {\n    this._closed = true\n  }\n\n  protected async fetch(path: string, init?: RequestInit): Promise\u003cResponse\u003e {\n    const fetchFn = this.config.fetch ?? globalThis.fetch\n    const headers = this.buildHeaders()\n    return fetchFn(`${this.baseUrl}${path}`, { ...init, headers })\n  }\n\n  private buildHeaders(): Record\u003cstring, string\u003e {\n    const headers: Record\u003cstring, string\u003e = {\n      'Content-Type': 'application/json',\n      ...this.config.headers\n    }\n    if (this.config.auth) {\n      if ('token' in this.config.auth) {\n        headers['Authorization'] = `Bearer ${this.config.auth.token}`\n      } else {\n        const { username, password } = this.config.auth\n        headers['Authorization'] = `Basic ${btoa(`${username}:${password}`)}`\n      }\n    }\n    return headers\n  }\n}\n```\n\n### Acceptance Criteria\n- [ ] All RED phase tests pass\n- [ ] Driver creates sessions correctly\n- [ ] executeQuery() works via HTTP POST\n- [ ] getServerInfo() fetches from /server-info\n- [ ] Authentication headers are properly set\n- [ ] close() marks driver as closed\n\n### Dependencies\n- RED: Neo4jHttpDriver class instantiation fails without implementation\n\n### TDD Cycle\nThis is the GREEN phase. Next: REFACTOR phase.","status":"open","priority":2,"issue_type":"task","created_at":"2026-01-05T06:34:47.70754-06:00","updated_at":"2026-01-05T06:34:47.70754-06:00"}
{"id":"neo4j-2x69","title":"[GREEN] Parser: Implement Property Access and Function Calls","description":"## Overview\nImplement property access and function call parsing.\n\n## Implementation Tasks\n\n### Postfix Expression Parser\n```typescript\nparsePostfix(): Expression {\n  let expr = this.parsePrimary()\n  \n  while (true) {\n    if (this.match('.')) {\n      const property = this.parseIdentifier()\n      expr = {\n        type: 'PropertyAccess',\n        object: expr,\n        property: property.name,\n        loc: this.getLoc(expr.loc.start)\n      }\n    } else if (this.match('[')) {\n      const index = this.parseExpression()\n      this.expect(']')\n      expr = {\n        type: 'DynamicPropertyAccess',\n        object: expr,\n        property: index,\n        loc: this.getLoc(expr.loc.start)\n      }\n    } else {\n      break\n    }\n  }\n  \n  return expr\n}\n```\n\n### Function Call Parser\n```typescript\nparseFunctionCall(name: string): FunctionCall {\n  const start = this.pos\n  this.expect('(')\n  \n  // Special case: count(*)\n  if (name.toLowerCase() === 'count' \u0026\u0026 this.match('*')) {\n    this.expect(')')\n    return {\n      type: 'FunctionCall',\n      name,\n      args: [{ type: 'CountStar' }],\n      loc: this.getLoc(start)\n    }\n  }\n  \n  // Check for DISTINCT\n  const distinct = this.match('DISTINCT')\n  \n  const args: Expression[] = []\n  if (!this.check(')')) {\n    do {\n      args.push(this.parseExpression())\n    } while (this.match(','))\n  }\n  \n  this.expect(')')\n  \n  return {\n    type: 'FunctionCall',\n    name,\n    args,\n    distinct,\n    loc: this.getLoc(start)\n  }\n}\n```\n\n### Primary with Function Detection\n```typescript\nparsePrimary(): Expression {\n  if (this.isIdentifier() \u0026\u0026 this.lookAhead(1).value === '(') {\n    const name = this.parseIdentifier().name\n    return this.parseFunctionCall(name)\n  }\n  // ... other primaries\n}\n```\n\n## Acceptance Criteria\n- [ ] All property access tests pass\n- [ ] All function call tests pass\n- [ ] DISTINCT handling correct\n- [ ] count(*) special case works\n\n## TDD Phase: GREEN\n## Depends On: neo4j-8dyi","status":"closed","priority":1,"issue_type":"task","created_at":"2026-01-05T06:47:53.763909-06:00","updated_at":"2026-01-05T07:19:22.174147-06:00","closed_at":"2026-01-05T07:19:22.174147-06:00","close_reason":"Implemented in this Ralph Wiggum session - 662 tests pass"}
{"id":"neo4j-318z","title":"[RED] Integration Tests: mongo.do","description":"# [RED] Integration Tests: mongo.do\n\n## Overview\nIntegration tests for neo4j.do interoperability with mongo.do, enabling graph+document hybrid queries.\n\n## Integration Scenarios\n\n### Data Synchronization\n```typescript\ndescribe('mongo.do Sync Integration', () =\u003e {\n  let mongoClient: MongoClient\n  let neo4jSession: Session\n\n  beforeAll(async () =\u003e {\n    mongoClient = new MongoClient('mongodb://mongo.do/testdb')\n    neo4jSession = neo4jDriver.session()\n  })\n\n  it('should create graph node from MongoDB document', async () =\u003e {\n    // Create document in MongoDB\n    const doc = await mongoClient.db().collection('users').insertOne({\n      name: 'Alice',\n      email: 'alice@example.com',\n      department: 'Engineering'\n    })\n\n    // Sync to neo4j.do\n    await neo4jSession.run(`\n      CREATE (u:User {\n        mongoId: $mongoId,\n        name: $name,\n        email: $email\n      })\n    `, {\n      mongoId: doc.insertedId.toString(),\n      name: 'Alice',\n      email: 'alice@example.com'\n    })\n\n    // Verify\n    const result = await neo4jSession.run(`\n      MATCH (u:User {mongoId: $mongoId}) RETURN u\n    `, { mongoId: doc.insertedId.toString() })\n\n    expect(result.records).toHaveLength(1)\n  })\n\n  it('should maintain referential link between systems', async () =\u003e {\n    // Setup linked data\n    const userDoc = await mongoClient.db().collection('users').insertOne({\n      name: 'Bob',\n      profile: { bio: 'Developer', skills: ['TypeScript', 'Graph'] }\n    })\n\n    await neo4jSession.run(`\n      CREATE (u:User {mongoId: $id, name: 'Bob'})\n    `, { id: userDoc.insertedId.toString() })\n\n    // Query graph, enrich from MongoDB\n    const graphResult = await neo4jSession.run(`\n      MATCH (u:User {name: 'Bob'}) RETURN u.mongoId as mongoId\n    `)\n\n    const mongoId = graphResult.records[0].get('mongoId')\n    const enrichedDoc = await mongoClient.db().collection('users').findOne({\n      _id: new ObjectId(mongoId)\n    })\n\n    expect(enrichedDoc?.profile.skills).toContain('TypeScript')\n  })\n})\n```\n\n### Hybrid Queries\n```typescript\ndescribe('Hybrid Graph+Document Queries', () =\u003e {\n  beforeAll(async () =\u003e {\n    // Setup: Users in MongoDB, relationships in Neo4j\n    const users = [\n      { _id: 'user1', name: 'Alice', metadata: { role: 'admin' } },\n      { _id: 'user2', name: 'Bob', metadata: { role: 'user' } },\n      { _id: 'user3', name: 'Charlie', metadata: { role: 'user' } }\n    ]\n    \n    await mongoClient.db().collection('users').insertMany(users)\n    \n    await neo4jSession.run(`\n      CREATE (a:User {mongoId: 'user1', name: 'Alice'})\n      CREATE (b:User {mongoId: 'user2', name: 'Bob'})\n      CREATE (c:User {mongoId: 'user3', name: 'Charlie'})\n      CREATE (a)-[:MANAGES]-\u003e(b)\n      CREATE (a)-[:MANAGES]-\u003e(c)\n      CREATE (b)-[:COLLABORATES]-\u003e(c)\n    `)\n  })\n\n  it('should query relationships then enrich from MongoDB', async () =\u003e {\n    // Find Alice's direct reports via graph\n    const graphResult = await neo4jSession.run(`\n      MATCH (manager:User {name: 'Alice'})-[:MANAGES]-\u003e(report:User)\n      RETURN report.mongoId as mongoId, report.name as name\n    `)\n\n    // Enrich with MongoDB metadata\n    const enrichedReports = await Promise.all(\n      graphResult.records.map(async record =\u003e {\n        const mongoDoc = await mongoClient.db().collection('users').findOne({\n          _id: record.get('mongoId')\n        })\n        return {\n          name: record.get('name'),\n          role: mongoDoc?.metadata?.role\n        }\n      })\n    )\n\n    expect(enrichedReports).toHaveLength(2)\n    expect(enrichedReports.every(r =\u003e r.role === 'user')).toBe(true)\n  })\n\n  it('should filter by MongoDB criteria then traverse graph', async () =\u003e {\n    // Find users with specific role in MongoDB\n    const admins = await mongoClient.db().collection('users')\n      .find({ 'metadata.role': 'admin' })\n      .toArray()\n\n    const adminIds = admins.map(a =\u003e a._id)\n\n    // Find who they manage in graph\n    const result = await neo4jSession.run(`\n      MATCH (admin:User)-[:MANAGES]-\u003e(report:User)\n      WHERE admin.mongoId IN $adminIds\n      RETURN report.name as name\n    `, { adminIds })\n\n    expect(result.records.map(r =\u003e r.get('name'))).toContain('Bob')\n  })\n})\n```\n\n### Change Data Capture\n```typescript\ndescribe('CDC Between mongo.do and neo4j.do', () =\u003e {\n  it('should sync MongoDB insert to Neo4j', async () =\u003e {\n    // This tests the CDC pipeline integration\n    // Setup: Watch MongoDB changes\n    const changeStream = mongoClient.db().collection('users').watch()\n    \n    // Insert triggers CDC\n    await mongoClient.db().collection('users').insertOne({\n      _id: 'new-user',\n      name: 'Diana',\n      connections: ['user1', 'user2']\n    })\n\n    // Wait for CDC processing\n    await new Promise(r =\u003e setTimeout(r, 1000))\n\n    // Verify Neo4j was updated\n    const result = await neo4jSession.run(`\n      MATCH (u:User {mongoId: 'new-user'}) RETURN u\n    `)\n\n    expect(result.records).toHaveLength(1)\n    \n    await changeStream.close()\n  })\n\n  it('should sync Neo4j relationship changes to MongoDB', async () =\u003e {\n    // Create relationship in Neo4j\n    await neo4jSession.run(`\n      MATCH (a:User {name: 'Alice'}), (d:User {name: 'Diana'})\n      CREATE (a)-[:MENTORS]-\u003e(d)\n    `)\n\n    // Wait for CDC\n    await new Promise(r =\u003e setTimeout(r, 1000))\n\n    // Verify MongoDB was updated with relationship info\n    const doc = await mongoClient.db().collection('users').findOne({ name: 'Diana' })\n    expect(doc?.mentors).toContain('user1') // Alice's mongoId\n  })\n})\n```\n\n### Error Handling\n```typescript\ndescribe('mongo.do Integration Error Handling', () =\u003e {\n  it('should handle MongoDB connection failure gracefully', async () =\u003e {\n    const badClient = new MongoClient('mongodb://invalid-host:27017')\n    \n    await expect(\n      badClient.connect()\n    ).rejects.toThrow()\n\n    // Neo4j operations should still work\n    const result = await neo4jSession.run('RETURN 1 as n')\n    expect(result.records[0].get('n').toInt()).toBe(1)\n  })\n\n  it('should handle sync failures without data corruption', async () =\u003e {\n    // Create in Neo4j\n    await neo4jSession.run(`\n      CREATE (u:User {mongoId: 'sync-test', name: 'SyncTest'})\n    `)\n\n    // Simulate failed MongoDB sync\n    // (e.g., by using invalid data that MongoDB rejects)\n    \n    // Neo4j data should remain consistent\n    const result = await neo4jSession.run(`\n      MATCH (u:User {mongoId: 'sync-test'}) RETURN u\n    `)\n    expect(result.records).toHaveLength(1)\n  })\n})\n```\n\n## Configuration\n```typescript\n// Integration config\nconst integrationConfig = {\n  mongo: {\n    url: process.env.MONGO_DO_URL || 'mongodb://mongo.do/test',\n    database: 'neo4j_integration_test'\n  },\n  neo4j: {\n    url: process.env.NEO4J_DO_URL || 'bolt://neo4j.do',\n    database: 'integration_test'\n  },\n  sync: {\n    enabled: true,\n    cdcTopic: 'neo4j-mongo-sync'\n  }\n}\n```\n\n## Acceptance Criteria\n- [ ] Data sync tests written\n- [ ] Hybrid query tests written  \n- [ ] CDC tests written\n- [ ] Error handling tests written\n- [ ] Configuration documented\n- [ ] Tests fail initially (RED phase)","status":"open","priority":3,"issue_type":"task","created_at":"2026-01-05T06:50:44.285413-06:00","updated_at":"2026-01-05T06:50:44.285413-06:00"}
{"id":"neo4j-32f","title":"REFACTOR: HttpTransaction class optimization","description":"## Test-Driven Development: REFACTOR Phase\n\n### Component\nHTTP Client SDK - HttpTransaction Class\n\n### Refactoring Goals\n\n1. **State machine pattern**\n   - Implement proper transaction state machine\n   - Add state transition validation\n\n2. **Auto-rollback on error**\n   - Implement automatic rollback on unhandled errors\n   - Add cleanup on garbage collection (where supported)\n\n3. **Query batching**\n   - Support running multiple queries in single request\n   - Optimize network round trips\n\n4. **Metadata tracking**\n   - Track queries executed in transaction\n   - Support transaction metadata for debugging\n\n### Code Improvements\n\n```typescript\n// Transaction state machine\nenum TransactionState {\n  OPEN = 'OPEN',\n  COMMITTED = 'COMMITTED',\n  ROLLED_BACK = 'ROLLED_BACK',\n  FAILED = 'FAILED'\n}\n\nexport class HttpTransaction {\n  private state: TransactionState = TransactionState.OPEN\n  private queryHistory: string[] = []\n\n  async run\u003cT = Record\u003e(\n    query: string,\n    parameters?: Record\u003cstring, unknown\u003e\n  ): Promise\u003cQueryResult\u003cT\u003e\u003e {\n    this.assertState(TransactionState.OPEN)\n    this.queryHistory.push(query)\n    \n    try {\n      return await this.executeQuery(query, parameters)\n    } catch (error) {\n      this.state = TransactionState.FAILED\n      throw error\n    }\n  }\n\n  // Batch multiple queries\n  async runBatch(\n    queries: Array\u003c{ query: string; parameters?: Record\u003cstring, unknown\u003e }\u003e\n  ): Promise\u003cQueryResult[]\u003e {\n    this.assertState(TransactionState.OPEN)\n    \n    const response = await this.driver.fetch(`/tx/${this.id}/run-batch`, {\n      method: 'POST',\n      body: JSON.stringify({ queries })\n    })\n    \n    return response.json()\n  }\n\n  private assertState(...allowedStates: TransactionState[]): void {\n    if (!allowedStates.includes(this.state)) {\n      throw new Error(\n        `Invalid transaction state: ${this.state}. Expected: ${allowedStates.join(' or ')}`\n      )\n    }\n  }\n}\n```\n\n### Acceptance Criteria\n- [ ] All existing tests still pass\n- [ ] State machine properly enforced\n- [ ] Batch query support added\n- [ ] Better error messages\n- [ ] Query history tracking for debugging\n\n### Dependencies\n- GREEN: Implement HttpTransaction class\n\n### TDD Cycle\nThis completes the RED-\u003eGREEN-\u003eREFACTOR cycle for HttpTransaction.","status":"open","priority":2,"issue_type":"task","created_at":"2026-01-05T06:37:20.923696-06:00","updated_at":"2026-01-05T06:37:20.923696-06:00"}
{"id":"neo4j-3c6i","title":"RED: Result.summary - Write failing tests for ResultSummary access","description":"## Overview\nWrite failing tests for the Result.summary property that provides access to ResultSummary.\n\n## Test Cases to Write\n\n```typescript\ndescribe('Result.summary', () =\u003e {\n  it('should return ResultSummary object', async () =\u003e {\n    const result = createMockResult([], { queryType: 'r' });\n    \n    const summary = await result.summary;\n    expect(summary).toBeInstanceOf(ResultSummary);\n  });\n\n  it('should contain query information', async () =\u003e {\n    const result = createMockResult([], {\n      query: { text: 'MATCH (n) RETURN n', parameters: { limit: 10 } }\n    });\n    \n    const summary = await result.summary;\n    expect(summary.query.text).toBe('MATCH (n) RETURN n');\n    expect(summary.query.parameters).toEqual({ limit: 10 });\n  });\n\n  it('should be available after records consumed', async () =\u003e {\n    const result = createMockResult([{ name: 'Alice' }]);\n    \n    await result.records; // Consume records first\n    const summary = await result.summary;\n    \n    expect(summary).toBeInstanceOf(ResultSummary);\n  });\n\n  it('should contain timing information', async () =\u003e {\n    const result = createMockResult([], {\n      resultAvailableAfter: 5,\n      resultConsumedAfter: 10\n    });\n    \n    const summary = await result.summary;\n    expect(summary.resultAvailableAfter).toBe(5);\n    expect(summary.resultConsumedAfter).toBe(10);\n  });\n});\n```\n\n## Acceptance Criteria\n- [ ] All tests written and failing (RED phase)\n- [ ] Tests verify ResultSummary type\n- [ ] Tests verify summary properties\n- [ ] Test file created at src/result/__tests__/result-summary.test.ts\n\n## TDD Phase\nRED - Tests should fail because Result.summary does not exist yet","status":"closed","priority":1,"issue_type":"task","created_at":"2026-01-05T06:42:32.053204-06:00","updated_at":"2026-01-05T08:52:47.256196-06:00","closed_at":"2026-01-05T08:52:47.256196-06:00","close_reason":"Already implemented with tests passing"}
{"id":"neo4j-3f4","title":"[RED] In-Memory Graph - Write failing tests for node storage with Map","description":"## Overview\nWrite failing tests for in-memory graph implementation before coding.\n\n## Test Cases to Write\n\n### Node Storage Tests\n- `test_create_node_stores_in_map` - Node accessible after creation\n- `test_get_node_returns_node_or_null`\n- `test_update_node_modifies_properties`\n- `test_delete_node_removes_from_map`\n- `test_node_has_correct_structure` - id, labels, properties\n\n### Adjacency List Tests\n- `test_relationship_creates_adjacency_entry`\n- `test_outgoing_adjacency_list_correct`\n- `test_incoming_adjacency_list_correct`\n- `test_delete_relationship_updates_adjacency`\n- `test_bidirectional_traversal_works`\n\n### Label Index Tests\n- `test_label_index_empty_initially`\n- `test_adding_label_updates_index`\n- `test_removing_label_updates_index`\n- `test_get_nodes_by_label_returns_correct_nodes`\n- `test_node_with_multiple_labels_indexed_correctly`\n\n### Relationship Type Index Tests\n- `test_type_index_empty_initially`\n- `test_creating_relationship_updates_type_index`\n- `test_get_relationships_by_type_works`\n- `test_deleting_relationship_updates_type_index`\n\n### Property Index Tests (Optional)\n- `test_property_index_creation`\n- `test_property_index_updates_on_node_change`\n- `test_query_by_indexed_property`\n\n## Acceptance Criteria\n- [ ] All tests written and failing\n- [ ] Tests cover Map-based storage\n- [ ] Tests cover adjacency list operations\n- [ ] Tests cover all index types\n- [ ] Edge cases covered (empty graph, missing nodes)\n\n## TDD Phase\n**RED** - Write failing tests first","status":"closed","priority":1,"issue_type":"task","created_at":"2026-01-05T06:35:20.008352-06:00","updated_at":"2026-01-05T08:46:57.516276-06:00","closed_at":"2026-01-05T08:46:57.516276-06:00","close_reason":"Tests passing - implementation complete"}
{"id":"neo4j-3gi0","title":"[RED] Parser: MATCH Clause Tests","description":"## Overview\nWrite failing tests for MATCH clause parsing.\n\n## Test Cases to Write\n\n### Basic MATCH\n- Simple: `MATCH (n)`\n- With label: `MATCH (n:Person)`\n- With properties: `MATCH (n:Person {name: 'John'})`\n\n### MATCH with Relationships\n- Outgoing: `MATCH (a)-[r]-\u003e(b)`\n- With type: `MATCH (a)-[:KNOWS]-\u003e(b)`\n- Chain: `MATCH (a)--\u003e(b)--\u003e(c)`\n\n### OPTIONAL MATCH\n- Simple: `OPTIONAL MATCH (n)`\n- With pattern: `OPTIONAL MATCH (a)-[:KNOWS]-\u003e(b)`\n\n### MATCH with WHERE\n- Simple: `MATCH (n) WHERE n.age \u003e 21`\n- Complex: `MATCH (n:Person) WHERE n.name = 'John' AND n.age \u003e 21`\n\n### Multiple Patterns\n- Comma-separated: `MATCH (a), (b)`\n- Named paths: `MATCH p = (a)--\u003e(b)`\n\n### Multiple MATCH Clauses\n- `MATCH (a) MATCH (b)`\n- `MATCH (a) OPTIONAL MATCH (a)-[:KNOWS]-\u003e(b)`\n\n## Acceptance Criteria\n- [ ] All MATCH tests written and failing\n- [ ] OPTIONAL MATCH tests included\n- [ ] WHERE integration tested\n- [ ] Error cases covered\n\n## TDD Phase: RED","status":"closed","priority":1,"issue_type":"task","created_at":"2026-01-05T06:41:56.641748-06:00","updated_at":"2026-01-05T07:19:48.955482-06:00","closed_at":"2026-01-05T07:19:48.955482-06:00","close_reason":"Parser implemented with MATCH, RETURN, node/relationship patterns, expressions - 34 parser tests pass"}
{"id":"neo4j-3hoi","title":"REFACTOR: Clean up rxTx.commit() implementation","description":"## Overview\nRefactor rxTx.commit() for robust commit handling.\n\n## Refactoring Tasks\n\n### Code Quality\n- Extract commit protocol logic\n- Improve error categorization\n- Add state machine for transaction\n- Document commit semantics\n\n### Error Handling\n- Categorize commit errors properly\n- Add retry logic for transient failures\n- Clear error messages\n\n### Integration\n- Align with sync tx.commit()\n- Share commit logic where possible\n- Consistent bookmark handling\n\n## Acceptance Criteria\n- All tests still pass\n- Robust commit handling\n- Clear error messages\n- Well-documented behavior","status":"open","priority":2,"issue_type":"task","created_at":"2026-01-05T06:39:22.150487-06:00","updated_at":"2026-01-05T06:39:22.150487-06:00"}
{"id":"neo4j-3hr8","title":"GREEN: Record.entries() - Implement key-value pairs method","description":"## Overview\nImplement the Record.entries() method to make all RED phase tests pass.\n\n## Implementation\n\n```typescript\nentries(): Array\u003c[string, any]\u003e {\n  return this._keys.map((key, i) =\u003e [key, this._values[i]]);\n}\n```\n\n## Acceptance Criteria\n- [ ] All RED phase tests now pass (GREEN phase)\n- [ ] Returns array of [key, value] tuples\n- [ ] Returns new array each call\n- [ ] Implementation is minimal\n\n## TDD Phase\nGREEN - Minimal implementation to pass tests\n\n## Dependencies\n- neo4j-03qw (RED phase tests)","status":"closed","priority":1,"issue_type":"task","created_at":"2026-01-05T06:41:11.577298-06:00","updated_at":"2026-01-05T08:55:15.888797-06:00","closed_at":"2026-01-05T08:55:15.888797-06:00","close_reason":"Record methods already implemented with tests"}
{"id":"neo4j-3i6g","title":"GREEN: Record.forEach(callback) - Implement field iteration","description":"## Overview\nImplement the Record.forEach(callback) method to make all RED phase tests pass.\n\n## Implementation\n\n```typescript\nforEach(callback: (value: any, key: string, record: Record) =\u003e void): void {\n  for (let i = 0; i \u003c this._keys.length; i++) {\n    callback(this._values[i], this._keys[i], this);\n  }\n}\n```\n\n## Acceptance Criteria\n- [ ] All RED phase tests now pass (GREEN phase)\n- [ ] Callback receives value, key, record\n- [ ] Maintains field order\n- [ ] Implementation is minimal\n\n## TDD Phase\nGREEN - Minimal implementation to pass tests\n\n## Dependencies\n- neo4j-8l39 (RED phase tests)","status":"closed","priority":1,"issue_type":"task","created_at":"2026-01-05T06:39:51.318786-06:00","updated_at":"2026-01-05T08:55:15.89118-06:00","closed_at":"2026-01-05T08:55:15.89118-06:00","close_reason":"Record methods already implemented with tests"}
{"id":"neo4j-3j8","title":"REFACTOR: Full-Text Search - Optimize FTS5 performance and add advanced features","description":"## Overview\nRefactor full-text search for production quality and advanced features.\n\n## Refactoring Goals\n\n### 1. Performance Optimization\n- Incremental index updates vs full rebuild\n- Query result caching\n- Index size monitoring and optimization\n- Async index rebuilding\n\n### 2. Advanced Search Features\n```typescript\ninterface AdvancedFTSOptions {\n  // Highlighting\n  highlight?: {\n    preTag: string;\n    postTag: string;\n    maxFragments: number;\n    fragmentSize: number;\n  };\n  \n  // Boosting\n  boost?: Record\u003cstring, number\u003e; // field -\u003e boost factor\n  \n  // Spell correction\n  didYouMean?: boolean;\n  \n  // Faceting\n  facets?: string[]; // Return facet counts\n}\n```\n\n### 3. Query Enhancements\n- Spell correction suggestions\n- Query expansion (synonyms)\n- Stopword configuration\n- Custom tokenizers\n\n### 4. Index Management\n- Index health checks\n- Automatic optimization scheduling\n- Index backup/restore\n- Migration between tokenizers\n\n### 5. Observability\n- Search query analytics\n- Zero-result query tracking\n- Index size metrics\n- Query latency percentiles\n\n## Tasks\n- [ ] Implement incremental index updates\n- [ ] Add highlighting support\n- [ ] Create spell correction\n- [ ] Build faceting feature\n- [ ] Add query analytics\n- [ ] Optimize trigger performance\n- [ ] Create index backup utilities\n\n## Acceptance Criteria\n- [ ] All tests still passing\n- [ ] \u003c 10ms p99 for simple queries\n- [ ] Highlighting working correctly\n- [ ] Spell correction suggestions accurate\n\n## Tags\nsuperset, fulltext-search, fts5, tdd-refactor, performance","status":"open","priority":3,"issue_type":"task","created_at":"2026-01-05T06:37:56.468292-06:00","updated_at":"2026-01-05T06:37:56.468292-06:00"}
{"id":"neo4j-3jae","title":"GREEN: Query Optimization - Predicate Pushdown","description":"## Overview\nImplement predicate pushdown optimization to make RED tests pass.\n\n## Implementation Tasks\n\n### 1. PredicateAnalyzer\n- Identify pushable predicates\n- Determine optimal push location\n- Track predicate dependencies\n\n### 2. PushdownExecutor\n- Push predicates to scan operations\n- Integrate with pattern translation\n- Handle compound predicates\n\n### 3. Join Order Optimizer\n- Reorder JOINs for efficiency\n- Put filtered tables first\n- Consider cardinality estimates\n\n### 4. Index Hint Handler\n- Parse USING INDEX hints\n- Generate SQLite index hints\n- Fallback for missing indexes\n\n## Files to Create/Modify\n- src/cypher/optimizer/predicate-analyzer.ts\n- src/cypher/optimizer/pushdown-executor.ts\n- src/cypher/optimizer/join-order-optimizer.ts\n- src/cypher/optimizer/index-hint-handler.ts\n\n## Acceptance Criteria\n- All RED phase tests pass\n- Predicates pushed to optimal locations\n- Query performance improved\n\n## TDD Phase\nGREEN - Make tests pass with minimal code\n\n## Dependencies\n- Depends on: RED: Query Optimization - Predicate Pushdown","status":"open","priority":2,"issue_type":"task","created_at":"2026-01-05T06:44:24.429279-06:00","updated_at":"2026-01-05T06:44:24.429279-06:00"}
{"id":"neo4j-3ont","title":"RED: Authentication mechanisms fail without implementation","description":"## Test-Driven Development: RED Phase\n\n### Component\nHTTP Client SDK - Authentication\n\n### Test Cases to Write (Expected to FAIL)\n\n```typescript\nimport { describe, it, expect, vi, beforeEach } from 'vitest'\nimport { \n  BasicAuth,\n  BearerAuth,\n  CustomAuth,\n  AuthManager,\n  TokenRefreshHandler\n} from '../src/client/auth'\nimport { Neo4jHttpDriver } from '../src/client/http-driver'\n\ndescribe('Authentication - RED', () =\u003e {\n  describe('BasicAuth', () =\u003e {\n    it('should create Basic auth header', () =\u003e {\n      const auth = new BasicAuth('neo4j', 'password')\n      const header = auth.getAuthHeader()\n      \n      expect(header).toBe('Basic bmVvNGo6cGFzc3dvcmQ=')\n    })\n\n    it('should handle special characters in password', () =\u003e {\n      const auth = new BasicAuth('user', 'p@ss:word!')\n      const header = auth.getAuthHeader()\n      \n      // Should properly encode special characters\n      const decoded = atob(header.replace('Basic ', ''))\n      expect(decoded).toBe('user:p@ss:word!')\n    })\n  })\n\n  describe('BearerAuth', () =\u003e {\n    it('should create Bearer auth header', () =\u003e {\n      const auth = new BearerAuth('my-jwt-token')\n      const header = auth.getAuthHeader()\n      \n      expect(header).toBe('Bearer my-jwt-token')\n    })\n\n    it('should support token refresh', async () =\u003e {\n      const refreshFn = vi.fn().mockResolvedValue('new-token')\n      const auth = new BearerAuth('initial-token', { refresh: refreshFn })\n      \n      await auth.refreshToken()\n      \n      expect(refreshFn).toHaveBeenCalled()\n      expect(auth.getAuthHeader()).toBe('Bearer new-token')\n    })\n\n    it('should auto-refresh on 401', async () =\u003e {\n      const refreshFn = vi.fn().mockResolvedValue('refreshed-token')\n      const mockFetch = vi.fn()\n        .mockResolvedValueOnce({ ok: false, status: 401 })\n        .mockResolvedValueOnce({ ok: true, json: () =\u003e Promise.resolve({}) })\n      \n      const driver = new Neo4jHttpDriver('https://neo4j.do/db/test', {\n        auth: new BearerAuth('expired-token', { refresh: refreshFn }),\n        fetch: mockFetch\n      })\n      \n      await driver.executeQuery('RETURN 1')\n      \n      expect(refreshFn).toHaveBeenCalled()\n      expect(mockFetch).toHaveBeenCalledTimes(2)\n    })\n  })\n\n  describe('CustomAuth', () =\u003e {\n    it('should support custom auth scheme', () =\u003e {\n      const auth = new CustomAuth('X-API-Key', 'my-api-key')\n      const headers = auth.getHeaders()\n      \n      expect(headers['X-API-Key']).toBe('my-api-key')\n    })\n\n    it('should support multiple custom headers', () =\u003e {\n      const auth = new CustomAuth({\n        'X-API-Key': 'key-123',\n        'X-Tenant-ID': 'tenant-456'\n      })\n      const headers = auth.getHeaders()\n      \n      expect(headers['X-API-Key']).toBe('key-123')\n      expect(headers['X-Tenant-ID']).toBe('tenant-456')\n    })\n  })\n\n  describe('AuthManager', () =\u003e {\n    it('should manage auth lifecycle', () =\u003e {\n      const manager = new AuthManager()\n      const auth = new BasicAuth('neo4j', 'password')\n      \n      manager.setAuth(auth)\n      expect(manager.isAuthenticated).toBe(true)\n      expect(manager.getAuthHeaders()).toHaveProperty('Authorization')\n    })\n\n    it('should clear auth', () =\u003e {\n      const manager = new AuthManager()\n      manager.setAuth(new BasicAuth('neo4j', 'password'))\n      \n      manager.clearAuth()\n      \n      expect(manager.isAuthenticated).toBe(false)\n      expect(manager.getAuthHeaders()).toEqual({})\n    })\n\n    it('should handle auth expiration', async () =\u003e {\n      vi.useFakeTimers()\n      const manager = new AuthManager()\n      const auth = new BearerAuth('token', { expiresIn: 3600 })\n      \n      manager.setAuth(auth)\n      expect(manager.isExpired).toBe(false)\n      \n      vi.advanceTimersByTime(3601000)\n      \n      expect(manager.isExpired).toBe(true)\n      vi.useRealTimers()\n    })\n  })\n\n  describe('TokenRefreshHandler', () =\u003e {\n    it('should refresh token before expiration', async () =\u003e {\n      vi.useFakeTimers()\n      const refreshFn = vi.fn().mockResolvedValue('new-token')\n      const handler = new TokenRefreshHandler({\n        refresh: refreshFn,\n        expiresIn: 3600,\n        refreshBuffer: 300 // Refresh 5 min before expiry\n      })\n      \n      handler.start()\n      \n      // Advance to 5 min before expiry\n      vi.advanceTimersByTime(3300000)\n      \n      expect(refreshFn).toHaveBeenCalled()\n      vi.useRealTimers()\n    })\n\n    it('should handle refresh failure with retry', async () =\u003e {\n      const refreshFn = vi.fn()\n        .mockRejectedValueOnce(new Error('Network error'))\n        .mockResolvedValueOnce('retry-token')\n      \n      const handler = new TokenRefreshHandler({\n        refresh: refreshFn,\n        maxRetries: 3\n      })\n      \n      await handler.refreshNow()\n      \n      expect(refreshFn).toHaveBeenCalledTimes(2)\n    })\n\n    it('should emit events on refresh', async () =\u003e {\n      const handler = new TokenRefreshHandler({\n        refresh: () =\u003e Promise.resolve('new-token')\n      })\n      \n      const onRefresh = vi.fn()\n      handler.on('refresh', onRefresh)\n      \n      await handler.refreshNow()\n      \n      expect(onRefresh).toHaveBeenCalledWith('new-token')\n    })\n  })\n\n  describe('Driver with auth', () =\u003e {\n    it('should include auth headers in requests', async () =\u003e {\n      const mockFetch = vi.fn().mockResolvedValue({\n        ok: true,\n        json: () =\u003e Promise.resolve({ records: [] })\n      })\n      \n      const driver = new Neo4jHttpDriver('https://neo4j.do/db/test', {\n        auth: { username: 'neo4j', password: 'secret' },\n        fetch: mockFetch\n      })\n      \n      await driver.executeQuery('RETURN 1')\n      \n      const headers = mockFetch.mock.calls[0][1].headers\n      expect(headers['Authorization']).toMatch(/^Basic /)\n    })\n\n    it('should work without auth', async () =\u003e {\n      const mockFetch = vi.fn().mockResolvedValue({\n        ok: true,\n        json: () =\u003e Promise.resolve({ records: [] })\n      })\n      \n      const driver = new Neo4jHttpDriver('https://neo4j.do/db/test', {\n        fetch: mockFetch\n      })\n      \n      await driver.executeQuery('RETURN 1')\n      \n      const headers = mockFetch.mock.calls[0][1].headers\n      expect(headers['Authorization']).toBeUndefined()\n    })\n  })\n})\n```\n\n### Acceptance Criteria\n- [ ] Test file created at `tests/client/auth.test.ts`\n- [ ] All tests fail with expected errors\n- [ ] Tests cover: Basic, Bearer, Custom auth, token refresh\n\n### TDD Cycle\nThis is the RED phase. Next: GREEN phase implementation.","status":"open","priority":2,"issue_type":"task","created_at":"2026-01-05T06:40:47.820079-06:00","updated_at":"2026-01-05T06:40:47.820079-06:00"}
{"id":"neo4j-3qj3","title":"[RED] E2E Pattern Matching Tests","description":"# [RED] E2E Pattern Matching Tests\n\n## Overview\nEnd-to-end tests for Cypher pattern matching across various complexity levels.\n\n## Test Categories\n\n### Simple Patterns\n```typescript\ndescribe('Simple Pattern Matching E2E', () =\u003e {\n  beforeEach(async () =\u003e {\n    await session.run(`\n      CREATE (a:Person {name: 'Alice', age: 30})-[:KNOWS]-\u003e(b:Person {name: 'Bob', age: 25}),\n             (b)-[:KNOWS]-\u003e(c:Person {name: 'Charlie', age: 35}),\n             (a)-[:WORKS_AT]-\u003e(comp:Company {name: 'Acme'})\n    `)\n  })\n\n  it('should match single node', async () =\u003e {\n    const result = await session.run('MATCH (n:Person) RETURN n')\n    expect(result.records).toHaveLength(3)\n  })\n\n  it('should match node-relationship-node', async () =\u003e {\n    const result = await session.run('MATCH (a)-[:KNOWS]-\u003e(b) RETURN a.name, b.name')\n    expect(result.records).toHaveLength(2)\n  })\n\n  it('should match with property filters', async () =\u003e {\n    const result = await session.run('MATCH (n:Person {name: \"Alice\"}) RETURN n')\n    expect(result.records).toHaveLength(1)\n  })\n\n  it('should match undirected relationships', async () =\u003e {\n    const result = await session.run('MATCH (a:Person {name: \"Bob\"})-[:KNOWS]-(other) RETURN other.name')\n    const names = result.records.map(r =\u003e r.get('other.name'))\n    expect(names).toContain('Alice')\n    expect(names).toContain('Charlie')\n  })\n})\n```\n\n### Variable-Length Paths\n```typescript\ndescribe('Variable-Length Path Matching E2E', () =\u003e {\n  beforeEach(async () =\u003e {\n    await session.run(`\n      CREATE (a:Person {name: 'A'})-[:KNOWS]-\u003e(b:Person {name: 'B'})-[:KNOWS]-\u003e(c:Person {name: 'C'})-[:KNOWS]-\u003e(d:Person {name: 'D'})\n    `)\n  })\n\n  it('should match exact length path', async () =\u003e {\n    const result = await session.run('MATCH (a:Person {name: \"A\"})-[:KNOWS*2]-\u003e(c) RETURN c.name')\n    expect(result.records[0].get('c.name')).toBe('C')\n  })\n\n  it('should match variable length range', async () =\u003e {\n    const result = await session.run('MATCH (a:Person {name: \"A\"})-[:KNOWS*1..3]-\u003e(x) RETURN x.name')\n    const names = result.records.map(r =\u003e r.get('x.name'))\n    expect(names).toContain('B')\n    expect(names).toContain('C')\n    expect(names).toContain('D')\n  })\n\n  it('should match unbounded variable length', async () =\u003e {\n    const result = await session.run('MATCH (a:Person {name: \"A\"})-[:KNOWS*]-\u003e(x) RETURN x.name')\n    expect(result.records).toHaveLength(3)\n  })\n\n  it('should match with zero minimum', async () =\u003e {\n    const result = await session.run('MATCH (a:Person {name: \"A\"})-[:KNOWS*0..1]-\u003e(x) RETURN x.name')\n    const names = result.records.map(r =\u003e r.get('x.name'))\n    expect(names).toContain('A') // Self with 0 hops\n    expect(names).toContain('B') // Direct neighbor\n  })\n})\n```\n\n### Complex Patterns\n```typescript\ndescribe('Complex Pattern Matching E2E', () =\u003e {\n  beforeEach(async () =\u003e {\n    await session.run(`\n      CREATE (alice:Person {name: 'Alice'})-[:KNOWS]-\u003e(bob:Person {name: 'Bob'}),\n             (alice)-[:WORKS_AT]-\u003e(acme:Company {name: 'Acme'}),\n             (bob)-[:WORKS_AT]-\u003e(acme),\n             (charlie:Person {name: 'Charlie'})-[:KNOWS]-\u003e(alice),\n             (charlie)-[:WORKS_AT]-\u003e(other:Company {name: 'Other'})\n    `)\n  })\n\n  it('should match triangle pattern', async () =\u003e {\n    await session.run(`\n      MATCH (alice)-[:KNOWS]-\u003e(bob)\n      MATCH (bob)-[:KNOWS]-\u003e(alice)\n    `) // No triangle in this data\n  })\n\n  it('should match multiple patterns in single MATCH', async () =\u003e {\n    const result = await session.run(`\n      MATCH (p:Person)-[:WORKS_AT]-\u003e(c:Company {name: 'Acme'}),\n            (p)-[:KNOWS]-(other:Person)\n      RETURN p.name, other.name\n    `)\n    expect(result.records.length).toBeGreaterThan(0)\n  })\n\n  it('should match with WHERE clause on relationships', async () =\u003e {\n    await session.run('MATCH ()-[r:KNOWS]-\u003e() SET r.since = 2020')\n    const result = await session.run('MATCH (a)-[r:KNOWS]-\u003e(b) WHERE r.since = 2020 RETURN a.name')\n    expect(result.records.length).toBeGreaterThan(0)\n  })\n\n  it('should match shortest path', async () =\u003e {\n    const result = await session.run(`\n      MATCH p = shortestPath((a:Person {name: 'Charlie'})-[*]-(b:Person {name: 'Bob'}))\n      RETURN length(p) as len\n    `)\n    expect(result.records[0].get('len').toInt()).toBe(2)\n  })\n\n  it('should match all shortest paths', async () =\u003e {\n    const result = await session.run(`\n      MATCH p = allShortestPaths((a:Person {name: 'Charlie'})-[*]-(b:Person {name: 'Bob'}))\n      RETURN p\n    `)\n    expect(result.records.length).toBeGreaterThanOrEqual(1)\n  })\n})\n```\n\n### Optional Match\n```typescript\ndescribe('Optional Match E2E', () =\u003e {\n  beforeEach(async () =\u003e {\n    await session.run(`\n      CREATE (a:Person {name: 'Alice'})-[:KNOWS]-\u003e(b:Person {name: 'Bob'}),\n             (c:Person {name: 'Lonely'})\n    `)\n  })\n\n  it('should return null for non-matching optional', async () =\u003e {\n    const result = await session.run(`\n      MATCH (p:Person)\n      OPTIONAL MATCH (p)-[:KNOWS]-\u003e(friend)\n      RETURN p.name, friend.name\n    `)\n    expect(result.records).toHaveLength(3)\n    const lonely = result.records.find(r =\u003e r.get('p.name') === 'Lonely')\n    expect(lonely?.get('friend.name')).toBeNull()\n  })\n\n  it('should preserve rows with OPTIONAL MATCH', async () =\u003e {\n    const result = await session.run(`\n      MATCH (p:Person {name: 'Lonely'})\n      OPTIONAL MATCH (p)-[:KNOWS]-\u003e(friend)\n      RETURN p, friend\n    `)\n    expect(result.records).toHaveLength(1)\n    expect(result.records[0].get('friend')).toBeNull()\n  })\n})\n```\n\n### Pattern Expressions\n```typescript\ndescribe('Pattern Expressions E2E', () =\u003e {\n  beforeEach(async () =\u003e {\n    await session.run(`\n      CREATE (a:Person {name: 'Alice'})-[:KNOWS]-\u003e(b:Person {name: 'Bob'}),\n             (c:Person {name: 'Charlie'})\n    `)\n  })\n\n  it('should use EXISTS in WHERE', async () =\u003e {\n    const result = await session.run(`\n      MATCH (p:Person)\n      WHERE EXISTS { (p)-[:KNOWS]-\u003e() }\n      RETURN p.name\n    `)\n    expect(result.records).toHaveLength(1)\n    expect(result.records[0].get('p.name')).toBe('Alice')\n  })\n\n  it('should use pattern comprehension', async () =\u003e {\n    const result = await session.run(`\n      MATCH (p:Person)\n      RETURN p.name, [(p)-[:KNOWS]-\u003e(friend) | friend.name] AS friends\n    `)\n    const alice = result.records.find(r =\u003e r.get('p.name') === 'Alice')\n    expect(alice?.get('friends')).toContain('Bob')\n  })\n\n  it('should use COUNT in pattern', async () =\u003e {\n    const result = await session.run(`\n      MATCH (p:Person)\n      RETURN p.name, COUNT { (p)-[:KNOWS]-\u003e() } AS friendCount\n    `)\n    const alice = result.records.find(r =\u003e r.get('p.name') === 'Alice')\n    expect(alice?.get('friendCount').toInt()).toBe(1)\n  })\n})\n```\n\n## Acceptance Criteria\n- [ ] Simple patterns tested\n- [ ] Variable-length paths tested\n- [ ] Complex multi-pattern queries tested\n- [ ] OPTIONAL MATCH tested\n- [ ] Pattern expressions tested\n- [ ] Shortest path algorithms tested\n- [ ] Tests fail initially (RED phase)","status":"open","priority":2,"issue_type":"task","created_at":"2026-01-05T06:41:17.861035-06:00","updated_at":"2026-01-05T06:41:17.861035-06:00"}
{"id":"neo4j-3vz","title":"REFACTOR: Record.keys - Optimize frozen keys array","description":"## Overview\nRefactor the Record.keys implementation for better memory efficiency.\n\n## Refactoring Tasks\n\n1. **Lazy Initialization**\n   - Ensure keys are only frozen once\n   - Consider freezing in constructor\n\n2. **Type Safety**\n   - Ensure readonly type is properly exposed\n\n## Acceptance Criteria\n- [ ] All tests still pass after refactoring\n- [ ] Memory efficient implementation\n- [ ] TypeScript types properly defined\n\n## TDD Phase\nREFACTOR - Improve code without changing behavior\n\n## Dependencies\n- neo4j-8q6 (GREEN phase implementation)","status":"closed","priority":1,"issue_type":"task","created_at":"2026-01-05T06:37:57.857754-06:00","updated_at":"2026-01-05T08:57:33.738553-06:00","closed_at":"2026-01-05T08:57:33.738553-06:00","close_reason":"Record methods already implemented with tests"}
{"id":"neo4j-3x5","title":"[REFACTOR] Integer Type - Optimize and Harden","description":"## Overview\nRefactor the Integer type implementation for performance, edge cases, and code quality.\n\n## TDD Phase: REFACTOR (Improve While Green)\n\n### Refactoring Goals\n\n#### Performance Optimizations\n- [ ] Cache common Integer values (0, 1, -1, small integers)\n- [ ] Optimize hot paths (equality, comparison)\n- [ ] Minimize object allocations in arithmetic\n- [ ] Consider using BigInt internally for simplicity (benchmark)\n\n#### Edge Case Hardening\n- [ ] Add tests for overflow scenarios\n- [ ] Handle NaN, Infinity inputs\n- [ ] Validate string parsing edge cases\n- [ ] Test with MAX_VALUE and MIN_VALUE boundaries\n- [ ] Division by zero behavior\n\n#### Code Quality\n- [ ] Extract helper functions for 64-bit operations\n- [ ] Add JSDoc comments for all public methods\n- [ ] Ensure consistent error messages\n- [ ] Add type narrowing helpers\n\n#### Additional Tests\n- [ ] Property-based tests for arithmetic laws\n- [ ] Fuzz testing for parsing\n- [ ] Serialization round-trip tests\n- [ ] Integration with Result type\n\n### Acceptance Criteria\n- [ ] All existing tests still pass\n- [ ] Performance benchmarks show improvement\n- [ ] 100% test coverage on Integer module\n- [ ] No any types in implementation\n- [ ] Documentation complete\n\n### Dependencies\n- Depends on: [GREEN] Integer Type - Implement to Pass Tests","status":"closed","priority":1,"issue_type":"task","created_at":"2026-01-05T06:35:15.443225-06:00","updated_at":"2026-01-05T07:46:37.197704-06:00","closed_at":"2026-01-05T07:46:37.197704-06:00","close_reason":"Completed in Ralph Wiggum session - 987 tests pass","dependencies":[{"issue_id":"neo4j-3x5","depends_on_id":"neo4j-6sj","type":"blocks","created_at":"2026-01-05T06:41:33.109595-06:00","created_by":"nathanclevenger"}]}
{"id":"neo4j-3ym","title":"REFACTOR: Transaction Class Core Operations Optimization","description":"## Overview\nRefactor Transaction class for robustness, performance, and edge case handling.\n\n## Refactoring Goals\n\n### State Machine Improvements\n- Formal state machine implementation\n- State transition validation\n- State history tracking for debugging\n\n### Performance Optimizations\n- Query batching within transaction\n- Lazy result materialization\n- Lock acquisition optimization\n\n### Edge Cases\n```typescript\ndescribe('Transaction Edge Cases', () =\u003e {\n  it('should handle run after commit')\n  it('should handle concurrent commits')\n  it('should handle commit during network failure')\n  it('should handle rollback during network failure')\n  it('should handle very long transactions')\n  it('should handle transaction timeout')\n  it('should handle partial query execution failure')\n  it('should handle out-of-memory during transaction')\n})\n```\n\n### Consistency Improvements\n- Write-ahead logging integration\n- Checkpoint handling\n- Recovery from partial commits\n\n### Code Quality\n- Extract state machine\n- Create transaction context\n- Improve error messages with transaction context\n- Add transaction ID to all logs\n\n## TDD Phase\n**REFACTOR** - Improve without breaking tests.\n\n## Dependencies\n- Depends on: GREEN: Transaction Class Core Operations Implementation\n\n## Acceptance Criteria\n- [ ] All tests pass\n- [ ] State machine is well-defined\n- [ ] Edge cases handled\n- [ ] Performance improved","status":"open","priority":2,"issue_type":"task","created_at":"2026-01-05T06:38:43.288644-06:00","updated_at":"2026-01-05T06:38:43.288644-06:00"}
{"id":"neo4j-3zd0","title":"GREEN: Implement proper subscription handling","description":"## Overview\nImplement proper subscription handling to make all RED tests pass.\n\n## Implementation Requirements\n\n### Subscription Lifecycle\n- Start execution on subscribe\n- Track active subscriptions\n- Handle unsubscription properly\n- Clean up resources on complete/error\n\n### Resource Management\n- Allocate on subscribe\n- Release on unsubscribe\n- Release on complete\n- Release on error\n\n### Implementation Details\n- Use proper Observable creation\n- Implement teardown logic\n- Handle concurrent subscriptions\n- Manage pending operations\n\n## Acceptance Criteria\n- All RED tests now pass (GREEN phase)\n- Subscriptions work correctly\n- Resources properly managed\n- No memory leaks","status":"open","priority":2,"issue_type":"task","created_at":"2026-01-05T06:42:53.98998-06:00","updated_at":"2026-01-05T06:42:53.98998-06:00"}
{"id":"neo4j-3zo","title":"[REFACTOR] SQLite Schema Design - Optimize and clean up schema implementation","description":"## Overview\nRefactor the schema implementation for better performance and maintainability.\n\n## Refactoring Tasks\n\n### Schema Organization\n- Extract schema definitions to constants\n- Create type-safe schema builder\n- Add schema documentation comments\n\n### Migration System\n- Implement versioned migrations\n- Add rollback support\n- Create migration CLI tool\n- Add migration status checking\n\n### Index Optimization\n- Analyze query patterns\n- Add composite indexes where beneficial\n- Consider partial indexes for common filters\n\n### Trigger Optimization\n```sql\n-- Auto-update updated_at\nCREATE TRIGGER IF NOT EXISTS update_node_timestamp \nAFTER UPDATE ON nodes\nBEGIN\n  UPDATE nodes SET updated_at = CURRENT_TIMESTAMP WHERE id = NEW.id;\nEND;\n```\n\n### Code Quality\n- Add JSDoc comments\n- Create TypeScript interfaces for schema\n- Add schema validation utility\n- Write schema documentation\n\n## Performance Considerations\n- PRAGMA settings for Durable Objects\n- WAL mode configuration\n- Foreign key enforcement settings\n\n## Acceptance Criteria\n- [ ] All tests still pass\n- [ ] Code is well-documented\n- [ ] Migration system is production-ready\n- [ ] Schema is optimized for common queries\n- [ ] No code duplication\n\n## TDD Phase\n**REFACTOR** - Improve without changing behavior","status":"open","priority":2,"issue_type":"task","created_at":"2026-01-05T06:34:49.852338-06:00","updated_at":"2026-01-05T06:34:49.852338-06:00"}
{"id":"neo4j-41o","title":"REFACTOR: REST API endpoint optimization","description":"## Test-Driven Development: REFACTOR Phase\n\n### Component\nHTTP Client SDK - REST API Endpoints\n\n### Refactoring Goals\n\n1. **Middleware extraction**\n   - Authentication middleware\n   - Error handling middleware\n   - Request validation middleware\n\n2. **OpenAPI specification**\n   - Generate OpenAPI/Swagger docs\n   - Validate requests against schema\n\n3. **Response formatting**\n   - Standardize response envelope\n   - HATEOAS links for discoverability\n\n4. **Performance optimizations**\n   - Response compression\n   - ETag support for caching\n\n### Code Improvements\n\n```typescript\n// Middleware for error handling\nconst errorHandler: ErrorHandler = (err, c) =\u003e {\n  console.error('API Error:', err)\n  \n  if (err instanceof Neo4jError) {\n    return c.json({\n      error: {\n        code: err.code,\n        message: err.message,\n        details: err.details\n      }\n    }, mapNeo4jErrorToStatus(err))\n  }\n  \n  return c.json({\n    error: {\n      code: 'INTERNAL_ERROR',\n      message: 'An unexpected error occurred'\n    }\n  }, 500)\n}\n\n// Request validation middleware\nconst validateQuery = validator('json', (value, c) =\u003e {\n  const parsed = querySchema.safeParse(value)\n  if (!parsed.success) {\n    return c.json({ error: parsed.error.format() }, 400)\n  }\n  return parsed.data\n})\n\n// Standardized response envelope\ninterface ApiResponse\u003cT\u003e {\n  data: T\n  meta: {\n    requestId: string\n    timestamp: string\n    duration: number\n  }\n  links?: Record\u003cstring, string\u003e\n}\n\n// Route with HATEOAS\napp.post('/tx/begin', validateTransaction, async (c) =\u003e {\n  const tx = await txManager.begin(c.req.valid('json'))\n  return c.json({\n    data: { id: tx.id, accessMode: tx.accessMode },\n    meta: { requestId: c.get('requestId'), timestamp: new Date().toISOString() },\n    links: {\n      run: `/tx/${tx.id}/run`,\n      commit: `/tx/${tx.id}/commit`,\n      rollback: `/tx/${tx.id}/rollback`\n    }\n  }, 201)\n})\n```\n\n### Acceptance Criteria\n- [ ] All existing tests still pass\n- [ ] Middleware properly separated\n- [ ] Error responses are consistent\n- [ ] OpenAPI spec generated\n- [ ] Response envelope standardized\n\n### Dependencies\n- GREEN: Implement REST API endpoint handlers\n\n### TDD Cycle\nThis completes the RED-\u003eGREEN-\u003eREFACTOR cycle for REST API Endpoints.","status":"open","priority":2,"issue_type":"task","created_at":"2026-01-05T06:38:43.957952-06:00","updated_at":"2026-01-05T06:38:43.957952-06:00"}
{"id":"neo4j-43y4","title":"REFACTOR: Result.keys - Optimize early key resolution","description":"## Overview\nRefactor the Result.keys implementation for optimal early availability.\n\n## Refactoring Tasks\n\n1. **Early Resolution**\n   - Resolve keys as soon as first record metadata available\n   - Do not wait for all records\n\n2. **Caching**\n   - Cache resolved keys\n   - Handle empty result sets\n\n## Acceptance Criteria\n- [ ] All tests still pass after refactoring\n- [ ] Keys available as early as possible\n- [ ] Properly cached\n\n## TDD Phase\nREFACTOR - Improve code without changing behavior\n\n## Dependencies\n- neo4j-bieb (GREEN phase implementation)","status":"closed","priority":1,"issue_type":"task","created_at":"2026-01-05T06:43:32.078064-06:00","updated_at":"2026-01-05T08:52:47.253768-06:00","closed_at":"2026-01-05T08:52:47.253768-06:00","close_reason":"Already implemented with tests passing"}
{"id":"neo4j-44n","title":"RED: HttpTransaction class methods fail without implementation","description":"## Test-Driven Development: RED Phase\n\n### Component\nHTTP Client SDK - HttpTransaction Class\n\n### Test Cases to Write (Expected to FAIL)\n\n```typescript\nimport { describe, it, expect, vi, beforeEach } from 'vitest'\nimport { HttpTransaction } from '../src/client/http-transaction'\nimport { Neo4jHttpDriver } from '../src/client/http-driver'\n\ndescribe('HttpTransaction - RED', () =\u003e {\n  let driver: Neo4jHttpDriver\n  let mockFetch: ReturnType\u003ctypeof vi.fn\u003e\n\n  beforeEach(() =\u003e {\n    mockFetch = vi.fn()\n    driver = new Neo4jHttpDriver('https://neo4j.do/db/mydb', { fetch: mockFetch })\n  })\n\n  describe('transaction ID management', () =\u003e {\n    it('should have a unique transaction ID', () =\u003e {\n      const tx = new HttpTransaction(driver, 'tx-123')\n      expect(tx.id).toBe('tx-123')\n    })\n\n    it('should track transaction state', () =\u003e {\n      const tx = new HttpTransaction(driver, 'tx-123')\n      expect(tx.isOpen).toBe(true)\n      expect(tx.isCommitted).toBe(false)\n      expect(tx.isRolledBack).toBe(false)\n    })\n  })\n\n  describe('run()', () =\u003e {\n    it('should execute query via POST /tx/{id}/run', async () =\u003e {\n      mockFetch.mockResolvedValue({\n        ok: true,\n        json: () =\u003e Promise.resolve({ records: [{ n: 1 }] })\n      })\n      \n      const tx = new HttpTransaction(driver, 'tx-123')\n      const result = await tx.run('RETURN 1 as n')\n      \n      expect(mockFetch).toHaveBeenCalledWith(\n        'https://neo4j.do/db/mydb/tx/tx-123/run',\n        expect.objectContaining({ method: 'POST' })\n      )\n      expect(result.records[0].get('n')).toBe(1)\n    })\n\n    it('should include parameters in request', async () =\u003e {\n      mockFetch.mockResolvedValue({\n        ok: true,\n        json: () =\u003e Promise.resolve({ records: [] })\n      })\n      \n      const tx = new HttpTransaction(driver, 'tx-123')\n      await tx.run('MATCH (n) WHERE n.id = $id RETURN n', { id: 456 })\n      \n      const body = JSON.parse(mockFetch.mock.calls[0][1].body)\n      expect(body.query).toBe('MATCH (n) WHERE n.id = $id RETURN n')\n      expect(body.parameters).toEqual({ id: 456 })\n    })\n\n    it('should reject run after commit', async () =\u003e {\n      mockFetch.mockResolvedValue({ ok: true, json: () =\u003e Promise.resolve({}) })\n      \n      const tx = new HttpTransaction(driver, 'tx-123')\n      await tx.commit()\n      \n      await expect(tx.run('RETURN 1')).rejects.toThrow('Transaction is not open')\n    })\n  })\n\n  describe('commit()', () =\u003e {\n    it('should commit via POST /tx/{id}/commit', async () =\u003e {\n      mockFetch.mockResolvedValue({\n        ok: true,\n        json: () =\u003e Promise.resolve({ bookmarks: ['bm:1'] })\n      })\n      \n      const tx = new HttpTransaction(driver, 'tx-123')\n      await tx.commit()\n      \n      expect(mockFetch).toHaveBeenCalledWith(\n        'https://neo4j.do/db/mydb/tx/tx-123/commit',\n        expect.objectContaining({ method: 'POST' })\n      )\n      expect(tx.isCommitted).toBe(true)\n      expect(tx.isOpen).toBe(false)\n    })\n\n    it('should return bookmarks after commit', async () =\u003e {\n      mockFetch.mockResolvedValue({\n        ok: true,\n        json: () =\u003e Promise.resolve({ bookmarks: ['bm:1', 'bm:2'] })\n      })\n      \n      const tx = new HttpTransaction(driver, 'tx-123')\n      const result = await tx.commit()\n      \n      expect(result.bookmarks).toEqual(['bm:1', 'bm:2'])\n    })\n  })\n\n  describe('rollback()', () =\u003e {\n    it('should rollback via POST /tx/{id}/rollback', async () =\u003e {\n      mockFetch.mockResolvedValue({ ok: true, json: () =\u003e Promise.resolve({}) })\n      \n      const tx = new HttpTransaction(driver, 'tx-123')\n      await tx.rollback()\n      \n      expect(mockFetch).toHaveBeenCalledWith(\n        'https://neo4j.do/db/mydb/tx/tx-123/rollback',\n        expect.objectContaining({ method: 'POST' })\n      )\n      expect(tx.isRolledBack).toBe(true)\n      expect(tx.isOpen).toBe(false)\n    })\n  })\n\n  describe('timeout handling', () =\u003e {\n    it('should support transaction timeout', async () =\u003e {\n      const tx = new HttpTransaction(driver, 'tx-123', { timeout: 30000 })\n      expect(tx.timeout).toBe(30000)\n    })\n\n    it('should abort on timeout', async () =\u003e {\n      vi.useFakeTimers()\n      mockFetch.mockImplementation(() =\u003e new Promise(() =\u003e {})) // Never resolves\n      \n      const tx = new HttpTransaction(driver, 'tx-123', { timeout: 1000 })\n      const promise = tx.run('RETURN 1')\n      \n      vi.advanceTimersByTime(1001)\n      \n      await expect(promise).rejects.toThrow('Transaction timed out')\n      vi.useRealTimers()\n    })\n  })\n})\n```\n\n### Acceptance Criteria\n- [ ] Test file created at `tests/client/http-transaction.test.ts`\n- [ ] All tests fail with expected errors\n- [ ] Tests cover: ID management, run, commit, rollback, timeout\n\n### TDD Cycle\nThis is the RED phase. Next: GREEN phase implementation.","status":"open","priority":2,"issue_type":"task","created_at":"2026-01-05T06:36:42.923906-06:00","updated_at":"2026-01-05T06:36:42.923906-06:00"}
{"id":"neo4j-46ck","title":"[GREEN] Parser: Implement RETURN and WITH Clauses","description":"## Overview\nImplement RETURN and WITH clause parsing.\n\n## Implementation Tasks\n\n### Return Clause Parser\n```typescript\nparseReturnClause(): ReturnClause {\n  const start = this.pos\n  this.expect('RETURN')\n  \n  const distinct = this.match('DISTINCT')\n  const items = this.parseReturnItems()\n  const orderBy = this.parseOrderBy()\n  const skip = this.parseSkip()\n  const limit = this.parseLimit()\n  \n  return {\n    type: 'ReturnClause',\n    distinct,\n    items,\n    orderBy,\n    skip,\n    limit,\n    loc: this.getLoc(start)\n  }\n}\n```\n\n### Return Items\n```typescript\nparseReturnItems(): ReturnItem[] {\n  if (this.match('*')) {\n    return [{ type: 'ReturnAll' }]\n  }\n  \n  const items: ReturnItem[] = []\n  do {\n    const expression = this.expressionParser.parseExpression()\n    let alias: string | undefined\n    if (this.match('AS')) {\n      alias = this.parseIdentifier().name\n    }\n    items.push({ expression, alias })\n  } while (this.match(','))\n  \n  return items\n}\n```\n\n### Order By Parser\n```typescript\nparseOrderBy(): OrderByItem[] | undefined {\n  if (\\!this.match('ORDER')) return undefined\n  this.expect('BY')\n  \n  const items: OrderByItem[] = []\n  do {\n    const expression = this.expressionParser.parseExpression()\n    let direction: 'ASC' | 'DESC' = 'ASC'\n    if (this.match('DESC') || this.match('DESCENDING')) {\n      direction = 'DESC'\n    } else {\n      this.match('ASC') || this.match('ASCENDING')\n    }\n    items.push({ expression, direction })\n  } while (this.match(','))\n  \n  return items\n}\n```\n\n### WITH Clause (similar to RETURN with WHERE)\n```typescript\nparseWithClause(): WithClause {\n  // Similar to RETURN but includes optional WHERE\n  const where = this.match('WHERE') \n    ? this.expressionParser.parseExpression() \n    : undefined\n  // ...\n}\n```\n\n## Acceptance Criteria\n- [ ] All RETURN tests pass\n- [ ] All WITH tests pass\n- [ ] ORDER BY works correctly\n- [ ] SKIP/LIMIT work correctly\n\n## TDD Phase: GREEN\n## Depends On: neo4j-xpfx","status":"closed","priority":1,"issue_type":"task","created_at":"2026-01-05T06:42:58.549199-06:00","updated_at":"2026-01-05T07:19:48.955898-06:00","closed_at":"2026-01-05T07:19:48.955898-06:00","close_reason":"Parser implemented with MATCH, RETURN, node/relationship patterns, expressions - 34 parser tests pass"}
{"id":"neo4j-47wh","title":"RED: Graph Algorithms - Write failing tests for algorithm procedures","description":"## Overview\nWrite failing tests for graph algorithm procedures implemented via SQL CTEs.\n\n## Test Cases\n\n```typescript\ndescribe('Graph Algorithms', () =\u003e {\n  beforeAll(async () =\u003e {\n    // Create test graph\n    await session.run(`\n      CREATE (a:City {name: \"A\"})\n      CREATE (b:City {name: \"B\"})\n      CREATE (c:City {name: \"C\"})\n      CREATE (d:City {name: \"D\"})\n      CREATE (e:City {name: \"E\"})\n      CREATE (a)-[:ROAD {distance: 10}]-\u003e(b)\n      CREATE (a)-[:ROAD {distance: 5}]-\u003e(c)\n      CREATE (b)-[:ROAD {distance: 3}]-\u003e(d)\n      CREATE (c)-[:ROAD {distance: 8}]-\u003e(d)\n      CREATE (c)-[:ROAD {distance: 2}]-\u003e(e)\n      CREATE (d)-[:ROAD {distance: 4}]-\u003e(e)\n    `);\n  });\n\n  describe('Shortest Path', () =\u003e {\n    it('should find shortest unweighted path', async () =\u003e {\n      const result = await session.run(`\n        CALL algo.shortestPath(\n          (a:City {name: \"A\"}),\n          (e:City {name: \"E\"}),\n          \"ROAD\"\n        ) YIELD path, length\n        RETURN [n IN nodes(path) | n.name] as cities, length\n      `);\n      \n      expect(result.records[0].get('length')).toBe(2);\n      expect(result.records[0].get('cities')).toEqual(['A', 'C', 'E']);\n    });\n\n    it('should find shortest weighted path', async () =\u003e {\n      const result = await session.run(`\n        CALL algo.shortestPath(\n          (a:City {name: \"A\"}),\n          (e:City {name: \"E\"}),\n          \"ROAD\",\n          { weightProperty: \"distance\" }\n        ) YIELD path, cost\n        RETURN [n IN nodes(path) | n.name] as cities, cost\n      `);\n      \n      expect(result.records[0].get('cost')).toBe(7); // A-\u003eC(5) + C-\u003eE(2)\n    });\n\n    it('should return null when no path exists', async () =\u003e {\n      await session.run('CREATE (:Island {name: \"Isolated\"})');\n      \n      const result = await session.run(`\n        CALL algo.shortestPath(\n          (a:City {name: \"A\"}),\n          (i:Island {name: \"Isolated\"}),\n          \"ROAD\"\n        ) YIELD path\n        RETURN path\n      `);\n      \n      expect(result.records[0].get('path')).toBeNull();\n    });\n\n    it('should support max depth limit', async () =\u003e {\n      const result = await session.run(`\n        CALL algo.shortestPath(\n          (a:City {name: \"A\"}),\n          (e:City {name: \"E\"}),\n          \"ROAD\",\n          { maxDepth: 1 }\n        ) YIELD path\n        RETURN path\n      `);\n      \n      expect(result.records[0].get('path')).toBeNull();\n    });\n  });\n\n  describe('PageRank', () =\u003e {\n    it('should compute PageRank scores', async () =\u003e {\n      const result = await session.run(`\n        CALL algo.pageRank(\"City\", \"ROAD\", { iterations: 20 })\n        YIELD node, score\n        RETURN node.name, score\n        ORDER BY score DESC\n      `);\n      \n      // Most connected node should have highest score\n      expect(result.records[0].get('node.name')).toBe('D'); // or 'E'\n      expect(result.records[0].get('score')).toBeGreaterThan(0);\n    });\n\n    it('should support damping factor', async () =\u003e {\n      const result = await session.run(`\n        CALL algo.pageRank(\"City\", \"ROAD\", { dampingFactor: 0.85 })\n        YIELD node, score\n        RETURN node.name, score\n      `);\n      \n      // Sum of all scores should approximate number of nodes\n      const totalScore = result.records.reduce((sum, r) =\u003e sum + r.get('score'), 0);\n      expect(totalScore).toBeCloseTo(5, 1);\n    });\n  });\n\n  describe('Community Detection', () =\u003e {\n    beforeAll(async () =\u003e {\n      // Create graph with clear communities\n      await session.run(`\n        CREATE (a1:Person {name: \"A1\", group: 1})\n        CREATE (a2:Person {name: \"A2\", group: 1})\n        CREATE (a3:Person {name: \"A3\", group: 1})\n        CREATE (b1:Person {name: \"B1\", group: 2})\n        CREATE (b2:Person {name: \"B2\", group: 2})\n        CREATE (b3:Person {name: \"B3\", group: 2})\n        CREATE (a1)-[:KNOWS]-\u003e(a2)\n        CREATE (a2)-[:KNOWS]-\u003e(a3)\n        CREATE (a1)-[:KNOWS]-\u003e(a3)\n        CREATE (b1)-[:KNOWS]-\u003e(b2)\n        CREATE (b2)-[:KNOWS]-\u003e(b3)\n        CREATE (b1)-[:KNOWS]-\u003e(b3)\n        CREATE (a1)-[:KNOWS]-\u003e(b1)\n      `);\n    });\n\n    it('should detect communities using Louvain', async () =\u003e {\n      const result = await session.run(`\n        CALL algo.communityDetection(\"Person\", \"KNOWS\", { algorithm: \"louvain\" })\n        YIELD node, community\n        RETURN node.name, community\n      `);\n      \n      const communities = new Map();\n      result.records.forEach(r =\u003e {\n        const name = r.get('node.name');\n        const comm = r.get('community');\n        if (!communities.has(comm)) communities.set(comm, []);\n        communities.get(comm).push(name);\n      });\n      \n      expect(communities.size).toBe(2);\n    });\n\n    it('should detect communities using Label Propagation', async () =\u003e {\n      const result = await session.run(`\n        CALL algo.communityDetection(\"Person\", \"KNOWS\", { algorithm: \"labelPropagation\" })\n        YIELD node, community\n        RETURN node.name, community\n      `);\n      \n      expect(result.records.length).toBe(6);\n    });\n  });\n\n  describe('Similarity', () =\u003e {\n    it('should compute cosine similarity between node vectors', async () =\u003e {\n      await session.run(`\n        CREATE (a:Doc {embedding: [1.0, 0.0, 0.0]})\n        CREATE (b:Doc {embedding: [1.0, 0.0, 0.0]})\n        CREATE (c:Doc {embedding: [0.0, 1.0, 0.0]})\n      `);\n      \n      const result = await session.run(`\n        MATCH (a:Doc), (b:Doc)\n        WHERE id(a) \u003c id(b)\n        CALL algo.similarity.cosine(a, b, \"embedding\") YIELD similarity\n        RETURN a.embedding, b.embedding, similarity\n      `);\n      \n      const sameVector = result.records.find(r =\u003e \n        JSON.stringify(r.get('a.embedding')) === JSON.stringify(r.get('b.embedding'))\n      );\n      expect(sameVector.get('similarity')).toBe(1.0);\n    });\n\n    it('should compute Jaccard similarity', async () =\u003e {\n      await session.run(`\n        CREATE (a:User {interests: [\"music\", \"movies\", \"sports\"]})\n        CREATE (b:User {interests: [\"music\", \"movies\", \"games\"]})\n      `);\n      \n      const result = await session.run(`\n        MATCH (a:User), (b:User)\n        WHERE a \u003c\u003e b\n        CALL algo.similarity.jaccard(a, b, \"interests\") YIELD similarity\n        RETURN similarity\n      `);\n      \n      expect(result.records[0].get('similarity')).toBeCloseTo(0.5, 2);\n    });\n  });\n\n  describe('Centrality', () =\u003e {\n    it('should compute betweenness centrality', async () =\u003e {\n      const result = await session.run(`\n        CALL algo.centrality.betweenness(\"City\", \"ROAD\")\n        YIELD node, score\n        RETURN node.name, score\n        ORDER BY score DESC\n      `);\n      \n      // Node C or D should have highest betweenness\n      expect(['C', 'D']).toContain(result.records[0].get('node.name'));\n    });\n\n    it('should compute degree centrality', async () =\u003e {\n      const result = await session.run(`\n        CALL algo.centrality.degree(\"City\", \"ROAD\", { direction: \"both\" })\n        YIELD node, score\n        RETURN node.name, score\n      `);\n      \n      expect(result.records.length).toBeGreaterThan(0);\n    });\n  });\n\n  describe('Connected Components', () =\u003e {\n    it('should find connected components', async () =\u003e {\n      const result = await session.run(`\n        CALL algo.connectedComponents(\"City\", \"ROAD\")\n        YIELD node, componentId\n        RETURN componentId, collect(node.name) as nodes\n      `);\n      \n      // Cities should be in one component, Island in another\n      expect(result.records.length).toBe(2);\n    });\n  });\n});\n```\n\n## Acceptance Criteria\n- [ ] All test cases written and failing\n- [ ] Test graphs with known algorithm results\n- [ ] Performance benchmarks defined\n\n## Tags\nsuperset, graph-algorithms, procedures, tdd-red","status":"open","priority":2,"issue_type":"task","created_at":"2026-01-05T06:49:48.44646-06:00","updated_at":"2026-01-05T06:49:48.44646-06:00"}
{"id":"neo4j-49mt","title":"[GREEN] Parser: Implement CASE Expression Parsing","description":"## Overview\nImplement CASE expression parsing.\n\n## Implementation Tasks\n\n### CASE Expression Parser\n```typescript\nparseCaseExpression(): CaseExpression {\n  const start = this.pos\n  this.expect('CASE')\n  \n  // Check for simple case (CASE expr WHEN ...)\n  let operand: Expression | undefined\n  if (\\!this.check('WHEN')) {\n    operand = this.parseExpression()\n  }\n  \n  // Parse WHEN clauses\n  const whenClauses: WhenClause[] = []\n  while (this.match('WHEN')) {\n    const condition = this.parseExpression()\n    this.expect('THEN')\n    const result = this.parseExpression()\n    whenClauses.push({ condition, result })\n  }\n  \n  // Parse optional ELSE\n  let elseResult: Expression | undefined\n  if (this.match('ELSE')) {\n    elseResult = this.parseExpression()\n  }\n  \n  this.expect('END')\n  \n  return {\n    type: 'CaseExpression',\n    operand,\n    whenClauses,\n    elseResult,\n    loc: this.getLoc(start)\n  }\n}\n```\n\n### AST Types\n```typescript\ninterface CaseExpression extends ASTNode {\n  type: 'CaseExpression'\n  operand?: Expression  // for simple CASE\n  whenClauses: WhenClause[]\n  elseResult?: Expression\n}\n\ninterface WhenClause {\n  condition: Expression\n  result: Expression\n}\n```\n\n### Integration\n- Add to parsePrimary() switch\n- Handle CASE as keyword properly\n\n## Acceptance Criteria\n- [ ] All CASE tests pass\n- [ ] Simple form works (CASE x WHEN)\n- [ ] Generic form works (CASE WHEN)\n- [ ] ELSE optional\n\n## TDD Phase: GREEN\n## Depends On: neo4j-treu","status":"open","priority":2,"issue_type":"task","created_at":"2026-01-05T06:48:30.77125-06:00","updated_at":"2026-01-05T06:48:30.77125-06:00"}
{"id":"neo4j-4c5","title":"[GREEN] Durable Object Implementation - Implement Neo4jDatabase class to pass tests","description":"## Overview\nImplement the Neo4jDatabase Durable Object to make all tests pass.\n\n## Implementation Requirements\n\n### Durable Object Class\n```typescript\nexport class Neo4jDatabase implements DurableObject {\n  private sql: SqlStorage;\n  private initialized = false;\n\n  constructor(state: DurableObjectState, env: Env) {\n    this.sql = state.storage.sql;\n  }\n\n  async fetch(request: Request): Promise\u003cResponse\u003e {\n    await this.ensureInitialized();\n    \n    const url = new URL(request.url);\n    switch (url.pathname) {\n      case '/query':\n        return this.handleQuery(request);\n      case '/transaction/begin':\n        return this.handleBeginTransaction(request);\n      case '/transaction/commit':\n        return this.handleCommitTransaction(request);\n      case '/transaction/rollback':\n        return this.handleRollbackTransaction(request);\n      default:\n        return new Response('Not Found', { status: 404 });\n    }\n  }\n\n  private async ensureInitialized(): Promise\u003cvoid\u003e {\n    if (this.initialized) return;\n    await this.initializeSchema();\n    this.initialized = true;\n  }\n}\n```\n\n### Request Handlers\n```typescript\ninterface QueryRequest {\n  query: string;\n  parameters?: Record\u003cstring, unknown\u003e;\n}\n\ninterface QueryResponse {\n  results: any[];\n  summary: {\n    counters: UpdateCounters;\n    time: number;\n  };\n}\n```\n\n### Schema Initialization\n- Apply migrations on first request\n- Check and update schema version\n- Create indexes and constraints\n\n## Files to Create\n- `src/durable-objects/neo4j-database.ts`\n- `src/durable-objects/handlers/query.ts`\n- `src/durable-objects/handlers/transaction.ts`\n\n## Acceptance Criteria\n- [ ] All RED phase tests pass\n- [ ] DO initializes correctly\n- [ ] Queries execute properly\n- [ ] Transactions work correctly\n- [ ] Errors handled gracefully\n\n## TDD Phase\n**GREEN** - Minimum code to pass tests","status":"closed","priority":1,"issue_type":"task","created_at":"2026-01-05T06:36:09.025399-06:00","updated_at":"2026-01-05T08:53:44.635589-06:00","closed_at":"2026-01-05T08:53:44.635589-06:00","close_reason":"Tests passing - implementation complete"}
{"id":"neo4j-4eq","title":"RED: Driver Class Factory \u0026 URI Parsing Tests","description":"## Overview\nWrite comprehensive failing tests for the Driver class factory function and URI parsing.\n\n## Test Cases\n\n### Factory Function Tests\n```typescript\ndescribe('neo4j.driver()', () =\u003e {\n  it('should create driver with URI only')\n  it('should create driver with URI and auth token')\n  it('should create driver with URI, auth, and config')\n  it('should throw on invalid URI format')\n  it('should throw on unsupported scheme')\n})\n```\n\n### URI Parsing Tests\n```typescript\ndescribe('URI Parsing', () =\u003e {\n  it('should parse neo4j:// scheme')\n  it('should parse neo4j+s:// scheme (encrypted)')\n  it('should parse bolt:// scheme')\n  it('should parse bolt+s:// scheme (encrypted)')\n  it('should extract host from URI')\n  it('should extract port from URI (default 7687)')\n  it('should handle custom ports')\n  it('should handle IPv6 addresses')\n  it('should parse query parameters')\n})\n```\n\n### Auth Token Tests\n```typescript\ndescribe('neo4j.auth', () =\u003e {\n  describe('basic()', () =\u003e {\n    it('should create basic auth token with username/password')\n    it('should create basic auth with realm')\n  })\n  describe('bearer()', () =\u003e {\n    it('should create bearer token')\n  })\n  describe('custom()', () =\u003e {\n    it('should create custom auth with principal/credentials/realm/scheme')\n    it('should include custom parameters')\n  })\n})\n```\n\n### Configuration Tests\n```typescript\ndescribe('Driver Configuration', () =\u003e {\n  it('should accept maxTransactionRetryTime')\n  it('should accept connectionTimeout')\n  it('should accept maxConnectionPoolSize')\n  it('should accept connectionAcquisitionTimeout')\n  it('should accept logging configuration')\n  it('should use defaults when not specified')\n  it('should validate configuration values')\n})\n```\n\n## TDD Phase\n**RED** - All tests should fail initially as no implementation exists.\n\n## Acceptance Criteria\n- [ ] All test cases written with clear descriptions\n- [ ] Tests use proper mocking for Cloudflare environment\n- [ ] Tests cover edge cases and error conditions\n- [ ] Tests are isolated and independent\n- [ ] Test file created at `src/driver/__tests__/driver.test.ts`","status":"closed","priority":1,"issue_type":"task","created_at":"2026-01-05T06:34:30.854121-06:00","updated_at":"2026-01-05T07:13:11.691317-06:00","closed_at":"2026-01-05T07:13:11.691317-06:00","close_reason":"Implemented in Ralph Wiggum session"}
{"id":"neo4j-4hz","title":"GREEN: Pattern to JOIN Translation - Relationship Patterns","description":"## Overview\nImplement relationship pattern translation to make RED tests pass.\n\n## Implementation Tasks\n\n### 1. Extend PatternTranslator for Relationships\n```typescript\nclass PatternTranslator {\n  translateRelationshipPattern(pattern: RelationshipPattern): SQLFragment {\n    const { startNode, relationship, endNode, direction } = pattern;\n    // Generate JOINs based on direction\n  }\n}\n```\n\n### 2. Direction Handler\n```typescript\nenum Direction { OUTGOING, INCOMING, BOTH }\n\nclass DirectionHandler {\n  getJoinConditions(direction: Direction, relAlias: string, \n                    startAlias: string, endAlias: string): string[] {\n    switch (direction) {\n      case Direction.OUTGOING:\n        return [`${startAlias}.id = ${relAlias}.start_node_id`,\n                `${endAlias}.id = ${relAlias}.end_node_id`];\n      case Direction.INCOMING:\n        return [`${startAlias}.id = ${relAlias}.end_node_id`,\n                `${endAlias}.id = ${relAlias}.start_node_id`];\n      case Direction.BOTH:\n        // OR condition for either direction\n    }\n  }\n}\n```\n\n### 3. Multi-Hop Pattern Handler\n```typescript\nclass PathPatternTranslator {\n  translatePath(segments: PathSegment[]): SQLFragment {\n    // Chain JOINs for each segment\n    // Share node references between adjacent segments\n  }\n}\n```\n\n### 4. Relationship Type Filter\n```typescript\nprivate translateTypeFilter(types: string[]): string {\n  if (types.length === 1) return `type = '${types[0]}'`;\n  return `type IN (${types.map(t =\u003e \"'\"+t+\"'\").join(', ')})`;\n}\n```\n\n## Files to Create/Modify\n- `src/cypher/translator/pattern-translator.ts`\n- `src/cypher/translator/direction-handler.ts`\n- `src/cypher/translator/path-pattern-translator.ts`\n\n## Acceptance Criteria\n- [ ] All RED phase tests pass\n- [ ] JOINs generated correctly for all directions\n- [ ] Multi-hop patterns work\n\n## TDD Phase\nGREEN - Make tests pass with minimal code\n\n## Dependencies\n- Depends on: RED: Pattern to JOIN Translation - Relationship Patterns","status":"closed","priority":1,"issue_type":"task","created_at":"2026-01-05T06:35:41.772273-06:00","updated_at":"2026-01-05T08:47:39.629372-06:00","closed_at":"2026-01-05T08:47:39.629372-06:00","close_reason":"Tests passing - implementation complete"}
{"id":"neo4j-4kp","title":"[GREEN] Temporal Types - Implement to Pass Tests","description":"## Overview\nImplement all Neo4j Temporal types to pass the failing tests.\n\n## TDD Phase: GREEN (Make Tests Pass)\n\n### Implementation Requirements\n\n#### Base Temporal Class (optional internal)\n```typescript\nabstract class Temporal {\n  abstract toString(): string;\n}\n```\n\n#### Date Implementation\n```typescript\nclass Date {\n  readonly year: number;\n  readonly month: number;\n  readonly day: number;\n  \n  constructor(year: number, month: number, day: number);\n  static fromStandardDate(date: globalThis.Date): Date;\n  \n  toString(): string;\n  toStandardDate(): globalThis.Date;\n}\n```\n\n#### Time Implementation\n```typescript\nclass Time {\n  readonly hour: number;\n  readonly minute: number;\n  readonly second: number;\n  readonly nanosecond: number;\n  readonly timeZoneOffsetSeconds: number;\n  \n  constructor(\n    hour: number,\n    minute: number,\n    second: number,\n    nanosecond: number,\n    timeZoneOffsetSeconds: number\n  );\n  \n  toString(): string;\n}\n```\n\n#### LocalTime Implementation\n```typescript\nclass LocalTime {\n  readonly hour: number;\n  readonly minute: number;\n  readonly second: number;\n  readonly nanosecond: number;\n  \n  constructor(\n    hour: number,\n    minute: number,\n    second: number,\n    nanosecond: number\n  );\n  static fromStandardDate(date: globalThis.Date): LocalTime;\n  \n  toString(): string;\n}\n```\n\n#### DateTime Implementation\n```typescript\nclass DateTime {\n  readonly year: number;\n  readonly month: number;\n  readonly day: number;\n  readonly hour: number;\n  readonly minute: number;\n  readonly second: number;\n  readonly nanosecond: number;\n  readonly timeZoneOffsetSeconds: number;\n  readonly timeZoneId?: string;\n  \n  constructor(\n    year: number,\n    month: number,\n    day: number,\n    hour: number,\n    minute: number,\n    second: number,\n    nanosecond: number,\n    timeZoneOffsetSeconds: number,\n    timeZoneId?: string\n  );\n  static fromStandardDate(date: globalThis.Date): DateTime;\n  \n  toString(): string;\n  toStandardDate(): globalThis.Date;\n}\n```\n\n#### LocalDateTime Implementation\n```typescript\nclass LocalDateTime {\n  readonly year: number;\n  readonly month: number;\n  readonly day: number;\n  readonly hour: number;\n  readonly minute: number;\n  readonly second: number;\n  readonly nanosecond: number;\n  \n  constructor(\n    year: number,\n    month: number,\n    day: number,\n    hour: number,\n    minute: number,\n    second: number,\n    nanosecond: number\n  );\n  static fromStandardDate(date: globalThis.Date): LocalDateTime;\n  \n  toString(): string;\n  toStandardDate(): globalThis.Date;\n}\n```\n\n#### Duration Implementation\n```typescript\nclass Duration {\n  readonly months: number;\n  readonly days: number;\n  readonly seconds: number;\n  readonly nanoseconds: number;\n  \n  constructor(\n    months: number,\n    days: number,\n    seconds: number,\n    nanoseconds: number\n  );\n  \n  toString(): string;\n}\n```\n\n### Implementation Notes\n- Use ISO 8601 format for all string representations\n- Handle nanosecond precision (Neo4j supports nanoseconds)\n- Timezone offset in seconds (not minutes)\n- Month/day values are 1-indexed (not 0-indexed)\n\n### Acceptance Criteria\n- [ ] All RED phase tests passing\n- [ ] All 6 temporal types implemented\n- [ ] Matches neo4j-driver API\n- [ ] Implementation files at `src/types/temporal/`\n- [ ] Exported from `src/types/index.ts`\n\n### Dependencies\n- Depends on: [RED] Temporal Types - Write Failing Tests","status":"closed","priority":1,"issue_type":"task","created_at":"2026-01-05T06:35:59.272454-06:00","updated_at":"2026-01-05T08:53:44.634022-06:00","closed_at":"2026-01-05T08:53:44.634022-06:00","close_reason":"Tests passing - implementation complete","dependencies":[{"issue_id":"neo4j-4kp","depends_on_id":"neo4j-xb7","type":"blocks","created_at":"2026-01-05T06:41:45.52764-06:00","created_by":"nathanclevenger"}]}
{"id":"neo4j-4m1","title":"[GREEN] Graph Types (Node, Relationship, Path) - Implement to Pass Tests","description":"## Overview\nImplement Neo4j Graph types to pass all failing tests.\n\n## TDD Phase: GREEN (Make Tests Pass)\n\n### Implementation Requirements\n\n#### Node Class\n```typescript\nexport class Node\u003cT extends Record\u003cstring, any\u003e = Record\u003cstring, any\u003e\u003e {\n  readonly identity: Integer;\n  readonly labels: readonly string[];\n  readonly properties: Readonly\u003cT\u003e;\n  readonly elementId: string;\n  \n  constructor(\n    identity: Integer,\n    labels: string[],\n    properties: T,\n    elementId?: string\n  );\n  \n  toString(): string;\n}\n```\n\n#### Relationship Class\n```typescript\nexport class Relationship\u003cT extends Record\u003cstring, any\u003e = Record\u003cstring, any\u003e\u003e {\n  readonly identity: Integer;\n  readonly start: Integer;\n  readonly end: Integer;\n  readonly type: string;\n  readonly properties: Readonly\u003cT\u003e;\n  readonly elementId: string;\n  readonly startNodeElementId: string;\n  readonly endNodeElementId: string;\n  \n  constructor(\n    identity: Integer,\n    start: Integer,\n    end: Integer,\n    type: string,\n    properties: T,\n    elementId?: string,\n    startNodeElementId?: string,\n    endNodeElementId?: string\n  );\n  \n  toString(): string;\n}\n```\n\n#### PathSegment Class\n```typescript\nexport class PathSegment {\n  readonly start: Node;\n  readonly relationship: Relationship;\n  readonly end: Node;\n  \n  constructor(\n    start: Node,\n    relationship: Relationship,\n    end: Node\n  );\n}\n```\n\n#### Path Class\n```typescript\nexport class Path {\n  readonly start: Node;\n  readonly end: Node;\n  readonly segments: readonly PathSegment[];\n  readonly length: number;\n  \n  constructor(\n    start: Node,\n    end: Node,\n    segments: PathSegment[]\n  );\n  \n  // Iterator support\n  [Symbol.iterator](): Iterator\u003cPathSegment\u003e;\n}\n```\n\n#### Type Guards\n```typescript\nexport function isNode(value: unknown): value is Node;\nexport function isRelationship(value: unknown): value is Relationship;\nexport function isPath(value: unknown): value is Path;\nexport function isPathSegment(value: unknown): value is PathSegment;\n```\n\n### Implementation Notes\n- Use readonly arrays and Readonly\u003cT\u003e for immutability\n- Generate elementId if not provided (for local creation)\n- Labels and type should be frozen after construction\n- Properties object should be deeply frozen\n\n### File Structure\n```\nsrc/types/graph/\n  index.ts\n  node.ts\n  relationship.ts\n  path.ts\n  path-segment.ts\n```\n\n### Acceptance Criteria\n- [ ] All RED phase tests passing\n- [ ] All graph types implemented\n- [ ] Type guards working correctly\n- [ ] Proper TypeScript generics for properties\n- [ ] Exported from `src/types/index.ts`\n\n### Dependencies\n- Depends on: [RED] Graph Types (Node, Relationship, Path) - Write Failing Tests\n- Depends on: [GREEN] Integer Type - Implement to Pass Tests","status":"closed","priority":1,"issue_type":"task","created_at":"2026-01-05T06:39:17.578027-06:00","updated_at":"2026-01-05T08:55:59.06343-06:00","closed_at":"2026-01-05T08:55:59.06343-06:00","close_reason":"Types implemented with tests","dependencies":[{"issue_id":"neo4j-4m1","depends_on_id":"neo4j-snk","type":"blocks","created_at":"2026-01-05T06:42:26.736388-06:00","created_by":"nathanclevenger"},{"issue_id":"neo4j-4m1","depends_on_id":"neo4j-6sj","type":"blocks","created_at":"2026-01-05T06:42:39.170883-06:00","created_by":"nathanclevenger"}]}
{"id":"neo4j-4o4e","title":"REFACTOR: Clean up rxTx.isOpen() implementation","description":"## Overview\nRefactor rxTx.isOpen() for robust state management.\n\n## Refactoring Tasks\n\n### Code Quality\n- Use enum for transaction states\n- Extract state machine\n- Add state transition validation\n- Document state diagram\n\n### Thread Safety\n- Ensure atomic state reads\n- Consider volatile/atomic primitives\n- Test concurrent access\n\n### Integration\n- Align with sync tx.isOpen()\n- Share state management code\n- Consistent state semantics\n\n## Acceptance Criteria\n- All tests still pass\n- Clean state machine\n- Thread-safe implementation\n- Well-documented states","status":"open","priority":2,"issue_type":"task","created_at":"2026-01-05T06:40:25.039498-06:00","updated_at":"2026-01-05T06:40:25.039498-06:00"}
{"id":"neo4j-4oeo","title":"GREEN: Dual-Mode Support (URI vs Env) Implementation","description":"## Overview\nImplement dual-mode support for URI-based in-memory and env-based Durable Object modes to pass all RED phase tests.\n\n## Implementation Requirements\n\n### Mode Detection\n```typescript\ntype DriverMode = 'in-memory' | 'durable-object'\n\ninterface DriverConfig {\n  mode?: DriverMode\n  // ... other config\n}\n\nfunction detectMode(\n  uriOrEnv: string | CloudflareEnv,\n  config?: DriverConfig\n): DriverMode {\n  if (typeof uriOrEnv === 'string') {\n    return 'in-memory'\n  }\n  if (isCloudflareEnv(uriOrEnv)) {\n    return 'durable-object'\n  }\n  throw new ConfigurationError('Invalid driver configuration')\n}\n\nfunction isCloudflareEnv(obj: unknown): obj is CloudflareEnv {\n  return typeof obj === 'object' \u0026\u0026 \n         obj \\!== null \u0026\u0026 \n         'GRAPH_DO' in obj\n}\n```\n\n### Factory Overloads\n```typescript\n// URI mode signatures\nexport function driver(uri: string): Driver\nexport function driver(uri: string, authToken: AuthToken): Driver\nexport function driver(uri: string, authToken: AuthToken, config: DriverConfig): Driver\n\n// Env mode signatures\nexport function driver(env: CloudflareEnv): Driver\nexport function driver(env: CloudflareEnv, config: DriverConfig): Driver\nexport function driver(config: { env: CloudflareEnv; database?: string }): Driver\n\n// Implementation\nexport function driver(\n  uriOrEnv: string | CloudflareEnv | { env: CloudflareEnv; database?: string },\n  authOrConfig?: AuthToken | DriverConfig,\n  maybeConfig?: DriverConfig\n): Driver {\n  const mode = detectMode(uriOrEnv, maybeConfig)\n  \n  if (mode === 'in-memory') {\n    return createInMemoryDriver(uriOrEnv as string, authOrConfig, maybeConfig)\n  } else {\n    return createDurableObjectDriver(uriOrEnv, authOrConfig as DriverConfig)\n  }\n}\n```\n\n### In-Memory Driver\n```typescript\nclass InMemoryDriver implements Driver {\n  private graph: InMemoryGraph\n\n  constructor(uri: string, config?: DriverConfig) {\n    this.graph = new InMemoryGraph()\n  }\n\n  session(config?: SessionConfig): Session {\n    return new InMemorySession(this.graph, config)\n  }\n}\n```\n\n### Durable Object Driver\n```typescript\nclass DurableObjectDriver implements Driver {\n  private env: CloudflareEnv\n  private doStub: DurableObjectStub\n\n  constructor(env: CloudflareEnv, config?: DriverConfig) {\n    this.env = env\n    const doId = env.GRAPH_DO.idFromName(config?.database ?? 'default')\n    this.doStub = env.GRAPH_DO.get(doId)\n  }\n\n  session(config?: SessionConfig): Session {\n    return new DurableObjectSession(this.doStub, config)\n  }\n}\n```\n\n## Files to Create/Modify\n- `src/driver/factory.ts`\n- `src/driver/in-memory-driver.ts`\n- `src/driver/durable-object-driver.ts`\n- `src/driver/types.ts`\n\n## TDD Phase\n**GREEN** - Implement to pass tests.\n\n## Dependencies\n- Depends on: RED: Dual-Mode Support (URI vs Env) Tests\n- Depends on: GREEN: Driver Lifecycle Methods Implementation\n\n## Acceptance Criteria\n- [ ] All RED phase tests pass\n- [ ] Mode detection works correctly\n- [ ] Both modes have same API\n- [ ] Cloudflare integration works","status":"closed","priority":1,"issue_type":"task","created_at":"2026-01-05T06:41:13.959433-06:00","updated_at":"2026-01-05T08:56:54.39185-06:00","closed_at":"2026-01-05T08:56:54.39185-06:00","close_reason":"Features implemented with tests"}
{"id":"neo4j-4ovs","title":"REFACTOR: Retry logic optimization","description":"## Test-Driven Development: REFACTOR Phase\n\n### Component\nHTTP Client SDK - Retry Logic\n\n### Refactoring Goals\n\n1. Circuit breaker pattern - Add circuit breaker to prevent cascading failures\n2. Retry budgets - Limit total retries across requests\n3. Observability - Add metrics and logging hooks\n4. Configurable strategies - Support different retry strategies\n\n### Acceptance Criteria\n- All existing tests still pass\n- Circuit breaker implemented\n- Retry budgets work correctly\n- Metrics hooks available\n- Code is more modular\n\n### Dependencies\n- GREEN: Implement Retry logic\n\n### TDD Cycle\nThis completes the RED-\u003eGREEN-\u003eREFACTOR cycle for Retry Logic.","status":"open","priority":2,"issue_type":"task","created_at":"2026-01-05T06:42:53.638554-06:00","updated_at":"2026-01-05T06:42:53.638554-06:00"}
{"id":"neo4j-4q9","title":"[RED] Lexer: String Literal Tests","description":"## Overview\nWrite failing tests for string literal tokenization in Cypher.\n\n## Test Cases to Write\n\n### Single-Quoted Strings\n- Simple: `'hello'`\n- With spaces: `'hello world'`\n- Empty: `''`\n- With escaped single quote: `'it\\'s'`\n- With escaped backslash: `'path\\\\to'`\n\n### Double-Quoted Strings\n- Simple: `\"hello\"`\n- With spaces: `\"hello world\"`\n- Empty: `\"\"`\n- With escaped double quote: `\"say \\\"hi\\\"\"`\n- With escaped backslash: `\"path\\\\to\"`\n\n### Escape Sequences\n- Newline: `\\n`\n- Tab: `\\t`\n- Carriage return: `\\r`\n- Unicode: `\\uXXXX`\n\n### Edge Cases\n- Unclosed string (should error with position)\n- String at end of input\n- String with newlines inside\n- Very long strings\n\n## Acceptance Criteria\n- [ ] All tests written and failing\n- [ ] Tests cover both quote styles\n- [ ] Tests cover all escape sequences\n- [ ] Error cases have proper error messages\n\n## TDD Phase: RED","status":"closed","priority":1,"issue_type":"task","created_at":"2026-01-05T06:35:11.301775-06:00","updated_at":"2026-01-05T07:46:37.19698-06:00","closed_at":"2026-01-05T07:46:37.19698-06:00","close_reason":"Completed in Ralph Wiggum session - 987 tests pass"}
{"id":"neo4j-4sy","title":"[RED] Label Management - Write failing tests for label operations","description":"## Overview\nWrite failing tests for label management operations before implementation.\n\n## Test Cases to Write\n\n### Add Label Tests\n- `test_add_label_to_node`\n- `test_add_label_already_exists_no_duplicate`\n- `test_add_label_updates_index`\n- `test_add_label_to_nonexistent_node_throws`\n- `test_add_multiple_labels_at_once`\n\n### Remove Label Tests\n- `test_remove_label_from_node`\n- `test_remove_label_updates_index`\n- `test_remove_nonexistent_label_no_error`\n- `test_remove_label_from_nonexistent_node_throws`\n- `test_remove_last_label_leaves_empty_array`\n\n### Get Labels Tests\n- `test_get_labels_for_node`\n- `test_get_labels_empty_for_unlabeled_node`\n- `test_get_all_labels_in_database`\n- `test_get_all_labels_unique`\n- `test_get_labels_after_add_remove_cycle`\n\n### Label Index Tests\n- `test_label_index_updated_on_add`\n- `test_label_index_updated_on_remove`\n- `test_label_index_query_returns_correct_nodes`\n- `test_label_index_empty_after_all_removed`\n- `test_label_index_handles_special_characters`\n\n### Label Validation Tests\n- `test_valid_label_names`\n- `test_invalid_label_names_rejected` - (empty, spaces, special chars)\n- `test_label_case_sensitivity`\n\n## Acceptance Criteria\n- [ ] All tests written and failing\n- [ ] Add/remove operations tested\n- [ ] Index maintenance tested\n- [ ] Validation tested\n\n## TDD Phase\n**RED** - Write failing tests first","status":"closed","priority":1,"issue_type":"task","created_at":"2026-01-05T06:39:19.222134-06:00","updated_at":"2026-01-05T08:56:35.536796-06:00","closed_at":"2026-01-05T08:56:35.536796-06:00","close_reason":"Tests passing - storage and transactions implemented"}
{"id":"neo4j-5170","title":"REFACTOR: Optimize buffer management","description":"## Overview\nRefactor buffer management for optimal performance.\n\n## Refactoring Tasks\n\n### Code Quality\n- Extract buffer abstraction\n- Clean up overflow handling\n- Add proper types\n- Document buffer behavior\n\n### Performance\n- Efficient buffer operations\n- Minimize copy overhead\n- Optimize for common cases\n- Consider ring buffer\n\n### Monitoring\n- Add buffer metrics\n- Memory usage tracking\n- Overflow event logging\n- Performance profiling\n\n## Acceptance Criteria\n- All tests still pass\n- Optimal buffer performance\n- Good metrics\n- Well-documented behavior","status":"open","priority":2,"issue_type":"task","created_at":"2026-01-05T06:46:18.667702-06:00","updated_at":"2026-01-05T06:46:18.667702-06:00"}
{"id":"neo4j-51e","title":"REFACTOR: Driver Class Factory \u0026 URI Parsing Optimization","description":"## Overview\nRefactor the Driver class factory and URI parsing for optimal performance and edge case handling.\n\n## Refactoring Goals\n\n### Performance Optimizations\n- URI parsing caching for repeated connections\n- Lazy initialization of driver internals\n- Efficient config merging with defaults\n\n### Code Quality\n- Extract URI validation into separate validator\n- Create builder pattern for complex configurations\n- Improve error messages with context\n\n### Edge Cases to Handle\n```typescript\ndescribe('Edge Cases', () =\u003e {\n  it('should handle URIs with special characters in credentials')\n  it('should handle very long URIs')\n  it('should handle concurrent driver creation')\n  it('should handle driver creation after close')\n  it('should properly clean up on creation failure')\n  it('should handle malformed IPv6 addresses')\n  it('should handle empty configuration objects')\n  it('should handle null vs undefined parameters')\n})\n```\n\n### Additional Tests\n- Stress tests for rapid driver creation/destruction\n- Memory leak detection tests\n- Configuration immutability tests\n\n## Files to Modify\n- `src/driver/driver.ts`\n- `src/driver/uri-parser.ts`\n- `src/driver/auth.ts`\n- `src/driver/config.ts`\n\n## TDD Phase\n**REFACTOR** - Improve code quality while maintaining passing tests.\n\n## Dependencies\n- Depends on: GREEN: Driver Class Factory \u0026 URI Parsing Implementation\n\n## Acceptance Criteria\n- [ ] All existing tests still pass\n- [ ] New edge case tests added and passing\n- [ ] Code follows DRY principles\n- [ ] Performance benchmarks documented\n- [ ] No memory leaks detected","status":"open","priority":2,"issue_type":"task","created_at":"2026-01-05T06:35:05.569604-06:00","updated_at":"2026-01-05T06:35:05.569604-06:00"}
{"id":"neo4j-538","title":"RED: Write failing tests for rxSession.lastBookmarks() method","description":"## Overview\nWrite failing tests for rxSession.lastBookmarks() bookmark retrieval method.\n\n## Test Cases to Write\n\n### Basic Bookmark Tests\n- lastBookmarks() returns string array\n- Returns empty array for new session\n- Returns bookmarks from session config\n- Returns updated bookmarks after transaction commit\n\n### Bookmark Update Tests\n- Bookmarks update after executeRead completes\n- Bookmarks update after executeWrite completes\n- Bookmarks update after explicit transaction commit\n- Bookmarks not updated after rollback\n\n### Multiple Transaction Tests\n- Bookmarks accumulate across transactions\n- Most recent bookmark takes precedence\n- Bookmarks from multiple databases tracked separately\n\n## Acceptance Criteria\n- All tests written and failing (RED phase)\n- Tests cover bookmark retrieval\n- Tests cover bookmark updates\n- Tests verify synchronous access","status":"open","priority":2,"issue_type":"task","created_at":"2026-01-05T06:37:28.037397-06:00","updated_at":"2026-01-05T06:37:28.037397-06:00"}
{"id":"neo4j-55g","title":"REFACTOR: Record.get(index) - Optimize unified get method","description":"## Overview\nRefactor the unified get(keyOrIndex) method for type safety and clarity.\n\n## Refactoring Tasks\n\n1. **Type Overloads**\n   - Add proper function overloads for string and number\n   - Ensure type inference works correctly\n\n2. **Code Organization**\n   - Clean up conditional logic\n   - Consider helper methods for clarity\n\n## Acceptance Criteria\n- [ ] All tests still pass after refactoring\n- [ ] TypeScript overloads properly defined\n- [ ] Code is readable and maintainable\n\n## TDD Phase\nREFACTOR - Improve code without changing behavior\n\n## Dependencies\n- neo4j-ttx (GREEN phase implementation)","status":"closed","priority":1,"issue_type":"task","created_at":"2026-01-05T06:35:41.736166-06:00","updated_at":"2026-01-05T08:47:39.630625-06:00","closed_at":"2026-01-05T08:47:39.630625-06:00","close_reason":"Tests passing - implementation complete"}
{"id":"neo4j-57y","title":"RED: Write failing tests for rxSession.executeWrite() method","description":"## Overview\nWrite failing tests for rxSession.executeWrite() transaction function for write operations.\n\n## Test Cases to Write\n\n### Basic Transaction Function Tests\n- executeWrite(work) returns Observable\n- Work function receives RxManagedTransaction\n- Work function can run write queries\n- Returns result of work function\n\n### Transaction Behavior Tests\n- Transaction auto-commits on success\n- Transaction auto-rollbacks on error\n- Write access mode is set\n- Bookmarks are updated after commit\n\n### Observable Semantics Tests\n- Cold observable (lazy execution)\n- Proper completion on success\n- Error emission on failure\n- Single execution per subscription\n\n### Retry Behavior Tests\n- Retries on transient errors\n- Does NOT retry on constraint violations\n- Respects retry configuration\n\n## Acceptance Criteria\n- All tests written and failing (RED phase)\n- Tests cover write-specific behavior\n- Tests verify Observable behavior\n- Tests cover retry scenarios","status":"open","priority":2,"issue_type":"task","created_at":"2026-01-05T06:36:23.741398-06:00","updated_at":"2026-01-05T06:36:23.741398-06:00"}
{"id":"neo4j-5a3e","title":"GREEN: Result.records - Implement records array property","description":"## Overview\nImplement the Result.records property to make all RED phase tests pass.\n\n## Implementation\n\n```typescript\nexport class Result\u003cR extends Record = Record\u003e {\n  private _records: R[] | null = null;\n  private _recordsPromise: Promise\u003cR[]\u003e;\n\n  constructor(recordStream: AsyncIterable\u003cR\u003e) {\n    this._recordsPromise = this._consumeStream(recordStream);\n  }\n\n  private async _consumeStream(stream: AsyncIterable\u003cR\u003e): Promise\u003cR[]\u003e {\n    if (this._records !== null) {\n      return this._records;\n    }\n    \n    const records: R[] = [];\n    for await (const record of stream) {\n      records.push(record);\n    }\n    this._records = records;\n    return this._records;\n  }\n\n  get records(): Promise\u003cR[]\u003e {\n    return this._recordsPromise;\n  }\n}\n```\n\n## Acceptance Criteria\n- [ ] All RED phase tests now pass (GREEN phase)\n- [ ] Returns Promise that resolves to Record array\n- [ ] Buffers records for multiple access\n- [ ] Implementation is minimal\n\n## TDD Phase\nGREEN - Minimal implementation to pass tests\n\n## Dependencies\n- neo4j-snp7 (RED phase tests)","status":"closed","priority":1,"issue_type":"task","created_at":"2026-01-05T06:42:03.070524-06:00","updated_at":"2026-01-05T08:52:47.257009-06:00","closed_at":"2026-01-05T08:52:47.257009-06:00","close_reason":"Already implemented with tests passing"}
{"id":"neo4j-5h48","title":"REFACTOR: Clean up rxTx.rollback() implementation","description":"## Overview\nRefactor rxTx.rollback() for robust rollback handling.\n\n## Refactoring Tasks\n\n### Code Quality\n- Share logic with commit where possible\n- Extract rollback protocol\n- Use transaction state machine\n- Clear error handling\n\n### Resource Cleanup\n- Ensure resources released on rollback\n- Handle partial failures\n- Connection cleanup\n\n### Integration\n- Align with sync tx.rollback()\n- Share rollback logic\n- Consistent behavior\n\n## Acceptance Criteria\n- All tests still pass\n- Robust rollback handling\n- Proper resource cleanup\n- Consistent with commit behavior","status":"open","priority":2,"issue_type":"task","created_at":"2026-01-05T06:39:52.798533-06:00","updated_at":"2026-01-05T06:39:52.798533-06:00"}
{"id":"neo4j-5i2","title":"[RED] AST: Pattern Node Types Tests","description":"## Overview\nWrite failing tests for pattern AST node types.\n\n## Test Cases to Write\n\n### Pattern Container\n```typescript\ninterface Pattern {\n  type: 'Pattern'\n  elements: PatternElement[]\n}\n```\n\n### Node Pattern\n```typescript\ninterface NodePattern {\n  type: 'NodePattern'\n  variable?: Identifier\n  labels: string[]\n  properties?: MapLiteral | Parameter\n}\n```\n\n### Relationship Pattern\n```typescript\ninterface RelationshipPattern {\n  type: 'RelationshipPattern'\n  variable?: Identifier\n  types: string[]\n  properties?: MapLiteral | Parameter\n  direction: 'outgoing' | 'incoming' | 'both' | 'none'\n  length?: RelationshipLength\n}\n\ninterface RelationshipLength {\n  min?: number\n  max?: number\n}\n```\n\n### Path Pattern\n```typescript\ninterface PathPattern {\n  type: 'PathPattern'\n  variable?: Identifier\n  pattern: PatternElement[]\n}\n```\n\n### Pattern Element\n```typescript\ntype PatternElement = NodePattern | RelationshipPattern | PathPattern\n```\n\n## Acceptance Criteria\n- [ ] All pattern type tests written\n- [ ] Tests cover all pattern variants\n- [ ] Relationship direction tested\n- [ ] Variable-length patterns tested\n\n## TDD Phase: RED","status":"closed","priority":1,"issue_type":"task","created_at":"2026-01-05T06:38:23.083289-06:00","updated_at":"2026-01-05T08:58:01.755025-06:00","closed_at":"2026-01-05T08:58:01.755025-06:00","close_reason":"AST, lexer and types tests passing"}
{"id":"neo4j-5ii","title":"[GREEN] Relationship Operations - Implement CRUD operations to pass tests","description":"## Overview\nImplement relationship CRUD operations to make all tests pass.\n\n## Implementation Requirements\n\n### Relationship Interface\n```typescript\ninterface Relationship {\n  id: number;\n  elementId: string;\n  type: string;\n  startNodeId: number;\n  startNodeElementId: string;\n  endNodeId: number;\n  endNodeElementId: string;\n  properties: Record\u003cstring, unknown\u003e;\n}\n\ntype Direction = 'OUTGOING' | 'INCOMING' | 'BOTH';\n```\n\n### RelationshipOperations Class\n```typescript\nclass RelationshipOperations {\n  constructor(private sql: SqlStorage) {}\n\n  createRelationship(\n    type: string,\n    startNodeId: number,\n    endNodeId: number,\n    properties: Record\u003cstring, unknown\u003e = {}\n  ): Relationship {\n    // Verify both nodes exist\n    const startExists = this.sql.exec('SELECT 1 FROM nodes WHERE id = ?', startNodeId).one();\n    const endExists = this.sql.exec('SELECT 1 FROM nodes WHERE id = ?', endNodeId).one();\n    \n    if (\\!startExists) throw new Error('Start node not found');\n    if (\\!endExists) throw new Error('End node not found');\n    \n    const result = this.sql.exec(\n      'INSERT INTO relationships (type, start_node_id, end_node_id, properties) VALUES (?, ?, ?, ?) RETURNING *',\n      type, startNodeId, endNodeId, JSON.stringify(properties)\n    );\n    return this.rowToRelationship(result.one());\n  }\n\n  getRelationship(id: number): Relationship | null {\n    const result = this.sql.exec('SELECT * FROM relationships WHERE id = ?', id);\n    const row = result.one();\n    return row ? this.rowToRelationship(row) : null;\n  }\n\n  updateRelationship(id: number, properties: Record\u003cstring, unknown\u003e): Relationship {\n    const existing = this.getRelationship(id);\n    if (\\!existing) throw new Error('Relationship not found');\n    \n    const merged = { ...existing.properties, ...properties };\n    Object.keys(merged).forEach(k =\u003e merged[k] === null \u0026\u0026 delete merged[k]);\n    \n    this.sql.exec(\n      'UPDATE relationships SET properties = ? WHERE id = ?',\n      JSON.stringify(merged), id\n    );\n    return this.getRelationship(id)\\!;\n  }\n\n  deleteRelationship(id: number): boolean {\n    const result = this.sql.exec('DELETE FROM relationships WHERE id = ?', id);\n    return result.rowsWritten \u003e 0;\n  }\n\n  getRelationshipsByType(type: string): Relationship[] {\n    return this.sql.exec('SELECT * FROM relationships WHERE type = ?', type)\n      .toArray().map(this.rowToRelationship);\n  }\n\n  getRelationshipsForNode(\n    nodeId: number,\n    direction: Direction = 'BOTH',\n    type?: string\n  ): Relationship[] {\n    let query = 'SELECT * FROM relationships WHERE ';\n    const conditions: string[] = [];\n    const params: (string | number)[] = [];\n\n    if (direction === 'OUTGOING' || direction === 'BOTH') {\n      conditions.push('start_node_id = ?');\n      params.push(nodeId);\n    }\n    if (direction === 'INCOMING' || direction === 'BOTH') {\n      conditions.push('end_node_id = ?');\n      params.push(nodeId);\n    }\n\n    query += '(' + conditions.join(' OR ') + ')';\n    \n    if (type) {\n      query += ' AND type = ?';\n      params.push(type);\n    }\n\n    return this.sql.exec(query, ...params).toArray().map(this.rowToRelationship);\n  }\n}\n```\n\n## Files to Create\n- `src/storage/operations/relationship-operations.ts`\n- `src/storage/types/relationship.ts`\n\n## Acceptance Criteria\n- [ ] All RED phase tests pass\n- [ ] Foreign key validation works\n- [ ] Direction filtering works\n- [ ] Type filtering works\n\n## TDD Phase\n**GREEN** - Minimum code to pass tests","status":"closed","priority":1,"issue_type":"task","created_at":"2026-01-05T06:37:43.851724-06:00","updated_at":"2026-01-05T08:58:13.609483-06:00","closed_at":"2026-01-05T08:58:13.609483-06:00","close_reason":"Implementation complete with tests"}
{"id":"neo4j-5ip","title":"Build configuration (tsup.config.ts)","description":"# Build Configuration with tsup\n\n## Overview\nConfigure tsup for building the neo4j.do library with multiple entry points and formats.\n\n## Entry Points\n- `src/index.ts` -\u003e Main export\n- `src/client.ts` -\u003e Client export\n- `src/types.ts` -\u003e Types export\n- `src/lite.ts` -\u003e Lite version (no RxJS dependencies)\n\n## Build Configuration\n```typescript\nimport { defineConfig } from 'tsup'\n\nexport default defineConfig({\n  entry: {\n    index: 'src/index.ts',\n    client: 'src/client.ts',\n    types: 'src/types.ts',\n    lite: 'src/lite.ts'\n  },\n  format: ['esm', 'cjs'],\n  dts: true,\n  clean: true,\n  splitting: true,\n  treeshake: true,\n  minify: false, // For debugging; enable for production\n  sourcemap: true,\n  external: ['rxjs'], // External for lite version\n  target: 'es2022'\n})\n```\n\n## Output Structure\n```\ndist/\n index.js\n index.d.ts\n client.js\n client.d.ts\n types.js\n types.d.ts\n lite.js\n lite.d.ts\n```\n\n## Acceptance Criteria\n- [ ] tsup.config.ts created\n- [ ] All entry points build successfully\n- [ ] ESM and CJS formats generated\n- [ ] Type declarations generated\n- [ ] Source maps generated\n- [ ] Build output is tree-shakeable","status":"closed","priority":1,"issue_type":"task","created_at":"2026-01-05T06:34:59.248449-06:00","updated_at":"2026-01-05T08:46:57.514067-06:00","closed_at":"2026-01-05T08:46:57.514067-06:00","close_reason":"Tests passing - implementation complete"}
{"id":"neo4j-5kj","title":"[REFACTOR] ID Generation - Add caching and optimize lookups","description":"## Overview\nRefactor ID generation for better performance and compatibility.\n\n## Refactoring Tasks\n\n### Performance Optimization\n```typescript\nclass IdGenerator {\n  private elementIdCache = new Map\u003cnumber, string\u003e();\n  private internalIdCache = new Map\u003cstring, number\u003e();\n  private cacheMaxSize = 10000;\n\n  encodeNodeId(internalId: number): string {\n    const cached = this.elementIdCache.get(internalId);\n    if (cached) return cached;\n    \n    const elementId = `4:${this.databaseUuid}:${internalId}`;\n    this.addToCache(internalId, elementId);\n    return elementId;\n  }\n\n  private addToCache(internalId: number, elementId: string): void {\n    if (this.elementIdCache.size \u003e= this.cacheMaxSize) {\n      // LRU eviction\n      const firstKey = this.elementIdCache.keys().next().value;\n      this.elementIdCache.delete(firstKey);\n    }\n    this.elementIdCache.set(internalId, elementId);\n    this.internalIdCache.set(elementId, internalId);\n  }\n}\n```\n\n### Batch Operations\n```typescript\nencodeNodeIds(internalIds: number[]): string[] {\n  return internalIds.map(id =\u003e this.encodeNodeId(id));\n}\n\ndecodeElementIds(elementIds: string[]): number[] {\n  return elementIds.map(id =\u003e this.extractInternalId(id));\n}\n```\n\n### Compatibility Layer\n```typescript\n// Support legacy ID formats\nparseLegacyId(id: string | number): number {\n  if (typeof id === 'number') return id;\n  if (id.includes(':')) return this.extractInternalId(id);\n  return parseInt(id, 10);\n}\n\n// Support Neo4j driver ID objects\nfromNeo4jId(neo4jId: { low: number; high: number }): number {\n  // Handle Neo4j Integer type\n  return neo4jId.low;\n}\n```\n\n### Code Quality\n- Add comprehensive type definitions\n- Add JSDoc documentation\n- Add ID format validation utilities\n- Create ID conversion helpers\n\n## Acceptance Criteria\n- [ ] All tests still pass\n- [ ] Caching improves performance\n- [ ] Batch operations available\n- [ ] Legacy compatibility added\n- [ ] Code well-documented\n\n## TDD Phase\n**REFACTOR** - Improve without changing behavior","status":"open","priority":2,"issue_type":"task","created_at":"2026-01-05T06:38:47.008023-06:00","updated_at":"2026-01-05T06:38:47.008023-06:00"}
{"id":"neo4j-5s6p","title":"GREEN: Implement error recovery patterns","description":"## Overview\nImplement error recovery support to make all RED tests pass.\n\n## Implementation Requirements\n\n### catchError Support\n- Enable catchError operator\n- Allow fallback streams\n- Support error transformation\n- Continue stream on recovery\n\n### Resource Management\n- Clean up on error\n- Clean up during recovery\n- Maintain connection pool\n- No resource leaks\n\n### Implementation Details\n- Proper error propagation\n- Support error interception\n- Enable stream continuation\n- Handle partial results\n\n## Acceptance Criteria\n- All RED tests now pass (GREEN phase)\n- Recovery patterns work\n- Resources managed correctly\n- Stream continuation works","status":"open","priority":2,"issue_type":"task","created_at":"2026-01-05T06:48:19.297174-06:00","updated_at":"2026-01-05T06:48:19.297174-06:00"}
{"id":"neo4j-5vgb","title":"[RED] Parser: LOAD CSV Tests","description":"## Overview\nWrite failing tests for LOAD CSV clause parsing.\n\n## Test Cases to Write\n\n### Basic LOAD CSV\n```cypher\nLOAD CSV FROM 'file:///data.csv' AS row\n\nLOAD CSV WITH HEADERS FROM 'file:///data.csv' AS row\n\nLOAD CSV FROM $url AS row\n```\n\n### With Field Terminator\n```cypher\nLOAD CSV FROM 'file:///data.csv' AS row FIELDTERMINATOR ';'\n```\n\n### Usage Context\n```cypher\nLOAD CSV WITH HEADERS FROM 'file:///people.csv' AS row\nCREATE (p:Person {name: row.name, age: toInteger(row.age)})\n```\n\n### PERIODIC COMMIT\n```cypher\nUSING PERIODIC COMMIT 1000\nLOAD CSV FROM 'file:///data.csv' AS row\nCREATE (n:Node {id: row.id})\n```\n\n### Error Cases\n- Missing AS alias\n- Invalid URL format\n- Missing FROM keyword\n\n## Acceptance Criteria\n- [ ] All LOAD CSV tests written and failing\n- [ ] WITH HEADERS tested\n- [ ] FIELDTERMINATOR tested\n- [ ] PERIODIC COMMIT tested\n\n## TDD Phase: RED","status":"open","priority":2,"issue_type":"task","created_at":"2026-01-05T06:52:02.187197-06:00","updated_at":"2026-01-05T06:52:02.187197-06:00"}
{"id":"neo4j-631q","title":"REFACTOR: Result.peek() - Optimize for streaming","description":"## Overview\nRefactor Result.peek() to work efficiently with streaming results.\n\n## Refactoring Tasks\n\n1. **Streaming Optimization**\n   - Peek should not require buffering all records\n   - Only fetch first record for peek\n\n2. **Type Safety**\n   - Proper null vs undefined handling\n   - Type return value correctly\n\n## Acceptance Criteria\n- [ ] All tests still pass after refactoring\n- [ ] Works efficiently with streaming\n- [ ] TypeScript types properly defined\n\n## TDD Phase\nREFACTOR - Improve code without changing behavior\n\n## Dependencies\n- neo4j-w5le (GREEN phase implementation)","status":"closed","priority":1,"issue_type":"task","created_at":"2026-01-05T06:49:02.555835-06:00","updated_at":"2026-01-05T07:19:22.168815-06:00","closed_at":"2026-01-05T07:19:22.168815-06:00","close_reason":"Implemented in this Ralph Wiggum session - 662 tests pass"}
{"id":"neo4j-63q3","title":"[GREEN] Types Module Export \u0026 API Surface - Implement Exports","description":"## Overview\nImplement the unified types module export to pass all tests.\n\n## TDD Phase: GREEN (Make Tests Pass)\n\n### Implementation Requirements\n\n#### Main Index File (src/types/index.ts)\n```typescript\n// Re-export all types\nexport { Integer, int, integer, isInt } from './integer';\nexport { \n  Date, Time, LocalTime, DateTime, LocalDateTime, Duration,\n  isDate, isTime, isLocalTime, isDateTime, isLocalDateTime, isDuration \n} from './temporal';\nexport { Point, isPoint, SRID } from './spatial';\nexport { Vector, vector, isVector } from './vector';\nexport { \n  Node, Relationship, Path, PathSegment,\n  isNode, isRelationship, isPath, isPathSegment \n} from './graph';\n\n// Types namespace for neo4j.types.* access\nexport const types = {\n  Date,\n  Time,\n  LocalTime,\n  DateTime,\n  LocalDateTime,\n  Duration,\n  Point,\n  Node,\n  Relationship,\n  Path,\n  PathSegment,\n  Integer,\n  Vector,\n};\n\n// Type exports\nexport type { SRIDValue } from './spatial';\nexport type { VectorDType } from './vector';\n```\n\n#### Main Package Export (src/index.ts)\n```typescript\nimport * as types from './types';\n\nconst neo4j = {\n  // Integer\n  int: types.int,\n  integer: types.integer,\n  isInt: types.isInt,\n  \n  // Temporal type guards\n  isDate: types.isDate,\n  isTime: types.isTime,\n  isLocalTime: types.isLocalTime,\n  isDateTime: types.isDateTime,\n  isLocalDateTime: types.isLocalDateTime,\n  isDuration: types.isDuration,\n  \n  // Spatial\n  isPoint: types.isPoint,\n  \n  // Vector (superset)\n  vector: types.vector,\n  isVector: types.isVector,\n  \n  // Graph type guards\n  isNode: types.isNode,\n  isRelationship: types.isRelationship,\n  isPath: types.isPath,\n  isPathSegment: types.isPathSegment,\n  \n  // Types namespace\n  types: types.types,\n};\n\nexport default neo4j;\nexport * from './types';\n```\n\n### Package.json Exports\n```json\n{\n  \"exports\": {\n    \".\": {\n      \"types\": \"./dist/index.d.ts\",\n      \"import\": \"./dist/index.js\"\n    },\n    \"./types\": {\n      \"types\": \"./dist/types/index.d.ts\",\n      \"import\": \"./dist/types/index.js\"\n    }\n  }\n}\n```\n\n### Acceptance Criteria\n- [ ] All RED phase tests passing\n- [ ] Default export works: `import neo4j from 'neo4j.do'`\n- [ ] Named exports work: `import { int, Node } from 'neo4j.do'`\n- [ ] Subpath export works: `import { int } from 'neo4j.do/types'`\n- [ ] TypeScript types exported correctly\n\n### Dependencies\n- Depends on: [RED] Types Module Export \u0026 API Surface - Write Failing Tests\n- Depends on: All GREEN implementation issues","status":"closed","priority":1,"issue_type":"task","created_at":"2026-01-05T06:40:18.251268-06:00","updated_at":"2026-01-05T08:55:59.06222-06:00","closed_at":"2026-01-05T08:55:59.06222-06:00","close_reason":"Types implemented with tests","dependencies":[{"issue_id":"neo4j-63q3","depends_on_id":"neo4j-nfdy","type":"blocks","created_at":"2026-01-05T06:42:32.782311-06:00","created_by":"nathanclevenger"},{"issue_id":"neo4j-63q3","depends_on_id":"neo4j-6sj","type":"blocks","created_at":"2026-01-05T06:42:44.869727-06:00","created_by":"nathanclevenger"},{"issue_id":"neo4j-63q3","depends_on_id":"neo4j-4kp","type":"blocks","created_at":"2026-01-05T06:42:45.112055-06:00","created_by":"nathanclevenger"},{"issue_id":"neo4j-63q3","depends_on_id":"neo4j-9va","type":"blocks","created_at":"2026-01-05T06:42:45.351537-06:00","created_by":"nathanclevenger"},{"issue_id":"neo4j-63q3","depends_on_id":"neo4j-eiy","type":"blocks","created_at":"2026-01-05T06:42:45.590236-06:00","created_by":"nathanclevenger"},{"issue_id":"neo4j-63q3","depends_on_id":"neo4j-4m1","type":"blocks","created_at":"2026-01-05T06:42:45.83191-06:00","created_by":"nathanclevenger"}]}
{"id":"neo4j-666","title":"[REFACTOR] Spatial Types (Point) - Optimize and Harden","description":"## Overview\nRefactor Point type for performance, edge cases, and enhanced functionality.\n\n## TDD Phase: REFACTOR (Improve While Green)\n\n### Refactoring Goals\n\n#### Distance Calculations (Optional Enhancement)\n- [ ] Add `point.distance(other)` for same SRID\n- [ ] Haversine distance for geographic points\n- [ ] Euclidean distance for cartesian points\n\n#### Bounding Box Support\n- [ ] `Point.boundingBox(points[])` utility\n- [ ] Within-bounds checking\n\n#### Edge Case Hardening\n- [ ] Antimeridian crossing (longitude +-180)\n- [ ] Pole proximity handling\n- [ ] Coordinate precision limits\n- [ ] Very large/small coordinate values\n\n#### Performance Optimizations\n- [ ] Cache toString() results\n- [ ] Efficient equality checking\n- [ ] Minimize property access overhead\n\n#### Code Quality\n- [ ] Add comprehensive JSDoc\n- [ ] Type narrowing for 2D vs 3D points\n- [ ] Better error messages for invalid coordinates\n\n#### Additional Tests\n- [ ] Distance calculation accuracy tests\n- [ ] Serialization round-trip tests\n- [ ] Property-based tests for coordinates\n- [ ] Integration with Cypher POINT() function\n\n### Acceptance Criteria\n- [ ] All existing tests still pass\n- [ ] Optional distance methods documented\n- [ ] 100% test coverage\n- [ ] JSDoc complete for all public API\n\n### Dependencies\n- Depends on: [GREEN] Spatial Types (Point) - Implement to Pass Tests","status":"closed","priority":1,"issue_type":"task","created_at":"2026-01-05T06:37:29.079602-06:00","updated_at":"2026-01-05T08:58:01.757456-06:00","closed_at":"2026-01-05T08:58:01.757456-06:00","close_reason":"AST, lexer and types tests passing","dependencies":[{"issue_id":"neo4j-666","depends_on_id":"neo4j-9va","type":"blocks","created_at":"2026-01-05T06:42:07.017974-06:00","created_by":"nathanclevenger"}]}
{"id":"neo4j-67q","title":"[GREEN] Lexer: Implement Identifier and Keyword Parsing","description":"## Overview\nImplement identifier and keyword tokenization.\n\n## Implementation Tasks\n\n### Identifier Scanner\n```typescript\nprivate scanIdentifier(): Token {\n  // Start with letter or underscore\n  // Continue with letter, digit, or underscore\n  // Check if result is a keyword\n  // Return KEYWORD or IDENTIFIER token\n}\n```\n\n### Backtick Identifier Scanner\n```typescript\nprivate scanBacktickIdentifier(): Token {\n  // Scan until closing backtick\n  // Handle escaped backticks\n  // Return IDENTIFIER token (never keyword)\n}\n```\n\n### Keyword Lookup\n```typescript\nconst KEYWORDS = new Set([\n  'MATCH', 'OPTIONAL', 'WHERE', 'RETURN', 'WITH', ...\n])\n\nprivate isKeyword(value: string): boolean {\n  return KEYWORDS.has(value.toUpperCase())\n}\n```\n\n## Acceptance Criteria\n- [ ] All identifier tests pass\n- [ ] All keyword tests pass\n- [ ] Case insensitivity for keywords\n- [ ] Backtick escaping works correctly\n\n## TDD Phase: GREEN\n## Depends On: neo4j-1uc","status":"closed","priority":1,"issue_type":"task","created_at":"2026-01-05T06:36:30.899863-06:00","updated_at":"2026-01-05T08:53:44.636558-06:00","closed_at":"2026-01-05T08:53:44.636558-06:00","close_reason":"Tests passing - implementation complete"}
{"id":"neo4j-68lg","title":"REFACTOR: AgentFS - Optimize filesystem operations and add FUSE support","description":"## Overview\nRefactor AgentFS for production performance and extended capabilities.\n\n## Refactoring Goals\n\n### 1. Performance Optimization\n- Directory listing caching\n- Lazy loading for large directories\n- Batch operations for bulk changes\n- Connection pooling\n\n### 2. Extended Operations\n```typescript\n// Copy operations\nasync copy(source: string, dest: string): Promise\u003cvoid\u003e;\n\n// Move/rename\nasync rename(oldPath: string, newPath: string): Promise\u003cvoid\u003e;\n\n// Recursive operations\nasync rmdir(path: string, options?: { recursive: boolean }): Promise\u003cvoid\u003e;\n\n// Atomic transactions\nasync transaction\u003cT\u003e(fn: (fs: AgentFS) =\u003e Promise\u003cT\u003e): Promise\u003cT\u003e;\n```\n\n### 3. FUSE Integration\n```typescript\n// For local development/debugging\nclass FUSEMount {\n  async mount(mountPoint: string, options?: FUSEOptions): Promise\u003cvoid\u003e;\n  async unmount(): Promise\u003cvoid\u003e;\n}\n\n// Enable: neo4j-fs mount /mnt/graph\n// Then use: ls /mnt/graph/Person/\n```\n\n### 4. WebDAV Support\n```typescript\n// HTTP-based filesystem access\nclass WebDAVServer {\n  handleRequest(request: Request): Promise\u003cResponse\u003e;\n}\n\n// Enable browsing graph via WebDAV clients\n```\n\n### 5. Streaming Support\n- Stream large node lists\n- Chunked file reads\n- Progress callbacks for bulk operations\n\n### 6. Security\n- Path traversal prevention\n- Access control per path\n- Audit logging\n\n## Tasks\n- [ ] Implement directory caching\n- [ ] Add copy/move operations\n- [ ] Create FUSE bindings\n- [ ] Build WebDAV server\n- [ ] Add streaming support\n- [ ] Implement access control\n\n## Acceptance Criteria\n- [ ] All tests still passing\n- [ ] \u003c 10ms for cached directory listings\n- [ ] FUSE mount working locally\n- [ ] WebDAV browsable via Finder/Explorer\n\n## Tags\nsuperset, agentfs, virtual-filesystem, tdd-refactor, fuse, webdav","status":"open","priority":3,"issue_type":"task","created_at":"2026-01-05T06:42:41.869741-06:00","updated_at":"2026-01-05T06:42:41.869741-06:00"}
{"id":"neo4j-6clj","title":"REFACTOR: Optimize flow control implementation","description":"## Overview\nRefactor flow control for optimal performance.\n\n## Refactoring Tasks\n\n### Code Quality\n- Extract flow controller\n- Clean up backpressure logic\n- Add proper types\n- Document flow semantics\n\n### Performance\n- Minimize latency impact\n- Optimize buffer sizing\n- Reduce allocation overhead\n- Efficient pause/resume\n\n### Configuration\n- Configurable buffer sizes\n- Strategy selection API\n- Tuning guidance\n- Performance metrics\n\n## Acceptance Criteria\n- All tests still pass\n- Optimal performance\n- Configurable behavior\n- Well-documented tuning","status":"open","priority":2,"issue_type":"task","created_at":"2026-01-05T06:45:48.484375-06:00","updated_at":"2026-01-05T06:45:48.484375-06:00"}
{"id":"neo4j-6fm9","title":"REFACTOR: Record.forEach(callback) - Add type safety","description":"## Overview\nRefactor the Record.forEach(callback) method with proper TypeScript generics.\n\n## Refactoring Tasks\n\n1. **Type Safety**\n   - Add proper generic callback type\n   - Ensure type inference works\n\n2. **API Consistency**\n   - Match Array.forEach signature pattern\n\n## Acceptance Criteria\n- [ ] All tests still pass after refactoring\n- [ ] TypeScript types properly defined\n- [ ] Callback types are inferred correctly\n\n## TDD Phase\nREFACTOR - Improve code without changing behavior\n\n## Dependencies\n- neo4j-3i6g (GREEN phase implementation)","status":"closed","priority":1,"issue_type":"task","created_at":"2026-01-05T06:40:01.959463-06:00","updated_at":"2026-01-05T08:55:15.890817-06:00","closed_at":"2026-01-05T08:55:15.890817-06:00","close_reason":"Record methods already implemented with tests"}
{"id":"neo4j-6fn","title":"[RED] Cypher Version Compatibility Tests (Cypher 9, 10)","description":"# [RED] Cypher Version Compatibility Tests\n\n## Overview\nCreate tests to verify compatibility with different Cypher versions, specifically Cypher 9 and Cypher 10.\n\n## Cypher Version Differences\n\n### Cypher 9 Features\n- Standard pattern matching\n- Classic aggregations\n- Original function set\n- Traditional path expressions\n\n### Cypher 10 New Features\n- Graph Pattern Matching (GPM)\n- Improved subqueries (CALL in transactions)\n- Enhanced type system\n- New functions and operators\n- Pattern comprehension improvements\n\n## Test Structure\n\n### Version Detection\n```typescript\ndescribe('Cypher Version Detection', () =\u003e {\n  it('should report supported Cypher version', async () =\u003e {\n    const result = await session.run('CALL dbms.components() YIELD versions')\n    // Verify version info is available\n  })\n\n  it('should accept version hint in query', async () =\u003e {\n    const result = await session.run('CYPHER 9 MATCH (n) RETURN n')\n    expect(result).toBeDefined()\n  })\n})\n```\n\n### Cypher 9 Compatibility\n```typescript\ndescribe('Cypher 9 Compatibility', () =\u003e {\n  it('should support variable-length paths', async () =\u003e {\n    await session.run('MATCH (a)-[*1..3]-\u003e(b) RETURN a, b')\n  })\n\n  it('should support classic aggregations', async () =\u003e {\n    await session.run('MATCH (n) RETURN count(n), sum(n.value), avg(n.value)')\n  })\n\n  it('should support UNWIND', async () =\u003e {\n    await session.run('UNWIND [1, 2, 3] AS x RETURN x')\n  })\n\n  it('should support FOREACH', async () =\u003e {\n    await session.run('FOREACH (x IN [1,2,3] | CREATE (:Node {value: x}))')\n  })\n})\n```\n\n### Cypher 10 Features\n```typescript\ndescribe('Cypher 10 Features', () =\u003e {\n  it('should support graph pattern quantifiers', async () =\u003e {\n    // New quantified path patterns\n    await session.run('MATCH (a)--\u003e+(b) RETURN a, b')\n  })\n\n  it('should support CALL in transactions', async () =\u003e {\n    await session.run(`\n      CALL {\n        CREATE (n:Node)\n        RETURN n\n      } IN TRANSACTIONS OF 100 ROWS\n    `)\n  })\n\n  it('should support enhanced type predicates', async () =\u003e {\n    await session.run('MATCH (n) WHERE n IS Node RETURN n')\n  })\n\n  it('should support new string functions', async () =\u003e {\n    await session.run(\"RETURN normalize('caf') AS normalized\")\n  })\n})\n```\n\n### Version-Specific Error Handling\n```typescript\ndescribe('Version-Specific Errors', () =\u003e {\n  it('should reject Cypher 10 syntax when requesting Cypher 9', async () =\u003e {\n    await expect(\n      session.run('CYPHER 9 MATCH (a)--\u003e+(b) RETURN a, b')\n    ).rejects.toThrow()\n  })\n\n  it('should provide helpful upgrade hints', async () =\u003e {\n    // When Cypher 10 feature used without version hint\n    // Suggest updating Cypher version\n  })\n})\n```\n\n## Compatibility Matrix\n| Feature | Cypher 9 | Cypher 10 | neo4j.do |\n|---------|----------|-----------|----------|\n| Variable-length paths | Yes | Yes | TBD |\n| Pattern quantifiers | No | Yes | TBD |\n| CALL IN TRANSACTIONS | No | Yes | TBD |\n\n## Acceptance Criteria\n- [ ] Tests written for Cypher 9 features\n- [ ] Tests written for Cypher 10 features\n- [ ] Version detection tests written\n- [ ] Compatibility matrix documented\n- [ ] Tests fail initially (RED phase)","status":"open","priority":2,"issue_type":"task","created_at":"2026-01-05T06:38:57.72616-06:00","updated_at":"2026-01-05T06:38:57.72616-06:00"}
{"id":"neo4j-6md","title":"RED: Pattern to JOIN Translation - Relationship Patterns","description":"## Overview\nWrite failing tests for relationship pattern translation to JOINs.\n\n## Test Cases to Write\n\n### Test 1: Two-Node Outgoing Relationship\n```typescript\ntest('translates (a)-[r]-\u003e(b) to JOIN', () =\u003e {\n  const ast = parse('MATCH (a)-[r]-\u003e(b) RETURN a, b');\n  const sql = translate(ast);\n  expect(sql).toContain('JOIN relationships');\n  expect(sql).toContain('JOIN nodes');\n  expect(sql).toContain('start_node_id');\n  expect(sql).toContain('end_node_id');\n});\n```\n\n### Test 2: Incoming Relationship\n```typescript\ntest('translates (a)\u003c-[r]-(b) with reversed direction', () =\u003e {\n  const ast = parse('MATCH (a)\u003c-[r]-(b) RETURN a, b');\n  const sql = translate(ast);\n  // a is end_node, b is start_node\n  expect(sql).toMatch(/a\\.id.*=.*end_node_id/);\n});\n```\n\n### Test 3: Undirected Relationship\n```typescript\ntest('translates (a)-[r]-(b) to bidirectional match', () =\u003e {\n  const ast = parse('MATCH (a)-[r]-(b) RETURN a, b');\n  const sql = translate(ast);\n  // Should match either direction\n  expect(sql).toMatch(/OR/);\n});\n```\n\n### Test 4: Relationship with Type\n```typescript\ntest('translates (a)-[r:KNOWS]-\u003e(b) with type filter', () =\u003e {\n  const ast = parse('MATCH (a)-[r:KNOWS]-\u003e(b) RETURN a, b');\n  const sql = translate(ast);\n  expect(sql).toContain(\"type = 'KNOWS'\");\n});\n```\n\n### Test 5: Relationship with Properties\n```typescript\ntest('translates relationship properties to WHERE', () =\u003e {\n  const ast = parse('MATCH (a)-[r {since: 2020}]-\u003e(b) RETURN r');\n  const sql = translate(ast);\n  expect(sql).toContain('json_extract');\n  expect(sql).toContain('since');\n});\n```\n\n### Test 6: Multiple Relationship Hops\n```typescript\ntest('translates (a)-[]-\u003e(b)-[]-\u003e(c) to multiple JOINs', () =\u003e {\n  const ast = parse('MATCH (a)-[r1]-\u003e(b)-[r2]-\u003e(c) RETURN a, c');\n  const sql = translate(ast);\n  // Should have 3 node aliases and 2 relationship JOINs\n  expect(sql.match(/JOIN/g)?.length).toBeGreaterThanOrEqual(4);\n});\n```\n\n### Test 7: Anonymous Relationship\n```typescript\ntest('handles anonymous relationship (a)--\u003e(b)', () =\u003e {\n  const ast = parse('MATCH (a)--\u003e(b) RETURN a');\n  const sql = translate(ast);\n  expect(sql).toContain('relationships');\n});\n```\n\n## Acceptance Criteria\n- [ ] All tests written and failing\n- [ ] Direction handling tested (in, out, both)\n- [ ] Multiple hops tested\n\n## TDD Phase\nRED - Write failing tests first","status":"closed","priority":1,"issue_type":"task","created_at":"2026-01-05T06:35:24.509766-06:00","updated_at":"2026-01-05T08:46:57.516685-06:00","closed_at":"2026-01-05T08:46:57.516685-06:00","close_reason":"Tests passing - implementation complete"}
{"id":"neo4j-6n87","title":"[RED] Parser: Predicate Expression Tests","description":"## Overview\nWrite failing tests for predicate expression parsing.\n\n## Test Cases to Write\n\n### NULL Predicates\n- IS NULL: n.value IS NULL\n- IS NOT NULL: n.value IS NOT NULL\n- Combined: n.x IS NULL OR n.y IS NOT NULL\n\n### String Predicates\n- STARTS WITH: n.name STARTS WITH 'J'\n- ENDS WITH: n.name ENDS WITH 'son'\n- CONTAINS: n.name CONTAINS 'oh'\n- Regex: n.name =~ '.*pattern.*'\n\n### List Predicates\n- IN: n.status IN ['active', 'pending']\n- NOT IN: n.status NOT IN ['deleted']\n- IN with expression: n.id IN ids\n\n### Quantified Predicates\n- ANY: ANY(x IN list WHERE x \u003e 0)\n- ALL: ALL(x IN list WHERE x \u003e 0)\n- NONE: NONE(x IN list WHERE x \u003c 0)\n- SINGLE: SINGLE(x IN list WHERE x = target)\n\n### EXISTS Predicate\n- Simple: EXISTS(n.property)\n- Pattern: EXISTS { MATCH (n)-[:KNOWS]-\u003e(m) }\n\n### Comparison Chains\n- n.a \u003c n.b \u003c n.c (if supported)\n\n### Combined Predicates\n- Complex WHERE clauses with multiple predicates\n- Nested predicates\n- Predicates with function calls\n\n## Acceptance Criteria\n- [ ] All predicate tests written and failing\n- [ ] NULL predicates tested\n- [ ] String predicates tested\n- [ ] Quantified predicates tested\n\n## TDD Phase: RED","status":"closed","priority":1,"issue_type":"task","created_at":"2026-01-05T06:50:12.879118-06:00","updated_at":"2026-01-05T07:19:48.959291-06:00","closed_at":"2026-01-05T07:19:48.959291-06:00","close_reason":"Parser implemented with MATCH, RETURN, node/relationship patterns, expressions - 34 parser tests pass"}
{"id":"neo4j-6nt","title":"REFACTOR: Neo4jHttpDriver class optimization","description":"## Test-Driven Development: REFACTOR Phase\n\n### Component\nHTTP Client SDK - Neo4jHttpDriver Class\n\n### Refactoring Goals\n\n1. **Extract HTTP client concerns**\n   - Create `HttpClient` utility class for fetch wrapper\n   - Centralize header building and error handling\n\n2. **Improve type safety**\n   - Add branded types for URL validation\n   - Strict typing for auth configurations\n\n3. **Connection pooling abstraction**\n   - Implement `ConnectionPool` interface\n   - Support keep-alive connections\n\n4. **Error handling**\n   - Create `HttpDriverError` class hierarchy\n   - Map HTTP status codes to Neo4j error types\n\n### Code Improvements\n\n```typescript\n// Extract to http-client.ts\nexport class HttpClient {\n  constructor(\n    private baseUrl: string,\n    private config: HttpClientConfig\n  ) {}\n\n  async request\u003cT\u003e(path: string, init?: RequestInit): Promise\u003cT\u003e {\n    const response = await this.fetch(path, init)\n    if (!response.ok) {\n      throw await this.createError(response)\n    }\n    return response.json()\n  }\n\n  private async createError(response: Response): Promise\u003cHttpDriverError\u003e {\n    const body = await response.json().catch(() =\u003e ({}))\n    return new HttpDriverError(response.status, body.message, body.code)\n  }\n}\n```\n\n### Acceptance Criteria\n- [ ] All existing tests still pass\n- [ ] HttpClient extracted and reusable\n- [ ] Error classes properly structured\n- [ ] Code coverage maintained or improved\n- [ ] No external dependencies added\n\n### Dependencies\n- GREEN: Implement Neo4jHttpDriver class\n\n### TDD Cycle\nThis completes the RED-\u003eGREEN-\u003eREFACTOR cycle for Neo4jHttpDriver.","status":"open","priority":2,"issue_type":"task","created_at":"2026-01-05T06:35:06.19288-06:00","updated_at":"2026-01-05T06:35:06.19288-06:00"}
{"id":"neo4j-6q5u","title":"[RED] E2E Transaction Tests","description":"# [RED] E2E Transaction Tests\n\n## Overview\nEnd-to-end tests for transaction handling including commit, rollback, and isolation.\n\n## Test Scenarios\n\n### Auto-commit Transactions\n```typescript\ndescribe('Auto-commit Transactions E2E', () =\u003e {\n  it('should auto-commit successful queries', async () =\u003e {\n    await session.run('CREATE (n:AutoCommit {value: 1})')\n    \n    // Verify in new session\n    const newSession = driver.session()\n    const result = await newSession.run('MATCH (n:AutoCommit) RETURN n')\n    expect(result.records).toHaveLength(1)\n    await newSession.close()\n  })\n\n  it('should auto-rollback on error', async () =\u003e {\n    try {\n      await session.run('CREATE (n:WillRollback) INVALID SYNTAX')\n    } catch (e) {\n      // Expected\n    }\n    \n    const result = await session.run('MATCH (n:WillRollback) RETURN n')\n    expect(result.records).toHaveLength(0)\n  })\n})\n```\n\n### Explicit Transactions\n```typescript\ndescribe('Explicit Transactions E2E', () =\u003e {\n  it('should commit transaction explicitly', async () =\u003e {\n    const tx = session.beginTransaction()\n    await tx.run('CREATE (n:ExplicitTx {value: 1})')\n    await tx.commit()\n    \n    const result = await session.run('MATCH (n:ExplicitTx) RETURN n')\n    expect(result.records).toHaveLength(1)\n  })\n\n  it('should rollback transaction explicitly', async () =\u003e {\n    const tx = session.beginTransaction()\n    await tx.run('CREATE (n:ToRollback {value: 1})')\n    await tx.rollback()\n    \n    const result = await session.run('MATCH (n:ToRollback) RETURN n')\n    expect(result.records).toHaveLength(0)\n  })\n\n  it('should execute multiple queries in transaction', async () =\u003e {\n    const tx = session.beginTransaction()\n    await tx.run('CREATE (a:MultiTx {name: \"A\"})')\n    await tx.run('CREATE (b:MultiTx {name: \"B\"})')\n    await tx.run('MATCH (a:MultiTx {name: \"A\"}), (b:MultiTx {name: \"B\"}) CREATE (a)-[:LINKS]-\u003e(b)')\n    await tx.commit()\n    \n    const result = await session.run('MATCH (a:MultiTx)-[:LINKS]-\u003e(b:MultiTx) RETURN a, b')\n    expect(result.records).toHaveLength(1)\n  })\n\n  it('should rollback all on any failure', async () =\u003e {\n    const tx = session.beginTransaction()\n    await tx.run('CREATE (n:PartialTx {name: \"First\"})')\n    \n    try {\n      await tx.run('INVALID CYPHER')\n    } catch (e) {\n      await tx.rollback()\n    }\n    \n    const result = await session.run('MATCH (n:PartialTx) RETURN n')\n    expect(result.records).toHaveLength(0)\n  })\n\n  it('should not allow operations after commit', async () =\u003e {\n    const tx = session.beginTransaction()\n    await tx.run('CREATE (n:Test)')\n    await tx.commit()\n    \n    await expect(tx.run('CREATE (n:AfterCommit)')).rejects.toThrow()\n  })\n\n  it('should not allow operations after rollback', async () =\u003e {\n    const tx = session.beginTransaction()\n    await tx.run('CREATE (n:Test)')\n    await tx.rollback()\n    \n    await expect(tx.run('CREATE (n:AfterRollback)')).rejects.toThrow()\n  })\n})\n```\n\n### Transaction Functions\n```typescript\ndescribe('Transaction Functions E2E', () =\u003e {\n  it('should execute read transaction', async () =\u003e {\n    await session.run('CREATE (n:ReadTxTest {value: 42})')\n    \n    const result = await session.executeRead(async tx =\u003e {\n      const res = await tx.run('MATCH (n:ReadTxTest) RETURN n.value as value')\n      return res.records[0].get('value').toInt()\n    })\n    \n    expect(result).toBe(42)\n  })\n\n  it('should execute write transaction', async () =\u003e {\n    await session.executeWrite(async tx =\u003e {\n      await tx.run('CREATE (n:WriteTxTest {value: 1})')\n    })\n    \n    const result = await session.run('MATCH (n:WriteTxTest) RETURN n')\n    expect(result.records).toHaveLength(1)\n  })\n\n  it('should rollback on exception in transaction function', async () =\u003e {\n    await expect(\n      session.executeWrite(async tx =\u003e {\n        await tx.run('CREATE (n:WillFail)')\n        throw new Error('Intentional failure')\n      })\n    ).rejects.toThrow('Intentional failure')\n    \n    const result = await session.run('MATCH (n:WillFail) RETURN n')\n    expect(result.records).toHaveLength(0)\n  })\n\n  it('should retry transient failures', async () =\u003e {\n    let attempts = 0\n    \n    await session.executeWrite(async tx =\u003e {\n      attempts++\n      if (attempts \u003c 3) {\n        // Simulate transient error\n        const error = new Error('Transient failure')\n        ;(error as any).code = 'Neo.TransientError.Transaction.DeadlockDetected'\n        throw error\n      }\n      await tx.run('CREATE (n:RetryTest)')\n    })\n    \n    expect(attempts).toBe(3)\n    const result = await session.run('MATCH (n:RetryTest) RETURN n')\n    expect(result.records).toHaveLength(1)\n  })\n\n  it('should return value from transaction function', async () =\u003e {\n    const sum = await session.executeRead(async tx =\u003e {\n      const res = await tx.run('UNWIND [1, 2, 3] AS n RETURN sum(n) as total')\n      return res.records[0].get('total').toInt()\n    })\n    \n    expect(sum).toBe(6)\n  })\n})\n```\n\n### Transaction Isolation\n```typescript\ndescribe('Transaction Isolation E2E', () =\u003e {\n  it('should isolate uncommitted changes', async () =\u003e {\n    const tx1 = session.beginTransaction()\n    await tx1.run('CREATE (n:IsolationTest {id: 1})')\n    \n    // tx1 not committed yet\n    const session2 = driver.session()\n    const result = await session2.run('MATCH (n:IsolationTest) RETURN n')\n    expect(result.records).toHaveLength(0) // Should not see uncommitted\n    \n    await tx1.commit()\n    await session2.close()\n  })\n\n  it('should see own uncommitted changes within transaction', async () =\u003e {\n    const tx = session.beginTransaction()\n    await tx.run('CREATE (n:SelfVisibility {id: 1})')\n    \n    const result = await tx.run('MATCH (n:SelfVisibility) RETURN n')\n    expect(result.records).toHaveLength(1) // Should see own changes\n    \n    await tx.rollback()\n  })\n\n  it('should handle concurrent transactions', async () =\u003e {\n    const session1 = driver.session()\n    const session2 = driver.session()\n    \n    await session1.executeWrite(async tx =\u003e {\n      await tx.run('CREATE (n:Concurrent {id: 1, value: \"initial\"})')\n    })\n    \n    // Start two concurrent write transactions\n    const tx1 = session1.beginTransaction()\n    const tx2 = session2.beginTransaction()\n    \n    await tx1.run('MATCH (n:Concurrent {id: 1}) SET n.value = \"tx1\"')\n    await tx2.run('MATCH (n:Concurrent {id: 1}) SET n.value = \"tx2\"')\n    \n    await tx1.commit()\n    // tx2 might fail due to conflict\n    try {\n      await tx2.commit()\n    } catch (e) {\n      // Conflict expected\n    }\n    \n    await session1.close()\n    await session2.close()\n  })\n})\n```\n\n### Transaction Timeouts\n```typescript\ndescribe('Transaction Timeouts E2E', () =\u003e {\n  it('should timeout long-running transaction', async () =\u003e {\n    const session = driver.session({\n      defaultAccessMode: 'WRITE'\n    })\n    \n    const tx = session.beginTransaction({\n      timeout: neo4j.int(1000) // 1 second\n    })\n    \n    // This test requires a way to simulate slow queries\n    // In real implementation, would test actual timeout behavior\n    \n    await tx.rollback()\n    await session.close()\n  })\n\n  it('should respect transaction metadata', async () =\u003e {\n    const tx = session.beginTransaction({\n      metadata: { app: 'test', purpose: 'e2e' }\n    })\n    \n    await tx.run('CREATE (n:MetadataTest)')\n    await tx.commit()\n  })\n})\n```\n\n### Legacy Transaction Methods\n```typescript\ndescribe('Legacy Transaction Methods E2E', () =\u003e {\n  it('should support readTransaction (deprecated)', async () =\u003e {\n    await session.run('CREATE (n:LegacyRead {value: 1})')\n    \n    const result = await session.readTransaction(async tx =\u003e {\n      return tx.run('MATCH (n:LegacyRead) RETURN n')\n    })\n    \n    expect(result.records).toHaveLength(1)\n  })\n\n  it('should support writeTransaction (deprecated)', async () =\u003e {\n    await session.writeTransaction(async tx =\u003e {\n      await tx.run('CREATE (n:LegacyWrite)')\n    })\n    \n    const result = await session.run('MATCH (n:LegacyWrite) RETURN n')\n    expect(result.records).toHaveLength(1)\n  })\n})\n```\n\n## Acceptance Criteria\n- [ ] Auto-commit tests written\n- [ ] Explicit transaction tests written\n- [ ] Transaction function tests written\n- [ ] Isolation tests written\n- [ ] Timeout tests written\n- [ ] Legacy method tests written\n- [ ] Tests fail initially (RED phase)","status":"open","priority":2,"issue_type":"task","created_at":"2026-01-05T06:43:16.267331-06:00","updated_at":"2026-01-05T06:43:16.267331-06:00"}
{"id":"neo4j-6sj","title":"[GREEN] Integer Type - Implement to Pass Tests","description":"## Overview\nImplement the Neo4j Integer type to pass all failing tests.\n\n## TDD Phase: GREEN (Make Tests Pass)\n\n### Implementation Requirements\n\n#### Class Structure\n```typescript\nclass Integer {\n  readonly low: number;   // Low 32 bits\n  readonly high: number;  // High 32 bits\n  \n  constructor(low: number, high: number);\n  \n  // Conversion\n  toNumber(): number;\n  toString(radix?: number): string;\n  toInt(): number;\n  toBigInt(): bigint;\n  \n  // Checks\n  inSafeRange(): boolean;\n  isZero(): boolean;\n  isNegative(): boolean;\n  isPositive(): boolean;\n  isOdd(): boolean;\n  isEven(): boolean;\n  \n  // Arithmetic\n  add(other: Integer | number | string): Integer;\n  subtract(other: Integer | number | string): Integer;\n  multiply(other: Integer | number | string): Integer;\n  divide(other: Integer | number | string): Integer;\n  modulo(other: Integer | number | string): Integer;\n  negate(): Integer;\n  \n  // Comparison\n  equals(other: Integer | number | string): boolean;\n  lessThan(other: Integer | number | string): boolean;\n  lessThanOrEqual(other: Integer | number | string): boolean;\n  greaterThan(other: Integer | number | string): boolean;\n  greaterThanOrEqual(other: Integer | number | string): boolean;\n  compare(other: Integer | number | string): number;\n  \n  // Bitwise\n  and(other: Integer | number | string): Integer;\n  or(other: Integer | number | string): Integer;\n  xor(other: Integer | number | string): Integer;\n  not(): Integer;\n  shiftLeft(bits: number): Integer;\n  shiftRight(bits: number): Integer;\n}\n```\n\n#### Factory Functions\n```typescript\nfunction int(value: number | string | Integer): Integer;\nconst integer = int; // Alias\n\ninteger.inSafeRange = (val: Integer): boolean =\u003e { ... };\ninteger.toNumber = (val: Integer): number =\u003e { ... };\ninteger.toString = (val: Integer, radix?: number): string =\u003e { ... };\n```\n\n#### Constants\n```typescript\nInteger.ZERO: Integer;\nInteger.ONE: Integer;\nInteger.NEG_ONE: Integer;\nInteger.MAX_VALUE: Integer;\nInteger.MIN_VALUE: Integer;\nInteger.MAX_SAFE_VALUE: Integer;\nInteger.MIN_SAFE_VALUE: Integer;\n```\n\n### Implementation Notes\n- Use two 32-bit numbers (low/high) for 64-bit representation\n- Match neo4j-driver behavior exactly\n- Handle string parsing for large integers\n- Implement efficient arithmetic using 32-bit operations\n\n### Acceptance Criteria\n- [ ] All RED phase tests passing\n- [ ] Implementation matches neo4j-driver API\n- [ ] No TypeScript errors\n- [ ] Implementation file at `src/types/integer.ts`\n- [ ] Exported from `src/types/index.ts`\n\n### Dependencies\n- Depends on: [RED] Integer Type - Write Failing Tests","status":"closed","priority":1,"issue_type":"task","created_at":"2026-01-05T06:34:56.435371-06:00","updated_at":"2026-01-05T06:51:53.439766-06:00","closed_at":"2026-01-05T06:51:53.439766-06:00","close_reason":"Implemented Integer type with 100% API compatibility with neo4j-driver. All 85 tests passing.","dependencies":[{"issue_id":"neo4j-6sj","depends_on_id":"neo4j-ddr","type":"blocks","created_at":"2026-01-05T06:41:27.79237-06:00","created_by":"nathanclevenger"}]}
{"id":"neo4j-71wz","title":"RED: EagerResult structure - Write failing tests for buffered result","description":"## Overview\nWrite failing tests for the EagerResult class that provides fully buffered results.\n\n## Test Cases to Write\n\n```typescript\ndescribe('EagerResult', () =\u003e {\n  it('should have records, summary, and keys properties', () =\u003e {\n    const eagerResult = new EagerResult(\n      ['name', 'age'],\n      [\n        new Record(['name', 'age'], ['Alice', 30]),\n        new Record(['name', 'age'], ['Bob', 25])\n      ],\n      createMockSummary()\n    );\n    \n    expect(eagerResult.keys).toEqual(['name', 'age']);\n    expect(eagerResult.records).toHaveLength(2);\n    expect(eagerResult.summary).toBeInstanceOf(ResultSummary);\n  });\n\n  it('should have synchronous access (not Promise)', () =\u003e {\n    const eagerResult = new EagerResult(\n      ['name'],\n      [new Record(['name'], ['Alice'])],\n      createMockSummary()\n    );\n    \n    // Should be synchronous, not Promise\n    expect(eagerResult.keys).toEqual(['name']);\n    expect(Array.isArray(eagerResult.records)).toBe(true);\n  });\n\n  it('should handle empty results', () =\u003e {\n    const eagerResult = new EagerResult(\n      ['name'],\n      [],\n      createMockSummary()\n    );\n    \n    expect(eagerResult.keys).toEqual(['name']);\n    expect(eagerResult.records).toEqual([]);\n  });\n\n  it('should be immutable', () =\u003e {\n    const eagerResult = new EagerResult(\n      ['name'],\n      [new Record(['name'], ['Alice'])],\n      createMockSummary()\n    );\n    \n    expect(() =\u003e {\n      (eagerResult as any).records = [];\n    }).toThrow();\n    \n    expect(() =\u003e {\n      (eagerResult as any).keys = [];\n    }).toThrow();\n  });\n\n  it('should match executeQuery return type', () =\u003e {\n    const eagerResult = new EagerResult(\n      ['n'],\n      [new Record(['n'], [new Node(1, ['Person'], {})])],\n      createMockSummary()\n    );\n    \n    // This is the shape returned by driver.executeQuery()\n    const { keys, records, summary } = eagerResult;\n    expect(keys).toBeDefined();\n    expect(records).toBeDefined();\n    expect(summary).toBeDefined();\n  });\n});\n```\n\n## Acceptance Criteria\n- [ ] All tests written and failing (RED phase)\n- [ ] Tests verify synchronous access\n- [ ] Tests verify immutability\n- [ ] Test file created at src/result/__tests__/eager-result.test.ts\n\n## TDD Phase\nRED - Tests should fail because EagerResult class does not exist yet","status":"closed","priority":1,"issue_type":"task","created_at":"2026-01-05T06:51:03.122468-06:00","updated_at":"2026-01-05T07:19:22.170376-06:00","closed_at":"2026-01-05T07:19:22.170376-06:00","close_reason":"Implemented in this Ralph Wiggum session - 662 tests pass"}
{"id":"neo4j-73h","title":"REFACTOR: Pattern to JOIN Translation - Single Node Pattern","description":"## Overview\nRefactor single node pattern translation for cleanliness and extensibility.\n\n## Refactoring Tasks\n\n### 1. Extract SQL Builder\n```typescript\nclass SQLBuilder {\n  select(columns: string[]): this;\n  from(table: string, alias?: string): this;\n  where(condition: string): this;\n  build(): string;\n}\n```\n\n### 2. Create Label Strategy Pattern\n```typescript\ninterface LabelMatcher {\n  match(labels: string[]): SQLCondition;\n}\n\nclass SingleLabelMatcher implements LabelMatcher { }\nclass MultiLabelMatcher implements LabelMatcher { }\n```\n\n### 3. Improve Property Access\n```typescript\nclass PropertyAccessor {\n  static jsonExtract(column: string, path: string): string;\n  static jsonSet(column: string, path: string, value: any): string;\n}\n```\n\n### 4. Add Documentation\n- JSDoc comments for public APIs\n- Inline comments for complex logic\n- Usage examples\n\n## Quality Improvements\n- [ ] No code duplication\n- [ ] Single responsibility per function\n- [ ] Consistent naming conventions\n- [ ] Type safety throughout\n\n## Acceptance Criteria\n- [ ] All tests still pass after refactoring\n- [ ] Code coverage maintained or improved\n- [ ] No new technical debt\n\n## TDD Phase\nREFACTOR - Improve code quality while keeping tests green\n\n## Dependencies\n- Depends on: GREEN: Pattern to JOIN Translation - Single Node Pattern","status":"closed","priority":1,"issue_type":"task","created_at":"2026-01-05T06:35:02.073918-06:00","updated_at":"2026-01-05T08:46:57.515838-06:00","closed_at":"2026-01-05T08:46:57.515838-06:00","close_reason":"Tests passing - implementation complete"}
{"id":"neo4j-75de","title":"REFACTOR: Record.values() - Add type safety and optimize","description":"## Overview\nRefactor the Record.values() method with proper TypeScript types.\n\n## Refactoring Tasks\n\n1. **Type Safety**\n   - Add proper return type based on record definition\n   - Consider generic type propagation\n\n2. **Optimization**\n   - Consider Array.from vs spread operator performance\n\n## Acceptance Criteria\n- [ ] All tests still pass after refactoring\n- [ ] TypeScript types properly defined\n- [ ] Performance is optimal\n\n## TDD Phase\nREFACTOR - Improve code without changing behavior\n\n## Dependencies\n- neo4j-do9a (GREEN phase implementation)","status":"closed","priority":1,"issue_type":"task","created_at":"2026-01-05T06:40:44.65726-06:00","updated_at":"2026-01-05T08:55:15.889653-06:00","closed_at":"2026-01-05T08:55:15.889653-06:00","close_reason":"Record methods already implemented with tests"}
{"id":"neo4j-76b","title":"[GREEN] SQLite Schema Design - Implement schema to pass tests","description":"## Overview\nImplement the SQLite schema to make all failing tests pass.\n\n## Implementation Requirements\n\n### Nodes Table\n```sql\nCREATE TABLE IF NOT EXISTS nodes (\n  id INTEGER PRIMARY KEY AUTOINCREMENT,\n  labels TEXT NOT NULL DEFAULT '[]',\n  properties TEXT NOT NULL DEFAULT '{}',\n  created_at DATETIME DEFAULT CURRENT_TIMESTAMP,\n  updated_at DATETIME DEFAULT CURRENT_TIMESTAMP\n);\n```\n\n### Relationships Table\n```sql\nCREATE TABLE IF NOT EXISTS relationships (\n  id INTEGER PRIMARY KEY AUTOINCREMENT,\n  type TEXT NOT NULL,\n  start_node_id INTEGER NOT NULL REFERENCES nodes(id),\n  end_node_id INTEGER NOT NULL REFERENCES nodes(id),\n  properties TEXT NOT NULL DEFAULT '{}',\n  created_at DATETIME DEFAULT CURRENT_TIMESTAMP\n);\n```\n\n### Indexes\n```sql\nCREATE INDEX IF NOT EXISTS idx_nodes_labels ON nodes(labels);\nCREATE INDEX IF NOT EXISTS idx_relationships_type ON relationships(type);\nCREATE INDEX IF NOT EXISTS idx_relationships_start ON relationships(start_node_id);\nCREATE INDEX IF NOT EXISTS idx_relationships_end ON relationships(end_node_id);\n```\n\n### Schema Versioning\n```sql\nCREATE TABLE IF NOT EXISTS schema_version (\n  version INTEGER PRIMARY KEY,\n  applied_at DATETIME DEFAULT CURRENT_TIMESTAMP\n);\n```\n\n## Files to Create/Modify\n- `src/storage/schema.ts` - Schema definitions\n- `src/storage/migrations.ts` - Migration runner\n\n## Acceptance Criteria\n- [ ] All RED phase tests now pass\n- [ ] Schema is created on Durable Object initialization\n- [ ] Foreign key constraints work correctly\n- [ ] Indexes are created properly\n\n## TDD Phase\n**GREEN** - Minimum code to pass tests","status":"closed","priority":1,"issue_type":"task","created_at":"2026-01-05T06:34:43.563302-06:00","updated_at":"2026-01-05T07:13:24.491375-06:00","closed_at":"2026-01-05T07:13:24.491375-06:00","close_reason":"SQLite schema implemented"}
{"id":"neo4j-78n","title":"GREEN: Implement HttpSession class","description":"## Test-Driven Development: GREEN Phase\n\n### Component\nHTTP Client SDK - HttpSession Class\n\n### Implementation Requirements\n\nImplement `src/client/http-session.ts`:\n\n```typescript\nimport { Neo4jHttpDriver } from './http-driver'\nimport { HttpTransaction } from './http-transaction'\nimport { QueryResult, Record } from './types'\n\nexport interface SessionConfig {\n  database?: string\n  defaultAccessMode?: 'READ' | 'WRITE'\n  bookmarks?: string[]\n}\n\nexport class HttpSession {\n  private _closed = false\n  private lastBookmarks: string[] = []\n\n  constructor(\n    private driver: Neo4jHttpDriver,\n    private config: SessionConfig = {}\n  ) {}\n\n  get isClosed(): boolean {\n    return this._closed\n  }\n\n  async run\u003cT = Record\u003e(\n    query: string,\n    parameters?: Record\u003cstring, unknown\u003e\n  ): Promise\u003cQueryResult\u003cT\u003e\u003e {\n    this.assertOpen()\n    \n    const response = await this.driver.fetch('/query', {\n      method: 'POST',\n      body: JSON.stringify({\n        query,\n        parameters: parameters ?? {},\n        database: this.config.database,\n        bookmarks: this.lastBookmarks\n      })\n    })\n\n    const data = await response.json()\n    this.lastBookmarks = data.bookmarks ?? []\n    return this.mapResult\u003cT\u003e(data)\n  }\n\n  async executeRead\u003cT\u003e(\n    work: (tx: HttpTransaction) =\u003e Promise\u003cT\u003e\n  ): Promise\u003cT\u003e {\n    return this.executeInTransaction(work, 'READ')\n  }\n\n  async executeWrite\u003cT\u003e(\n    work: (tx: HttpTransaction) =\u003e Promise\u003cT\u003e\n  ): Promise\u003cT\u003e {\n    return this.executeInTransaction(work, 'WRITE')\n  }\n\n  private async executeInTransaction\u003cT\u003e(\n    work: (tx: HttpTransaction) =\u003e Promise\u003cT\u003e,\n    accessMode: 'READ' | 'WRITE'\n  ): Promise\u003cT\u003e {\n    this.assertOpen()\n    const tx = await this.beginTransaction({ accessMode })\n    try {\n      const result = await work(tx)\n      await tx.commit()\n      return result\n    } catch (error) {\n      await tx.rollback()\n      throw error\n    }\n  }\n\n  async beginTransaction(config?: { accessMode?: 'READ' | 'WRITE' }): Promise\u003cHttpTransaction\u003e {\n    this.assertOpen()\n    \n    const response = await this.driver.fetch('/tx/begin', {\n      method: 'POST',\n      body: JSON.stringify({\n        database: this.config.database,\n        accessMode: config?.accessMode ?? this.config.defaultAccessMode ?? 'WRITE',\n        bookmarks: this.lastBookmarks\n      })\n    })\n\n    const data = await response.json()\n    return new HttpTransaction(this.driver, data.id)\n  }\n\n  async close(): Promise\u003cvoid\u003e {\n    this._closed = true\n  }\n\n  private assertOpen(): void {\n    if (this._closed) {\n      throw new Error('Session is closed')\n    }\n  }\n\n  private mapResult\u003cT\u003e(data: any): QueryResult\u003cT\u003e {\n    return {\n      records: data.records.map((r: any) =\u003e new Record(r)),\n      summary: data.summary,\n      keys: data.keys\n    }\n  }\n}\n```\n\n### Acceptance Criteria\n- [ ] All RED phase tests pass\n- [ ] run() POSTs to /query endpoint\n- [ ] executeRead/Write use correct access modes\n- [ ] beginTransaction returns HttpTransaction\n- [ ] Session tracks bookmarks\n- [ ] close() prevents further operations\n\n### Dependencies\n- RED: HttpSession class methods fail without implementation\n- GREEN: Implement Neo4jHttpDriver class\n\n### TDD Cycle\nThis is the GREEN phase. Next: REFACTOR phase.","status":"open","priority":2,"issue_type":"task","created_at":"2026-01-05T06:35:55.784768-06:00","updated_at":"2026-01-05T06:35:55.784768-06:00"}
{"id":"neo4j-7d98","title":"REFACTOR: Streaming support optimization","description":"## Test-Driven Development: REFACTOR Phase\n\n### Component\nHTTP Client SDK - Streaming Support\n\n### Refactoring Goals\n\n1. Stream transformers - Composable stream transformations\n2. Memory management - Bounded buffers for back-pressure\n3. Reconnection logic - Auto-reconnect for SSE\n4. Compression support - Handle gzip/deflate streams\n\n### Acceptance Criteria\n- All existing tests still pass\n- Stream transformers composable\n- Memory bounded correctly\n- SSE reconnects automatically\n- Compressed streams handled\n\n### Dependencies\n- GREEN: Implement Streaming support\n\n### TDD Cycle\nThis completes the RED-\u003eGREEN-\u003eREFACTOR cycle for Streaming Support.","status":"open","priority":2,"issue_type":"task","created_at":"2026-01-05T06:48:25.536613-06:00","updated_at":"2026-01-05T06:48:25.536613-06:00"}
{"id":"neo4j-7dvi","title":"GREEN: Result async iteration - Implement Symbol.asyncIterator","description":"## Overview\nImplement async iteration support to make all RED phase tests pass.\n\n## Implementation\n\n```typescript\nasync *[Symbol.asyncIterator](): AsyncIterator\u003cR\u003e {\n  for await (const record of this._recordStream) {\n    yield record;\n  }\n}\n```\n\n## Acceptance Criteria\n- [ ] All RED phase tests now pass (GREEN phase)\n- [ ] Implements Symbol.asyncIterator\n- [ ] Works with for-await-of\n- [ ] Implementation is minimal\n\n## TDD Phase\nGREEN - Minimal implementation to pass tests\n\n## Dependencies\n- neo4j-gqfi (RED phase tests)","status":"closed","priority":1,"issue_type":"task","created_at":"2026-01-05T06:48:13.750453-06:00","updated_at":"2026-01-05T07:19:22.169582-06:00","closed_at":"2026-01-05T07:19:22.169582-06:00","close_reason":"Implemented in this Ralph Wiggum session - 662 tests pass"}
{"id":"neo4j-7ec","title":"REFACTOR: Session Bookmarks \u0026 Lifecycle Optimization","description":"## Overview\nRefactor Session bookmarks and lifecycle for robustness and advanced scenarios.\n\n## Refactoring Goals\n\n### Bookmark Enhancements\n- Bookmark manager for cross-session coordination\n- Bookmark compression for storage efficiency\n- Bookmark expiration handling\n- Multi-database bookmark merging\n\n### Lifecycle Improvements\n- Graceful degradation on partial failures\n- Session pooling support\n- Idle session timeout\n- Session health monitoring\n\n### Edge Cases\n```typescript\ndescribe('Session Lifecycle Edge Cases', () =\u003e {\n  it('should handle close during query execution')\n  it('should handle close during transaction work function')\n  it('should handle rapid open/close cycles')\n  it('should handle close with uncommitted changes')\n  it('should handle concurrent close calls')\n  it('should handle driver close during session operation')\n})\n\ndescribe('Bookmark Edge Cases', () =\u003e {\n  it('should handle malformed bookmarks gracefully')\n  it('should handle bookmarks from future transactions')\n  it('should handle bookmarks from deleted databases')\n  it('should handle very old bookmarks')\n  it('should merge bookmarks from multiple databases')\n})\n```\n\n### Observability\n- Session lifecycle events\n- Bookmark tracking metrics\n- Query timing telemetry\n\n## TDD Phase\n**REFACTOR** - Improve without breaking tests.\n\n## Dependencies\n- Depends on: GREEN: Session Bookmarks \u0026 Lifecycle Implementation\n\n## Acceptance Criteria\n- [ ] All tests pass\n- [ ] Advanced bookmark scenarios work\n- [ ] Session lifecycle is bulletproof\n- [ ] Metrics and logging added","status":"open","priority":2,"issue_type":"task","created_at":"2026-01-05T06:37:49.313366-06:00","updated_at":"2026-01-05T06:37:49.313366-06:00"}
{"id":"neo4j-7t2","title":"[RED] Vector Type - Write Failing Tests","description":"## Overview\nWrite comprehensive failing tests for the Vector type (superset feature for AI/ML workloads).\n\n## TDD Phase: RED (Write Failing Tests)\n\n### Note: Superset Feature\nThis is a **superset feature** not in standard neo4j-driver. It provides first-class vector support for embeddings and AI/ML use cases.\n\n### Test Cases to Write\n\n#### Vector Factory\n```typescript\n// From Float32Array (most common for embeddings)\nneo4j.vector(new Float32Array([0.1, 0.2, 0.3]))\n\n// From regular array (auto-converts to Float32)\nneo4j.vector([0.1, 0.2, 0.3])\n\n// With explicit type\nneo4j.vector(data, 'float32')\nneo4j.vector(data, 'float64')\nneo4j.vector(data, 'int8')\nneo4j.vector(data, 'int16')\nneo4j.vector(data, 'int32')\nneo4j.vector(data, 'int64')\n```\n\n#### Vector Properties\n```typescript\nvector.dimensions    // number of elements\nvector.dtype         // 'float32' | 'float64' | 'int8' | etc.\nvector.byteLength    // size in bytes\n```\n\n#### Vector Methods\n```typescript\nvector.asTypedArray()      // returns underlying TypedArray\nvector.toArray()           // returns regular number[]\nvector.at(index)           // element access\nvector.slice(start, end)   // returns new Vector\nvector.toString()          // string representation\n```\n\n#### Type Guard\n```typescript\nneo4j.isVector(value)  // true for Vector instances\n```\n\n#### Serialization\n```typescript\nvector.toJSON()        // { type: 'Vector', dtype, dimensions, data }\nVector.fromJSON(obj)   // reconstruct from JSON\n```\n\n### Test Categories\n\n#### 1. Construction Tests\n- From each TypedArray type\n- From regular arrays\n- With explicit dtype specification\n- Invalid input handling\n\n#### 2. Property Tests\n- dimensions accuracy\n- dtype correctness\n- byteLength calculation\n\n#### 3. Method Tests\n- asTypedArray returns correct type\n- toArray conversion\n- at() bounds checking\n- slice() behavior\n\n#### 4. Edge Cases\n- Empty vectors\n- Very large vectors (10K+ dimensions)\n- Single-element vectors\n- NaN/Infinity values\n- Type coercion edge cases\n\n### Acceptance Criteria\n- [ ] All tests written and failing (RED state)\n- [ ] All supported dtypes tested\n- [ ] Edge cases covered\n- [ ] Test file at `src/types/vector.test.ts`\n\n### References\n- [Neo4j Vector Index](https://neo4j.com/docs/cypher-manual/current/indexes/semantic-indexes/vector-indexes/)\n- Common embedding sizes: 384, 768, 1536, 3072","status":"open","priority":2,"issue_type":"task","created_at":"2026-01-05T06:37:51.588788-06:00","updated_at":"2026-01-05T06:37:51.588788-06:00"}
{"id":"neo4j-7vap","title":"[GREEN] Transaction Support - Implement transaction handling to pass tests","description":"## Overview\nImplement transaction support to make all tests pass.\n\n## Implementation Requirements\n\n### Transaction Class\n```typescript\ntype TransactionMode = 'READ' | 'WRITE';\ntype TransactionState = 'ACTIVE' | 'COMMITTED' | 'ROLLED_BACK' | 'EXPIRED';\n\nclass Transaction {\n  readonly id: string;\n  readonly mode: TransactionMode;\n  readonly startedAt: number;\n  private state: TransactionState = 'ACTIVE';\n\n  constructor(\n    private sql: SqlStorage,\n    mode: TransactionMode = 'WRITE',\n    private timeout: number = 30000\n  ) {\n    this.id = crypto.randomUUID();\n    this.mode = mode;\n    this.startedAt = Date.now();\n    \n    if (mode === 'WRITE') {\n      this.sql.exec('BEGIN IMMEDIATE');\n    } else {\n      this.sql.exec('BEGIN');\n    }\n  }\n\n  isActive(): boolean {\n    if (this.state \\!== 'ACTIVE') return false;\n    if (Date.now() - this.startedAt \u003e this.timeout) {\n      this.expire();\n      return false;\n    }\n    return true;\n  }\n\n  commit(): void {\n    this.ensureActive();\n    this.sql.exec('COMMIT');\n    this.state = 'COMMITTED';\n  }\n\n  rollback(): void {\n    this.ensureActive();\n    this.sql.exec('ROLLBACK');\n    this.state = 'ROLLED_BACK';\n  }\n\n  private expire(): void {\n    if (this.state === 'ACTIVE') {\n      this.sql.exec('ROLLBACK');\n      this.state = 'EXPIRED';\n    }\n  }\n\n  private ensureActive(): void {\n    if (\\!this.isActive()) {\n      throw new Error(`Transaction ${this.id} is not active (state: ${this.state})`);\n    }\n  }\n}\n```\n\n### TransactionManager Class\n```typescript\nclass TransactionManager {\n  private transactions = new Map\u003cstring, Transaction\u003e();\n\n  constructor(private sql: SqlStorage) {}\n\n  begin(mode: TransactionMode = 'WRITE', timeout?: number): string {\n    const tx = new Transaction(this.sql, mode, timeout);\n    this.transactions.set(tx.id, tx);\n    return tx.id;\n  }\n\n  commit(txId: string): void {\n    const tx = this.getActiveTransaction(txId);\n    tx.commit();\n    this.transactions.delete(txId);\n  }\n\n  rollback(txId: string): void {\n    const tx = this.getActiveTransaction(txId);\n    tx.rollback();\n    this.transactions.delete(txId);\n  }\n\n  getTransaction(txId: string): Transaction | undefined {\n    return this.transactions.get(txId);\n  }\n\n  private getActiveTransaction(txId: string): Transaction {\n    const tx = this.transactions.get(txId);\n    if (\\!tx) throw new Error(`Transaction ${txId} not found`);\n    if (\\!tx.isActive()) throw new Error(`Transaction ${txId} is not active`);\n    return tx;\n  }\n\n  // Cleanup expired transactions\n  cleanup(): void {\n    for (const [id, tx] of this.transactions) {\n      if (\\!tx.isActive()) {\n        this.transactions.delete(id);\n      }\n    }\n  }\n}\n```\n\n## Files to Create\n- `src/storage/transactions/transaction.ts`\n- `src/storage/transactions/transaction-manager.ts`\n\n## Acceptance Criteria\n- [ ] All RED phase tests pass\n- [ ] BEGIN/COMMIT/ROLLBACK work\n- [ ] Transaction isolation enforced\n- [ ] Timeouts handled properly\n\n## TDD Phase\n**GREEN** - Minimum code to pass tests","status":"closed","priority":1,"issue_type":"task","created_at":"2026-01-05T06:41:04.063578-06:00","updated_at":"2026-01-05T08:56:35.537223-06:00","closed_at":"2026-01-05T08:56:35.537223-06:00","close_reason":"Tests passing - storage and transactions implemented"}
{"id":"neo4j-7w5m","title":"REFACTOR: Authentication mechanisms optimization","description":"## Test-Driven Development: REFACTOR Phase\n\n### Component\nHTTP Client SDK - Authentication\n\n### Refactoring Goals\n\n1. **Auth provider interface**\n   - Create pluggable auth provider system\n   - Support OAuth2 flows\n\n2. **Secure token storage**\n   - Abstract token storage\n   - Support secure storage backends\n\n3. **Auth interceptor pattern**\n   - Create request interceptor for auth\n   - Handle 401 responses globally\n\n4. **Multi-tenant support**\n   - Support per-request auth override\n   - Database-specific credentials\n\n### Code Improvements\n\n```typescript\n// Pluggable auth provider\nexport interface AuthProvider {\n  readonly type: string\n  getHeaders(): Promise\u003cRecord\u003cstring, string\u003e\u003e\n  onResponse?(response: Response): Promise\u003cvoid\u003e\n  dispose?(): void\n}\n\n// OAuth2 support\nexport class OAuth2Auth implements AuthProvider {\n  readonly type = 'oauth2'\n  \n  constructor(\n    private config: OAuth2Config,\n    private storage: TokenStorage\n  ) {}\n\n  async getHeaders(): Promise\u003cRecord\u003cstring, string\u003e\u003e {\n    let token = await this.storage.getAccessToken()\n    \n    if (this.isExpired(token)) {\n      token = await this.refreshAccessToken()\n    }\n    \n    return { Authorization: `Bearer ${token.accessToken}` }\n  }\n\n  async onResponse(response: Response): Promise\u003cvoid\u003e {\n    if (response.status === 401) {\n      await this.refreshAccessToken()\n    }\n  }\n\n  private async refreshAccessToken(): Promise\u003cTokenSet\u003e {\n    const refreshToken = await this.storage.getRefreshToken()\n    const tokenSet = await this.fetchNewTokens(refreshToken)\n    await this.storage.setTokens(tokenSet)\n    return tokenSet\n  }\n}\n\n// Token storage abstraction\nexport interface TokenStorage {\n  getAccessToken(): Promise\u003cTokenSet | null\u003e\n  getRefreshToken(): Promise\u003cstring | null\u003e\n  setTokens(tokens: TokenSet): Promise\u003cvoid\u003e\n  clearTokens(): Promise\u003cvoid\u003e\n}\n\nexport class MemoryTokenStorage implements TokenStorage {\n  private tokens: TokenSet | null = null\n  \n  async getAccessToken() { return this.tokens }\n  async getRefreshToken() { return this.tokens?.refreshToken ?? null }\n  async setTokens(tokens: TokenSet) { this.tokens = tokens }\n  async clearTokens() { this.tokens = null }\n}\n\n// Auth interceptor\nexport class AuthInterceptor {\n  constructor(private authProvider: AuthProvider) {}\n\n  async intercept(request: Request): Promise\u003cRequest\u003e {\n    const headers = await this.authProvider.getHeaders()\n    const newHeaders = new Headers(request.headers)\n    \n    for (const [key, value] of Object.entries(headers)) {\n      newHeaders.set(key, value)\n    }\n    \n    return new Request(request.url, {\n      ...request,\n      headers: newHeaders\n    })\n  }\n\n  async handleResponse(response: Response): Promise\u003cResponse\u003e {\n    await this.authProvider.onResponse?.(response)\n    return response\n  }\n}\n```\n\n### Acceptance Criteria\n- [ ] All existing tests still pass\n- [ ] Auth provider interface is pluggable\n- [ ] OAuth2 flow supported\n- [ ] Token storage abstracted\n- [ ] Auth interceptor pattern implemented\n\n### Dependencies\n- GREEN: Implement Authentication mechanisms\n\n### TDD Cycle\nThis completes the RED-\u003eGREEN-\u003eREFACTOR cycle for Authentication.","status":"open","priority":2,"issue_type":"task","created_at":"2026-01-05T06:41:31.736762-06:00","updated_at":"2026-01-05T06:41:31.736762-06:00"}
{"id":"neo4j-7ykb","title":"RED: Write failing tests for Observable error propagation","description":"## Overview\nWrite failing tests for proper error propagation through Observable chains.\n\n## Test Cases to Write\n\n### Error Emission Tests\n- Errors emitted to subscriber error handler\n- Error terminates Observable\n- Error contains appropriate message\n- Error has correct error type\n\n### Error Types\n- Neo4jError propagated correctly\n- ServiceUnavailable error handling\n- SessionExpired error handling\n- TransientError identification\n- ConstraintViolation error handling\n\n### Error Chain Propagation\n- Errors propagate through pipe()\n- Errors propagate through flatMap()\n- Errors stop further emissions\n- catchError() can intercept\n\n### Error Context\n- Error includes query info\n- Error includes server info\n- Error includes timing info\n- Stack trace preserved\n\n## Acceptance Criteria\n- All tests written and failing (RED phase)\n- Tests cover all error types\n- Tests verify propagation\n- Tests verify error context","status":"open","priority":2,"issue_type":"task","created_at":"2026-01-05T06:43:17.782889-06:00","updated_at":"2026-01-05T06:43:17.782889-06:00"}
{"id":"neo4j-80r","title":"RED: Session Bookmarks \u0026 Lifecycle Tests","description":"## Overview\nWrite comprehensive failing tests for Session bookmarks, causal consistency, and lifecycle management.\n\n## Test Cases\n\n### Bookmark Tests\n```typescript\ndescribe('session.lastBookmark()', () =\u003e {\n  it('should return null before any transaction')\n  it('should return bookmark after write transaction')\n  it('should return latest bookmark after multiple writes')\n  it('should not change after read transaction')\n})\n\ndescribe('session.lastBookmarks()', () =\u003e {\n  it('should return empty array before any transaction')\n  it('should return array with single bookmark')\n  it('should return array with multiple bookmarks')\n  it('should include initial bookmarks from config')\n})\n```\n\n### Causal Consistency Tests\n```typescript\ndescribe('Causal Consistency', () =\u003e {\n  it('should wait for bookmarks when session created with bookmarks')\n  it('should chain bookmarks across sessions')\n  it('should handle bookmark from different database')\n  it('should handle invalid bookmark format')\n  it('should handle expired bookmark')\n})\n```\n\n### Session Lifecycle Tests\n```typescript\ndescribe('session.close()', () =\u003e {\n  it('should close session successfully')\n  it('should rollback open transaction on close')\n  it('should release all resources')\n  it('should be idempotent')\n  it('should reject new operations after close')\n  it('should wait for in-flight queries')\n})\n\ndescribe('Session State', () =\u003e {\n  it('should track session open/closed state')\n  it('should throw SessionExpired on operation after close')\n  it('should remove from driver tracking on close')\n})\n```\n\n### Configuration Tests\n```typescript\ndescribe('Session Configuration', () =\u003e {\n  it('should use specified database')\n  it('should default to neo4j database')\n  it('should respect defaultAccessMode for transactions')\n  it('should apply fetchSize to results')\n  it('should impersonate user when specified')\n})\n```\n\n## TDD Phase\n**RED** - All tests should fail initially.\n\n## Acceptance Criteria\n- [ ] All test cases written\n- [ ] Causal consistency scenarios covered\n- [ ] Lifecycle edge cases tested\n- [ ] Configuration validation tested","status":"closed","priority":1,"issue_type":"task","created_at":"2026-01-05T06:37:13.274195-06:00","updated_at":"2026-01-05T08:57:46.160447-06:00","closed_at":"2026-01-05T08:57:46.160447-06:00","close_reason":"Translation and session tests passing"}
{"id":"neo4j-82ks","title":"GREEN: Result.summary - Implement ResultSummary property","description":"## Overview\nImplement the Result.summary property to make all RED phase tests pass.\n\n## Implementation\n\n```typescript\nprivate _summary: ResultSummary | null = null;\nprivate _summaryPromise: Promise\u003cResultSummary\u003e;\n\nget summary(): Promise\u003cResultSummary\u003e {\n  return this._summaryPromise;\n}\n```\n\n## Acceptance Criteria\n- [ ] All RED phase tests now pass (GREEN phase)\n- [ ] Returns Promise that resolves to ResultSummary\n- [ ] Summary available after records consumed\n- [ ] Implementation is minimal\n\n## TDD Phase\nGREEN - Minimal implementation to pass tests\n\n## Dependencies\n- neo4j-3c6i (RED phase tests)","status":"closed","priority":1,"issue_type":"task","created_at":"2026-01-05T06:42:42.278997-06:00","updated_at":"2026-01-05T08:52:47.255808-06:00","closed_at":"2026-01-05T08:52:47.255808-06:00","close_reason":"Already implemented with tests passing"}
{"id":"neo4j-82o","title":"[RED] Neo4j Driver Behavior Parity Tests","description":"# [RED] Neo4j Driver Behavior Parity Tests\n\n## Overview\nCreate tests that verify neo4j.do behaves identically to neo4j-driver in all scenarios.\n\n## Behavioral Tests\n\n### Connection Behavior\n```typescript\ndescribe('Connection Behavior Parity', () =\u003e {\n  it('should handle connection failure gracefully', async () =\u003e {\n    const d = driver('bolt://invalid-host:7687', auth.basic('u', 'p'))\n    await expect(d.verifyConnectivity()).rejects.toThrow()\n  })\n\n  it('should timeout on slow connections', async () =\u003e {\n    const d = driver('bolt://slow-host:7687', auth.basic('u', 'p'), {\n      connectionTimeout: 1000\n    })\n    await expect(d.verifyConnectivity()).rejects.toThrow(/timeout/i)\n  })\n\n  it('should reconnect after connection loss', async () =\u003e {\n    // Test connection recovery behavior\n  })\n})\n```\n\n### Query Result Behavior\n```typescript\ndescribe('Query Result Behavior Parity', () =\u003e {\n  it('should return same result structure', async () =\u003e {\n    const result = await session.run('CREATE (n:Test {name: $name}) RETURN n', { name: 'test' })\n    \n    expect(result.records).toBeInstanceOf(Array)\n    expect(result.records[0].get('n')).toBeDefined()\n    expect(result.records[0].get(0)).toBeDefined() // Index access\n    expect(result.summary.counters.nodesCreated()).toBe(1)\n  })\n\n  it('should handle null values identically', async () =\u003e {\n    const result = await session.run('RETURN null AS value')\n    expect(result.records[0].get('value')).toBeNull()\n  })\n\n  it('should handle empty results', async () =\u003e {\n    const result = await session.run('MATCH (n:NonExistent) RETURN n')\n    expect(result.records).toEqual([])\n  })\n})\n```\n\n### Transaction Behavior\n```typescript\ndescribe('Transaction Behavior Parity', () =\u003e {\n  it('should rollback on error in transaction function', async () =\u003e {\n    await expect(\n      session.executeWrite(async tx =\u003e {\n        await tx.run('CREATE (n:WillBeRolledBack)')\n        throw new Error('Intentional error')\n      })\n    ).rejects.toThrow('Intentional error')\n\n    const result = await session.run('MATCH (n:WillBeRolledBack) RETURN count(n) AS count')\n    expect(result.records[0].get('count').toInt()).toBe(0)\n  })\n\n  it('should commit on successful transaction', async () =\u003e {\n    await session.executeWrite(async tx =\u003e {\n      await tx.run('CREATE (n:WillBeCommitted)')\n    })\n\n    const result = await session.run('MATCH (n:WillBeCommitted) RETURN count(n) AS count')\n    expect(result.records[0].get('count').toInt()).toBe(1)\n  })\n\n  it('should handle nested queries in transaction', async () =\u003e {\n    await session.executeWrite(async tx =\u003e {\n      await tx.run('CREATE (a:Person {name: \"Alice\"})')\n      await tx.run('CREATE (b:Person {name: \"Bob\"})')\n      await tx.run('MATCH (a:Person {name: \"Alice\"}), (b:Person {name: \"Bob\"}) CREATE (a)-[:KNOWS]-\u003e(b)')\n    })\n  })\n})\n```\n\n### Type Coercion Behavior\n```typescript\ndescribe('Type Coercion Behavior Parity', () =\u003e {\n  it('should handle Integer type', async () =\u003e {\n    const result = await session.run('RETURN 42 AS num')\n    const num = result.records[0].get('num')\n    expect(neo4j.isInt(num)).toBe(true)\n    expect(num.toInt()).toBe(42)\n  })\n\n  it('should handle large integers', async () =\u003e {\n    const result = await session.run('RETURN 9007199254740993 AS bigNum')\n    const bigNum = result.records[0].get('bigNum')\n    expect(bigNum.toString()).toBe('9007199254740993')\n  })\n\n  it('should handle temporal types', async () =\u003e {\n    const result = await session.run('RETURN datetime() AS now')\n    const now = result.records[0].get('now')\n    expect(now.year).toBeDefined()\n    expect(now.month).toBeDefined()\n  })\n})\n```\n\n## Acceptance Criteria\n- [ ] All behavior tests written\n- [ ] Tests fail initially (RED phase)\n- [ ] Edge cases covered\n- [ ] Error scenarios documented","status":"open","priority":2,"issue_type":"task","created_at":"2026-01-05T06:37:31.334913-06:00","updated_at":"2026-01-05T06:37:31.334913-06:00"}
{"id":"neo4j-83mm","title":"[GREEN] Parser: Implement Literal Expression Parsing","description":"## Overview\nImplement literal expression parsing.\n\n## Implementation Tasks\n\n### Expression Parser (src/parser/expression-parser.ts)\n```typescript\nexport class ExpressionParser {\n  parsePrimary(): Expression {\n    const token = this.peek()\n    \n    switch (token.type) {\n      case 'STRING':\n        return this.parseStringLiteral()\n      case 'INTEGER':\n        return this.parseIntegerLiteral()\n      case 'FLOAT':\n        return this.parseFloatLiteral()\n      case 'KEYWORD':\n        if (token.value === 'true' || token.value === 'false') {\n          return this.parseBooleanLiteral()\n        }\n        if (token.value === 'null') {\n          return this.parseNullLiteral()\n        }\n        break\n    }\n    \n    if (token.value === '[') {\n      return this.parseListLiteral()\n    }\n    if (token.value === '{') {\n      return this.parseMapLiteral()\n    }\n    \n    // ... other primaries\n  }\n}\n```\n\n### List Literal Parser\n```typescript\nparseListLiteral(): ListLiteral {\n  const start = this.pos\n  this.expect('[')\n  \n  const elements: Expression[] = []\n  if (\\!this.check(']')) {\n    do {\n      elements.push(this.parseExpression())\n    } while (this.match(','))\n  }\n  \n  this.expect(']')\n  \n  return {\n    type: 'ListLiteral',\n    elements,\n    loc: this.getLoc(start)\n  }\n}\n```\n\n### Map Literal Parser\n```typescript\nparseMapLiteral(): MapLiteral {\n  const start = this.pos\n  this.expect('{')\n  \n  const entries: MapEntry[] = []\n  if (\\!this.check('}')) {\n    do {\n      const key = this.parseMapKey()\n      this.expect(':')\n      const value = this.parseExpression()\n      entries.push({ key, value })\n    } while (this.match(','))\n  }\n  \n  this.expect('}')\n  \n  return {\n    type: 'MapLiteral',\n    entries,\n    loc: this.getLoc(start)\n  }\n}\n```\n\n## Acceptance Criteria\n- [ ] All literal tests pass\n- [ ] Nested structures work\n- [ ] Proper AST nodes created\n- [ ] Source locations accurate\n\n## TDD Phase: GREEN\n## Depends On: neo4j-ehoi","status":"closed","priority":1,"issue_type":"task","created_at":"2026-01-05T06:46:20.834273-06:00","updated_at":"2026-01-05T07:19:22.172471-06:00","closed_at":"2026-01-05T07:19:22.172471-06:00","close_reason":"Implemented in this Ralph Wiggum session - 662 tests pass"}
{"id":"neo4j-83q","title":"REFACTOR: CREATE/MERGE Translation","description":"## Overview\nRefactor CREATE/MERGE translation for maintainability and performance.\n\n## Refactoring Tasks\n\n### 1. Mutation Builder Pattern\n- Unified interface for INSERT/UPDATE/DELETE\n- Batch operation support\n\n### 2. MERGE Strategy Pattern\n- InsertStrategy for new entities\n- UpdateStrategy for existing entities\n- Clean conditional logic\n\n### 3. ID Generation Strategy\n- UUID strategy (default)\n- Sequential strategy (optional)\n- Custom ID strategy\n\n### 4. Transaction Wrapper\n- Ensure atomicity of multi-statement mutations\n- Rollback support for failures\n\n## Quality Improvements\n- Clean separation of CREATE vs MERGE logic\n- Reusable property serialization\n- Consistent error handling\n- Performance optimization for batch creates\n\n## Acceptance Criteria\n- All tests still pass\n- Code is extensible for new mutation types\n- Batch operations optimized\n\n## TDD Phase\nREFACTOR - Improve code quality while keeping tests green\n\n## Dependencies\n- Depends on: GREEN: CREATE/MERGE Translation","status":"closed","priority":1,"issue_type":"task","created_at":"2026-01-05T06:38:55.290576-06:00","updated_at":"2026-01-05T08:57:46.15608-06:00","closed_at":"2026-01-05T08:57:46.15608-06:00","close_reason":"Translation and session tests passing"}
{"id":"neo4j-857w","title":"REFACTOR: Result.records - Optimize buffering strategy","description":"## Overview\nRefactor the Result.records implementation for better memory management and API consistency.\n\n## Refactoring Tasks\n\n1. **Memory Management**\n   - Consider lazy vs eager buffering\n   - Implement proper cleanup\n\n2. **Type Safety**\n   - Add proper generic types\n   - Ensure Record type flows through\n\n## Acceptance Criteria\n- [ ] All tests still pass after refactoring\n- [ ] Memory efficient implementation\n- [ ] TypeScript types properly defined\n\n## TDD Phase\nREFACTOR - Improve code without changing behavior\n\n## Dependencies\n- neo4j-5a3e (GREEN phase implementation)","status":"closed","priority":1,"issue_type":"task","created_at":"2026-01-05T06:42:15.228989-06:00","updated_at":"2026-01-05T08:52:47.256657-06:00","closed_at":"2026-01-05T08:52:47.256657-06:00","close_reason":"Already implemented with tests passing"}
{"id":"neo4j-85v","title":"REFACTOR: Variable-Length Path Translation - Recursive CTEs","description":"## Overview\nRefactor variable-length path translation for performance and maintainability.\n\n## Refactoring Tasks\n\n### 1. Strategy Pattern for Depth Handling\n```typescript\ninterface DepthStrategy {\n  translate(pattern: VariableLengthPattern): SQLFragment;\n  isApplicable(min?: number, max?: number): boolean;\n}\n\nclass ExactDepthStrategy implements DepthStrategy {\n  // Use JOINs for exact depth (more efficient)\n}\n\nclass BoundedDepthStrategy implements DepthStrategy {\n  // Use recursive CTE with bounds\n}\n\nclass UnboundedDepthStrategy implements DepthStrategy {\n  // Use recursive CTE with safety limit\n}\n```\n\n### 2. CTE Builder\n```typescript\nclass CTEBuilder {\n  withRecursive(name: string): this;\n  baseCase(query: string): this;\n  recursiveCase(query: string): this;\n  terminationCondition(condition: string): this;\n  build(): string;\n}\n```\n\n### 3. Performance Optimizations\n- Use LIMIT in recursive CTE for safety\n- Optimize visited array for SQLite\n- Consider using bloom filter for cycle detection\n- Add query hints for index usage\n\n### 4. Path Result Builder\n```typescript\nclass PathBuilder {\n  buildNodeArray(): string;\n  buildRelationshipArray(): string;\n  buildFullPath(): string;\n}\n```\n\n## Quality Improvements\n- [ ] Clean strategy selection\n- [ ] Reusable CTE builder\n- [ ] Performance profiling added\n- [ ] Memory-efficient cycle detection\n\n## Acceptance Criteria\n- [ ] All tests still pass\n- [ ] Performance improved for common cases\n- [ ] Code is extensible for new depth patterns\n\n## TDD Phase\nREFACTOR - Improve code quality while keeping tests green\n\n## Dependencies\n- Depends on: GREEN: Variable-Length Path Translation - Recursive CTEs","status":"open","priority":2,"issue_type":"task","created_at":"2026-01-05T06:36:57.744501-06:00","updated_at":"2026-01-05T06:36:57.744501-06:00"}
{"id":"neo4j-86d2","title":"RED: Result.subscribe(observer) - Write failing tests for streaming interface","description":"## Overview\nWrite failing tests for the Result.subscribe(observer) method for streaming results.\n\n## Test Cases to Write\n\n```typescript\ndescribe('Result.subscribe(observer)', () =\u003e {\n  it('should call onNext for each record', async () =\u003e {\n    const result = createMockResult([\n      { name: 'Alice' },\n      { name: 'Bob' }\n    ]);\n    \n    const records: Record[] = [];\n    await new Promise\u003cvoid\u003e((resolve, reject) =\u003e {\n      result.subscribe({\n        onNext: (record) =\u003e records.push(record),\n        onCompleted: () =\u003e resolve(),\n        onError: reject\n      });\n    });\n    \n    expect(records).toHaveLength(2);\n  });\n\n  it('should call onCompleted with summary', async () =\u003e {\n    const result = createMockResult([{ name: 'Alice' }]);\n    \n    let receivedSummary: ResultSummary | null = null;\n    await new Promise\u003cvoid\u003e((resolve) =\u003e {\n      result.subscribe({\n        onNext: () =\u003e {},\n        onCompleted: (summary) =\u003e {\n          receivedSummary = summary;\n          resolve();\n        },\n        onError: () =\u003e {}\n      });\n    });\n    \n    expect(receivedSummary).toBeInstanceOf(ResultSummary);\n  });\n\n  it('should call onError for failures', async () =\u003e {\n    const result = createFailingResult(new Error('Query failed'));\n    \n    let receivedError: Error | null = null;\n    await new Promise\u003cvoid\u003e((resolve) =\u003e {\n      result.subscribe({\n        onNext: () =\u003e {},\n        onCompleted: () =\u003e {},\n        onError: (error) =\u003e {\n          receivedError = error;\n          resolve();\n        }\n      });\n    });\n    \n    expect(receivedError?.message).toBe('Query failed');\n  });\n\n  it('should call onKeys with column names', async () =\u003e {\n    const result = createMockResult([{ name: 'Alice', age: 30 }]);\n    \n    let receivedKeys: string[] = [];\n    await new Promise\u003cvoid\u003e((resolve) =\u003e {\n      result.subscribe({\n        onKeys: (keys) =\u003e { receivedKeys = keys; },\n        onNext: () =\u003e {},\n        onCompleted: () =\u003e resolve(),\n        onError: () =\u003e {}\n      });\n    });\n    \n    expect(receivedKeys).toEqual(['name', 'age']);\n  });\n});\n```\n\n## Acceptance Criteria\n- [ ] All tests written and failing (RED phase)\n- [ ] Tests verify observer callbacks\n- [ ] Tests verify error handling\n- [ ] Test file created at src/result/__tests__/result-subscribe.test.ts\n\n## TDD Phase\nRED - Tests should fail because subscribe method does not exist yet","status":"open","priority":2,"issue_type":"task","created_at":"2026-01-05T06:50:11.28176-06:00","updated_at":"2026-01-05T06:50:11.28176-06:00"}
{"id":"neo4j-87a","title":"REFACTOR: Record.length - Ensure immutability","description":"## Overview\nRefactor the Record.length property for immutability guarantees.\n\n## Refactoring Tasks\n\n1. **Immutability**\n   - Ensure property cannot be overwritten\n   - Consider Object.defineProperty if needed\n\n## Acceptance Criteria\n- [ ] All tests still pass after refactoring\n- [ ] Property is truly immutable\n- [ ] TypeScript types properly defined\n\n## TDD Phase\nREFACTOR - Improve code without changing behavior\n\n## Dependencies\n- neo4j-0h4 (GREEN phase implementation)","status":"closed","priority":1,"issue_type":"task","created_at":"2026-01-05T06:38:42.615375-06:00","updated_at":"2026-01-05T08:57:33.737112-06:00","closed_at":"2026-01-05T08:57:33.737112-06:00","close_reason":"Record methods already implemented with tests"}
{"id":"neo4j-88cb","title":"RED: Client configuration fails without implementation","description":"## Test-Driven Development: RED Phase\n\n### Component\nHTTP Client SDK - Client Configuration\n\n### Test Cases to Write (Expected to FAIL)\n\nTests for:\n- baseUrl configuration and validation\n- Custom fetch implementation injection\n- Timeout settings (connection, request, query)\n- Header customization\n- TLS/SSL options for non-Cloudflare deployments\n\n### Test Examples\n- Should validate baseUrl format\n- Should accept custom fetch function\n- Should configure connection timeout\n- Should merge custom headers\n- Should support TLS certificate options\n\n### Acceptance Criteria\n- Test file created at tests/client/config.test.ts\n- All tests fail with expected errors\n- Tests cover all configuration options\n\n### TDD Cycle\nThis is the RED phase. Next: GREEN phase implementation.","status":"open","priority":2,"issue_type":"task","created_at":"2026-01-05T06:43:06.462123-06:00","updated_at":"2026-01-05T06:43:06.462123-06:00"}
{"id":"neo4j-89ss","title":"GREEN: Graph Algorithms - Implement algorithms using recursive CTEs","description":"## Overview\nImplement graph algorithms using SQL recursive CTEs.\n\n## Implementation Requirements\n\n### Core Components\n\n#### 1. Shortest Path (BFS/Dijkstra)\n```typescript\nasync function shortestPath(\n  startNode: Node,\n  endNode: Node,\n  relType: string,\n  options?: { weightProperty?: string; maxDepth?: number }\n): AsyncGenerator\u003c{ path: Path; cost: number }\u003e {\n  if (options?.weightProperty) {\n    // Dijkstra's algorithm via recursive CTE\n    const sql = `\n      WITH RECURSIVE dijkstra AS (\n        -- Base case: start node\n        SELECT \n          r.end_node_id as node_id,\n          json_extract(r.properties, '$.${options.weightProperty}') as cost,\n          json_array(?) as path,\n          1 as depth\n        FROM relationships r\n        WHERE r.start_node_id = ?\n          AND r.type = ?\n        \n        UNION ALL\n        \n        -- Recursive case: explore neighbors\n        SELECT \n          r.end_node_id,\n          d.cost + json_extract(r.properties, '$.${options.weightProperty}'),\n          json_insert(d.path, '$[#]', r.end_node_id),\n          d.depth + 1\n        FROM dijkstra d\n        JOIN relationships r ON r.start_node_id = d.node_id\n        WHERE r.type = ?\n          AND d.depth \u003c ?\n          AND r.end_node_id NOT IN (SELECT value FROM json_each(d.path))\n      ),\n      shortest AS (\n        SELECT \n          node_id,\n          MIN(cost) as min_cost,\n          path\n        FROM dijkstra\n        WHERE node_id = ?\n        GROUP BY node_id\n      )\n      SELECT path, min_cost as cost FROM shortest\n    `;\n  } else {\n    // BFS for unweighted\n    const sql = `\n      WITH RECURSIVE bfs AS (\n        SELECT \n          ? as node_id,\n          json_array(?) as path,\n          0 as depth\n        \n        UNION ALL\n        \n        SELECT \n          r.end_node_id,\n          json_insert(b.path, '$[#]', r.end_node_id),\n          b.depth + 1\n        FROM bfs b\n        JOIN relationships r ON r.start_node_id = b.node_id\n        WHERE r.type = ?\n          AND b.depth \u003c ?\n          AND r.end_node_id NOT IN (SELECT value FROM json_each(b.path))\n      )\n      SELECT path, depth as length\n      FROM bfs\n      WHERE node_id = ?\n      ORDER BY depth\n      LIMIT 1\n    `;\n  }\n}\n```\n\n#### 2. PageRank\n```typescript\nasync function pageRank(\n  label: string,\n  relType: string,\n  options?: { iterations?: number; dampingFactor?: number }\n): AsyncGenerator\u003c{ node: Node; score: number }\u003e {\n  const d = options?.dampingFactor ?? 0.85;\n  const iterations = options?.iterations ?? 20;\n  \n  // Initialize scores\n  await this.db.exec(`\n    CREATE TEMP TABLE pagerank_scores AS\n    SELECT id, 1.0 as score FROM nodes WHERE labels LIKE '%${label}%'\n  `);\n  \n  // Iterative computation\n  for (let i = 0; i \u003c iterations; i++) {\n    await this.db.exec(`\n      WITH outgoing_counts AS (\n        SELECT start_node_id, COUNT(*) as out_degree\n        FROM relationships WHERE type = ?\n        GROUP BY start_node_id\n      ),\n      incoming_scores AS (\n        SELECT \n          r.end_node_id as node_id,\n          SUM(ps.score / oc.out_degree) as incoming_score\n        FROM relationships r\n        JOIN pagerank_scores ps ON r.start_node_id = ps.id\n        JOIN outgoing_counts oc ON r.start_node_id = oc.start_node_id\n        WHERE r.type = ?\n        GROUP BY r.end_node_id\n      )\n      UPDATE pagerank_scores\n      SET score = (1 - ?) + ? * COALESCE(\n        (SELECT incoming_score FROM incoming_scores WHERE node_id = pagerank_scores.id),\n        0\n      )\n    `, [relType, relType, d, d]);\n  }\n  \n  // Yield results\n  const results = await this.db.prepare(`\n    SELECT n.*, ps.score\n    FROM pagerank_scores ps\n    JOIN nodes n ON ps.id = n.id\n    ORDER BY ps.score DESC\n  `).all();\n  \n  for (const row of results) {\n    yield { node: this.toNode(row), score: row.score };\n  }\n}\n```\n\n#### 3. Community Detection (Label Propagation)\n```typescript\nasync function communityDetection(\n  label: string,\n  relType: string,\n  options?: { algorithm?: 'louvain' | 'labelPropagation'; maxIterations?: number }\n): AsyncGenerator\u003c{ node: Node; community: number }\u003e {\n  // Label Propagation Algorithm\n  // Each node starts with unique community, then adopts most frequent neighbor's label\n  \n  await this.db.exec(`\n    CREATE TEMP TABLE communities AS\n    SELECT id, ROW_NUMBER() OVER () as community FROM nodes WHERE labels LIKE '%${label}%'\n  `);\n  \n  for (let i = 0; i \u003c (options?.maxIterations ?? 10); i++) {\n    const changes = await this.db.exec(`\n      WITH neighbor_communities AS (\n        SELECT \n          r.end_node_id as node_id,\n          c.community,\n          COUNT(*) as freq\n        FROM relationships r\n        JOIN communities c ON r.start_node_id = c.id\n        WHERE r.type = ?\n        GROUP BY r.end_node_id, c.community\n      ),\n      best_community AS (\n        SELECT \n          node_id,\n          community\n        FROM (\n          SELECT \n            node_id,\n            community,\n            ROW_NUMBER() OVER (PARTITION BY node_id ORDER BY freq DESC) as rn\n          FROM neighbor_communities\n        ) WHERE rn = 1\n      )\n      UPDATE communities\n      SET community = (\n        SELECT community FROM best_community WHERE node_id = communities.id\n      )\n      WHERE EXISTS (SELECT 1 FROM best_community WHERE node_id = communities.id)\n    `);\n    \n    if (changes === 0) break; // Converged\n  }\n}\n```\n\n#### 4. Similarity Functions\n```typescript\nfunction cosineSimilarity(vec1: number[], vec2: number[]): number {\n  let dotProduct = 0;\n  let norm1 = 0;\n  let norm2 = 0;\n  \n  for (let i = 0; i \u003c vec1.length; i++) {\n    dotProduct += vec1[i] * vec2[i];\n    norm1 += vec1[i] * vec1[i];\n    norm2 += vec2[i] * vec2[i];\n  }\n  \n  return dotProduct / (Math.sqrt(norm1) * Math.sqrt(norm2));\n}\n\nfunction jaccardSimilarity(set1: any[], set2: any[]): number {\n  const intersection = set1.filter(x =\u003e set2.includes(x)).length;\n  const union = new Set([...set1, ...set2]).size;\n  return intersection / union;\n}\n```\n\n#### 5. Connected Components\n```typescript\nasync function connectedComponents(\n  label: string,\n  relType: string\n): AsyncGenerator\u003c{ node: Node; componentId: number }\u003e {\n  const sql = `\n    WITH RECURSIVE components AS (\n      -- Start with minimum ID per connected group\n      SELECT \n        id as node_id,\n        id as component_id\n      FROM nodes \n      WHERE labels LIKE '%${label}%'\n      \n      UNION\n      \n      SELECT \n        r.end_node_id,\n        MIN(c.component_id)\n      FROM relationships r\n      JOIN components c ON r.start_node_id = c.node_id\n      WHERE r.type = ?\n      GROUP BY r.end_node_id\n    )\n    SELECT \n      node_id,\n      MIN(component_id) as component_id\n    FROM components\n    GROUP BY node_id\n  `;\n}\n```\n\n## Acceptance Criteria\n- [ ] All RED phase tests passing\n- [ ] Algorithms produce correct results\n- [ ] Reasonable performance for medium graphs\n- [ ] Memory-efficient streaming results\n\n## Dependencies\n- RED: Graph Algorithms tests\n\n## Tags\nsuperset, graph-algorithms, procedures, recursive-cte, tdd-green","status":"open","priority":2,"issue_type":"task","created_at":"2026-01-05T06:50:41.597112-06:00","updated_at":"2026-01-05T06:50:41.597112-06:00"}
{"id":"neo4j-8dyi","title":"[RED] Parser: Property Access and Function Call Tests","description":"## Overview\nWrite failing tests for property access and function call parsing.\n\n## Test Cases to Write\n\n### Dot Property Access\n- Simple: `n.name`\n- Chained: `n.address.city`\n- After function: `head(list).value`\n\n### Bracket Property Access\n- String key: `n['name']`\n- Dynamic key: `n[key]`\n- Expression: `n[i + 1]`\n- Mixed: `n.items[0].value`\n\n### Function Calls\n- No args: `timestamp()`\n- Single arg: `count(n)`\n- Multiple args: `substring('hello', 0, 3)`\n- Nested: `lower(trim(s))`\n\n### Aggregate Functions\n- count: `count(n)`, `count(*)`\n- sum: `sum(n.value)`\n- avg: `avg(n.value)`\n- min/max: `min(n.x)`, `max(n.x)`\n- collect: `collect(n)`\n\n### DISTINCT in Aggregates\n- `count(DISTINCT n)`\n- `collect(DISTINCT n.name)`\n\n### Built-in Functions\n- String: `lower(s)`, `upper(s)`, `trim(s)`, `substring(s, 0, 5)`\n- List: `head(l)`, `tail(l)`, `size(l)`, `range(1, 10)`\n- Math: `abs(n)`, `ceil(n)`, `floor(n)`, `round(n)`\n- Type: `type(r)`, `labels(n)`, `keys(n)`\n\n### Namespace Functions\n- `datetime()`\n- `date()`\n- `duration({days: 1})`\n- `point({x: 1, y: 2})`\n\n## Acceptance Criteria\n- [ ] All property access tests written\n- [ ] All function call tests written\n- [ ] DISTINCT tested\n- [ ] Nested calls tested\n\n## TDD Phase: RED","status":"closed","priority":1,"issue_type":"task","created_at":"2026-01-05T06:47:29.628638-06:00","updated_at":"2026-01-05T07:19:22.173698-06:00","closed_at":"2026-01-05T07:19:22.173698-06:00","close_reason":"Implemented in this Ralph Wiggum session - 662 tests pass"}
{"id":"neo4j-8fm","title":"Initialize package.json with correct metadata","description":"# Initialize package.json with correct metadata\n\n## Overview\nSet up the foundational package.json file for the neo4j.do project with all required metadata, dependencies, and scripts.\n\n## Requirements\n- Package name: `neo4j.do`\n- Description: Neo4j-compatible graph database on Cloudflare Workers\n- Main entry point configuration\n- Module type: ESM\n- Engine requirements: Node.js 18+\n- Author and license information\n- Repository URLs\n\n## Dependencies to Include\n- Production: None initially (pure implementation)\n- Dev Dependencies:\n  - typescript\n  - tsup (bundler)\n  - vitest (testing)\n  - @cloudflare/workers-types\n  - wrangler\n  - eslint\n  - prettier\n\n## Scripts\n- `build`: Build with tsup\n- `dev`: Development mode\n- `test`: Run vitest\n- `test:watch`: Run vitest in watch mode\n- `lint`: Run eslint\n- `format`: Run prettier\n- `typecheck`: Run tsc --noEmit\n- `deploy`: Deploy to Cloudflare Workers\n\n## Acceptance Criteria\n- [ ] package.json created with all metadata\n- [ ] All scripts are defined and functional\n- [ ] Dependencies are correctly categorized\n- [ ] Package can be installed without errors","status":"closed","priority":1,"issue_type":"task","created_at":"2026-01-05T06:34:24.217211-06:00","updated_at":"2026-01-05T06:50:26.498106-06:00","closed_at":"2026-01-05T06:50:26.498106-06:00","close_reason":"package.json created with all required metadata, scripts, and dependencies including typescript, tsup, vitest, wrangler, and @cloudflare/workers-types"}
{"id":"neo4j-8gjc","title":"GREEN: Expression Translation","description":"## Overview\nImplement expression translation to make RED tests pass.\n\n## Implementation Tasks\n\n### 1. ExpressionTranslator Class\n- translatePropertyAccess(): json_extract generation\n- translateArithmetic(): SQL arithmetic operators\n- translateComparison(): SQL comparison operators\n- translateBoolean(): AND, OR, NOT\n- translateNull(): IS NULL, IS NOT NULL\n\n### 2. String Function Translator\n- startsWithToLike(): LIKE 'prefix%'\n- containsToLike(): LIKE '%substring%'\n- endsWithToLike(): LIKE '%suffix'\n- toLower(), toUpper(): SQL LOWER, UPPER\n\n### 3. List Function Translator\n- arrayAccess(): JSON array subscript\n- size(): json_array_length\n- head(), last(), tail(): Array operations\n\n### 4. Type Coercion\n- toString(): CAST AS TEXT\n- toInteger(): CAST AS INTEGER\n- toFloat(): CAST AS REAL\n- toBoolean(): Boolean conversion\n\n### 5. CASE Expression\n- translateCase(): SQL CASE WHEN THEN ELSE END\n\n## Files to Create/Modify\n- src/cypher/translator/expression-translator.ts\n- src/cypher/translator/string-functions.ts\n- src/cypher/translator/list-functions.ts\n- src/cypher/translator/type-coercion.ts\n\n## Acceptance Criteria\n- All RED phase tests pass\n- All operators translated correctly\n- Type coercion works\n\n## TDD Phase\nGREEN - Make tests pass with minimal code\n\n## Dependencies\n- Depends on: RED: Expression Translation","status":"closed","priority":1,"issue_type":"task","created_at":"2026-01-05T06:41:54.882775-06:00","updated_at":"2026-01-05T08:53:30.819055-06:00","closed_at":"2026-01-05T08:53:30.819055-06:00","close_reason":"Aggregation/expression translation already implemented"}
{"id":"neo4j-8hb","title":"REFACTOR: Record.get(key) - Optimize and clean up implementation","description":"## Overview\nRefactor the Record.get(key) implementation for better performance and code quality.\n\n## Refactoring Tasks\n\n1. **Type Safety**\n   - Add proper TypeScript generics\n   - Ensure return type matches column type\n\n2. **Performance**\n   - Verify Map lookup is O(1)\n   - Consider frozen object for immutability\n\n3. **Code Quality**\n   - Add JSDoc documentation\n   - Ensure Neo4j driver API compatibility\n\n## Acceptance Criteria\n- [ ] All tests still pass after refactoring\n- [ ] Code is clean and well-documented\n- [ ] TypeScript types are properly defined\n- [ ] Performance is optimal\n\n## TDD Phase\nREFACTOR - Improve code without changing behavior\n\n## Dependencies\n- neo4j-b16 (GREEN phase implementation)","status":"closed","priority":1,"issue_type":"task","created_at":"2026-01-05T06:34:57.079477-06:00","updated_at":"2026-01-05T07:46:37.196204-06:00","closed_at":"2026-01-05T07:46:37.196204-06:00","close_reason":"Completed in Ralph Wiggum session - 987 tests pass"}
{"id":"neo4j-8ho9","title":"[GREEN] Parser: Implement Operator Expression Parsing","description":"## Overview\nImplement operator expression parsing with correct precedence.\n\n## Implementation Tasks\n\n### Precedence Table\n```typescript\n// Lower number = lower precedence (binds less tightly)\nconst PRECEDENCE = {\n  'OR': 1,\n  'XOR': 2,\n  'AND': 3,\n  'NOT': 4,  // unary\n  '=': 5, '\u003c\u003e': 5, '\u003c': 5, '\u003e': 5, '\u003c=': 5, '\u003e=': 5,\n  'IN': 6, 'STARTS WITH': 6, 'ENDS WITH': 6, 'CONTAINS': 6, '=~': 6,\n  '+': 7, '-': 7,\n  '*': 8, '/': 8, '%': 8,\n  '^': 9,  // right associative\n  'unary-': 10,  // unary minus\n}\n```\n\n### Pratt Parser Implementation\n```typescript\nparseExpression(minPrecedence: number = 0): Expression {\n  let left = this.parseUnary()\n  \n  while (true) {\n    const op = this.peek()\n    const prec = this.getPrecedence(op)\n    \n    if (prec === null || prec \u003c minPrecedence) {\n      break\n    }\n    \n    this.advance()\n    \n    // Handle right associativity for ^\n    const nextMinPrec = op.value === '^' ? prec : prec + 1\n    const right = this.parseExpression(nextMinPrec)\n    \n    left = {\n      type: 'BinaryExpression',\n      operator: op.value,\n      left,\n      right,\n      loc: this.getLoc(left.loc.start)\n    }\n  }\n  \n  return left\n}\n\nparseUnary(): Expression {\n  if (this.match('NOT') || this.match('-')) {\n    const operator = this.previous()\n    const argument = this.parseUnary()\n    return {\n      type: 'UnaryExpression',\n      operator: operator.value,\n      argument,\n      loc: this.getLoc(operator)\n    }\n  }\n  return this.parsePrimary()\n}\n```\n\n### Multi-Word Operators\n- Handle `STARTS WITH` as single operator\n- Handle `ENDS WITH` as single operator\n- Handle `IS NULL` as single operator\n\n## Acceptance Criteria\n- [ ] All operator tests pass\n- [ ] Precedence correct\n- [ ] Associativity correct\n- [ ] Multi-word operators work\n\n## TDD Phase: GREEN\n## Depends On: neo4j-oh7e","status":"closed","priority":1,"issue_type":"task","created_at":"2026-01-05T06:47:09.656814-06:00","updated_at":"2026-01-05T07:19:22.17331-06:00","closed_at":"2026-01-05T07:19:22.17331-06:00","close_reason":"Implemented in this Ralph Wiggum session - 662 tests pass"}
{"id":"neo4j-8l39","title":"RED: Record.forEach(callback) - Write failing tests for field iteration","description":"## Overview\nWrite failing tests for the Record.forEach(callback) method that iterates over fields.\n\n## Test Cases to Write\n\n```typescript\ndescribe('Record.forEach(callback)', () =\u003e {\n  it('should iterate over all fields with value, key, record', () =\u003e {\n    const record = new Record(['name', 'age'], ['Alice', 30]);\n    const calls: Array\u003c[any, string, Record]\u003e = [];\n    \n    record.forEach((value, key, rec) =\u003e {\n      calls.push([value, key, rec]);\n    });\n    \n    expect(calls).toEqual([\n      ['Alice', 'name', record],\n      [30, 'age', record]\n    ]);\n  });\n\n  it('should not call callback for empty record', () =\u003e {\n    const record = new Record([], []);\n    const callback = jest.fn();\n    \n    record.forEach(callback);\n    \n    expect(callback).not.toHaveBeenCalled();\n  });\n\n  it('should maintain field order', () =\u003e {\n    const record = new Record(['c', 'a', 'b'], [3, 1, 2]);\n    const keys: string[] = [];\n    \n    record.forEach((_, key) =\u003e keys.push(key));\n    \n    expect(keys).toEqual(['c', 'a', 'b']);\n  });\n\n  it('should handle null and undefined values', () =\u003e {\n    const record = new Record(['a', 'b'], [null, undefined]);\n    const values: any[] = [];\n    \n    record.forEach((value) =\u003e values.push(value));\n    \n    expect(values).toEqual([null, undefined]);\n  });\n\n  it('should not return anything', () =\u003e {\n    const record = new Record(['name'], ['Alice']);\n    const result = record.forEach(() =\u003e 'ignored');\n    expect(result).toBeUndefined();\n  });\n});\n```\n\n## Acceptance Criteria\n- [ ] All tests written and failing (RED phase)\n- [ ] Tests verify callback signature\n- [ ] Tests verify iteration order\n- [ ] Test file created at src/result/__tests__/record-foreach.test.ts\n\n## TDD Phase\nRED - Tests should fail because forEach method does not exist yet","status":"closed","priority":1,"issue_type":"task","created_at":"2026-01-05T06:39:38.611953-06:00","updated_at":"2026-01-05T08:55:15.891533-06:00","closed_at":"2026-01-05T08:55:15.891533-06:00","close_reason":"Record methods already implemented with tests"}
{"id":"neo4j-8p7r","title":"RED: Write failing tests for rxResult.records() method","description":"## Overview\nWrite failing tests for rxResult.records() streaming record access method.\n\n## Test Cases to Write\n\n### Basic Records Tests\n- records() returns Observable of Record\n- Emits each record individually\n- Order matches database order\n- Completes after last record\n\n### Streaming Behavior Tests\n- Records emitted as they arrive\n- Supports large result sets\n- Memory efficient (streaming)\n- Backpressure respected\n\n### Observable Behavior Tests\n- Cold observable (query on subscribe)\n- Proper completion signaling\n- Error emission on failure\n- Unsubscription stops processing\n\n### Record Content Tests\n- Records have correct keys\n- Records have correct values\n- All Neo4j types supported\n- Null values handled\n\n### Integration with RxJS Operators\n- Works with map()\n- Works with filter()\n- Works with take()\n- Works with reduce()\n\n## Acceptance Criteria\n- All tests written and failing (RED phase)\n- Tests verify streaming behavior\n- Tests cover RxJS integration\n- Tests verify backpressure","status":"open","priority":2,"issue_type":"task","created_at":"2026-01-05T06:41:12.88309-06:00","updated_at":"2026-01-05T06:41:12.88309-06:00"}
{"id":"neo4j-8q6","title":"GREEN: Record.keys - Implement column names array property","description":"## Overview\nImplement the Record.keys property to make all RED phase tests pass.\n\n## Implementation\n\n```typescript\nprivate _frozenKeys: readonly string[] | null = null;\n\nget keys(): readonly string[] {\n  if (this._frozenKeys === null) {\n    this._frozenKeys = Object.freeze([...this._keys]);\n  }\n  return this._frozenKeys;\n}\n```\n\n## Acceptance Criteria\n- [ ] All RED phase tests now pass (GREEN phase)\n- [ ] Returns frozen array\n- [ ] Returns same instance on multiple access\n- [ ] Implementation is minimal\n\n## TDD Phase\nGREEN - Minimal implementation to pass tests\n\n## Dependencies\n- neo4j-95e (RED phase tests)","status":"closed","priority":1,"issue_type":"task","created_at":"2026-01-05T06:37:46.236683-06:00","updated_at":"2026-01-05T08:57:33.738997-06:00","closed_at":"2026-01-05T08:57:33.738997-06:00","close_reason":"Record methods already implemented with tests"}
{"id":"neo4j-8ugu","title":"RED: Request/Response serialization fails without implementation","description":"## Test-Driven Development: RED Phase\n\n### Component\nHTTP Client SDK - Request/Response Serialization\n\n### Test Cases to Write (Expected to FAIL)\n\n```typescript\nimport { describe, it, expect } from 'vitest'\nimport { \n  serializeQuery,\n  serializeParameters,\n  deserializeResult,\n  deserializeNeo4jTypes,\n  parseErrorResponse\n} from '../src/client/serialization'\n\ndescribe('Serialization - RED', () =\u003e {\n  describe('serializeQuery()', () =\u003e {\n    it('should serialize Cypher query to JSON', () =\u003e {\n      const result = serializeQuery('MATCH (n) RETURN n', { limit: 10 })\n      expect(result).toEqual({\n        query: 'MATCH (n) RETURN n',\n        parameters: { limit: 10 }\n      })\n    })\n  })\n\n  describe('serializeParameters()', () =\u003e {\n    it('should handle primitive types', () =\u003e {\n      const result = serializeParameters({\n        string: 'hello',\n        number: 42,\n        float: 3.14,\n        boolean: true,\n        null: null\n      })\n      expect(result).toEqual({\n        string: 'hello',\n        number: 42,\n        float: 3.14,\n        boolean: true,\n        null: null\n      })\n    })\n\n    it('should serialize Date to Neo4j DateTime', () =\u003e {\n      const date = new Date('2024-01-15T10:30:00Z')\n      const result = serializeParameters({ date })\n      expect(result.date).toEqual({\n        __neo4j_type__: 'DateTime',\n        value: '2024-01-15T10:30:00.000Z'\n      })\n    })\n\n    it('should serialize Neo4j Integer for large numbers', () =\u003e {\n      const bigNum = 9007199254740993n // Beyond safe integer\n      const result = serializeParameters({ id: bigNum })\n      expect(result.id).toEqual({\n        __neo4j_type__: 'Integer',\n        value: '9007199254740993'\n      })\n    })\n\n    it('should serialize arrays', () =\u003e {\n      const result = serializeParameters({ tags: ['a', 'b', 'c'] })\n      expect(result.tags).toEqual(['a', 'b', 'c'])\n    })\n\n    it('should serialize nested objects as maps', () =\u003e {\n      const result = serializeParameters({\n        person: { name: 'Alice', age: 30 }\n      })\n      expect(result.person).toEqual({ name: 'Alice', age: 30 })\n    })\n\n    it('should serialize Point spatial type', () =\u003e {\n      const point = { latitude: 40.7128, longitude: -74.0060 }\n      const result = serializeParameters({ \n        location: { __type__: 'Point', ...point, srid: 4326 }\n      })\n      expect(result.location).toEqual({\n        __neo4j_type__: 'Point',\n        srid: 4326,\n        x: -74.0060,\n        y: 40.7128\n      })\n    })\n\n    it('should serialize Duration type', () =\u003e {\n      const result = serializeParameters({\n        interval: { __type__: 'Duration', months: 1, days: 5, seconds: 3600 }\n      })\n      expect(result.interval).toEqual({\n        __neo4j_type__: 'Duration',\n        months: 1,\n        days: 5,\n        seconds: 3600,\n        nanoseconds: 0\n      })\n    })\n  })\n\n  describe('deserializeResult()', () =\u003e {\n    it('should deserialize query result to records', () =\u003e {\n      const response = {\n        keys: ['n', 'count'],\n        records: [\n          { n: { name: 'Alice' }, count: 5 },\n          { n: { name: 'Bob' }, count: 3 }\n        ]\n      }\n      \n      const result = deserializeResult(response)\n      expect(result.keys).toEqual(['n', 'count'])\n      expect(result.records).toHaveLength(2)\n      expect(result.records[0].get('n')).toEqual({ name: 'Alice' })\n      expect(result.records[0].get('count')).toBe(5)\n    })\n\n    it('should include query summary', () =\u003e {\n      const response = {\n        keys: [],\n        records: [],\n        summary: {\n          counters: { nodesCreated: 1 },\n          queryType: 'w',\n          plan: null\n        }\n      }\n      \n      const result = deserializeResult(response)\n      expect(result.summary.counters.nodesCreated).toBe(1)\n      expect(result.summary.queryType).toBe('w')\n    })\n  })\n\n  describe('deserializeNeo4jTypes()', () =\u003e {\n    it('should reconstruct Node from JSON', () =\u003e {\n      const json = {\n        __neo4j_type__: 'Node',\n        identity: '123',\n        labels: ['Person'],\n        properties: { name: 'Alice' }\n      }\n      \n      const node = deserializeNeo4jTypes(json)\n      expect(node.identity.toString()).toBe('123')\n      expect(node.labels).toContain('Person')\n      expect(node.properties.name).toBe('Alice')\n    })\n\n    it('should reconstruct Relationship from JSON', () =\u003e {\n      const json = {\n        __neo4j_type__: 'Relationship',\n        identity: '456',\n        type: 'KNOWS',\n        startNodeIdentity: '123',\n        endNodeIdentity: '789',\n        properties: { since: 2020 }\n      }\n      \n      const rel = deserializeNeo4jTypes(json)\n      expect(rel.type).toBe('KNOWS')\n      expect(rel.startNodeElementId).toBe('123')\n    })\n\n    it('should reconstruct Path from JSON', () =\u003e {\n      const json = {\n        __neo4j_type__: 'Path',\n        start: { __neo4j_type__: 'Node', identity: '1', labels: ['A'], properties: {} },\n        end: { __neo4j_type__: 'Node', identity: '2', labels: ['B'], properties: {} },\n        segments: []\n      }\n      \n      const path = deserializeNeo4jTypes(json)\n      expect(path.start.identity.toString()).toBe('1')\n      expect(path.end.identity.toString()).toBe('2')\n    })\n\n    it('should reconstruct DateTime from JSON', () =\u003e {\n      const json = {\n        __neo4j_type__: 'DateTime',\n        value: '2024-01-15T10:30:00.000Z'\n      }\n      \n      const dt = deserializeNeo4jTypes(json)\n      expect(dt.toStandardDate().toISOString()).toBe('2024-01-15T10:30:00.000Z')\n    })\n\n    it('should reconstruct Integer from string', () =\u003e {\n      const json = {\n        __neo4j_type__: 'Integer',\n        value: '9007199254740993'\n      }\n      \n      const int = deserializeNeo4jTypes(json)\n      expect(int.toBigInt()).toBe(9007199254740993n)\n    })\n  })\n\n  describe('parseErrorResponse()', () =\u003e {\n    it('should parse Neo4j error response', () =\u003e {\n      const response = {\n        error: {\n          code: 'Neo.ClientError.Statement.SyntaxError',\n          message: 'Invalid syntax at position 5'\n        }\n      }\n      \n      const error = parseErrorResponse(response)\n      expect(error.code).toBe('Neo.ClientError.Statement.SyntaxError')\n      expect(error.message).toBe('Invalid syntax at position 5')\n      expect(error.classification).toBe('ClientError')\n    })\n\n    it('should handle transient errors', () =\u003e {\n      const response = {\n        error: {\n          code: 'Neo.TransientError.Transaction.LockClient',\n          message: 'Lock wait timeout'\n        }\n      }\n      \n      const error = parseErrorResponse(response)\n      expect(error.isRetryable).toBe(true)\n    })\n\n    it('should handle unknown error format', () =\u003e {\n      const response = { message: 'Something went wrong' }\n      \n      const error = parseErrorResponse(response)\n      expect(error.code).toBe('Neo.ClientError.General.UnknownError')\n    })\n  })\n})\n```\n\n### Acceptance Criteria\n- [ ] Test file created at `tests/client/serialization.test.ts`\n- [ ] All tests fail with expected errors\n- [ ] Tests cover all Neo4j types and edge cases\n\n### TDD Cycle\nThis is the RED phase. Next: GREEN phase implementation.","status":"open","priority":2,"issue_type":"task","created_at":"2026-01-05T06:39:27.860597-06:00","updated_at":"2026-01-05T06:39:27.860597-06:00"}
{"id":"neo4j-8uq","title":"RED: Write failing tests for rxSession.beginTransaction() method","description":"## Overview\nWrite failing tests for rxSession.beginTransaction() explicit transaction method.\n\n## Test Cases to Write\n\n### Basic Transaction Creation Tests\n- beginTransaction() returns Observable of RxTransaction\n- Transaction is created on subscription\n- Transaction is not created until subscribed (cold)\n- Multiple subscriptions create multiple transactions\n\n### Transaction Configuration Tests\n- Accepts transaction metadata\n- Accepts timeout configuration\n- Respects session access mode\n\n### Observable Behavior Tests\n- Emits single RxTransaction then completes\n- Error on connection failure\n- Proper cleanup on unsubscription\n\n### State Tests\n- Transaction is open after emission\n- Session tracks active transaction\n- Cannot begin while transaction active\n\n## Acceptance Criteria\n- All tests written and failing (RED phase)\n- Tests cover explicit transaction creation\n- Tests verify Observable semantics\n- Tests cover configuration options","status":"open","priority":2,"issue_type":"task","created_at":"2026-01-05T06:36:56.141891-06:00","updated_at":"2026-01-05T06:36:56.141891-06:00"}
{"id":"neo4j-8y8o","title":"GREEN: Result.single() - Implement single record expectation","description":"## Overview\nImplement the Result.single() method to make all RED phase tests pass.\n\n## Implementation\n\n```typescript\nasync single(): Promise\u003cR\u003e {\n  const records = await this.records;\n  \n  if (records.length === 0) {\n    throw new Error('Expected exactly one record, but got no records');\n  }\n  \n  if (records.length \u003e 1) {\n    throw new Error(`Expected exactly one record, but got ${records.length} records`);\n  }\n  \n  return records[0];\n}\n```\n\n## Acceptance Criteria\n- [ ] All RED phase tests now pass (GREEN phase)\n- [ ] Returns single record or throws\n- [ ] Error messages are descriptive\n- [ ] Implementation is minimal\n\n## TDD Phase\nGREEN - Minimal implementation to pass tests\n\n## Dependencies\n- neo4j-n99h (RED phase tests)","status":"closed","priority":1,"issue_type":"task","created_at":"2026-01-05T06:49:29.623578-06:00","updated_at":"2026-01-05T07:19:22.167113-06:00","closed_at":"2026-01-05T07:19:22.167113-06:00","close_reason":"Implemented in this Ralph Wiggum session - 662 tests pass"}
{"id":"neo4j-9250","title":"REFACTOR: Improve Mock RxSession API","description":"## Overview\nRefactor Mock RxSession for better developer experience.\n\n## Refactoring Tasks\n\n### Code Quality\n- Clean API design\n- Type-safe configuration\n- Builder pattern\n- Good defaults\n\n### Features\n- Add assertion helpers\n- Fluent API\n- Reset/clear mocks\n- Spy functionality\n\n### Documentation\n- Usage examples\n- Testing patterns guide\n- Integration with test frameworks\n- Best practices\n\n## Acceptance Criteria\n- All tests still pass\n- Clean, fluent API\n- Comprehensive features\n- Good documentation","status":"open","priority":2,"issue_type":"task","created_at":"2026-01-05T06:48:56.22374-06:00","updated_at":"2026-01-05T06:48:56.22374-06:00"}
{"id":"neo4j-93w","title":"RED: Write failing tests for rxSession.close() method","description":"## Overview\nWrite failing tests for rxSession.close() cleanup method.\n\n## Test Cases to Write\n\n### Basic Close Tests\n- close() returns Observable of void\n- Session resources released on subscription\n- Connection returned to pool\n- Multiple close calls are safe (idempotent)\n\n### Active Transaction Tests\n- Close rolls back active transaction\n- Close waits for pending operations\n- Close emits error if rollback fails\n\n### Observable Behavior Tests\n- Cold observable (lazy execution)\n- Completes after cleanup\n- Error emission on failure\n- Subscription triggers cleanup\n\n### Post-Close Tests\n- Operations after close emit error\n- Session state reflects closed status\n- Bookmarks still accessible after close\n\n## Acceptance Criteria\n- All tests written and failing (RED phase)\n- Tests cover cleanup behavior\n- Tests verify Observable semantics\n- Tests cover error scenarios","status":"open","priority":2,"issue_type":"task","created_at":"2026-01-05T06:37:56.8499-06:00","updated_at":"2026-01-05T06:37:56.8499-06:00"}
{"id":"neo4j-95e","title":"RED: Record.keys - Write failing tests for column names array","description":"## Overview\nWrite failing tests for the Record.keys property that returns array of column names.\n\n## Test Cases to Write\n\n```typescript\ndescribe('Record.keys', () =\u003e {\n  it('should return array of column names', () =\u003e {\n    const record = new Record(['name', 'age', 'city'], ['Alice', 30, 'NYC']);\n    expect(record.keys).toEqual(['name', 'age', 'city']);\n  });\n\n  it('should return empty array for empty record', () =\u003e {\n    const record = new Record([], []);\n    expect(record.keys).toEqual([]);\n  });\n\n  it('should preserve order of columns', () =\u003e {\n    const record = new Record(['z', 'a', 'm'], [1, 2, 3]);\n    expect(record.keys).toEqual(['z', 'a', 'm']);\n  });\n\n  it('should be read-only (frozen array)', () =\u003e {\n    const record = new Record(['name'], ['Alice']);\n    expect(() =\u003e {\n      (record.keys as string[]).push('illegal');\n    }).toThrow();\n  });\n\n  it('should return same array instance on multiple access', () =\u003e {\n    const record = new Record(['name'], ['Alice']);\n    expect(record.keys).toBe(record.keys);\n  });\n});\n```\n\n## Acceptance Criteria\n- [ ] All tests written and failing (RED phase)\n- [ ] Tests verify immutability of keys array\n- [ ] Tests verify order preservation\n- [ ] Test file created at src/result/__tests__/record-keys.test.ts\n\n## TDD Phase\nRED - Tests should fail because keys property does not exist yet","status":"closed","priority":1,"issue_type":"task","created_at":"2026-01-05T06:37:33.129287-06:00","updated_at":"2026-01-05T08:57:33.739397-06:00","closed_at":"2026-01-05T08:57:33.739397-06:00","close_reason":"Record methods already implemented with tests"}
{"id":"neo4j-96nm","title":"REFACTOR: Improve error emission patterns","description":"## Overview\nRefactor error emission for consistency and clarity.\n\n## Refactoring Tasks\n\n### Code Quality\n- Standardize error creation\n- Extract error factory\n- Add error type guards\n- Document error types\n\n### Error Messages\n- Clear, actionable messages\n- Include troubleshooting hints\n- Consistent format\n- Localization ready\n\n### Integration\n- Align with sync error handling\n- Share error definitions\n- Consistent behavior\n- Good TypeScript support\n\n## Acceptance Criteria\n- All tests still pass\n- Clear error messages\n- Consistent error handling\n- Well-documented errors","status":"open","priority":2,"issue_type":"task","created_at":"2026-01-05T06:47:19.881971-06:00","updated_at":"2026-01-05T06:47:19.881971-06:00"}
{"id":"neo4j-98j","title":"GREEN: Implement HttpTransaction class","description":"## Test-Driven Development: GREEN Phase\n\n### Component\nHTTP Client SDK - HttpTransaction Class\n\n### Implementation Requirements\n\nImplement `src/client/http-transaction.ts`:\n\n```typescript\nimport { Neo4jHttpDriver } from './http-driver'\nimport { QueryResult, Record } from './types'\n\nexport interface TransactionConfig {\n  timeout?: number\n  metadata?: Record\u003cstring, unknown\u003e\n}\n\nexport interface CommitResult {\n  bookmarks: string[]\n}\n\nexport class HttpTransaction {\n  readonly id: string\n  readonly timeout?: number\n  \n  private _isOpen = true\n  private _isCommitted = false\n  private _isRolledBack = false\n  private abortController?: AbortController\n\n  constructor(\n    private driver: Neo4jHttpDriver,\n    id: string,\n    config?: TransactionConfig\n  ) {\n    this.id = id\n    this.timeout = config?.timeout\n  }\n\n  get isOpen(): boolean {\n    return this._isOpen\n  }\n\n  get isCommitted(): boolean {\n    return this._isCommitted\n  }\n\n  get isRolledBack(): boolean {\n    return this._isRolledBack\n  }\n\n  async run\u003cT = Record\u003e(\n    query: string,\n    parameters?: Record\u003cstring, unknown\u003e\n  ): Promise\u003cQueryResult\u003cT\u003e\u003e {\n    this.assertOpen()\n\n    const response = await this.fetchWithTimeout(`/tx/${this.id}/run`, {\n      method: 'POST',\n      body: JSON.stringify({ query, parameters: parameters ?? {} })\n    })\n\n    const data = await response.json()\n    return this.mapResult\u003cT\u003e(data)\n  }\n\n  async commit(): Promise\u003cCommitResult\u003e {\n    this.assertOpen()\n\n    const response = await this.driver.fetch(`/tx/${this.id}/commit`, {\n      method: 'POST'\n    })\n\n    const data = await response.json()\n    this._isOpen = false\n    this._isCommitted = true\n    \n    return { bookmarks: data.bookmarks ?? [] }\n  }\n\n  async rollback(): Promise\u003cvoid\u003e {\n    this.assertOpen()\n\n    await this.driver.fetch(`/tx/${this.id}/rollback`, {\n      method: 'POST'\n    })\n\n    this._isOpen = false\n    this._isRolledBack = true\n  }\n\n  private async fetchWithTimeout(path: string, init: RequestInit): Promise\u003cResponse\u003e {\n    if (!this.timeout) {\n      return this.driver.fetch(path, init)\n    }\n\n    this.abortController = new AbortController()\n    const timeoutId = setTimeout(() =\u003e {\n      this.abortController?.abort()\n    }, this.timeout)\n\n    try {\n      return await this.driver.fetch(path, {\n        ...init,\n        signal: this.abortController.signal\n      })\n    } catch (error) {\n      if (error instanceof Error \u0026\u0026 error.name === 'AbortError') {\n        throw new Error('Transaction timed out')\n      }\n      throw error\n    } finally {\n      clearTimeout(timeoutId)\n    }\n  }\n\n  private assertOpen(): void {\n    if (!this._isOpen) {\n      throw new Error('Transaction is not open')\n    }\n  }\n\n  private mapResult\u003cT\u003e(data: any): QueryResult\u003cT\u003e {\n    return {\n      records: data.records.map((r: any) =\u003e new Record(r)),\n      summary: data.summary,\n      keys: data.keys\n    }\n  }\n}\n```\n\n### Acceptance Criteria\n- [ ] All RED phase tests pass\n- [ ] Transaction ID properly managed\n- [ ] run() POSTs to /tx/{id}/run\n- [ ] commit() POSTs to /tx/{id}/commit\n- [ ] rollback() POSTs to /tx/{id}/rollback\n- [ ] Timeout handling works with AbortController\n\n### Dependencies\n- RED: HttpTransaction class methods fail without implementation\n- GREEN: Implement Neo4jHttpDriver class\n\n### TDD Cycle\nThis is the GREEN phase. Next: REFACTOR phase.","status":"open","priority":2,"issue_type":"task","created_at":"2026-01-05T06:37:01.939322-06:00","updated_at":"2026-01-05T06:37:01.939322-06:00"}
{"id":"neo4j-990","title":"RED: MATCH Clause Translation","description":"## Overview\nWrite failing tests for MATCH clause translation to SQL SELECT with JOINs.\n\n## Test Cases to Write\n\n### Test 1: Simple MATCH\n- translates simple MATCH to SELECT\n- FROM nodes table\n\n### Test 2: OPTIONAL MATCH\n- translates OPTIONAL MATCH to LEFT JOIN\n\n### Test 3: Multiple MATCH Clauses\n- handles multiple MATCH clauses with cartesian product\n\n### Test 4: MATCH with WHERE\n- integrates WHERE clause with json_extract\n\n### Test 5: Connected MATCHes Share Variables\n- connects MATCH clauses by shared variables\n\n### Test 6: MATCH with Multiple Patterns\n- handles comma-separated patterns in MATCH\n\n### Test 7: OPTIONAL MATCH with No Results\n- OPTIONAL MATCH returns NULL when no match via LEFT JOIN\n\n## Acceptance Criteria\n- All tests written and failing\n- OPTIONAL MATCH correctly uses LEFT JOIN\n- Variable binding across clauses tested\n\n## TDD Phase\nRED - Write failing tests first","status":"closed","priority":1,"issue_type":"task","created_at":"2026-01-05T06:37:33.415134-06:00","updated_at":"2026-01-05T08:57:46.158808-06:00","closed_at":"2026-01-05T08:57:46.158808-06:00","close_reason":"Translation and session tests passing"}
{"id":"neo4j-99g4","title":"RED: Aggregation Translation","description":"## Overview\nWrite failing tests for aggregation function translation.\n\n## Test Cases to Write\n\n### Test 1: count(*)\n- RETURN count(*) -\u003e SELECT COUNT(*)\n\n### Test 2: count(n)\n- RETURN count(n) -\u003e SELECT COUNT(n.id)\n\n### Test 3: count(DISTINCT n.name)\n- COUNT(DISTINCT json_extract(...))\n\n### Test 4: sum()\n- RETURN sum(n.amount) -\u003e SELECT SUM(json_extract(...))\n\n### Test 5: avg()\n- RETURN avg(n.score) -\u003e SELECT AVG(...)\n\n### Test 6: min() and max()\n- RETURN min(n.age), max(n.age)\n\n### Test 7: collect()\n- RETURN collect(n.name) -\u003e JSON_GROUP_ARRAY\n\n### Test 8: collect(DISTINCT)\n- RETURN collect(DISTINCT n.tag)\n\n### Test 9: Grouping Key Inference\n- RETURN n.label, count(*) -\u003e GROUP BY n.label\n\n### Test 10: Multiple Aggregates\n- RETURN sum(n.a), avg(n.b), count(*)\n\n### Test 11: Nested Aggregation (Error)\n- count(sum(n.a)) should throw error\n\n### Test 12: Aggregation in WHERE (Error)\n- WHERE count(*) \u003e 5 should throw error\n\n## Acceptance Criteria\n- All tests written and failing\n- GROUP BY inference correct\n- Invalid aggregation usage detected\n\n## TDD Phase\nRED - Write failing tests first","status":"closed","priority":1,"issue_type":"task","created_at":"2026-01-05T06:42:25.455149-06:00","updated_at":"2026-01-05T08:53:30.818251-06:00","closed_at":"2026-01-05T08:53:30.818251-06:00","close_reason":"Aggregation/expression translation already implemented"}
{"id":"neo4j-9ex","title":"REFACTOR: Clean up rxSession.executeWrite() implementation","description":"## Overview\nRefactor rxSession.executeWrite() for maintainability.\n\n## Refactoring Tasks\n\n### Code Quality\n- Share common logic with executeRead\n- Extract transaction function executor\n- Improve type inference\n- Better error categorization\n\n### Bookmark Management\n- Extract bookmark handling logic\n- Ensure thread-safe bookmark updates\n- Optimize bookmark serialization\n\n### Performance\n- Review Observable chain efficiency\n- Minimize allocations\n- Optimize retry path\n\n## Acceptance Criteria\n- All tests still pass\n- Shared code with executeRead\n- Clean bookmark management\n- Efficient implementation","status":"open","priority":2,"issue_type":"task","created_at":"2026-01-05T06:36:36.523054-06:00","updated_at":"2026-01-05T06:36:36.523054-06:00"}
{"id":"neo4j-9v84","title":"[GREEN] Label Management - Implement label operations to pass tests","description":"## Overview\nImplement label management operations to make all tests pass.\n\n## Implementation Requirements\n\n### LabelManager Class\n```typescript\nclass LabelManager {\n  constructor(private sql: SqlStorage) {}\n\n  addLabel(nodeId: number, label: string): void {\n    this.validateLabel(label);\n    \n    const node = this.sql.exec('SELECT labels FROM nodes WHERE id = ?', nodeId).one();\n    if (\\!node) throw new Error('Node not found');\n    \n    const labels: string[] = JSON.parse(node.labels);\n    if (\\!labels.includes(label)) {\n      labels.push(label);\n      this.sql.exec(\n        'UPDATE nodes SET labels = ?, updated_at = CURRENT_TIMESTAMP WHERE id = ?',\n        JSON.stringify(labels), nodeId\n      );\n    }\n  }\n\n  addLabels(nodeId: number, newLabels: string[]): void {\n    newLabels.forEach(label =\u003e this.validateLabel(label));\n    \n    const node = this.sql.exec('SELECT labels FROM nodes WHERE id = ?', nodeId).one();\n    if (\\!node) throw new Error('Node not found');\n    \n    const labels: string[] = JSON.parse(node.labels);\n    const toAdd = newLabels.filter(l =\u003e \\!labels.includes(l));\n    \n    if (toAdd.length \u003e 0) {\n      labels.push(...toAdd);\n      this.sql.exec(\n        'UPDATE nodes SET labels = ?, updated_at = CURRENT_TIMESTAMP WHERE id = ?',\n        JSON.stringify(labels), nodeId\n      );\n    }\n  }\n\n  removeLabel(nodeId: number, label: string): void {\n    const node = this.sql.exec('SELECT labels FROM nodes WHERE id = ?', nodeId).one();\n    if (\\!node) throw new Error('Node not found');\n    \n    const labels: string[] = JSON.parse(node.labels);\n    const index = labels.indexOf(label);\n    \n    if (index \\!== -1) {\n      labels.splice(index, 1);\n      this.sql.exec(\n        'UPDATE nodes SET labels = ?, updated_at = CURRENT_TIMESTAMP WHERE id = ?',\n        JSON.stringify(labels), nodeId\n      );\n    }\n  }\n\n  getLabels(nodeId: number): string[] {\n    const node = this.sql.exec('SELECT labels FROM nodes WHERE id = ?', nodeId).one();\n    if (\\!node) throw new Error('Node not found');\n    return JSON.parse(node.labels);\n  }\n\n  getAllLabels(): string[] {\n    const result = this.sql.exec(\n      'SELECT DISTINCT value FROM nodes, json_each(nodes.labels)'\n    );\n    return result.toArray().map(row =\u003e row.value as string);\n  }\n\n  private validateLabel(label: string): void {\n    if (\\!label || typeof label \\!== 'string') {\n      throw new Error('Label must be a non-empty string');\n    }\n    if (\\!/^[A-Za-z_][A-Za-z0-9_]*$/.test(label)) {\n      throw new Error('Invalid label format');\n    }\n  }\n}\n```\n\n## Files to Create\n- `src/storage/operations/label-manager.ts`\n\n## Acceptance Criteria\n- [ ] All RED phase tests pass\n- [ ] Labels stored as JSON array\n- [ ] Duplicates prevented\n- [ ] Validation enforced\n\n## TDD Phase\n**GREEN** - Minimum code to pass tests","status":"closed","priority":1,"issue_type":"task","created_at":"2026-01-05T06:39:25.355822-06:00","updated_at":"2026-01-05T08:56:35.536203-06:00","closed_at":"2026-01-05T08:56:35.536203-06:00","close_reason":"Tests passing - storage and transactions implemented"}
{"id":"neo4j-9va","title":"[GREEN] Spatial Types (Point) - Implement to Pass Tests","description":"## Overview\nImplement the Neo4j Point spatial type to pass all failing tests.\n\n## TDD Phase: GREEN (Make Tests Pass)\n\n### Implementation Requirements\n\n#### SRID Enum/Constants\n```typescript\nexport const SRID = {\n  CARTESIAN_2D: 7203,\n  CARTESIAN_3D: 9157,\n  WGS84_2D: 4326,\n  WGS84_3D: 4979,\n} as const;\n\nexport type SRIDValue = typeof SRID[keyof typeof SRID];\n```\n\n#### Point Class\n```typescript\nexport class Point {\n  readonly srid: SRIDValue;\n  readonly x: number;\n  readonly y: number;\n  readonly z?: number;\n  \n  constructor(srid: SRIDValue, x: number, y: number, z?: number);\n  \n  toString(): string;\n  \n  // For geographic points, provide aliases\n  get longitude(): number;  // alias for x\n  get latitude(): number;   // alias for y\n  get height(): number | undefined;  // alias for z\n}\n```\n\n#### Type Guard\n```typescript\nexport function isPoint(value: unknown): value is Point {\n  return value instanceof Point;\n}\n```\n\n#### Validation\n- 2D SRIDs (7203, 4326) should not have z coordinate\n- 3D SRIDs (9157, 4979) may have z coordinate\n- Geographic coordinates should be validated:\n  - Longitude: -180 to 180\n  - Latitude: -90 to 90\n\n### File Structure\n```\nsrc/types/spatial/\n  index.ts\n  point.ts\n  srid.ts\n```\n\n### Export from Main Types\n```typescript\n// src/types/index.ts\nexport { Point, isPoint, SRID } from './spatial';\n```\n\n### Acceptance Criteria\n- [ ] All RED phase tests passing\n- [ ] Point class implemented with all properties\n- [ ] SRID constants exported\n- [ ] Type guard working\n- [ ] Proper TypeScript types\n- [ ] Exported from `src/types/index.ts`\n\n### Dependencies\n- Depends on: [RED] Spatial Types (Point) - Write Failing Tests","status":"closed","priority":1,"issue_type":"task","created_at":"2026-01-05T06:37:12.734363-06:00","updated_at":"2026-01-05T08:58:01.757895-06:00","closed_at":"2026-01-05T08:58:01.757895-06:00","close_reason":"AST, lexer and types tests passing","dependencies":[{"issue_id":"neo4j-9va","depends_on_id":"neo4j-yxe","type":"blocks","created_at":"2026-01-05T06:42:01.706524-06:00","created_by":"nathanclevenger"}]}
{"id":"neo4j-9ys","title":"[GREEN] Lexer: Implement String Literal Parsing","description":"## Overview\nImplement string literal tokenization to pass all string tests.\n\n## Implementation Tasks\n\n### String Scanner\n```typescript\nprivate scanString(quote: '\"' | \"'\"): Token {\n  // Track start position\n  // Scan until matching quote\n  // Handle escape sequences\n  // Return STRING token\n}\n```\n\n### Escape Sequence Handler\n```typescript\nprivate parseEscapeSequence(): string {\n  // \\' -\u003e '\n  // \\\" -\u003e \"\n  // \\\\ -\u003e \\\n  // \\n -\u003e newline\n  // \\t -\u003e tab\n  // \\r -\u003e carriage return\n  // \\uXXXX -\u003e unicode char\n}\n```\n\n### Error Handling\n- UnterminatedStringError with line/column\n- InvalidEscapeSequenceError with position\n\n## Acceptance Criteria\n- [ ] All string literal tests pass\n- [ ] Both quote styles work correctly\n- [ ] All escape sequences handled\n- [ ] Clear error messages for invalid strings\n\n## TDD Phase: GREEN\n## Depends On: neo4j-4q9","status":"closed","priority":1,"issue_type":"task","created_at":"2026-01-05T06:35:27.6309-06:00","updated_at":"2026-01-05T08:46:57.518502-06:00","closed_at":"2026-01-05T08:46:57.518502-06:00","close_reason":"Tests passing - implementation complete"}
{"id":"neo4j-9zx","title":"GREEN: MATCH Clause Translation","description":"## Overview\nImplement MATCH clause translation to make RED tests pass.\n\n## Implementation Tasks\n\n### 1. MatchClauseTranslator Class\n- translateMatch(clause): Generate SELECT with JOINs\n- translateOptionalMatch(clause): Generate LEFT JOINs\n- handleMultipleMatches(clauses): Combine multiple MATCH clauses\n\n### 2. WHERE Integration\n- Combine pattern WHERE with explicit WHERE\n- Translate Cypher expressions to SQL\n\n### 3. Variable Sharing\n- Track variables across MATCH clauses\n- Ensure same variable refers to same table alias\n\n### 4. Cartesian Product Handling\n- Detect disconnected patterns\n- Generate CROSS JOIN or comma-separated FROM\n\n## Files to Create/Modify\n- src/cypher/translator/match-clause-translator.ts\n- src/cypher/translator/where-integrator.ts\n\n## Acceptance Criteria\n- All RED phase tests pass\n- LEFT JOIN used for OPTIONAL MATCH\n- Variables properly shared\n\n## TDD Phase\nGREEN - Make tests pass with minimal code\n\n## Dependencies\n- Depends on: RED: MATCH Clause Translation","status":"closed","priority":1,"issue_type":"task","created_at":"2026-01-05T06:37:51.742353-06:00","updated_at":"2026-01-05T08:57:46.158422-06:00","closed_at":"2026-01-05T08:57:46.158422-06:00","close_reason":"Translation and session tests passing"}
{"id":"neo4j-a0e6","title":"RED: Write failing tests for rxTx.rollback() method","description":"## Overview\nWrite failing tests for rxTx.rollback() transaction rollback method.\n\n## Test Cases to Write\n\n### Basic Rollback Tests\n- rollback() returns Observable of void\n- Changes discarded after rollback\n- Transaction closed after rollback\n- Bookmarks NOT updated after rollback\n\n### Observable Behavior Tests\n- Cold observable (rollback on subscribe)\n- Completes on successful rollback\n- Error emission on rollback failure\n- Single emission semantics\n\n### State Tests\n- Transaction marked as closed after rollback\n- Cannot run queries after rollback\n- Cannot rollback twice (error or idempotent)\n- Cannot commit after rollback\n\n### Error Scenarios\n- Connection lost during rollback\n- Timeout during rollback\n- Partial rollback handling\n\n## Acceptance Criteria\n- All tests written and failing (RED phase)\n- Tests verify rollback behavior\n- Tests cover Observable semantics\n- Tests cover error scenarios","status":"open","priority":2,"issue_type":"task","created_at":"2026-01-05T06:39:39.329893-06:00","updated_at":"2026-01-05T06:39:39.329893-06:00"}
{"id":"neo4j-a4g","title":"GREEN: Implement REST API endpoint handlers","description":"## Test-Driven Development: GREEN Phase\n\n### Component\nHTTP Client SDK - REST API Endpoints (Server-Side)\n\n### Implementation Requirements\n\nImplement `src/api/rest-routes.ts`:\n\n```typescript\nimport { Hono } from 'hono'\nimport { GraphDatabase } from '../graph/database'\nimport { TransactionManager } from '../transaction/manager'\n\nexport function createRestRoutes(db: GraphDatabase) {\n  const app = new Hono()\n  const txManager = new TransactionManager(db)\n\n  // POST /query - Execute single query\n  app.post('/query', async (c) =\u003e {\n    const { query, parameters, database, bookmarks } = await c.req.json()\n    const result = await db.query(query, parameters, { database, bookmarks })\n    return c.json({\n      records: result.records,\n      keys: result.keys,\n      summary: result.summary,\n      bookmarks: result.bookmarks\n    })\n  })\n\n  // POST /tx/begin - Start transaction\n  app.post('/tx/begin', async (c) =\u003e {\n    const { database, accessMode, bookmarks } = await c.req.json()\n    const tx = await txManager.begin({ database, accessMode, bookmarks })\n    return c.json({ id: tx.id, accessMode: tx.accessMode }, 201)\n  })\n\n  // POST /tx/:id/run - Run in transaction\n  app.post('/tx/:id/run', async (c) =\u003e {\n    const id = c.req.param('id')\n    const tx = txManager.get(id)\n    if (!tx) return c.json({ error: 'Transaction not found' }, 404)\n    \n    const { query, parameters } = await c.req.json()\n    const result = await tx.run(query, parameters)\n    return c.json({\n      records: result.records,\n      keys: result.keys,\n      summary: result.summary\n    })\n  })\n\n  // POST /tx/:id/commit - Commit transaction\n  app.post('/tx/:id/commit', async (c) =\u003e {\n    const id = c.req.param('id')\n    const tx = txManager.get(id)\n    if (!tx) return c.json({ error: 'Transaction not found' }, 404)\n    \n    const result = await tx.commit()\n    txManager.remove(id)\n    return c.json({ bookmarks: result.bookmarks })\n  })\n\n  // POST /tx/:id/rollback - Rollback transaction\n  app.post('/tx/:id/rollback', async (c) =\u003e {\n    const id = c.req.param('id')\n    const tx = txManager.get(id)\n    if (!tx) return c.json({ error: 'Transaction not found' }, 404)\n    \n    await tx.rollback()\n    txManager.remove(id)\n    return c.json({ success: true })\n  })\n\n  // GET /server-info - Server metadata\n  app.get('/server-info', (c) =\u003e {\n    return c.json({\n      address: 'neo4j.do',\n      protocolVersion: '5.0',\n      agent: 'neo4j.do/1.0.0',\n      connectionId: crypto.randomUUID()\n    })\n  })\n\n  // GET /databases - List databases\n  app.get('/databases', async (c) =\u003e {\n    const databases = await db.listDatabases()\n    return c.json({ databases })\n  })\n\n  // POST /databases - Create database\n  app.post('/databases', async (c) =\u003e {\n    const { name } = await c.req.json()\n    if (!/^[a-z][a-z0-9_]*$/i.test(name)) {\n      return c.json({ error: 'Invalid database name' }, 400)\n    }\n    const database = await db.createDatabase(name)\n    return c.json({ name: database.name }, 201)\n  })\n\n  return app\n}\n```\n\n### Acceptance Criteria\n- [ ] All RED phase tests pass\n- [ ] POST /query executes Cypher\n- [ ] Transaction endpoints manage lifecycle\n- [ ] GET /server-info returns metadata\n- [ ] Database management endpoints work\n\n### Dependencies\n- RED: REST API endpoint handlers fail without implementation\n\n### TDD Cycle\nThis is the GREEN phase. Next: REFACTOR phase.","status":"open","priority":2,"issue_type":"task","created_at":"2026-01-05T06:38:25.91329-06:00","updated_at":"2026-01-05T06:38:25.91329-06:00"}
{"id":"neo4j-a52","title":"EPIC: neo4j.do - Neo4j-compatible graph database on Cloudflare Workers","description":"## Vision\n\nBuild neo4j.do - a Neo4j-compatible graph database running on Cloudflare Workers with 100% API compatibility with the official neo4j-driver npm package, plus intelligent superset features.\n\n## Goals\n\n1. Drop-in Replacement: Any code using neo4j-driver should work with neo4j.do\n2. Edge-Native: Run entirely on Cloudflare Workers with Durable Objects + SQLite\n3. Cypher Support: Full Cypher query language parsing and execution\n4. Superset Features: Auto-embeddings, vector search, AI integration\n\n## Architecture: Dual-Mode (following mongo.do)\n\n- URI Mode: In-memory graph for testing\n- Durable Objects Mode: Production with SQLite persistence\n\n## Key Innovation: Cypher to SQL Compiler\n\nTranslates Cypher pattern matching to SQL JOINs with recursive CTEs for variable-length paths.","status":"open","priority":0,"issue_type":"epic","created_at":"2026-01-05T06:31:38.572913-06:00","updated_at":"2026-01-05T06:31:56.316187-06:00"}
{"id":"neo4j-addh","title":"[GREEN] Parser: Implement LOAD CSV Parsing","description":"## Overview\nImplement LOAD CSV clause parsing.\n\n## Implementation Tasks\n\n### LOAD CSV Parser\n```typescript\nparseLoadCsvClause(): LoadCsvClause {\n  const start = this.pos\n  this.expect('LOAD')\n  this.expect('CSV')\n  \n  const withHeaders = this.match('WITH') \u0026\u0026 this.match('HEADERS')\n  \n  this.expect('FROM')\n  \n  const source = this.parseExpression() // string or parameter\n  \n  this.expect('AS')\n  \n  const variable = this.parseIdentifier()\n  \n  let fieldTerminator: string | undefined\n  if (this.match('FIELDTERMINATOR')) {\n    fieldTerminator = this.parseStringLiteral().value\n  }\n  \n  return {\n    type: 'LoadCsvClause',\n    withHeaders,\n    source,\n    variable,\n    fieldTerminator,\n    loc: this.getLoc(start)\n  }\n}\n```\n\n### USING PERIODIC COMMIT\n```typescript\nparsePeriodicCommit(): PeriodicCommitHint {\n  const start = this.pos\n  this.expect('USING')\n  this.expect('PERIODIC')\n  this.expect('COMMIT')\n  \n  let batchSize: number | undefined\n  if (this.isNumber()) {\n    batchSize = this.parseInteger()\n  }\n  \n  return {\n    type: 'PeriodicCommitHint',\n    batchSize,\n    loc: this.getLoc(start)\n  }\n}\n```\n\n### AST Types\n```typescript\ninterface LoadCsvClause extends ASTNode {\n  type: 'LoadCsvClause'\n  withHeaders: boolean\n  source: Expression\n  variable: Identifier\n  fieldTerminator?: string\n}\n\ninterface PeriodicCommitHint extends ASTNode {\n  type: 'PeriodicCommitHint'\n  batchSize?: number\n}\n```\n\n## Acceptance Criteria\n- [ ] All LOAD CSV tests pass\n- [ ] WITH HEADERS works\n- [ ] FIELDTERMINATOR works\n- [ ] PERIODIC COMMIT works\n\n## TDD Phase: GREEN\n## Depends On: neo4j-5vgb","status":"open","priority":2,"issue_type":"task","created_at":"2026-01-05T06:52:20.842766-06:00","updated_at":"2026-01-05T06:52:20.842766-06:00"}
{"id":"neo4j-adf","title":"RED: Variable-Length Path Translation - Recursive CTEs","description":"## Overview\nWrite failing tests for variable-length path translation using recursive CTEs.\n\n## Test Cases to Write\n\n### Test 1: Unlimited Depth (*)\n```typescript\ntest('translates [*] to recursive CTE', () =\u003e {\n  const ast = parse('MATCH (a)-[*]-\u003e(b) RETURN a, b');\n  const sql = translate(ast);\n  expect(sql).toContain('WITH RECURSIVE');\n  expect(sql).toContain('UNION');\n});\n```\n\n### Test 2: Exact Depth (*n)\n```typescript\ntest('translates [*3] to 3-level JOIN', () =\u003e {\n  const ast = parse('MATCH (a)-[*3]-\u003e(b) RETURN a, b');\n  const sql = translate(ast);\n  // Should have exactly 3 relationship JOINs\n  expect(sql.match(/JOIN relationships/g)?.length).toBe(3);\n});\n```\n\n### Test 3: Range Depth (*n..m)\n```typescript\ntest('translates [*1..3] to bounded recursive CTE', () =\u003e {\n  const ast = parse('MATCH (a)-[*1..3]-\u003e(b) RETURN a, b');\n  const sql = translate(ast);\n  expect(sql).toContain('WITH RECURSIVE');\n  expect(sql).toContain('depth');\n  expect(sql).toMatch(/depth.*\u003c=.*3/);\n});\n```\n\n### Test 4: Minimum Only (*n..)\n```typescript\ntest('translates [*2..] to min-bounded CTE', () =\u003e {\n  const ast = parse('MATCH (a)-[*2..]-\u003e(b) RETURN a, b');\n  const sql = translate(ast);\n  expect(sql).toMatch(/depth.*\u003e=.*2/);\n});\n```\n\n### Test 5: Cycle Detection\n```typescript\ntest('includes cycle detection in recursive CTE', () =\u003e {\n  const ast = parse('MATCH (a)-[*]-\u003e(b) RETURN a, b');\n  const sql = translate(ast);\n  // Should track visited nodes to prevent cycles\n  expect(sql).toContain('visited');\n});\n```\n\n### Test 6: Path Construction\n```typescript\ntest('constructs path with nodes and relationships', () =\u003e {\n  const ast = parse('MATCH path = (a)-[*]-\u003e(b) RETURN path');\n  const sql = translate(ast);\n  // Should collect nodes and relationships in path\n  expect(sql).toContain('JSON_GROUP_ARRAY');\n});\n```\n\n### Test 7: With Relationship Type Filter\n```typescript\ntest('translates [*:KNOWS] with type filter', () =\u003e {\n  const ast = parse('MATCH (a)-[:KNOWS*]-\u003e(b) RETURN b');\n  const sql = translate(ast);\n  expect(sql).toContain(\"type = 'KNOWS'\");\n});\n```\n\n## Acceptance Criteria\n- [ ] All tests written and failing\n- [ ] Cycle detection tested\n- [ ] Performance bounds tested\n\n## TDD Phase\nRED - Write failing tests first","status":"open","priority":2,"issue_type":"task","created_at":"2026-01-05T06:36:14.562393-06:00","updated_at":"2026-01-05T06:36:14.562393-06:00"}
{"id":"neo4j-adxn","title":"GREEN: Implement unsubscription cleanup","description":"## Overview\nImplement proper cleanup on unsubscription to make all RED tests pass.\n\n## Implementation Requirements\n\n### Cleanup Actions\n- Cancel pending queries\n- Release connections\n- Clear buffers\n- Rollback active transactions\n\n### Implementation Details\n- Add teardown logic to Observables\n- Track resources to clean up\n- Handle cleanup order\n- Ensure cleanup runs\n\n### Resource Management\n- Connection pool return\n- Memory deallocation\n- Buffer clearing\n- State cleanup\n\n## Acceptance Criteria\n- All RED tests now pass (GREEN phase)\n- All resources cleaned up\n- No memory leaks\n- Clean state after unsubscribe","status":"open","priority":2,"issue_type":"task","created_at":"2026-01-05T06:44:29.545877-06:00","updated_at":"2026-01-05T06:44:29.545877-06:00"}
{"id":"neo4j-afgx","title":"[RED] Parser: SET and REMOVE Clause Tests","description":"## Overview\nWrite failing tests for SET and REMOVE clause parsing.\n\n## Test Cases to Write\n\n### Basic SET\n- Property: `SET n.name = 'John'`\n- Multiple properties: `SET n.name = 'John', n.age = 30`\n- Label: `SET n:Person`\n- Multiple labels: `SET n:Person:Employee`\n\n### SET with Operators\n- Replace all: `SET n = {name: 'John'}`\n- Merge properties: `SET n += {age: 30}`\n- From parameter: `SET n = $props`\n\n### SET in Context\n- After MATCH: `MATCH (n) SET n.updated = true`\n- After CREATE: `CREATE (n) SET n.created = timestamp()`\n- In MERGE: `MERGE (n) ON CREATE SET n.x = 1`\n\n### Basic REMOVE\n- Property: `REMOVE n.name`\n- Multiple properties: `REMOVE n.name, n.age`\n- Label: `REMOVE n:Temp`\n- Multiple labels: `REMOVE n:Label1:Label2`\n\n### Mixed SET/REMOVE\n- `SET n.name = 'John' REMOVE n.temp`\n- Sequence matters\n\n## Acceptance Criteria\n- [ ] All SET tests written and failing\n- [ ] All REMOVE tests written and failing\n- [ ] All SET operators tested\n- [ ] Error cases covered\n\n## TDD Phase: RED","status":"closed","priority":1,"issue_type":"task","created_at":"2026-01-05T06:43:53.456058-06:00","updated_at":"2026-01-05T08:46:40.403517-06:00","closed_at":"2026-01-05T08:46:40.403517-06:00","close_reason":"Tests passing - implementation complete"}
{"id":"neo4j-afj7","title":"GREEN: Change Data Capture - Implement CDC with webhooks and Kafka","description":"## Overview\nImplement Change Data Capture streaming functionality.\n\n## Implementation Requirements\n\n### Core Components\n\n#### 1. Event Schema\n```typescript\ninterface CDCEvent {\n  id: string;\n  timestamp: number;\n  operation: 'CREATE' | 'UPDATE' | 'DELETE';\n  entityType: 'node' | 'relationship';\n  entityId: string;\n  \n  // For nodes\n  labels?: string[];\n  \n  // For relationships\n  type?: string;\n  startNodeId?: string;\n  endNodeId?: string;\n  \n  // Property changes\n  before?: Record\u003cstring, any\u003e;\n  after?: Record\u003cstring, any\u003e;\n  changes?: Record\u003cstring, { from: any; to: any }\u003e;\n  \n  // Metadata\n  transactionId?: string;\n  userId?: string;\n}\n```\n\n#### 2. Event Capture via Triggers\n```sql\n-- CDC event log table\nCREATE TABLE cdc_events (\n  id TEXT PRIMARY KEY,\n  timestamp INTEGER NOT NULL,\n  operation TEXT NOT NULL,\n  entity_type TEXT NOT NULL,\n  entity_id TEXT NOT NULL,\n  labels TEXT, -- JSON array\n  rel_type TEXT,\n  start_node_id TEXT,\n  end_node_id TEXT,\n  before_props TEXT, -- JSON\n  after_props TEXT, -- JSON\n  transaction_id TEXT,\n  processed INTEGER DEFAULT 0\n);\n\nCREATE INDEX idx_cdc_timestamp ON cdc_events(timestamp);\nCREATE INDEX idx_cdc_processed ON cdc_events(processed) WHERE processed = 0;\n\n-- Triggers on nodes table\nCREATE TRIGGER cdc_node_insert AFTER INSERT ON nodes\nBEGIN\n  INSERT INTO cdc_events (id, timestamp, operation, entity_type, entity_id, labels, after_props)\n  VALUES (\n    'evt_' || hex(randomblob(8)),\n    unixepoch('now', 'subsec') * 1000,\n    'CREATE',\n    'node',\n    NEW.id,\n    NEW.labels,\n    NEW.properties\n  );\nEND;\n\nCREATE TRIGGER cdc_node_update AFTER UPDATE ON nodes\nBEGIN\n  INSERT INTO cdc_events (id, timestamp, operation, entity_type, entity_id, labels, before_props, after_props)\n  VALUES (\n    'evt_' || hex(randomblob(8)),\n    unixepoch('now', 'subsec') * 1000,\n    'UPDATE',\n    'node',\n    NEW.id,\n    NEW.labels,\n    OLD.properties,\n    NEW.properties\n  );\nEND;\n\nCREATE TRIGGER cdc_node_delete AFTER DELETE ON nodes\nBEGIN\n  INSERT INTO cdc_events (id, timestamp, operation, entity_type, entity_id, labels, before_props)\n  VALUES (\n    'evt_' || hex(randomblob(8)),\n    unixepoch('now', 'subsec') * 1000,\n    'DELETE',\n    'node',\n    OLD.id,\n    OLD.labels,\n    OLD.properties\n  );\nEND;\n```\n\n#### 3. Subscription Manager\n```typescript\ninterface SubscriptionFilter {\n  labels?: string[];\n  relTypes?: string[];\n  operations?: ('CREATE' | 'UPDATE' | 'DELETE')[];\n  properties?: string[];\n}\n\nclass SubscriptionManager {\n  private subscriptions = new Map\u003cstring, Subscription\u003e();\n\n  async subscribe(\n    filter: SubscriptionFilter | '*',\n    callback: (event: CDCEvent) =\u003e void\n  ): Promise\u003cSubscription\u003e {\n    const id = generateId();\n    const subscription = new Subscription(id, filter, callback);\n    this.subscriptions.set(id, subscription);\n    return subscription;\n  }\n\n  async dispatch(event: CDCEvent): Promise\u003cvoid\u003e {\n    for (const sub of this.subscriptions.values()) {\n      if (this.matchesFilter(event, sub.filter)) {\n        sub.callback(event);\n      }\n    }\n  }\n\n  private matchesFilter(event: CDCEvent, filter: SubscriptionFilter | '*'): boolean {\n    if (filter === '*') return true;\n    \n    if (filter.labels \u0026\u0026 !filter.labels.some(l =\u003e event.labels?.includes(l))) {\n      return false;\n    }\n    if (filter.operations \u0026\u0026 !filter.operations.includes(event.operation)) {\n      return false;\n    }\n    // ... more filter checks\n    \n    return true;\n  }\n}\n```\n\n#### 4. Webhook Manager\n```typescript\ninterface WebhookConfig {\n  url: string;\n  filter: SubscriptionFilter;\n  secret?: string;\n  retryPolicy?: {\n    maxRetries: number;\n    backoff: 'fixed' | 'exponential';\n    initialDelay: number;\n  };\n}\n\nclass WebhookManager {\n  async registerWebhook(config: WebhookConfig): Promise\u003cstring\u003e {\n    const id = generateId();\n    await this.store.save(id, config);\n    return id;\n  }\n\n  async dispatch(event: CDCEvent): Promise\u003cvoid\u003e {\n    const webhooks = await this.store.getMatchingWebhooks(event);\n    \n    await Promise.all(webhooks.map(webhook =\u003e \n      this.sendWithRetry(webhook, event)\n    ));\n  }\n\n  private async sendWithRetry(webhook: WebhookConfig, event: CDCEvent): Promise\u003cvoid\u003e {\n    const signature = this.sign(event, webhook.secret);\n    \n    for (let attempt = 0; attempt \u003c= webhook.retryPolicy?.maxRetries ?? 3; attempt++) {\n      try {\n        await fetch(webhook.url, {\n          method: 'POST',\n          headers: {\n            'Content-Type': 'application/json',\n            'X-Webhook-Signature': signature\n          },\n          body: JSON.stringify({ event })\n        });\n        return;\n      } catch (error) {\n        if (attempt === webhook.retryPolicy?.maxRetries) throw error;\n        await this.backoff(attempt, webhook.retryPolicy);\n      }\n    }\n  }\n}\n```\n\n#### 5. Kafka Integration\n```typescript\nclass KafkaPublisher {\n  async configureKafka(config: KafkaConfig): Promise\u003cvoid\u003e {\n    // Store Kafka configuration\n  }\n\n  async publish(event: CDCEvent): Promise\u003cvoid\u003e {\n    // Use Kafka.do or native Kafka binding\n    await this.producer.send({\n      topic: this.config.topic,\n      messages: [{\n        key: event.entityId,\n        value: JSON.stringify(event),\n        headers: {\n          'operation': event.operation,\n          'entity-type': event.entityType\n        }\n      }]\n    });\n  }\n}\n```\n\n#### 6. Event Poller (for Workers)\n```typescript\n// Since Workers can't have persistent connections,\n// use Durable Objects or polling\nclass CDCEventPoller {\n  async poll(): Promise\u003cCDCEvent[]\u003e {\n    const events = await this.db.prepare(`\n      SELECT * FROM cdc_events \n      WHERE processed = 0 \n      ORDER BY timestamp \n      LIMIT 100\n    `).all();\n    \n    return events.map(this.toCDCEvent);\n  }\n\n  async markProcessed(eventIds: string[]): Promise\u003cvoid\u003e {\n    await this.db.prepare(`\n      UPDATE cdc_events SET processed = 1 WHERE id IN (${eventIds.map(() =\u003e '?').join(',')})\n    `).bind(...eventIds).run();\n  }\n}\n```\n\n## Acceptance Criteria\n- [ ] All RED phase tests passing\n- [ ] Event capture via triggers\n- [ ] Subscription filtering working\n- [ ] Webhooks delivered with retries\n- [ ] Event replay functional\n\n## Dependencies\n- RED: CDC tests\n- Queue binding for async processing\n\n## Tags\nsuperset, cdc, change-data-capture, webhooks, kafka, tdd-green","status":"open","priority":2,"issue_type":"task","created_at":"2026-01-05T06:48:24.6782-06:00","updated_at":"2026-01-05T06:48:24.6782-06:00"}
{"id":"neo4j-agtg","title":"GREEN: Implement Mock RxSession testing utility","description":"## Overview\nImplement Mock RxSession to make all RED tests pass.\n\n## Implementation Requirements\n\n### Mock Creation\n- createMockRxSession() factory\n- Implement all RxSession methods\n- Return Observable mocks\n- Support configuration\n\n### Configuration API\n- mockRxSession.whenRun(query).thenReturn(data)\n- mockRxSession.whenRun(query).thenError(error)\n- Configure transactions\n- Configure timing\n\n### Verification API\n- mockRxSession.verify.run(query)\n- Check call count\n- Check arguments\n- Check order\n\n## Acceptance Criteria\n- All RED tests now pass (GREEN phase)\n- Mock fully functional\n- Configuration works\n- Verification works","status":"open","priority":2,"issue_type":"task","created_at":"2026-01-05T06:48:49.810747-06:00","updated_at":"2026-01-05T06:48:49.810747-06:00"}
{"id":"neo4j-ajg","title":"[REFACTOR] Temporal Types - Optimize and Harden","description":"## Overview\nRefactor temporal types for performance, edge cases, and code quality.\n\n## TDD Phase: REFACTOR (Improve While Green)\n\n### Refactoring Goals\n\n#### Performance Optimizations\n- [ ] Lazy string formatting (cache toString results)\n- [ ] Efficient comparison methods\n- [ ] Minimize allocations in conversions\n\n#### Edge Case Hardening\n- [ ] Leap year handling (Feb 29)\n- [ ] Leap seconds\n- [ ] DST transitions\n- [ ] Timezone offset boundaries (-12:00 to +14:00)\n- [ ] Year boundaries (negative years, year 0)\n- [ ] Month/day validation\n- [ ] Nanosecond overflow handling\n\n#### Additional Features\n- [ ] Add arithmetic: date.add(duration)\n- [ ] Add comparison: date.equals(other), date.compareTo(other)\n- [ ] Add factories: Date.now(), DateTime.now()\n\n#### Code Quality\n- [ ] Extract shared temporal utilities\n- [ ] Add comprehensive JSDoc\n- [ ] Consistent error messages\n- [ ] Shared validation logic\n\n#### Additional Tests\n- [ ] Timezone database edge cases\n- [ ] Historical dates (Julian calendar issues)\n- [ ] Far future dates\n- [ ] Round-trip serialization tests\n- [ ] Cross-type comparisons\n\n### Acceptance Criteria\n- [ ] All existing tests still pass\n- [ ] Edge cases covered with new tests\n- [ ] 100% test coverage on temporal modules\n- [ ] Performance benchmarks documented\n- [ ] JSDoc complete\n\n### Dependencies\n- Depends on: [GREEN] Temporal Types - Implement to Pass Tests","status":"closed","priority":1,"issue_type":"task","created_at":"2026-01-05T06:36:18.729309-06:00","updated_at":"2026-01-05T08:54:14.035137-06:00","closed_at":"2026-01-05T08:54:14.035137-06:00","close_reason":"Tests passing - implementation complete","dependencies":[{"issue_id":"neo4j-ajg","depends_on_id":"neo4j-4kp","type":"blocks","created_at":"2026-01-05T06:41:50.842132-06:00","created_by":"nathanclevenger"}]}
{"id":"neo4j-ak6d","title":"RED: Record.values() - Write failing tests for values array","description":"## Overview\nWrite failing tests for the Record.values() method that returns array of values.\n\n## Test Cases to Write\n\n```typescript\ndescribe('Record.values()', () =\u003e {\n  it('should return array of values', () =\u003e {\n    const record = new Record(['name', 'age'], ['Alice', 30]);\n    expect(record.values()).toEqual(['Alice', 30]);\n  });\n\n  it('should return empty array for empty record', () =\u003e {\n    const record = new Record([], []);\n    expect(record.values()).toEqual([]);\n  });\n\n  it('should preserve value order', () =\u003e {\n    const record = new Record(['a', 'b', 'c'], [1, 2, 3]);\n    expect(record.values()).toEqual([1, 2, 3]);\n  });\n\n  it('should include null and undefined values', () =\u003e {\n    const record = new Record(['a', 'b'], [null, undefined]);\n    expect(record.values()).toEqual([null, undefined]);\n  });\n\n  it('should return new array each time', () =\u003e {\n    const record = new Record(['name'], ['Alice']);\n    const v1 = record.values();\n    const v2 = record.values();\n    expect(v1).not.toBe(v2);\n    expect(v1).toEqual(v2);\n  });\n\n  it('should preserve complex types', () =\u003e {\n    const node = new Node(1, ['Person'], { name: 'Alice' });\n    const record = new Record(['person'], [node]);\n    expect(record.values()[0]).toBe(node);\n  });\n});\n```\n\n## Acceptance Criteria\n- [ ] All tests written and failing (RED phase)\n- [ ] Tests verify value array contents\n- [ ] Tests verify new array returned each call\n- [ ] Test file created at src/result/__tests__/record-values.test.ts\n\n## TDD Phase\nRED - Tests should fail because values method does not exist yet","status":"closed","priority":1,"issue_type":"task","created_at":"2026-01-05T06:40:22.15384-06:00","updated_at":"2026-01-05T08:55:15.890424-06:00","closed_at":"2026-01-05T08:55:15.890424-06:00","close_reason":"Record methods already implemented with tests"}
{"id":"neo4j-akzn","title":"[REFACTOR] Transaction Support - Add savepoints and improve isolation","description":"## Overview\nRefactor transaction support for advanced features and better isolation.\n\n## Refactoring Tasks\n\n### Savepoint Support\n```typescript\nclass Transaction {\n  private savepoints: string[] = [];\n\n  savepoint(name: string): void {\n    this.ensureActive();\n    this.sql.exec(`SAVEPOINT ${name}`);\n    this.savepoints.push(name);\n  }\n\n  rollbackToSavepoint(name: string): void {\n    this.ensureActive();\n    const index = this.savepoints.indexOf(name);\n    if (index === -1) throw new Error(`Savepoint ${name} not found`);\n    \n    this.sql.exec(`ROLLBACK TO ${name}`);\n    // Remove savepoints created after this one\n    this.savepoints = this.savepoints.slice(0, index + 1);\n  }\n\n  releaseSavepoint(name: string): void {\n    this.ensureActive();\n    this.sql.exec(`RELEASE ${name}`);\n    this.savepoints = this.savepoints.filter(s =\u003e s \\!== name);\n  }\n}\n```\n\n### Transaction Bookmarks (Neo4j Causal Clustering)\n```typescript\ninterface TransactionBookmark {\n  id: string;\n  timestamp: number;\n  lastCommitId: number;\n}\n\nclass TransactionManager {\n  lastBookmark(): TransactionBookmark {\n    const lastCommit = this.sql.exec(\n      'SELECT MAX(id) as id FROM commits'\n    ).one();\n    return {\n      id: crypto.randomUUID(),\n      timestamp: Date.now(),\n      lastCommitId: lastCommit?.id ?? 0\n    };\n  }\n\n  beginAfterBookmark(bookmark: TransactionBookmark, mode: TransactionMode): string {\n    // Ensure we see at least the bookmark's commit\n    return this.begin(mode);\n  }\n}\n```\n\n### Transaction Logging\n```typescript\ninterface TransactionLog {\n  txId: string;\n  operation: 'BEGIN' | 'COMMIT' | 'ROLLBACK';\n  mode: TransactionMode;\n  timestamp: number;\n  duration?: number;\n  error?: string;\n}\n\nclass TransactionManager {\n  private logs: TransactionLog[] = [];\n\n  private log(entry: TransactionLog): void {\n    this.logs.push(entry);\n    // Optionally persist to storage\n  }\n\n  getTransactionLogs(since?: number): TransactionLog[] {\n    if (since) {\n      return this.logs.filter(l =\u003e l.timestamp \u003e= since);\n    }\n    return this.logs;\n  }\n}\n```\n\n### Code Quality\n- Add transaction metrics\n- Implement deadlock detection\n- Add transaction retry logic\n- Create transaction decorators\n\n## Acceptance Criteria\n- [ ] All tests still pass\n- [ ] Savepoints available\n- [ ] Bookmarks implemented\n- [ ] Logging comprehensive\n- [ ] Code well-documented\n\n## TDD Phase\n**REFACTOR** - Improve without changing behavior","status":"open","priority":2,"issue_type":"task","created_at":"2026-01-05T06:41:11.5885-06:00","updated_at":"2026-01-05T06:41:11.5885-06:00"}
{"id":"neo4j-amgo","title":"REFACTOR: Optimize rxResult.records() streaming","description":"## Overview\nRefactor rxResult.records() for optimal streaming performance.\n\n## Refactoring Tasks\n\n### Code Quality\n- Extract record parsing logic\n- Improve type definitions\n- Add proper generics\n- Document streaming behavior\n\n### Performance\n- Optimize record creation\n- Minimize allocations\n- Efficient backpressure handling\n- Consider buffer strategies\n\n### RxJS Integration\n- Ensure operator compatibility\n- Test with common patterns\n- Document recommended usage\n\n## Acceptance Criteria\n- All tests still pass\n- Optimal streaming performance\n- Clean RxJS integration\n- Well-documented patterns","status":"open","priority":2,"issue_type":"task","created_at":"2026-01-05T06:41:25.714483-06:00","updated_at":"2026-01-05T06:41:25.714483-06:00"}
{"id":"neo4j-ard0","title":"REFACTOR: Browser compatibility optimization","description":"## Test-Driven Development: REFACTOR Phase\n\n### Component\nHTTP Client SDK - Browser Compatibility\n\n### Refactoring Goals\n\n1. Polyfill strategy - Optional polyfills for older browsers\n2. Bundle optimization - Code splitting for features\n3. TypeScript declarations - Browser-specific type definitions\n4. Documentation - CORS setup guides, CSP considerations\n\n### Acceptance Criteria\n- All existing tests still pass\n- Polyfills optional and tree-shakeable\n- Bundle size minimized\n- TypeScript types accurate\n- Documentation covers browser setup\n\n### Dependencies\n- GREEN: Implement Browser compatibility\n\n### TDD Cycle\nThis completes the RED-\u003eGREEN-\u003eREFACTOR cycle for Browser Compatibility.","status":"open","priority":2,"issue_type":"task","created_at":"2026-01-05T06:49:05.468779-06:00","updated_at":"2026-01-05T06:49:05.468779-06:00"}
{"id":"neo4j-au2","title":"REFACTOR: Clean up rxSession.lastBookmarks() implementation","description":"## Overview\nRefactor rxSession.lastBookmarks() for better bookmark management.\n\n## Refactoring Tasks\n\n### Code Quality\n- Extract bookmark manager class\n- Share with sync session implementation\n- Improve type safety\n- Add bookmark validation\n\n### Performance\n- Optimize bookmark storage\n- Consider immutable bookmark arrays\n- Efficient bookmark merging\n\n### Documentation\n- Document bookmark semantics\n- Add examples for causal consistency\n- Explain multi-database bookmarks\n\n## Acceptance Criteria\n- All tests still pass\n- Shared bookmark management code\n- Efficient implementation\n- Well-documented behavior","status":"open","priority":2,"issue_type":"task","created_at":"2026-01-05T06:37:40.452107-06:00","updated_at":"2026-01-05T06:37:40.452107-06:00"}
{"id":"neo4j-auuz","title":"REFACTOR: Dual-Mode Support Optimization","description":"## Overview\nRefactor dual-mode support for advanced scenarios, edge cases, and Cloudflare-specific optimizations.\n\n## Refactoring Goals\n\n### Cloudflare Optimizations\n- DO stub caching and reuse\n- Request coalescing for DO calls\n- Alarm-based consistency checks\n- WebSocket for real-time updates\n\n### Edge Cases\n```typescript\ndescribe('Mode Detection Edge Cases', () =\u003e {\n  it('should handle null env gracefully')\n  it('should handle env without GRAPH_DO binding')\n  it('should handle invalid URI gracefully')\n  it('should handle mixed URI and env configuration')\n})\n\ndescribe('In-Memory Mode Edge Cases', () =\u003e {\n  it('should handle memory limits')\n  it('should handle concurrent driver instances')\n  it('should handle graph corruption recovery')\n  it('should handle large graph serialization')\n})\n\ndescribe('Durable Object Mode Edge Cases', () =\u003e {\n  it('should handle DO not found')\n  it('should handle DO timeout')\n  it('should handle DO rate limiting')\n  it('should handle DO size limits')\n  it('should handle DO migration during operation')\n  it('should handle DO hibernation wake-up')\n  it('should reconnect after DO restart')\n})\n```\n\n### Performance\n- Lazy DO connection\n- Connection pooling simulation\n- Request batching to DO\n- Result streaming from DO\n\n### Developer Experience\n- Clear error messages for mode issues\n- Debug mode for mode detection\n- Telemetry for mode usage\n\n### Code Quality\n- Extract mode-specific logic to strategies\n- Create unified interface for both modes\n- Add mode switching support (for testing)\n\n## TDD Phase\n**REFACTOR** - Improve without breaking tests.\n\n## Dependencies\n- Depends on: GREEN: Dual-Mode Support (URI vs Env) Implementation\n\n## Acceptance Criteria\n- [ ] All tests pass\n- [ ] Cloudflare optimizations implemented\n- [ ] Edge cases handled\n- [ ] Both modes perform well","status":"open","priority":2,"issue_type":"task","created_at":"2026-01-05T06:41:41.801009-06:00","updated_at":"2026-01-05T06:41:41.801009-06:00"}
{"id":"neo4j-b16","title":"GREEN: Record.get(key) - Implement get value by column name","description":"## Overview\nImplement the Record.get(key) method to make all RED phase tests pass.\n\n## Implementation\n\n```typescript\nexport class Record\u003cR extends Dict = Dict\u003e {\n  private _keys: string[];\n  private _values: any[];\n  private _fieldLookup: Map\u003cstring, number\u003e;\n\n  constructor(keys: string[], values: any[]) {\n    this._keys = keys;\n    this._values = values;\n    this._fieldLookup = new Map(keys.map((k, i) =\u003e [k, i]));\n  }\n\n  get(key: string): any {\n    const index = this._fieldLookup.get(key);\n    if (index === undefined) {\n      return undefined;\n    }\n    return this._values[index];\n  }\n}\n```\n\n## Acceptance Criteria\n- [ ] All RED phase tests now pass (GREEN phase)\n- [ ] Implementation is minimal - just enough to pass tests\n- [ ] No premature optimization\n- [ ] Record class created at `src/result/record.ts`\n\n## TDD Phase\nGREEN - Minimal implementation to pass tests\n\n## Dependencies\n- neo4j-i2k (RED phase tests)","status":"closed","priority":1,"issue_type":"task","created_at":"2026-01-05T06:34:41.918471-06:00","updated_at":"2026-01-05T07:14:26.73946-06:00","closed_at":"2026-01-05T07:14:26.73946-06:00","close_reason":"Record.get implemented with tests passing"}
{"id":"neo4j-b7g1","title":"RED: Browser compatibility fails without implementation","description":"## Test-Driven Development: RED Phase\n\n### Component\nHTTP Client SDK - Browser Compatibility\n\n### Test Cases to Write (Expected to FAIL)\n\nTests for:\n- Works in browser environments without Node.js APIs\n- No Node.js dependencies (no fs, path, crypto, etc.)\n- Uses Fetch API correctly\n- CORS handling guidance in errors\n- Bundle size optimization\n\n### Test Examples\n- Should not import Node.js modules\n- Should use globalThis.fetch\n- Should work with browser crypto.randomUUID\n- Should provide helpful CORS error messages\n- Should tree-shake unused code\n\n### Acceptance Criteria\n- Test file created at tests/client/browser.test.ts\n- All tests fail with expected errors\n- Tests verify no Node.js dependencies\n\n### TDD Cycle\nThis is the RED phase. Next: GREEN phase implementation.","status":"open","priority":2,"issue_type":"task","created_at":"2026-01-05T06:48:40.01284-06:00","updated_at":"2026-01-05T06:48:40.01284-06:00"}
{"id":"neo4j-ba7l","title":"RED: DELETE Translation","description":"## Overview\nWrite failing tests for DELETE clause translation.\n\n## Test Cases to Write\n\n### Test 1: DELETE Node\n- DELETE n -\u003e DELETE FROM nodes with relationship check\n\n### Test 2: DELETE Relationship\n- DELETE r -\u003e DELETE FROM relationships\n\n### Test 3: DETACH DELETE Node\n- DETACH DELETE n -\u003e Delete relationships first, then node\n\n### Test 4: DELETE with WHERE\n- Conditional deletion based on properties\n\n### Test 5: DELETE Multiple Entities\n- DELETE a, b, r -\u003e Multiple DELETE statements\n\n### Test 6: DELETE Fails with Connected Node\n- DELETE node with relationships should fail without DETACH\n\n### Test 7: DELETE from Pattern Match\n- MATCH (a)-[r]-\u003e(b) DELETE r -\u003e Delete matched relationships\n\n### Test 8: DELETE All Nodes of Label\n- MATCH (n:Temp) DELETE n -\u003e Batch delete\n\n## Acceptance Criteria\n- All tests written and failing\n- DETACH DELETE handles relationships\n- Integrity constraints tested\n\n## TDD Phase\nRED - Write failing tests first","status":"closed","priority":1,"issue_type":"task","created_at":"2026-01-05T06:40:00.643359-06:00","updated_at":"2026-01-05T08:55:39.25388-06:00","closed_at":"2026-01-05T08:55:39.25388-06:00","close_reason":"Translation already implemented with tests"}
{"id":"neo4j-bec","title":"Configure package exports (main, client, types, lite)","description":"# Configure Package Exports\n\n## Overview\nSet up proper package.json exports field for the neo4j.do package with multiple entry points.\n\n## Export Configuration\n```json\n{\n  \"name\": \"neo4j.do\",\n  \"exports\": {\n    \".\": {\n      \"types\": \"./dist/index.d.ts\",\n      \"import\": \"./dist/index.js\",\n      \"require\": \"./dist/index.cjs\"\n    },\n    \"./client\": {\n      \"types\": \"./dist/client.d.ts\",\n      \"import\": \"./dist/client.js\",\n      \"require\": \"./dist/client.cjs\"\n    },\n    \"./types\": {\n      \"types\": \"./dist/types.d.ts\",\n      \"import\": \"./dist/types.js\",\n      \"require\": \"./dist/types.cjs\"\n    },\n    \"./lite\": {\n      \"types\": \"./dist/lite.d.ts\",\n      \"import\": \"./dist/lite.js\",\n      \"require\": \"./dist/lite.cjs\"\n    }\n  },\n  \"main\": \"./dist/index.cjs\",\n  \"module\": \"./dist/index.js\",\n  \"types\": \"./dist/index.d.ts\",\n  \"files\": [\"dist\"],\n  \"sideEffects\": false\n}\n```\n\n## Entry Point Descriptions\n\n### Main (`neo4j.do`)\n- Full-featured driver with RxJS support\n- Complete API surface matching neo4j-driver\n- All transaction types\n\n### Client (`neo4j.do/client`)\n- Standalone client for direct usage\n- Connection management\n- Session handling\n\n### Types (`neo4j.do/types`)\n- All TypeScript type definitions\n- Cypher types (Integer, Point, Duration, etc.)\n- Result types\n- Configuration types\n\n### Lite (`neo4j.do/lite`)\n- No RxJS dependency\n- Smaller bundle size\n- Promise-only API\n- Suitable for edge environments\n\n## Acceptance Criteria\n- [ ] All exports resolve correctly\n- [ ] TypeScript types work for all entry points\n- [ ] ESM imports work: `import { driver } from 'neo4j.do'`\n- [ ] CJS requires work: `const { driver } = require('neo4j.do')`\n- [ ] Subpath imports work: `import { Session } from 'neo4j.do/client'`\n- [ ] Lite version excludes RxJS","status":"closed","priority":1,"issue_type":"task","created_at":"2026-01-05T06:36:33.828489-06:00","updated_at":"2026-01-05T08:58:57.51504-06:00","closed_at":"2026-01-05T08:58:57.51504-06:00","close_reason":"Configuration already in place"}
{"id":"neo4j-bieb","title":"GREEN: Result.keys - Implement column names Promise","description":"## Overview\nImplement the Result.keys property to make all RED phase tests pass.\n\n## Implementation\n\n```typescript\nprivate _keys: string[] | null = null;\nprivate _keysPromise: Promise\u003cstring[]\u003e;\n\nget keys(): Promise\u003cstring[]\u003e {\n  return this._keysPromise;\n}\n```\n\n## Acceptance Criteria\n- [ ] All RED phase tests now pass (GREEN phase)\n- [ ] Returns Promise of column names\n- [ ] Available before records consumed\n- [ ] Implementation is minimal\n\n## TDD Phase\nGREEN - Minimal implementation to pass tests\n\n## Dependencies\n- neo4j-uamj (RED phase tests)","status":"closed","priority":1,"issue_type":"task","created_at":"2026-01-05T06:43:20.193889-06:00","updated_at":"2026-01-05T08:52:47.254592-06:00","closed_at":"2026-01-05T08:52:47.254592-06:00","close_reason":"Already implemented with tests passing"}
{"id":"neo4j-bk7","title":"RED: UPDATE Translation (SET/REMOVE)","description":"## Overview\nWrite failing tests for SET and REMOVE clause translation to UPDATE statements.\n\n## Test Cases to Write\n\n### Test 1: SET Single Property\n- SET n.name = 'Bob' -\u003e UPDATE with json_set\n\n### Test 2: SET Multiple Properties\n- SET n.name = 'Bob', n.age = 30 -\u003e Multiple json_set calls\n\n### Test 3: SET Node = Map (Replace All)\n- SET n = {name: 'Bob'} -\u003e Full property replacement\n\n### Test 4: SET Node += Map (Merge)\n- SET n += {age: 30} -\u003e Property merge with json_patch\n\n### Test 5: REMOVE Property\n- REMOVE n.age -\u003e UPDATE with json_remove\n\n### Test 6: REMOVE Label\n- REMOVE n:Employee -\u003e Update labels array\n\n### Test 7: SET with Expression\n- SET n.age = n.age + 1 -\u003e Computed property update\n\n### Test 8: SET Relationship Property\n- SET r.since = 2020 -\u003e UPDATE relationships table\n\n### Test 9: SET from Another Property\n- SET n.nickname = n.name -\u003e Copy property value\n\n## Acceptance Criteria\n- All tests written and failing\n- json_set/json_remove used correctly\n- Label manipulation handled\n\n## TDD Phase\nRED - Write failing tests first","status":"closed","priority":1,"issue_type":"task","created_at":"2026-01-05T06:39:13.033336-06:00","updated_at":"2026-01-05T08:55:39.255409-06:00","closed_at":"2026-01-05T08:55:39.255409-06:00","close_reason":"Translation already implemented with tests"}
{"id":"neo4j-bro4","title":"[RED] Performance Benchmark: Query Execution Time","description":"# [RED] Performance Benchmark: Query Execution Time\n\n## Overview\nCreate benchmark tests to measure and track query execution time performance.\n\n## Benchmark Categories\n\n### Simple Query Benchmarks\n```typescript\ndescribe('Simple Query Benchmarks', () =\u003e {\n  beforeAll(async () =\u003e {\n    // Setup: Create test data\n    await session.run(`\n      UNWIND range(1, 10000) AS i\n      CREATE (n:BenchNode {id: i, value: i * 10, name: 'Node ' + i})\n    `)\n    \n    // Create indexes\n    await session.run('CREATE INDEX bench_node_id IF NOT EXISTS FOR (n:BenchNode) ON (n.id)')\n  })\n\n  bench('return constant', async () =\u003e {\n    await session.run('RETURN 1')\n  })\n\n  bench('match single node by ID (indexed)', async () =\u003e {\n    await session.run('MATCH (n:BenchNode {id: 5000}) RETURN n')\n  })\n\n  bench('match all nodes (10k)', async () =\u003e {\n    await session.run('MATCH (n:BenchNode) RETURN n')\n  })\n\n  bench('match with filter', async () =\u003e {\n    await session.run('MATCH (n:BenchNode) WHERE n.value \u003e 50000 RETURN n')\n  })\n\n  bench('count nodes', async () =\u003e {\n    await session.run('MATCH (n:BenchNode) RETURN count(n)')\n  })\n\n  bench('aggregate sum', async () =\u003e {\n    await session.run('MATCH (n:BenchNode) RETURN sum(n.value)')\n  })\n})\n```\n\n### Relationship Traversal Benchmarks\n```typescript\ndescribe('Relationship Traversal Benchmarks', () =\u003e {\n  beforeAll(async () =\u003e {\n    // Create connected graph\n    await session.run(`\n      UNWIND range(1, 1000) AS i\n      CREATE (n:GraphNode {id: i})\n    `)\n    \n    await session.run(`\n      MATCH (a:GraphNode), (b:GraphNode)\n      WHERE a.id \u003c b.id AND rand() \u003c 0.01\n      CREATE (a)-[:CONNECTED]-\u003e(b)\n    `)\n  })\n\n  bench('single hop traversal', async () =\u003e {\n    await session.run('MATCH (a:GraphNode {id: 1})-[:CONNECTED]-\u003e(b) RETURN b')\n  })\n\n  bench('two hop traversal', async () =\u003e {\n    await session.run('MATCH (a:GraphNode {id: 1})-[:CONNECTED*2]-\u003e(c) RETURN c')\n  })\n\n  bench('variable length 1-3', async () =\u003e {\n    await session.run('MATCH (a:GraphNode {id: 1})-[:CONNECTED*1..3]-\u003e(x) RETURN x')\n  })\n\n  bench('shortest path', async () =\u003e {\n    await session.run(`\n      MATCH p = shortestPath((a:GraphNode {id: 1})-[*]-(b:GraphNode {id: 500}))\n      RETURN p\n    `)\n  })\n\n  bench('all paths limited', async () =\u003e {\n    await session.run(`\n      MATCH p = (a:GraphNode {id: 1})-[*..3]-(b:GraphNode)\n      RETURN p LIMIT 100\n    `)\n  })\n})\n```\n\n### Write Operation Benchmarks\n```typescript\ndescribe('Write Operation Benchmarks', () =\u003e {\n  afterEach(async () =\u003e {\n    await session.run('MATCH (n:WriteTest) DETACH DELETE n')\n  })\n\n  bench('create single node', async () =\u003e {\n    await session.run('CREATE (n:WriteTest {value: 1})')\n  })\n\n  bench('create with parameters', async () =\u003e {\n    await session.run('CREATE (n:WriteTest {value: $v})', { v: Math.random() })\n  })\n\n  bench('batch create 100 nodes', async () =\u003e {\n    await session.run(`\n      UNWIND range(1, 100) AS i\n      CREATE (n:WriteTest {id: i})\n    `)\n  })\n\n  bench('create node and relationship', async () =\u003e {\n    await session.run(`\n      CREATE (a:WriteTest)-[:REL]-\u003e(b:WriteTest)\n    `)\n  })\n\n  bench('merge operation', async () =\u003e {\n    await session.run(`\n      MERGE (n:WriteTest {key: 'singleton'})\n      ON CREATE SET n.created = timestamp()\n      ON MATCH SET n.updated = timestamp()\n    `)\n  })\n})\n```\n\n### Transaction Benchmarks\n```typescript\ndescribe('Transaction Benchmarks', () =\u003e {\n  bench('auto-commit transaction', async () =\u003e {\n    await session.run('RETURN 1')\n  })\n\n  bench('explicit transaction single query', async () =\u003e {\n    const tx = session.beginTransaction()\n    await tx.run('RETURN 1')\n    await tx.commit()\n  })\n\n  bench('transaction function read', async () =\u003e {\n    await session.executeRead(async tx =\u003e {\n      return tx.run('RETURN 1')\n    })\n  })\n\n  bench('transaction function write', async () =\u003e {\n    await session.executeWrite(async tx =\u003e {\n      return tx.run('CREATE (n:TxBench) DELETE n')\n    })\n  })\n\n  bench('multi-query transaction', async () =\u003e {\n    const tx = session.beginTransaction()\n    for (let i = 0; i \u003c 10; i++) {\n      await tx.run('RETURN $i', { i })\n    }\n    await tx.commit()\n  })\n})\n```\n\n## Benchmark Configuration\n```typescript\n// vitest.config.ts additions for benchmarks\nexport default defineConfig({\n  test: {\n    benchmark: {\n      include: ['benchmarks/**/*.bench.ts'],\n      reporters: ['default', 'json'],\n      outputFile: 'benchmark-results.json'\n    }\n  }\n})\n```\n\n## Result Tracking\n- Store benchmark results in JSON format\n- Track results over time in CI\n- Alert on significant regressions (\u003e20% slower)\n\n## Expected Baseline Targets\n| Operation | Target P50 | Target P99 |\n|-----------|-----------|-----------|\n| Return constant | \u003c1ms | \u003c5ms |\n| Indexed lookup | \u003c5ms | \u003c20ms |\n| 10k node scan | \u003c100ms | \u003c500ms |\n| Single hop | \u003c5ms | \u003c20ms |\n| Create node | \u003c5ms | \u003c20ms |\n| Transaction overhead | \u003c10ms | \u003c50ms |\n\n## Acceptance Criteria\n- [ ] Benchmark test suite created\n- [ ] All query type benchmarks included\n- [ ] Baseline measurements documented\n- [ ] CI integration for tracking\n- [ ] Regression detection configured","status":"open","priority":3,"issue_type":"task","created_at":"2026-01-05T06:48:53.749011-06:00","updated_at":"2026-01-05T06:48:53.749011-06:00"}
{"id":"neo4j-cgs","title":"wrangler.jsonc for Cloudflare Workers","description":"# Wrangler Configuration\n\n## Overview\nConfigure wrangler.jsonc for deploying neo4j.do to Cloudflare Workers.\n\n## Configuration File\n```jsonc\n{\n  \"name\": \"neo4j-do\",\n  \"main\": \"dist/index.js\",\n  \"compatibility_date\": \"2024-01-01\",\n  \"compatibility_flags\": [\"nodejs_compat\"],\n  \n  // Durable Objects for graph storage\n  \"durable_objects\": {\n    \"bindings\": [\n      {\n        \"name\": \"GRAPH_STORE\",\n        \"class_name\": \"GraphStore\"\n      },\n      {\n        \"name\": \"TRANSACTION_COORDINATOR\",\n        \"class_name\": \"TransactionCoordinator\"\n      }\n    ]\n  },\n  \n  // D1 database for metadata and indexes\n  \"d1_databases\": [\n    {\n      \"binding\": \"DB\",\n      \"database_name\": \"neo4j-do\",\n      \"database_id\": \"\u003cto-be-created\u003e\"\n    }\n  ],\n  \n  // KV for caching\n  \"kv_namespaces\": [\n    {\n      \"binding\": \"CACHE\",\n      \"id\": \"\u003cto-be-created\u003e\"\n    }\n  ],\n  \n  // Vectorize for vector search (optional)\n  \"vectorize\": [\n    {\n      \"binding\": \"VECTORS\",\n      \"index_name\": \"neo4j-do-vectors\"\n    }\n  ],\n  \n  // Environment variables\n  \"vars\": {\n    \"ENVIRONMENT\": \"production\"\n  },\n  \n  // Development settings\n  \"dev\": {\n    \"port\": 8787,\n    \"local_protocol\": \"http\"\n  }\n}\n```\n\n## Bindings Required\n1. **Durable Objects**: Graph storage and transaction coordination\n2. **D1 Database**: Metadata, indexes, and Cypher query cache\n3. **KV Namespace**: Query result caching\n4. **Vectorize**: Optional vector similarity search\n\n## Environment Configurations\n- `wrangler.jsonc` - Base configuration\n- Environment-specific via `--env` flag\n\n## Acceptance Criteria\n- [ ] wrangler.jsonc created\n- [ ] Durable Object classes defined\n- [ ] D1 database binding configured\n- [ ] KV namespace configured\n- [ ] Local development works with `wrangler dev`\n- [ ] Deployment works with `wrangler deploy`","status":"closed","priority":1,"issue_type":"task","created_at":"2026-01-05T06:36:10.658873-06:00","updated_at":"2026-01-05T08:58:57.514122-06:00","closed_at":"2026-01-05T08:58:57.514122-06:00","close_reason":"Configuration already in place"}
{"id":"neo4j-co8m","title":"REFACTOR: Create marble testing utilities","description":"## Overview\nRefactor and create utilities for marble testing.\n\n## Refactoring Tasks\n\n### Code Quality\n- Create test helpers\n- Document marble syntax\n- Add example patterns\n- Type-safe assertions\n\n### Utilities\n- Neo4j-specific marble helpers\n- Common test patterns\n- Assertion utilities\n- Error verification helpers\n\n### Documentation\n- Marble testing guide\n- Syntax reference\n- Pattern library\n- Troubleshooting guide\n\n## Acceptance Criteria\n- All tests still pass\n- Useful marble utilities\n- Clear documentation\n- Pattern library","status":"open","priority":2,"issue_type":"task","created_at":"2026-01-05T06:49:58.919313-06:00","updated_at":"2026-01-05T06:49:58.919313-06:00"}
{"id":"neo4j-cou1","title":"REFACTOR: Managed Transaction Auto-Retry Optimization","description":"## Overview\nRefactor managed transaction auto-retry for advanced scenarios and edge cases.\n\n## Refactoring Goals\n\n### Advanced Retry Strategies\n- Circuit breaker pattern integration\n- Adaptive retry timing based on error type\n- Retry budget across sessions\n- Bulkhead isolation for retries\n\n### Edge Cases\n```typescript\ndescribe('Retry Edge Cases', () =\u003e {\n  it('should handle work function throwing non-Error')\n  it('should handle work function returning rejected promise')\n  it('should handle clock skew during retry')\n  it('should handle system sleep during retry')\n  it('should handle rapid sequential failures')\n  it('should handle error during rollback')\n  it('should handle session close during retry')\n  it('should handle driver close during retry')\n  it('should handle memory pressure during retry')\n})\n```\n\n### Observability\n- Retry attempt logging\n- Retry metrics collection\n- Error rate tracking\n- Backoff timing telemetry\n\n### Performance\n- Reuse transaction objects when possible\n- Optimize error classification\n- Reduce allocation during retry loop\n\n### Code Quality\n- Extract retry policy interface\n- Create pluggable retry strategies\n- Add retry event hooks\n\n## TDD Phase\n**REFACTOR** - Improve without breaking tests.\n\n## Dependencies\n- Depends on: GREEN: Managed Transaction Auto-Retry Implementation\n\n## Acceptance Criteria\n- [ ] All tests pass\n- [ ] Advanced strategies available\n- [ ] Edge cases handled\n- [ ] Observability added","status":"open","priority":2,"issue_type":"task","created_at":"2026-01-05T06:39:43.85176-06:00","updated_at":"2026-01-05T06:39:43.85176-06:00"}
{"id":"neo4j-cs7e","title":"REFACTOR: Aggregation Translation","description":"## Overview\nRefactor aggregation translation for extensibility and correctness.\n\n## Refactoring Tasks\n\n### 1. Aggregate Function Registry\n- Register standard aggregates\n- Allow custom aggregate functions\n- Signature validation\n\n### 2. GroupBy Analyzer\n- Clean detection of grouping requirements\n- Handle complex grouping expressions\n- Optimize grouping key selection\n\n### 3. Collect Optimization\n- Efficient JSON array building\n- Handle large result sets\n- DISTINCT deduplication\n\n### 4. Aggregation Context\n- Track aggregation scope\n- Prevent invalid nesting\n- Clear error messages\n\n## Quality Improvements\n- Extensible aggregate registry\n- Clean grouping logic\n- Performance for large aggregations\n- Type-safe aggregate expressions\n\n## Acceptance Criteria\n- All tests still pass\n- Easy to add new aggregates\n- Performance optimized\n\n## TDD Phase\nREFACTOR - Improve code quality while keeping tests green\n\n## Dependencies\n- Depends on: GREEN: Aggregation Translation","status":"closed","priority":1,"issue_type":"task","created_at":"2026-01-05T06:42:54.60737-06:00","updated_at":"2026-01-05T08:53:30.816961-06:00","closed_at":"2026-01-05T08:53:30.816961-06:00","close_reason":"Aggregation/expression translation already implemented"}
{"id":"neo4j-csli","title":"[RED] Parser: CREATE and MERGE Clause Tests","description":"## Overview\nWrite failing tests for CREATE and MERGE clause parsing.\n\n## Test Cases to Write\n\n### Basic CREATE\n- Node: `CREATE (n)`\n- With label: `CREATE (n:Person)`\n- With properties: `CREATE (n:Person {name: 'John'})`\n\n### CREATE Relationships\n- Simple: `CREATE (a)-[:KNOWS]-\u003e(b)`\n- With properties: `CREATE (a)-[:KNOWS {since: 2020}]-\u003e(b)`\n- Full pattern: `CREATE (a:Person)-[:KNOWS]-\u003e(b:Person)`\n\n### CREATE Multiple\n- Patterns: `CREATE (a), (b)`\n- Chain: `CREATE (a)-[:X]-\u003e(b)-[:Y]-\u003e(c)`\n\n### MERGE\n- Node: `MERGE (n:Person {name: 'John'})`\n- Relationship: `MERGE (a)-[:KNOWS]-\u003e(b)`\n\n### MERGE with ON CREATE/ON MATCH\n- ON CREATE: `MERGE (n:Person) ON CREATE SET n.created = timestamp()`\n- ON MATCH: `MERGE (n:Person) ON MATCH SET n.accessed = timestamp()`\n- Both: `MERGE (n:Person) ON CREATE SET n.created = 1 ON MATCH SET n.accessed = 2`\n\n### CREATE after MATCH\n- `MATCH (a) CREATE (a)-[:KNOWS]-\u003e(b:Person)`\n- `MATCH (a), (b) CREATE (a)-[:KNOWS]-\u003e(b)`\n\n## Acceptance Criteria\n- [ ] All CREATE tests written and failing\n- [ ] All MERGE tests written and failing\n- [ ] ON CREATE/ON MATCH tested\n- [ ] Error cases covered\n\n## TDD Phase: RED","status":"closed","priority":1,"issue_type":"task","created_at":"2026-01-05T06:43:16.36984-06:00","updated_at":"2026-01-05T08:46:40.401935-06:00","closed_at":"2026-01-05T08:46:40.401935-06:00","close_reason":"Tests passing - implementation complete"}
{"id":"neo4j-cuf3","title":"RED: Bookmark Manager \u0026 Causal Consistency Tests","description":"## Overview\nWrite comprehensive failing tests for BookmarkManager and causal consistency across sessions.\n\n## Test Cases\n\n### BookmarkManager Tests\n```typescript\ndescribe('BookmarkManager', () =\u003e {\n  it('should create BookmarkManager instance')\n  it('should store bookmarks from session')\n  it('should retrieve bookmarks for session')\n  it('should support multiple databases')\n  it('should notify on bookmark update')\n  it('should allow custom bookmark supplier')\n  it('should allow custom bookmark consumer')\n})\n```\n\n### Bookmark Generation Tests\n```typescript\ndescribe('Bookmark Generation', () =\u003e {\n  it('should generate bookmark after executeWrite')\n  it('should generate bookmark after tx.commit()')\n  it('should not generate bookmark after executeRead')\n  it('should not generate bookmark after tx.rollback()')\n  it('should include database in bookmark')\n  it('should include transaction ID in bookmark')\n  it('should be monotonically increasing')\n})\n```\n\n### Bookmark Consumption Tests\n```typescript\ndescribe('Bookmark Consumption', () =\u003e {\n  it('should wait for bookmark in new session')\n  it('should accept single bookmark')\n  it('should accept multiple bookmarks')\n  it('should accept bookmark array')\n  it('should handle unknown bookmark')\n  it('should timeout waiting for bookmark')\n})\n```\n\n### Cross-Session Consistency Tests\n```typescript\ndescribe('Causal Consistency', () =\u003e {\n  it('should read your own writes across sessions')\n  it('should chain writes with bookmarks')\n  it('should handle concurrent sessions with bookmarks')\n  it('should work across different databases')\n})\n\ndescribe('Cross-Session Flow', () =\u003e {\n  it('should propagate bookmark from write to read')\n  it('should propagate multiple bookmarks')\n  it('should merge bookmarks from parallel writes')\n})\n```\n\n### BookmarkManager Integration Tests\n```typescript\ndescribe('BookmarkManager Integration', () =\u003e {\n  it('should integrate with driver.executeQuery')\n  it('should integrate with session.executeRead')\n  it('should integrate with session.executeWrite')\n  it('should share bookmarks across sessions')\n})\n```\n\n## TDD Phase\n**RED** - All tests should fail initially.\n\n## Acceptance Criteria\n- [ ] All bookmark lifecycle tests written\n- [ ] Cross-session scenarios covered\n- [ ] Multi-database scenarios tested\n- [ ] Integration tests defined","status":"closed","priority":1,"issue_type":"task","created_at":"2026-01-05T06:40:01.252864-06:00","updated_at":"2026-01-05T08:56:54.393668-06:00","closed_at":"2026-01-05T08:56:54.393668-06:00","close_reason":"Features implemented with tests"}
{"id":"neo4j-d0c","title":"GREEN: Implement rxTx.commit() method","description":"## Overview\nImplement rxTx.commit() to make all RED tests pass.\n\n## Implementation Requirements\n\n### Method Signature\n```typescript\ninterface RxTransaction {\n  commit(): Observable\u003cvoid\u003e\n}\n```\n\n### Implementation Details\n- Create Observable for commit process\n- Send COMMIT to database\n- Update session bookmarks\n- Mark transaction as closed\n- Handle commit errors\n\n### Observable Semantics\n- Cold observable (lazy commit)\n- Complete on success\n- Error on failure\n- Prevent multiple commits\n\n## Acceptance Criteria\n- All RED tests now pass (GREEN phase)\n- Changes persisted correctly\n- Bookmarks updated\n- Transaction state managed","status":"open","priority":2,"issue_type":"task","created_at":"2026-01-05T06:39:15.374871-06:00","updated_at":"2026-01-05T06:39:15.374871-06:00"}
{"id":"neo4j-d1sd","title":"GREEN: Aggregation Translation","description":"## Overview\nImplement aggregation function translation to make RED tests pass.\n\n## Implementation Tasks\n\n### 1. AggregationTranslator Class\n- translateCount(): COUNT() with DISTINCT support\n- translateSum(): SUM()\n- translateAvg(): AVG()\n- translateMin(): MIN()\n- translateMax(): MAX()\n- translateCollect(): JSON_GROUP_ARRAY()\n\n### 2. GroupBy Inference Engine\n- Analyze RETURN clause for aggregates\n- Non-aggregated expressions become grouping keys\n- Handle complex expressions in GROUP BY\n\n### 3. DISTINCT in Aggregates\n- COUNT(DISTINCT x)\n- collect(DISTINCT x)\n\n### 4. Validation\n- Detect nested aggregations (error)\n- Detect aggregation in WHERE (error)\n- Ensure grouping consistency\n\n## Files to Create/Modify\n- src/cypher/translator/aggregation-translator.ts\n- src/cypher/translator/groupby-inferrer.ts\n- src/cypher/translator/aggregation-validator.ts\n\n## Acceptance Criteria\n- All RED phase tests pass\n- GROUP BY correctly generated\n- Errors thrown for invalid usage\n\n## TDD Phase\nGREEN - Make tests pass with minimal code\n\n## Dependencies\n- Depends on: RED: Aggregation Translation","status":"closed","priority":1,"issue_type":"task","created_at":"2026-01-05T06:42:40.729402-06:00","updated_at":"2026-01-05T08:53:30.817771-06:00","closed_at":"2026-01-05T08:53:30.817771-06:00","close_reason":"Aggregation/expression translation already implemented"}
{"id":"neo4j-d6n","title":"REFACTOR: HttpSession class optimization","description":"## Test-Driven Development: REFACTOR Phase\n\n### Component\nHTTP Client SDK - HttpSession Class\n\n### Refactoring Goals\n\n1. **Bookmark management**\n   - Extract BookmarkManager class\n   - Support bookmark chaining across sessions\n\n2. **Transaction retry logic**\n   - Add configurable retry for transient errors\n   - Implement retry in executeRead/executeWrite\n\n3. **Result streaming preparation**\n   - Abstract result handling for future streaming\n   - Create ResultCursor interface\n\n4. **Database routing**\n   - Support multi-database configurations\n   - Handle database parameter consistently\n\n### Code Improvements\n\n```typescript\n// Extract bookmark management\nexport class BookmarkManager {\n  private bookmarks: Set\u003cstring\u003e = new Set()\n\n  add(bookmarks: string[]): void {\n    bookmarks.forEach(b =\u003e this.bookmarks.add(b))\n  }\n\n  get(): string[] {\n    return [...this.bookmarks]\n  }\n\n  clear(): void {\n    this.bookmarks.clear()\n  }\n}\n\n// Improved session with retry\nexport class HttpSession {\n  private bookmarkManager: BookmarkManager\n\n  async executeRead\u003cT\u003e(\n    work: (tx: HttpTransaction) =\u003e Promise\u003cT\u003e,\n    config?: TransactionConfig\n  ): Promise\u003cT\u003e {\n    return this.executeWithRetry(work, 'READ', config?.maxRetries ?? 3)\n  }\n\n  private async executeWithRetry\u003cT\u003e(\n    work: (tx: HttpTransaction) =\u003e Promise\u003cT\u003e,\n    accessMode: 'READ' | 'WRITE',\n    maxRetries: number\n  ): Promise\u003cT\u003e {\n    let lastError: Error | undefined\n    for (let attempt = 0; attempt \u003c= maxRetries; attempt++) {\n      try {\n        return await this.executeInTransaction(work, accessMode)\n      } catch (error) {\n        if (!this.isRetryable(error) || attempt === maxRetries) throw error\n        lastError = error as Error\n        await this.delay(Math.pow(2, attempt) * 100)\n      }\n    }\n    throw lastError\n  }\n}\n```\n\n### Acceptance Criteria\n- [ ] All existing tests still pass\n- [ ] BookmarkManager extracted\n- [ ] Retry logic implemented\n- [ ] Code is more modular and testable\n\n### Dependencies\n- GREEN: Implement HttpSession class\n\n### TDD Cycle\nThis completes the RED-\u003eGREEN-\u003eREFACTOR cycle for HttpSession.","status":"open","priority":2,"issue_type":"task","created_at":"2026-01-05T06:36:18.297315-06:00","updated_at":"2026-01-05T06:36:18.297315-06:00"}
{"id":"neo4j-d83","title":"RED: Transaction Class Core Operations Tests","description":"## Overview\nWrite comprehensive failing tests for Transaction class core operations: run(), commit(), rollback(), and isOpen().\n\n## Test Cases\n\n### Transaction.run() Tests\n```typescript\ndescribe('tx.run()', () =\u003e {\n  it('should execute Cypher query within transaction')\n  it('should execute query with parameters')\n  it('should return Result object')\n  it('should allow multiple queries in same transaction')\n  it('should see changes from previous queries in transaction')\n  it('should isolate changes from other transactions')\n  it('should throw on syntax errors')\n  it('should throw if transaction is closed')\n  it('should throw if transaction is rolled back')\n})\n```\n\n### Transaction.commit() Tests\n```typescript\ndescribe('tx.commit()', () =\u003e {\n  it('should commit all changes')\n  it('should make changes visible to other sessions')\n  it('should close the transaction')\n  it('should be idempotent')\n  it('should throw if already rolled back')\n  it('should throw on constraint violation')\n  it('should generate bookmark for session')\n  it('should release locks')\n})\n```\n\n### Transaction.rollback() Tests\n```typescript\ndescribe('tx.rollback()', () =\u003e {\n  it('should discard all changes')\n  it('should close the transaction')\n  it('should be idempotent')\n  it('should work after commit failure')\n  it('should not throw if already committed')\n  it('should release locks')\n  it('should not generate bookmark')\n})\n```\n\n### Transaction.isOpen() Tests\n```typescript\ndescribe('tx.isOpen()', () =\u003e {\n  it('should return true for new transaction')\n  it('should return false after commit')\n  it('should return false after rollback')\n  it('should return false after error')\n})\n```\n\n### Transaction Isolation Tests\n```typescript\ndescribe('Transaction Isolation', () =\u003e {\n  it('should isolate uncommitted reads')\n  it('should isolate uncommitted writes')\n  it('should handle concurrent transactions')\n  it('should detect write conflicts')\n})\n```\n\n## TDD Phase\n**RED** - All tests should fail initially.\n\n## Acceptance Criteria\n- [ ] All test cases written\n- [ ] ACID properties tested\n- [ ] Concurrent transaction tests included\n- [ ] Error scenarios covered","status":"closed","priority":1,"issue_type":"task","created_at":"2026-01-05T06:38:08.804144-06:00","updated_at":"2026-01-05T08:57:46.159635-06:00","closed_at":"2026-01-05T08:57:46.159635-06:00","close_reason":"Translation and session tests passing"}
{"id":"neo4j-d9a","title":"GREEN: Implement rxSession.close() method","description":"## Overview\nImplement rxSession.close() to make all RED tests pass.\n\n## Implementation Requirements\n\n### Method Signature\n```typescript\ninterface RxSession {\n  close(): Observable\u003cvoid\u003e\n}\n```\n\n### Implementation Details\n- Create Observable for cleanup process\n- Rollback any active transaction\n- Release connection resources\n- Return connection to pool\n- Mark session as closed\n\n### Observable Semantics\n- Cold observable (cleanup on subscribe)\n- Complete on successful cleanup\n- Error on cleanup failure\n- Safe for multiple subscriptions\n\n## Acceptance Criteria\n- All RED tests now pass (GREEN phase)\n- Resources properly released\n- Active transactions handled\n- Observable semantics correct","status":"open","priority":2,"issue_type":"task","created_at":"2026-01-05T06:38:03.357946-06:00","updated_at":"2026-01-05T06:38:03.357946-06:00"}
{"id":"neo4j-da6","title":"RED: REST API endpoint handlers fail without implementation","description":"## Test-Driven Development: RED Phase\n\n### Component\nHTTP Client SDK - REST API Endpoints (Server-Side)\n\n### Test Cases to Write (Expected to FAIL)\n\n```typescript\nimport { describe, it, expect, beforeEach } from 'vitest'\nimport { createTestApp } from '../test-utils'\n\ndescribe('REST API Endpoints - RED', () =\u003e {\n  let app: ReturnType\u003ctypeof createTestApp\u003e\n\n  beforeEach(() =\u003e {\n    app = createTestApp()\n  })\n\n  describe('POST /query', () =\u003e {\n    it('should execute a single Cypher query', async () =\u003e {\n      const response = await app.request('/query', {\n        method: 'POST',\n        headers: { 'Content-Type': 'application/json' },\n        body: JSON.stringify({\n          query: 'RETURN 1 as n',\n          parameters: {}\n        })\n      })\n      \n      expect(response.status).toBe(200)\n      const data = await response.json()\n      expect(data.records).toHaveLength(1)\n      expect(data.records[0].n).toBe(1)\n    })\n\n    it('should handle query parameters', async () =\u003e {\n      const response = await app.request('/query', {\n        method: 'POST',\n        body: JSON.stringify({\n          query: 'RETURN $value as result',\n          parameters: { value: 'hello' }\n        })\n      })\n      \n      const data = await response.json()\n      expect(data.records[0].result).toBe('hello')\n    })\n  })\n\n  describe('POST /tx/begin', () =\u003e {\n    it('should start a new transaction', async () =\u003e {\n      const response = await app.request('/tx/begin', {\n        method: 'POST',\n        body: JSON.stringify({ database: 'neo4j' })\n      })\n      \n      expect(response.status).toBe(201)\n      const data = await response.json()\n      expect(data.id).toBeDefined()\n      expect(data.id).toMatch(/^tx-/)\n    })\n\n    it('should include access mode in response', async () =\u003e {\n      const response = await app.request('/tx/begin', {\n        method: 'POST',\n        body: JSON.stringify({ accessMode: 'READ' })\n      })\n      \n      const data = await response.json()\n      expect(data.accessMode).toBe('READ')\n    })\n  })\n\n  describe('POST /tx/{id}/run', () =\u003e {\n    it('should run query within transaction', async () =\u003e {\n      // First begin transaction\n      const beginRes = await app.request('/tx/begin', { method: 'POST' })\n      const { id } = await beginRes.json()\n      \n      // Then run query\n      const response = await app.request(`/tx/${id}/run`, {\n        method: 'POST',\n        body: JSON.stringify({ query: 'CREATE (n:Test) RETURN n' })\n      })\n      \n      expect(response.status).toBe(200)\n      const data = await response.json()\n      expect(data.records).toBeDefined()\n    })\n\n    it('should reject invalid transaction ID', async () =\u003e {\n      const response = await app.request('/tx/invalid-id/run', {\n        method: 'POST',\n        body: JSON.stringify({ query: 'RETURN 1' })\n      })\n      \n      expect(response.status).toBe(404)\n    })\n  })\n\n  describe('POST /tx/{id}/commit', () =\u003e {\n    it('should commit transaction', async () =\u003e {\n      const beginRes = await app.request('/tx/begin', { method: 'POST' })\n      const { id } = await beginRes.json()\n      \n      const response = await app.request(`/tx/${id}/commit`, { method: 'POST' })\n      \n      expect(response.status).toBe(200)\n      const data = await response.json()\n      expect(data.bookmarks).toBeDefined()\n    })\n  })\n\n  describe('POST /tx/{id}/rollback', () =\u003e {\n    it('should rollback transaction', async () =\u003e {\n      const beginRes = await app.request('/tx/begin', { method: 'POST' })\n      const { id } = await beginRes.json()\n      \n      const response = await app.request(`/tx/${id}/rollback`, { method: 'POST' })\n      \n      expect(response.status).toBe(200)\n    })\n  })\n\n  describe('GET /server-info', () =\u003e {\n    it('should return server metadata', async () =\u003e {\n      const response = await app.request('/server-info')\n      \n      expect(response.status).toBe(200)\n      const data = await response.json()\n      expect(data.address).toBeDefined()\n      expect(data.protocolVersion).toBeDefined()\n      expect(data.agent).toContain('neo4j.do')\n    })\n  })\n\n  describe('GET /databases', () =\u003e {\n    it('should list available databases', async () =\u003e {\n      const response = await app.request('/databases')\n      \n      expect(response.status).toBe(200)\n      const data = await response.json()\n      expect(Array.isArray(data.databases)).toBe(true)\n    })\n  })\n\n  describe('POST /databases', () =\u003e {\n    it('should create a new database', async () =\u003e {\n      const response = await app.request('/databases', {\n        method: 'POST',\n        body: JSON.stringify({ name: 'testdb' })\n      })\n      \n      expect(response.status).toBe(201)\n      const data = await response.json()\n      expect(data.name).toBe('testdb')\n    })\n\n    it('should reject invalid database name', async () =\u003e {\n      const response = await app.request('/databases', {\n        method: 'POST',\n        body: JSON.stringify({ name: 'invalid name!' })\n      })\n      \n      expect(response.status).toBe(400)\n    })\n  })\n})\n```\n\n### Acceptance Criteria\n- [ ] Test file created at `tests/api/rest-endpoints.test.ts`\n- [ ] All tests fail with 404 or not implemented\n- [ ] Tests cover all REST endpoints\n\n### TDD Cycle\nThis is the RED phase. Next: GREEN phase implementation.","status":"open","priority":2,"issue_type":"task","created_at":"2026-01-05T06:37:59.826168-06:00","updated_at":"2026-01-05T06:37:59.826168-06:00"}
{"id":"neo4j-dccl","title":"GREEN: Managed Transaction Auto-Retry Implementation","description":"## Overview\nImplement managed transaction auto-retry logic with exponential backoff to pass all RED phase tests.\n\n## Implementation Requirements\n\n### Retry Configuration\n```typescript\ninterface RetryConfig {\n  maxRetryTime: number      // Default: 30000ms\n  initialDelay: number      // Default: 1000ms\n  maxDelay: number          // Default: 5000ms\n  delayMultiplier: number   // Default: 2.0\n  jitterFactor: number      // Default: 0.2\n}\n\nconst DEFAULT_RETRY_CONFIG: RetryConfig = {\n  maxRetryTime: 30000,\n  initialDelay: 1000,\n  maxDelay: 5000,\n  delayMultiplier: 2.0,\n  jitterFactor: 0.2\n}\n```\n\n### Retry Logic\n```typescript\nasync function executeWithRetry\u003cT\u003e(\n  session: Session,\n  work: (tx: ManagedTransaction) =\u003e Promise\u003cT\u003e,\n  accessMode: AccessMode,\n  config: RetryConfig\n): Promise\u003cT\u003e {\n  const startTime = Date.now()\n  let delay = config.initialDelay\n  let lastError: Error | null = null\n\n  while (Date.now() - startTime \u003c config.maxRetryTime) {\n    const tx = new ManagedTransaction(session, accessMode)\n    \n    try {\n      const result = await work(tx)\n      await tx._commit()\n      return result\n    } catch (error) {\n      lastError = error\n      await tx._rollback()\n      \n      if (!isRetryableError(error)) {\n        throw error\n      }\n      \n      await sleep(addJitter(delay, config.jitterFactor))\n      delay = Math.min(delay * config.delayMultiplier, config.maxDelay)\n    }\n  }\n\n  throw new RetryExhausted('Transaction retry time exceeded', lastError)\n}\n```\n\n### Error Classification\n```typescript\nfunction isRetryableError(error: Error): boolean {\n  if (error instanceof Neo4jError) {\n    return error.code.startsWith('Neo.TransientError') ||\n           error.code === 'Neo.ClientError.Cluster.NotALeader' ||\n           error.code === 'ServiceUnavailable'\n  }\n  return error instanceof SessionExpired ||\n         error instanceof ConnectionError\n}\n```\n\n### Backoff Implementation\n```typescript\nfunction addJitter(delay: number, factor: number): number {\n  const jitter = delay * factor * (Math.random() * 2 - 1)\n  return Math.max(0, delay + jitter)\n}\n\nfunction sleep(ms: number): Promise\u003cvoid\u003e {\n  return new Promise(resolve =\u003e setTimeout(resolve, ms))\n}\n```\n\n## Files to Create/Modify\n- `src/transaction/retry.ts`\n- `src/transaction/managed-transaction.ts`\n- `src/errors/retry-exhausted.ts`\n- `src/errors/error-classifier.ts`\n\n## TDD Phase\n**GREEN** - Implement to pass tests.\n\n## Dependencies\n- Depends on: RED: Managed Transaction Auto-Retry Tests\n- Depends on: GREEN: Transaction Class Core Operations Implementation\n\n## Acceptance Criteria\n- [ ] All RED phase tests pass\n- [ ] Retry logic is correct\n- [ ] Backoff algorithm works\n- [ ] Error classification accurate","status":"closed","priority":1,"issue_type":"task","created_at":"2026-01-05T06:39:27.172573-06:00","updated_at":"2026-01-05T08:56:54.39405-06:00","closed_at":"2026-01-05T08:56:54.39405-06:00","close_reason":"Features implemented with tests"}
{"id":"neo4j-dda","title":"[RED] OpenCypher TCK Integration","description":"# [RED] OpenCypher TCK Integration\n\n## Overview\nIntegrate the OpenCypher Technology Compatibility Kit (TCK) to validate Cypher language compliance.\n\n## What is OpenCypher TCK?\nThe TCK is a set of Cucumber/Gherkin feature files that define the expected behavior of a Cypher implementation. It covers:\n- Query syntax\n- Operators\n- Functions\n- Pattern matching\n- Aggregations\n- And more\n\n## Integration Steps\n\n### 1. Fetch TCK Feature Files\n```bash\n# Clone or download OpenCypher TCK\ngit clone https://github.com/opencypher/openCypher.git\n# Feature files are in: tck/features/\n```\n\n### 2. Setup Cucumber Test Runner\n```typescript\n// tests/tck/cucumber.config.ts\nimport { setWorldConstructor, World } from '@cucumber/cucumber'\n\nclass Neo4jDoWorld extends World {\n  driver: Driver\n  session: Session\n  result: Result\n\n  async connect() {\n    this.driver = neo4jDo.driver('bolt://localhost')\n    this.session = this.driver.session()\n  }\n\n  async query(cypher: string, params?: Record\u003cstring, any\u003e) {\n    this.result = await this.session.run(cypher, params)\n  }\n\n  async cleanup() {\n    await this.session.close()\n    await this.driver.close()\n  }\n}\n\nsetWorldConstructor(Neo4jDoWorld)\n```\n\n### 3. Implement Step Definitions\n```typescript\n// tests/tck/steps/common.steps.ts\nimport { Given, When, Then } from '@cucumber/cucumber'\n\nGiven('an empty graph', async function() {\n  await this.query('MATCH (n) DETACH DELETE n')\n})\n\nGiven('having executed:', async function(cypher: string) {\n  await this.query(cypher)\n})\n\nWhen('executing query:', async function(cypher: string) {\n  await this.query(cypher)\n})\n\nThen('the result should be:', async function(expected: DataTable) {\n  // Compare this.result with expected\n})\n```\n\n### 4. TCK Categories to Test\n- **Expressions**: Literals, parameters, operators\n- **Match**: Pattern matching, optional match\n- **Return**: Projections, aliasing, ordering\n- **With**: Query chaining\n- **Create**: Node and relationship creation\n- **Merge**: Upsert operations\n- **Delete**: Deletion operations\n- **Set/Remove**: Property modifications\n- **Aggregation**: count, sum, avg, collect, etc.\n- **Functions**: String, math, list, temporal\n\n## Test Configuration\n```json\n{\n  \"scripts\": {\n    \"test:tck\": \"cucumber-js tests/tck/features --require tests/tck/steps\"\n  }\n}\n```\n\n## Tracking Compliance\nCreate a compliance matrix:\n```markdown\n| TCK Category | Total Tests | Passing | Failing | % |\n|--------------|-------------|---------|---------|---|\n| Expressions  | 150         | 0       | 150     | 0 |\n| Match        | 200         | 0       | 200     | 0 |\n| ...          | ...         | ...     | ...     |...|\n```\n\n## Acceptance Criteria\n- [ ] TCK feature files integrated\n- [ ] Cucumber test runner configured\n- [ ] Step definitions created\n- [ ] Initial test run completes (all failing)\n- [ ] Compliance tracking documented","status":"open","priority":2,"issue_type":"task","created_at":"2026-01-05T06:38:33.844046-06:00","updated_at":"2026-01-05T06:38:33.844046-06:00"}
{"id":"neo4j-ddr","title":"[RED] Integer Type - Write Failing Tests","description":"## Overview\nWrite comprehensive failing tests for the Neo4j Integer type before implementation.\n\n## TDD Phase: RED (Write Failing Tests)\n\n### Test Cases to Write\n\n#### Factory Functions\n- `neo4j.int(value)` creates Integer from number\n- `neo4j.int(value)` creates Integer from string\n- `neo4j.int(value)` creates Integer from another Integer\n- `neo4j.integer(value)` alias works identically\n\n#### Safe Range Checking\n- `neo4j.integer.inSafeRange(int)` returns true for safe integers\n- `neo4j.integer.inSafeRange(int)` returns false for unsafe integers\n- `Integer.inSafeRange()` instance method\n\n#### Conversion Methods\n- `Integer.toNumber()` returns JavaScript number\n- `Integer.toNumber()` throws for unsafe integers (or returns approximate)\n- `Integer.toString()` returns string representation\n- `Integer.toString(radix)` supports different bases\n- `Integer.toInt()` returns 32-bit integer\n- `Integer.toBigInt()` returns BigInt\n\n#### Arithmetic Operations\n- `Integer.add(other)` addition\n- `Integer.subtract(other)` subtraction\n- `Integer.multiply(other)` multiplication\n- `Integer.divide(other)` integer division\n- `Integer.modulo(other)` remainder\n- `Integer.negate()` negation\n\n#### Comparison Operations\n- `Integer.equals(other)` equality\n- `Integer.lessThan(other)` less than\n- `Integer.lessThanOrEqual(other)` less than or equal\n- `Integer.greaterThan(other)` greater than\n- `Integer.greaterThanOrEqual(other)` greater than or equal\n- `Integer.compare(other)` returns -1, 0, or 1\n\n#### Bitwise Operations\n- `Integer.and(other)` bitwise AND\n- `Integer.or(other)` bitwise OR\n- `Integer.xor(other)` bitwise XOR\n- `Integer.not()` bitwise NOT\n- `Integer.shiftLeft(bits)` left shift\n- `Integer.shiftRight(bits)` right shift\n\n#### Edge Cases\n- Maximum 64-bit integer (2^63 - 1)\n- Minimum 64-bit integer (-2^63)\n- Zero handling\n- Overflow behavior\n- Division by zero\n\n#### Type Guards\n- `neo4j.isInt(value)` returns true for Integer\n- `neo4j.isInt(value)` returns false for number\n\n### Acceptance Criteria\n- [ ] All tests written and failing (RED state)\n- [ ] Tests match neo4j-driver API exactly\n- [ ] Edge cases covered\n- [ ] Tests are isolated and independent\n- [ ] Test file created at `src/types/integer.test.ts`\n\n### References\n- [neo4j-driver Integer API](https://neo4j.com/docs/api/javascript-driver/current/class/lib6/integer.js~Integer.html)","status":"closed","priority":1,"issue_type":"task","created_at":"2026-01-05T06:34:35.620699-06:00","updated_at":"2026-01-05T06:51:46.652828-06:00","closed_at":"2026-01-05T06:51:46.652828-06:00","close_reason":"Wrote comprehensive failing tests for Integer type covering all API methods, factory functions, arithmetic, comparison, bitwise operations, and edge cases"}
{"id":"neo4j-detp","title":"GREEN: Implement Observable error emission","description":"## Overview\nImplement proper error emission to make all RED tests pass.\n\n## Implementation Requirements\n\n### Error Emission\n- Emit via error() callback\n- Include error details\n- Proper error types\n- Single error emission\n\n### Error Creation\n- Create appropriate error types\n- Include error codes\n- Preserve stack traces\n- Add context info\n\n### Implementation Details\n- Catch errors in Observable\n- Convert to appropriate type\n- Emit and terminate\n- Clean up resources\n\n## Acceptance Criteria\n- All RED tests now pass (GREEN phase)\n- Errors emitted correctly\n- Error types appropriate\n- Context preserved","status":"open","priority":2,"issue_type":"task","created_at":"2026-01-05T06:47:13.606483-06:00","updated_at":"2026-01-05T06:47:13.606483-06:00"}
{"id":"neo4j-di74","title":"RED: Write failing tests for buffer management","description":"## Overview\nWrite failing tests for proper buffer management in reactive streaming.\n\n## Test Cases to Write\n\n### Basic Buffer Tests\n- Records buffered when consumer slow\n- Buffer size bounded\n- Buffer overflow handled correctly\n- Buffer drained on demand\n\n### Buffer Configuration Tests\n- Default buffer size reasonable\n- Custom buffer size respected\n- Buffer strategy configurable\n- Buffer metrics available\n\n### Memory Tests\n- Memory usage bounded\n- Large result sets don't OOM\n- Buffer memory released after use\n- Memory pressure handling\n\n### Edge Cases\n- Empty result buffer handling\n- Single record buffering\n- Rapid buffer fill/drain\n- Concurrent buffer access\n\n## Acceptance Criteria\n- All tests written and failing (RED phase)\n- Tests verify buffer behavior\n- Tests verify memory bounds\n- Tests cover edge cases","status":"open","priority":2,"issue_type":"task","created_at":"2026-01-05T06:46:06.490044-06:00","updated_at":"2026-01-05T06:46:06.490044-06:00"}
{"id":"neo4j-do9a","title":"GREEN: Record.values() - Implement values array method","description":"## Overview\nImplement the Record.values() method to make all RED phase tests pass.\n\n## Implementation\n\n```typescript\nvalues(): any[] {\n  return [...this._values];\n}\n```\n\n## Acceptance Criteria\n- [ ] All RED phase tests now pass (GREEN phase)\n- [ ] Returns copy of values array\n- [ ] Preserves order and types\n- [ ] Implementation is minimal\n\n## TDD Phase\nGREEN - Minimal implementation to pass tests\n\n## Dependencies\n- neo4j-ak6d (RED phase tests)","status":"closed","priority":1,"issue_type":"task","created_at":"2026-01-05T06:40:32.990462-06:00","updated_at":"2026-01-05T08:55:15.890034-06:00","closed_at":"2026-01-05T08:55:15.890034-06:00","close_reason":"Record methods already implemented with tests"}
{"id":"neo4j-e12","title":"GREEN: Implement rxSession.run() method","description":"## Overview\nImplement `rxSession.run()` to make all RED tests pass.\n\n## Implementation Requirements\n\n### Method Signature\n```typescript\ninterface RxSession {\n  run(cypher: string, params?: Record\u003cstring, any\u003e): RxResult\n}\n```\n\n### Implementation Details\n- Create RxResult wrapper around query execution\n- Ensure lazy execution (cold observable)\n- Handle parameter serialization\n- Wire up to underlying session/connection\n- Proper error propagation\n\n### Observable Semantics\n- Query executes on first subscription\n- Each subscription creates new execution\n- Support unsubscription/cancellation\n\n## Acceptance Criteria\n- [ ] All RED tests now pass (GREEN phase)\n- [ ] Returns proper RxResult instance\n- [ ] Observable semantics correct\n- [ ] Parameter handling works","status":"open","priority":2,"issue_type":"task","created_at":"2026-01-05T06:35:11.770194-06:00","updated_at":"2026-01-05T06:35:11.770194-06:00"}
{"id":"neo4j-e2j","title":"[REFACTOR] Vector Type - Optimize and Add Math Operations","description":"## Overview\nRefactor Vector type for performance and add mathematical operations.\n\n## TDD Phase: REFACTOR (Improve While Green)\n\n### Refactoring Goals\n\n#### Mathematical Operations\n- [ ] `vector.dot(other)` - dot product\n- [ ] `vector.magnitude()` - L2 norm\n- [ ] `vector.normalize()` - unit vector\n- [ ] `vector.add(other)` - element-wise addition\n- [ ] `vector.subtract(other)` - element-wise subtraction\n- [ ] `vector.scale(factor)` - scalar multiplication\n\n#### Similarity Functions\n- [ ] `vector.cosineSimilarity(other)`\n- [ ] `vector.euclideanDistance(other)`\n\n#### Performance Optimizations\n- [ ] SIMD operations where available\n- [ ] Lazy magnitude calculation (cache)\n- [ ] Zero-copy slicing with ArrayBuffer views\n- [ ] Efficient serialization (base64 for binary)\n\n#### Edge Case Hardening\n- [ ] Dimension mismatch errors\n- [ ] Zero vector handling (normalize)\n- [ ] Overflow in integer vectors\n- [ ] Precision loss warnings\n\n#### Code Quality\n- [ ] Comprehensive JSDoc\n- [ ] Better error messages\n- [ ] Type narrowing helpers\n\n#### Additional Tests\n- [ ] Mathematical property tests (dot product commutativity, etc.)\n- [ ] Large vector performance benchmarks\n- [ ] Serialization round-trip tests\n- [ ] Memory usage tests\n\n### Integration Considerations\n- [ ] How vectors map to Cypher VECTOR type\n- [ ] Integration with vector search queries\n- [ ] Batch operations for multiple vectors\n\n### Acceptance Criteria\n- [ ] All existing tests still pass\n- [ ] Math operations tested and accurate\n- [ ] Performance benchmarks documented\n- [ ] 100% test coverage\n\n### Dependencies\n- Depends on: [GREEN] Vector Type - Implement to Pass Tests","status":"open","priority":2,"issue_type":"task","created_at":"2026-01-05T06:38:29.465263-06:00","updated_at":"2026-01-05T06:38:29.465263-06:00","dependencies":[{"issue_id":"neo4j-e2j","depends_on_id":"neo4j-eiy","type":"blocks","created_at":"2026-01-05T06:42:21.762183-06:00","created_by":"nathanclevenger"}]}
{"id":"neo4j-e3d8","title":"RED: Subquery Translation","description":"## Overview\nWrite failing tests for subquery translation (EXISTS, comprehensions, CALL).\n\n## Test Cases to Write\n\n### Test 1: EXISTS Subquery\n- WHERE EXISTS { MATCH (n)-[:KNOWS]-\u003e(m) } -\u003e SQL EXISTS\n\n### Test 2: NOT EXISTS\n- WHERE NOT EXISTS { ... } -\u003e NOT EXISTS\n\n### Test 3: Pattern Comprehension\n- [p = (a)--\u003e(b) | p] -\u003e Correlated subquery\n\n### Test 4: List Comprehension\n- [x IN list WHERE x \u003e 0 | x * 2] -\u003e Subquery with filter\n\n### Test 5: CALL Subquery\n- CALL { MATCH (n) RETURN n } -\u003e CTE or inline subquery\n\n### Test 6: CALL with UNION\n- CALL { ... UNION ... } RETURN -\u003e Combined results\n\n### Test 7: Correlated Subquery\n- Subquery referencing outer variable\n\n### Test 8: COUNT Subquery\n- RETURN COUNT { (n)-[:KNOWS]-\u003e() }\n\n### Test 9: Nested Subqueries\n- EXISTS inside EXISTS\n\n## Acceptance Criteria\n- All tests written and failing\n- EXISTS pattern correct\n- CALL subqueries handled\n\n## TDD Phase\nRED - Write failing tests first","status":"open","priority":2,"issue_type":"task","created_at":"2026-01-05T06:43:11.355192-06:00","updated_at":"2026-01-05T06:43:11.355192-06:00"}
{"id":"neo4j-e3h","title":"ESLint + Prettier setup","description":"# ESLint + Prettier Setup\n\n## Overview\nConfigure ESLint and Prettier for consistent code style and quality in the neo4j.do project.\n\n## ESLint Configuration\n- TypeScript ESLint plugin\n- Strict type-checking rules\n- Import sorting\n- No unused variables\n- Consistent return types\n\n## Prettier Configuration\n```json\n{\n  \"semi\": false,\n  \"singleQuote\": true,\n  \"tabWidth\": 2,\n  \"trailingComma\": \"es5\",\n  \"printWidth\": 100,\n  \"arrowParens\": \"avoid\"\n}\n```\n\n## ESLint Config (eslint.config.js)\n```javascript\nimport eslint from '@eslint/js'\nimport tseslint from 'typescript-eslint'\nimport prettierConfig from 'eslint-config-prettier'\n\nexport default tseslint.config(\n  eslint.configs.recommended,\n  ...tseslint.configs.strictTypeChecked,\n  prettierConfig,\n  {\n    languageOptions: {\n      parserOptions: {\n        project: true,\n        tsconfigRootDir: import.meta.dirname\n      }\n    },\n    rules: {\n      '@typescript-eslint/no-unused-vars': ['error', { argsIgnorePattern: '^_' }],\n      '@typescript-eslint/explicit-function-return-type': 'warn',\n      '@typescript-eslint/no-explicit-any': 'error'\n    }\n  },\n  {\n    ignores: ['dist/**', 'node_modules/**', '*.config.*']\n  }\n)\n```\n\n## Files to Create\n- `eslint.config.js`\n- `.prettierrc`\n- `.prettierignore`\n- `.editorconfig`\n\n## Acceptance Criteria\n- [ ] ESLint configured with TypeScript support\n- [ ] Prettier configured\n- [ ] No conflicts between ESLint and Prettier\n- [ ] Lint command works: `npm run lint`\n- [ ] Format command works: `npm run format`\n- [ ] Pre-commit hook consideration documented","status":"open","priority":1,"issue_type":"task","created_at":"2026-01-05T06:35:36.477707-06:00","updated_at":"2026-01-05T06:35:36.477707-06:00"}
{"id":"neo4j-ecj","title":"[REFACTOR] In-Memory Graph - Optimize memory usage and performance","description":"## Overview\nRefactor in-memory graph for better performance and memory efficiency.\n\n## Refactoring Tasks\n\n### Memory Optimization\n- Use typed arrays where beneficial\n- Implement property deduplication\n- Consider flyweight pattern for common values\n- Add memory usage monitoring\n\n### Performance Optimization\n- Batch index updates\n- Implement lazy index rebuilding\n- Add caching for frequent queries\n- Optimize adjacency list iteration\n\n### API Improvements\n```typescript\n// Add iterator support\ngraph.nodes(): IterableIterator\u003cNode\u003e\ngraph.relationships(): IterableIterator\u003cRelationship\u003e\n\n// Add bulk operations\ngraph.createNodes(nodes: NodeInput[]): Node[]\ngraph.createRelationships(rels: RelInput[]): Relationship[]\n```\n\n### Code Quality\n- Extract common index logic\n- Add generics for type safety\n- Implement proper error handling\n- Add performance benchmarks\n\n### Testing Improvements\n- Add property-based tests\n- Add stress tests for large graphs\n- Add memory leak tests\n- Benchmark against baseline\n\n## Acceptance Criteria\n- [ ] All tests still pass\n- [ ] Memory usage reduced\n- [ ] Query performance improved\n- [ ] Code is cleaner and well-typed\n- [ ] Benchmarks documented\n\n## TDD Phase\n**REFACTOR** - Improve without changing behavior","status":"open","priority":2,"issue_type":"task","created_at":"2026-01-05T06:35:32.490103-06:00","updated_at":"2026-01-05T06:35:32.490103-06:00"}
{"id":"neo4j-ee0o","title":"RED: Result.peek() - Write failing tests for peeking first record","description":"## Overview\nWrite failing tests for the Result.peek() method that returns the first record without consuming.\n\n## Test Cases to Write\n\n```typescript\ndescribe('Result.peek()', () =\u003e {\n  it('should return first record without consuming result', async () =\u003e {\n    const result = createMockResult([\n      { name: 'Alice' },\n      { name: 'Bob' }\n    ]);\n    \n    const first = await result.peek();\n    expect(first?.get('name')).toBe('Alice');\n    \n    // Records should still be available\n    const records = await result.records;\n    expect(records).toHaveLength(2);\n  });\n\n  it('should return null for empty result', async () =\u003e {\n    const result = createMockResult([]);\n    \n    const first = await result.peek();\n    expect(first).toBeNull();\n  });\n\n  it('should return same record on multiple peeks', async () =\u003e {\n    const result = createMockResult([{ name: 'Alice' }]);\n    \n    const peek1 = await result.peek();\n    const peek2 = await result.peek();\n    \n    expect(peek1).toBe(peek2);\n  });\n\n  it('should return Record instance', async () =\u003e {\n    const result = createMockResult([{ name: 'Alice' }]);\n    \n    const first = await result.peek();\n    expect(first).toBeInstanceOf(Record);\n  });\n});\n```\n\n## Acceptance Criteria\n- [ ] All tests written and failing (RED phase)\n- [ ] Tests verify non-consuming peek\n- [ ] Tests verify null for empty result\n- [ ] Test file created at src/result/__tests__/result-peek.test.ts\n\n## TDD Phase\nRED - Tests should fail because peek method does not exist yet","status":"closed","priority":1,"issue_type":"task","created_at":"2026-01-05T06:48:39.788397-06:00","updated_at":"2026-01-05T07:19:22.168022-06:00","closed_at":"2026-01-05T07:19:22.168022-06:00","close_reason":"Implemented in this Ralph Wiggum session - 662 tests pass"}
{"id":"neo4j-ehoi","title":"[RED] Parser: Literal Expression Tests","description":"## Overview\nWrite failing tests for literal expression parsing.\n\n## Test Cases to Write\n\n### String Literals\n- Single quotes: `'hello'`\n- Double quotes: `\"hello\"`\n- With escapes: `'it\\'s'`, `\"say \\\"hi\\\"\"`\n- Empty: `''`, `\"\"`\n\n### Numeric Literals\n- Integers: `0`, `42`, `-17`\n- Floats: `3.14`, `-2.5`, `.5`\n- Scientific: `1e10`, `1.5e-3`\n- Hex: `0xFF`, `0x1A2B`\n\n### Boolean Literals\n- `true`, `TRUE`, `True`\n- `false`, `FALSE`, `False`\n\n### Null Literal\n- `null`, `NULL`, `Null`\n\n### List Literals\n- Empty: `[]`\n- Simple: `[1, 2, 3]`\n- Mixed: `[1, 'two', true, null]`\n- Nested: `[[1, 2], [3, 4]]`\n- With expressions: `[n.x, n.y, n.z]`\n\n### Map Literals\n- Empty: `{}`\n- Simple: `{name: 'John'}`\n- Multiple: `{name: 'John', age: 30}`\n- Nested: `{address: {city: 'NYC'}}`\n- Quoted keys: `{\\`odd-key\\`: 1}`\n- With expressions: `{sum: a + b}`\n\n## Acceptance Criteria\n- [ ] All literal tests written and failing\n- [ ] All types covered\n- [ ] Nested structures tested\n- [ ] Edge cases documented\n\n## TDD Phase: RED","status":"closed","priority":1,"issue_type":"task","created_at":"2026-01-05T06:45:48.261653-06:00","updated_at":"2026-01-05T07:19:22.171692-06:00","closed_at":"2026-01-05T07:19:22.171692-06:00","close_reason":"Implemented in this Ralph Wiggum session - 662 tests pass"}
{"id":"neo4j-ei9","title":"[REFACTOR] Relationship Operations - Optimize traversal and add batch operations","description":"## Overview\nRefactor relationship operations for better traversal performance.\n\n## Refactoring Tasks\n\n### Query Optimization\n```typescript\n// Add compound index for common queries\nCREATE INDEX idx_rel_start_type ON relationships(start_node_id, type);\nCREATE INDEX idx_rel_end_type ON relationships(end_node_id, type);\n\n// Optimized traversal query\ngetRelationshipsForNode(nodeId: number, direction: Direction, type?: string): Relationship[] {\n  if (direction === 'BOTH') {\n    return [\n      ...this.getRelationshipsForNode(nodeId, 'OUTGOING', type),\n      ...this.getRelationshipsForNode(nodeId, 'INCOMING', type)\n    ];\n  }\n  // Use appropriate index based on direction\n}\n```\n\n### Batch Operations\n```typescript\ncreateRelationships(rels: RelationshipInput[]): Relationship[] {\n  return this.sql.transaction(() =\u003e {\n    return rels.map(r =\u003e this.createRelationship(r.type, r.startNodeId, r.endNodeId, r.properties));\n  });\n}\n\ndeleteRelationships(ids: number[]): number {\n  return this.sql.transaction(() =\u003e {\n    let deleted = 0;\n    for (const id of ids) {\n      if (this.deleteRelationship(id)) deleted++;\n    }\n    return deleted;\n  });\n}\n```\n\n### Traversal Helpers\n```typescript\n// Get connected nodes directly\ngetConnectedNodes(nodeId: number, direction: Direction, relType?: string): Node[] {\n  // Efficient join query\n}\n\n// Expand multiple levels\nexpand(nodeId: number, depth: number, direction: Direction): { nodes: Node[], relationships: Relationship[] } {\n  // BFS or DFS expansion\n}\n```\n\n### Code Quality\n- Extract query builders\n- Add relationship validation\n- Implement cascade delete option\n- Add traversal statistics\n\n## Acceptance Criteria\n- [ ] All tests still pass\n- [ ] Traversal performance improved\n- [ ] Batch operations available\n- [ ] Helper methods added\n- [ ] Code well-documented\n\n## TDD Phase\n**REFACTOR** - Improve without changing behavior","status":"open","priority":2,"issue_type":"task","created_at":"2026-01-05T06:37:51.551682-06:00","updated_at":"2026-01-05T06:37:51.551682-06:00"}
{"id":"neo4j-eiok","title":"GREEN: Implement rxResult.records() method","description":"## Overview\nImplement rxResult.records() to make all RED tests pass.\n\n## Implementation Requirements\n\n### Method Signature\n```typescript\ninterface RxResult {\n  records(): Observable\u003cRecord\u003e\n}\n```\n\n### Implementation Details\n- Create Observable that emits Records\n- Stream records as they arrive\n- Support backpressure\n- Handle large result sets efficiently\n\n### Observable Semantics\n- Cold observable (lazy execution)\n- Multiple emissions (one per record)\n- Complete after last record\n- Error on query failure\n\n### Memory Management\n- Don't buffer all records\n- Stream from database\n- Release records after emission\n\n## Acceptance Criteria\n- All RED tests now pass (GREEN phase)\n- Records streamed correctly\n- Backpressure supported\n- Memory efficient","status":"open","priority":2,"issue_type":"task","created_at":"2026-01-05T06:41:19.183091-06:00","updated_at":"2026-01-05T06:41:19.183091-06:00"}
{"id":"neo4j-eiy","title":"[GREEN] Vector Type - Implement to Pass Tests","description":"## Overview\nImplement the Vector type to pass all failing tests.\n\n## TDD Phase: GREEN (Make Tests Pass)\n\n### Implementation Requirements\n\n#### TypedArray Types\n```typescript\ntype VectorDType = \n  | 'int8' \n  | 'int16' \n  | 'int32' \n  | 'int64'   // BigInt64Array\n  | 'float32' \n  | 'float64';\n\ntype TypedArrayMap = {\n  int8: Int8Array;\n  int16: Int16Array;\n  int32: Int32Array;\n  int64: BigInt64Array;\n  float32: Float32Array;\n  float64: Float64Array;\n};\n```\n\n#### Vector Class\n```typescript\nexport class Vector\u003cT extends VectorDType = 'float32'\u003e {\n  readonly #data: TypedArrayMap[T];\n  readonly dtype: T;\n  \n  constructor(data: TypedArrayMap[T], dtype: T);\n  \n  // Properties\n  get dimensions(): number;\n  get byteLength(): number;\n  \n  // Element access\n  at(index: number): number | bigint;\n  \n  // Conversion\n  asTypedArray(): TypedArrayMap[T];\n  toArray(): (number | bigint)[];\n  \n  // Iteration\n  [Symbol.iterator](): Iterator\u003cnumber | bigint\u003e;\n  \n  // Slicing\n  slice(start?: number, end?: number): Vector\u003cT\u003e;\n  \n  // Serialization\n  toString(): string;\n  toJSON(): VectorJSON;\n  static fromJSON(json: VectorJSON): Vector;\n}\n```\n\n#### Factory Function\n```typescript\nfunction vector(\n  data: ArrayLike\u003cnumber\u003e | TypedArray,\n  dtype?: VectorDType\n): Vector {\n  // Infer dtype from TypedArray if not specified\n  // Default to float32 for regular arrays\n}\n```\n\n#### Type Guard\n```typescript\nfunction isVector(value: unknown): value is Vector {\n  return value instanceof Vector;\n}\n```\n\n### Implementation Notes\n- Store data as TypedArray internally for efficiency\n- Support BigInt64Array for int64 (needed for some embeddings)\n- Efficient serialization for network transfer\n- Consider ArrayBuffer sharing for slices\n\n### File Structure\n```\nsrc/types/\n  vector.ts\n  vector.test.ts\n```\n\n### Acceptance Criteria\n- [ ] All RED phase tests passing\n- [ ] All dtype variants working\n- [ ] Efficient memory usage\n- [ ] Proper TypeScript generics\n- [ ] Exported from `src/types/index.ts`\n\n### Dependencies\n- Depends on: [RED] Vector Type - Write Failing Tests","status":"open","priority":2,"issue_type":"task","created_at":"2026-01-05T06:38:12.993171-06:00","updated_at":"2026-01-05T06:38:12.993171-06:00","dependencies":[{"issue_id":"neo4j-eiy","depends_on_id":"neo4j-7t2","type":"blocks","created_at":"2026-01-05T06:42:21.51364-06:00","created_by":"nathanclevenger"}]}
{"id":"neo4j-ek0n","title":"GREEN: Implement rxResult.keys() method","description":"## Overview\nImplement rxResult.keys() to make all RED tests pass.\n\n## Implementation Requirements\n\n### Method Signature\n```typescript\ninterface RxResult {\n  keys(): Observable\u003cstring[]\u003e\n}\n```\n\n### Implementation Details\n- Create Observable for keys\n- Extract from result metadata\n- Available immediately (before records)\n- Cache for multiple subscriptions\n\n### Observable Semantics\n- Single emission of key array\n- Complete after emission\n- Error on query failure\n- Support replay for multiple subs\n\n## Acceptance Criteria\n- All RED tests now pass (GREEN phase)\n- Returns correct column names\n- Observable semantics correct\n- Multiple subscriptions work","status":"open","priority":2,"issue_type":"task","created_at":"2026-01-05T06:40:48.948829-06:00","updated_at":"2026-01-05T06:40:48.948829-06:00"}
{"id":"neo4j-ek1j","title":"[RED] Property Storage - Write failing tests for JSON property handling","description":"## Overview\nWrite failing tests for property storage and type preservation before implementation.\n\n## Test Cases to Write\n\n### JSON Serialization Tests\n- `test_serialize_string_property`\n- `test_serialize_number_property`\n- `test_serialize_boolean_property`\n- `test_serialize_null_property`\n- `test_serialize_array_property`\n- `test_serialize_nested_object_property`\n\n### Type Preservation Tests\n- `test_integer_preserved_not_float`\n- `test_float_preserved_correctly`\n- `test_large_integer_preserved` - BigInt handling\n- `test_date_serialization` - ISO string format\n- `test_point_serialization` - Spatial types\n- `test_duration_serialization` - Temporal duration\n\n### Nested Property Access Tests\n- `test_get_nested_property` - prop.nested.value\n- `test_set_nested_property`\n- `test_delete_nested_property`\n- `test_nested_array_access` - prop.items[0]\n- `test_deeply_nested_access`\n\n### Property Existence Tests\n- `test_property_exists_returns_true`\n- `test_property_not_exists_returns_false`\n- `test_nested_property_exists`\n- `test_null_property_exists_vs_missing`\n\n### Edge Cases\n- `test_empty_string_property`\n- `test_empty_object_property`\n- `test_empty_array_property`\n- `test_unicode_property_values`\n- `test_very_large_property_values`\n- `test_circular_reference_handling`\n\n## Acceptance Criteria\n- [ ] All tests written and failing\n- [ ] Type preservation tested\n- [ ] Nested access tested\n- [ ] Edge cases covered\n\n## TDD Phase\n**RED** - Write failing tests first","status":"closed","priority":1,"issue_type":"task","created_at":"2026-01-05T06:40:08.516359-06:00","updated_at":"2026-01-05T08:56:35.535509-06:00","closed_at":"2026-01-05T08:56:35.535509-06:00","close_reason":"Tests passing - storage and transactions implemented"}
{"id":"neo4j-emem","title":"GREEN: Implement request-based flow control","description":"## Overview\nImplement request-based flow control to make all RED tests pass.\n\n## Implementation Requirements\n\n### Flow Control\n- Track requested count\n- Emit only when requested\n- Pause production when blocked\n- Resume on request\n\n### Implementation Details\n- Integrate with RxJS backpressure\n- Support request(n) semantics\n- Handle unbounded requests\n- Coordinate with database fetch\n\n### Database Integration\n- Control fetch size from database\n- Buffer management\n- Pause/resume streaming\n- Efficient resource usage\n\n## Acceptance Criteria\n- All RED tests now pass (GREEN phase)\n- Flow control works correctly\n- Memory bounded\n- Database fetch coordinated","status":"open","priority":2,"issue_type":"task","created_at":"2026-01-05T06:45:42.215058-06:00","updated_at":"2026-01-05T06:45:42.215058-06:00"}
{"id":"neo4j-emw8","title":"REFACTOR: Improve rxResult.consume() implementation","description":"## Overview\nRefactor rxResult.consume() for robust summary handling.\n\n## Refactoring Tasks\n\n### Code Quality\n- Extract ResultSummary builder\n- Share with sync result.consume()\n- Improve type definitions\n- Document summary fields\n\n### Statistics Handling\n- Validate counter accuracy\n- Handle missing statistics\n- Default values for optional fields\n\n### Integration\n- Align with sync consume()\n- Share summary parsing code\n- Consistent behavior\n\n## Acceptance Criteria\n- All tests still pass\n- Clean ResultSummary builder\n- Accurate statistics\n- Consistent with sync API","status":"open","priority":2,"issue_type":"task","created_at":"2026-01-05T06:41:58.072093-06:00","updated_at":"2026-01-05T06:41:58.072093-06:00"}
{"id":"neo4j-eqh3","title":"GREEN: Implement rxResult.consume() method","description":"## Overview\nImplement rxResult.consume() to make all RED tests pass.\n\n## Implementation Requirements\n\n### Method Signature\n```typescript\ninterface RxResult {\n  consume(): Observable\u003cResultSummary\u003e\n}\n```\n\n### Implementation Details\n- Create Observable for result summary\n- Consume remaining records if needed\n- Parse query statistics\n- Build ResultSummary object\n\n### ResultSummary Structure\n- Query counters\n- Query type\n- Database information\n- Server information\n- Notifications\n\n### Observable Semantics\n- Single emission\n- Complete after emission\n- Error on failure\n- Can be called after records()\n\n## Acceptance Criteria\n- All RED tests now pass (GREEN phase)\n- Returns complete ResultSummary\n- Statistics accurate\n- Observable semantics correct","status":"open","priority":2,"issue_type":"task","created_at":"2026-01-05T06:41:51.209468-06:00","updated_at":"2026-01-05T06:41:51.209468-06:00"}
{"id":"neo4j-extl","title":"REFACTOR: Improve error propagation patterns","description":"## Overview\nRefactor error propagation for better developer experience.\n\n## Refactoring Tasks\n\n### Code Quality\n- Standardize error creation\n- Share with sync error handling\n- Add error type guards\n- Document error types\n\n### Error Context\n- Enrich error messages\n- Add query context\n- Add timing information\n- Include helpful suggestions\n\n### Recovery Patterns\n- Document catchError patterns\n- Add retry utilities\n- Create error recovery helpers\n- Document best practices\n\n## Acceptance Criteria\n- All tests still pass\n- Clear error messages\n- Good error context\n- Documented recovery patterns","status":"open","priority":2,"issue_type":"task","created_at":"2026-01-05T06:43:33.259561-06:00","updated_at":"2026-01-05T06:43:33.259561-06:00"}
{"id":"neo4j-fcmi","title":"[REFACTOR] Backup and Recovery - Add streaming and compression","description":"## Overview\nRefactor backup and recovery for large-scale data handling.\n\n## Refactoring Tasks\n\n### Streaming Export\n```typescript\nclass StreamingExporter {\n  async *exportToJsonStream(): AsyncGenerator\u003cstring\u003e {\n    yield '{\"version\":\"1.0\",\"nodes\":[';\n    \n    let first = true;\n    for await (const node of this.nodeOps.streamNodes()) {\n      if (\\!first) yield ',';\n      yield JSON.stringify(node);\n      first = false;\n    }\n    \n    yield '],\"relationships\":[';\n    \n    first = true;\n    for await (const rel of this.relOps.streamRelationships()) {\n      if (\\!first) yield ',';\n      yield JSON.stringify(rel);\n      first = false;\n    }\n    \n    yield ']}';\n  }\n}\n```\n\n### Compression Support\n```typescript\nclass CompressedExporter {\n  async exportCompressed(): Promise\u003cReadableStream\u003cUint8Array\u003e\u003e {\n    const jsonStream = this.exporter.exportToJsonStream();\n    return jsonStream.pipeThrough(new CompressionStream('gzip'));\n  }\n}\n\nclass CompressedImporter {\n  async importCompressed(stream: ReadableStream\u003cUint8Array\u003e): Promise\u003cImportResult\u003e {\n    const decompressed = stream.pipeThrough(new DecompressionStream('gzip'));\n    return this.importFromStream(decompressed);\n  }\n}\n```\n\n### Incremental Backup\n```typescript\ninterface ChangeLog {\n  timestamp: number;\n  operation: 'CREATE' | 'UPDATE' | 'DELETE';\n  entityType: 'node' | 'relationship';\n  entityId: number;\n  data?: unknown;\n}\n\nclass IncrementalBackup {\n  private changeLog: ChangeLog[] = [];\n  \n  recordChange(change: ChangeLog): void {\n    this.changeLog.push(change);\n  }\n  \n  exportChangesSince(timestamp: number): ChangeLog[] {\n    return this.changeLog.filter(c =\u003e c.timestamp \u003e= timestamp);\n  }\n  \n  applyChanges(changes: ChangeLog[]): void {\n    for (const change of changes) {\n      // Apply each change in order\n    }\n  }\n}\n```\n\n### Format Validation\n```typescript\nimport { z } from 'zod';\n\nconst GraphJsonSchema = z.object({\n  version: z.string(),\n  metadata: z.object({\n    exportedAt: z.string(),\n    nodeCount: z.number(),\n    relationshipCount: z.number()\n  }),\n  nodes: z.array(z.object({\n    id: z.number(),\n    labels: z.array(z.string()),\n    properties: z.record(z.unknown())\n  })),\n  relationships: z.array(z.object({\n    id: z.number(),\n    type: z.string(),\n    startNodeId: z.number(),\n    endNodeId: z.number(),\n    properties: z.record(z.unknown())\n  }))\n});\n\nfunction validateImportData(data: unknown): GraphJson {\n  return GraphJsonSchema.parse(data);\n}\n```\n\n### Code Quality\n- Add progress callbacks\n- Implement resume on failure\n- Add integrity verification\n- Create backup scheduling utilities\n\n## Acceptance Criteria\n- [ ] All tests still pass\n- [ ] Streaming works for large graphs\n- [ ] Compression reduces size\n- [ ] Incremental backup available\n- [ ] Code well-documented\n\n## TDD Phase\n**REFACTOR** - Improve without changing behavior","status":"open","priority":2,"issue_type":"task","created_at":"2026-01-05T06:43:00.901777-06:00","updated_at":"2026-01-05T06:43:00.901777-06:00"}
{"id":"neo4j-fij","title":"[GREEN] AST: Implement Visitor Pattern","description":"## Overview\nImplement the AST visitor pattern.\n\n## Implementation Tasks\n\n### Visitor Interface (src/parser/ast/visitor.ts)\n```typescript\nexport interface ASTVisitor\u003cT = void\u003e {\n  // Queries\n  visitQuery?(node: Query): T\n  visitUnion?(node: Union): T\n  \n  // Clauses\n  visitMatchClause?(node: MatchClause): T\n  visitReturnClause?(node: ReturnClause): T\n  visitWithClause?(node: WithClause): T\n  visitCreateClause?(node: CreateClause): T\n  visitMergeClause?(node: MergeClause): T\n  visitDeleteClause?(node: DeleteClause): T\n  visitSetClause?(node: SetClause): T\n  visitRemoveClause?(node: RemoveClause): T\n  visitUnwindClause?(node: UnwindClause): T\n  \n  // Patterns\n  visitNodePattern?(node: NodePattern): T\n  visitRelationshipPattern?(node: RelationshipPattern): T\n  \n  // Expressions\n  visitBinaryExpression?(node: BinaryExpression): T\n  visitUnaryExpression?(node: UnaryExpression): T\n  visitFunctionCall?(node: FunctionCall): T\n  visitPropertyAccess?(node: PropertyAccess): T\n  visitIdentifier?(node: Identifier): T\n  visitLiteral?(node: Literal): T\n  \n  // Fallback\n  visit?(node: ASTNode): T\n}\n```\n\n### Walk Function\n```typescript\nexport function walk\u003cT\u003e(\n  node: ASTNode,\n  visitor: ASTVisitor\u003cT\u003e,\n  context?: any\n): T | undefined {\n  const method = `visit${node.type}` as keyof ASTVisitor\u003cT\u003e\n  if (visitor[method]) {\n    return (visitor[method] as Function)(node, context)\n  }\n  return visitor.visit?.(node, context)\n}\n```\n\n### Recursive Walker\n```typescript\nexport function walkAll(node: ASTNode, visitor: ASTVisitor): void {\n  // Walk this node\n  // Walk all children recursively\n}\n```\n\n## Acceptance Criteria\n- [ ] All visitor tests pass\n- [ ] Dispatch to correct method\n- [ ] Fallback behavior works\n- [ ] Recursive walking complete\n\n## TDD Phase: GREEN\n## Depends On: neo4j-070","status":"closed","priority":1,"issue_type":"task","created_at":"2026-01-05T06:39:07.125814-06:00","updated_at":"2026-01-05T08:58:01.753084-06:00","closed_at":"2026-01-05T08:58:01.753084-06:00","close_reason":"AST, lexer and types tests passing"}
{"id":"neo4j-fra","title":"REFACTOR: Improve rxTx.run() implementation","description":"## Overview\nRefactor rxTx.run() for better code quality.\n\n## Refactoring Tasks\n\n### Code Quality\n- Share code with rxSession.run()\n- Extract common query execution\n- Improve type definitions\n- Better error messages\n\n### Transaction Integration\n- Ensure proper transaction binding\n- Handle transaction state checks\n- Optimize for multiple queries\n\n### Performance\n- Minimize Observable overhead\n- Efficient parameter handling\n- Consider query batching\n\n## Acceptance Criteria\n- All tests still pass\n- DRY code with session.run\n- Clean transaction integration\n- Efficient implementation","status":"open","priority":2,"issue_type":"task","created_at":"2026-01-05T06:38:51.833819-06:00","updated_at":"2026-01-05T06:38:51.833819-06:00"}
{"id":"neo4j-fu25","title":"RED: Write failing tests for marble testing support","description":"## Overview\nWrite failing tests for RxJS marble testing support.\n\n## Test Cases to Write\n\n### Basic Marble Tests\n- Records stream matches marble diagram\n- Keys stream matches marble diagram\n- Error timing matches diagram\n- Completion timing matches diagram\n\n### Marble Syntax Tests\n- '-' for time frame works\n- Values at positions work\n- '#' for error works\n- '|' for completion works\n- '^' for subscription works\n\n### Complex Pattern Tests\n- Multiple emissions pattern\n- Delayed emission pattern\n- Error after emissions\n- Conditional completion\n\n### Integration Tests\n- rxSession.run() marble testable\n- rxResult.records() marble testable\n- Transaction operations testable\n- Multiple query coordination\n\n## Acceptance Criteria\n- All tests written and failing (RED phase)\n- Tests verify marble syntax\n- Tests verify complex patterns\n- Tests show integration","status":"open","priority":2,"issue_type":"task","created_at":"2026-01-05T06:49:45.671473-06:00","updated_at":"2026-01-05T06:49:45.671473-06:00"}
{"id":"neo4j-gahj","title":"[REFACTOR] Graph Types - Optimize and Add Utilities","description":"## Overview\nRefactor Graph types for performance, utilities, and code quality.\n\n## TDD Phase: REFACTOR (Improve While Green)\n\n### Refactoring Goals\n\n#### Node Utilities\n- [ ] `node.hasLabel(label)` - check for label\n- [ ] `node.getProperty(key, default)` - safe property access\n- [ ] `Node.create(labels, properties)` - factory without ID (for local use)\n\n#### Relationship Utilities\n- [ ] `rel.connectsTo(node)` - check if connects to node\n- [ ] `rel.isDirectedFrom(node)` - check direction\n- [ ] `Relationship.create(type, properties)` - factory without IDs\n\n#### Path Utilities\n- [ ] `path.nodes()` - all nodes in path\n- [ ] `path.relationships()` - all relationships in path\n- [ ] `path.contains(node)` - check if node in path\n- [ ] `path.reverse()` - reversed path\n\n#### Performance Optimizations\n- [ ] Lazy property freezing\n- [ ] Cache common operations\n- [ ] Efficient iteration for paths\n\n#### Code Quality\n- [ ] Add comprehensive JSDoc\n- [ ] Better toString() formatting\n- [ ] Consistent error messages\n- [ ] Extract shared validation logic\n\n#### Additional Tests\n- [ ] Complex path traversal tests\n- [ ] Large graph structure tests\n- [ ] Serialization round-trip tests\n- [ ] Type narrowing with generics tests\n\n#### Integration Considerations\n- [ ] How to handle UNWIND results\n- [ ] Aggregation result handling\n- [ ] Projection results\n\n### Acceptance Criteria\n- [ ] All existing tests still pass\n- [ ] Utility methods tested\n- [ ] 100% test coverage\n- [ ] JSDoc complete\n- [ ] Performance benchmarks\n\n### Dependencies\n- Depends on: [GREEN] Graph Types (Node, Relationship, Path) - Implement to Pass Tests","status":"closed","priority":1,"issue_type":"task","created_at":"2026-01-05T06:39:34.258582-06:00","updated_at":"2026-01-05T08:55:59.063072-06:00","closed_at":"2026-01-05T08:55:59.063072-06:00","close_reason":"Types implemented with tests","dependencies":[{"issue_id":"neo4j-gahj","depends_on_id":"neo4j-4m1","type":"blocks","created_at":"2026-01-05T06:42:26.968119-06:00","created_by":"nathanclevenger"}]}
{"id":"neo4j-gfq","title":"GREEN: Auto Vector Embeddings - Implement automatic embedding generation","description":"## Overview\nImplement automatic vector embedding generation to make all RED tests pass.\n\n## Implementation Requirements\n\n### Core Components\n\n#### 1. Embedding Configuration Store\n```typescript\ninterface EmbeddingConfig {\n  indexName: string;\n  label?: string;\n  relType?: string;\n  sourceField: string | string[];\n  targetField: string;\n  model: string;\n  dimensions: number;\n  separator?: string;\n}\n\nclass EmbeddingConfigStore {\n  async configure(config: EmbeddingConfig): Promise\u003cvoid\u003e;\n  async getConfigsForLabel(label: string): Promise\u003cEmbeddingConfig[]\u003e;\n  async getConfigsForRelType(relType: string): Promise\u003cEmbeddingConfig[]\u003e;\n}\n```\n\n#### 2. Workers AI Embedding Service\n```typescript\nclass WorkersAIEmbeddingService {\n  constructor(private ai: Ai) {}\n  \n  async embed(text: string, model: string): Promise\u003cnumber[]\u003e;\n  async embedBatch(texts: string[], model: string): Promise\u003cnumber[][]\u003e;\n}\n```\n\n#### 3. Auto-Embedding Interceptor\n```typescript\nclass AutoEmbeddingInterceptor {\n  async beforeNodeCreate(label: string, properties: Record\u003cstring, any\u003e): Promise\u003cRecord\u003cstring, any\u003e\u003e;\n  async beforeNodeUpdate(label: string, oldProps: Record\u003cstring, any\u003e, newProps: Record\u003cstring, any\u003e): Promise\u003cRecord\u003cstring, any\u003e\u003e;\n  async beforeRelationshipCreate(type: string, properties: Record\u003cstring, any\u003e): Promise\u003cRecord\u003cstring, any\u003e\u003e;\n}\n```\n\n#### 4. Batch Embedding Processor\n```typescript\nclass BatchEmbeddingProcessor {\n  private queue: EmbeddingJob[] = [];\n  private batchSize = 50;\n  \n  async queueEmbedding(job: EmbeddingJob): Promise\u003cvoid\u003e;\n  async flush(): Promise\u003cvoid\u003e;\n  async processExisting(label: string, field: string, options: BatchOptions): Promise\u003cBatchResult\u003e;\n}\n```\n\n### SQL Schema Additions\n```sql\nCREATE TABLE embedding_configs (\n  id TEXT PRIMARY KEY,\n  index_name TEXT NOT NULL UNIQUE,\n  entity_type TEXT NOT NULL CHECK (entity_type IN ('node', 'relationship')),\n  label_or_type TEXT NOT NULL,\n  source_fields TEXT NOT NULL, -- JSON array\n  target_field TEXT NOT NULL,\n  model TEXT NOT NULL DEFAULT '@cf/baai/bge-m3',\n  dimensions INTEGER NOT NULL DEFAULT 1024,\n  separator TEXT DEFAULT ' ',\n  created_at TEXT DEFAULT (datetime('now')),\n  updated_at TEXT DEFAULT (datetime('now'))\n);\n\nCREATE INDEX idx_embedding_configs_label ON embedding_configs(label_or_type) WHERE entity_type = 'node';\nCREATE INDEX idx_embedding_configs_reltype ON embedding_configs(label_or_type) WHERE entity_type = 'relationship';\n```\n\n### Procedures to Implement\n- `CALL db.index.vector.configure(indexName, options)`\n- `CALL db.embeddings.bulkGenerate(label, field, options)`\n- `CALL db.embeddings.status()` - show embedding queue status\n\n## Acceptance Criteria\n- [ ] All RED phase tests passing\n- [ ] Workers AI integration working\n- [ ] Batch processing efficient (\u003c 5s for 100 nodes)\n- [ ] Configuration persisted across restarts\n- [ ] Error handling for AI failures\n\n## Dependencies\n- RED: Auto Vector Embeddings tests\n- Vectorize binding\n\n## Tags\nsuperset, embeddings, workers-ai, tdd-green","status":"open","priority":2,"issue_type":"task","created_at":"2026-01-05T06:35:07.052411-06:00","updated_at":"2026-01-05T06:35:07.052411-06:00"}
{"id":"neo4j-gh4w","title":"GREEN: Implement Retry logic","description":"## Test-Driven Development: GREEN Phase\n\n### Component\nHTTP Client SDK - Retry Logic\n\n### Implementation Requirements\n\nImplement src/client/retry.ts with:\n- isRetryableError() function to identify retryable errors\n- ExponentialBackoff class for calculating delays  \n- RetryPolicy class for executing with retries\n- RetryHandler class to wrap fetch with retry logic\n\n### Acceptance Criteria\n- All RED phase tests pass\n- isRetryableError identifies correct errors\n- ExponentialBackoff calculates delays correctly\n- RetryPolicy respects maxRetries\n- RetryHandler wraps fetch properly\n- Retry-After header respected\n\n### Dependencies\n- RED: Retry logic fails without implementation\n\n### TDD Cycle\nThis is the GREEN phase. Next: REFACTOR phase.","status":"open","priority":2,"issue_type":"task","created_at":"2026-01-05T06:42:41.472621-06:00","updated_at":"2026-01-05T06:42:41.472621-06:00"}
{"id":"neo4j-ght","title":"[RED] Node Operations - Write failing tests for CRUD operations","description":"## Overview\nWrite failing tests for all node CRUD operations before implementation.\n\n## Test Cases to Write\n\n### createNode Tests\n- `test_create_node_returns_node_with_id`\n- `test_create_node_with_single_label`\n- `test_create_node_with_multiple_labels`\n- `test_create_node_with_properties`\n- `test_create_node_with_empty_properties`\n- `test_create_node_generates_unique_ids`\n- `test_create_node_sets_created_at_timestamp`\n\n### getNode Tests\n- `test_get_node_returns_existing_node`\n- `test_get_node_returns_null_for_missing`\n- `test_get_node_includes_all_properties`\n- `test_get_node_includes_labels`\n- `test_get_node_with_invalid_id_type`\n\n### updateNode Tests\n- `test_update_node_changes_properties`\n- `test_update_node_merges_properties`\n- `test_update_node_can_remove_property_with_null`\n- `test_update_node_updates_timestamp`\n- `test_update_nonexistent_node_throws`\n\n### deleteNode Tests\n- `test_delete_node_removes_from_storage`\n- `test_delete_node_with_relationships_throws`\n- `test_delete_nonexistent_node_returns_false`\n- `test_delete_node_removes_from_indexes`\n\n### getNodesByLabel Tests\n- `test_get_nodes_by_label_returns_matching`\n- `test_get_nodes_by_label_empty_for_unknown`\n- `test_get_nodes_by_label_multiple_results`\n\n### getAllNodes Tests\n- `test_get_all_nodes_returns_all`\n- `test_get_all_nodes_empty_graph`\n- `test_get_all_nodes_with_pagination`\n\n## Acceptance Criteria\n- [ ] All tests written and failing\n- [ ] Edge cases covered\n- [ ] Error conditions tested\n- [ ] Return types validated\n\n## TDD Phase\n**RED** - Write failing tests first","status":"closed","priority":1,"issue_type":"task","created_at":"2026-01-05T06:36:49.442195-06:00","updated_at":"2026-01-05T08:54:14.036397-06:00","closed_at":"2026-01-05T08:54:14.036397-06:00","close_reason":"Tests passing - implementation complete"}
{"id":"neo4j-giy","title":"REFACTOR: Improve rxSession.beginTransaction() implementation","description":"## Overview\nRefactor rxSession.beginTransaction() for better code quality.\n\n## Refactoring Tasks\n\n### Code Quality\n- Extract transaction initialization logic\n- Improve error handling\n- Add proper TypeScript types\n- Document transaction lifecycle\n\n### Resource Management\n- Ensure proper cleanup on errors\n- Handle unsubscription correctly\n- Manage connection resources\n\n### Integration\n- Align with sync session.beginTransaction()\n- Share common transaction creation code\n- Consistent logging\n\n## Acceptance Criteria\n- All tests still pass\n- Clean separation of concerns\n- Proper resource management\n- Well-documented code","status":"open","priority":2,"issue_type":"task","created_at":"2026-01-05T06:37:08.912131-06:00","updated_at":"2026-01-05T06:37:08.912131-06:00"}
{"id":"neo4j-gjj","title":"RED: Record.length - Write failing tests for number of columns","description":"## Overview\nWrite failing tests for the Record.length property that returns number of columns.\n\n## Test Cases to Write\n\n```typescript\ndescribe('Record.length', () =\u003e {\n  it('should return number of columns', () =\u003e {\n    const record = new Record(['name', 'age', 'city'], ['Alice', 30, 'NYC']);\n    expect(record.length).toBe(3);\n  });\n\n  it('should return 0 for empty record', () =\u003e {\n    const record = new Record([], []);\n    expect(record.length).toBe(0);\n  });\n\n  it('should return 1 for single column', () =\u003e {\n    const record = new Record(['name'], ['Alice']);\n    expect(record.length).toBe(1);\n  });\n\n  it('should be read-only', () =\u003e {\n    const record = new Record(['name'], ['Alice']);\n    expect(() =\u003e {\n      (record as any).length = 5;\n    }).toThrow();\n  });\n});\n```\n\n## Acceptance Criteria\n- [ ] All tests written and failing (RED phase)\n- [ ] Tests verify correct count\n- [ ] Tests verify read-only nature\n- [ ] Test file created at src/result/__tests__/record-length.test.ts\n\n## TDD Phase\nRED - Tests should fail because length property does not exist yet","status":"closed","priority":1,"issue_type":"task","created_at":"2026-01-05T06:38:19.294313-06:00","updated_at":"2026-01-05T08:57:33.738174-06:00","closed_at":"2026-01-05T08:57:33.738174-06:00","close_reason":"Record methods already implemented with tests"}
{"id":"neo4j-gkn","title":"REFACTOR: Improve rxSession.run() implementation","description":"## Overview\nRefactor `rxSession.run()` for better code quality and performance.\n\n## Refactoring Tasks\n\n### Code Quality\n- Extract query execution logic\n- Improve parameter validation\n- Add comprehensive type definitions\n- Ensure consistent error handling\n\n### Observable Optimization\n- Optimize cold observable creation\n- Consider shareReplay for repeated access\n- Review subscription management\n\n### Integration\n- Align with sync session.run() where appropriate\n- Share common query execution code\n- Consistent logging/tracing\n\n## Acceptance Criteria\n- [ ] All tests still pass\n- [ ] Clean, maintainable code\n- [ ] Proper TypeScript types\n- [ ] Good performance characteristics","status":"open","priority":2,"issue_type":"task","created_at":"2026-01-05T06:35:18.063497-06:00","updated_at":"2026-01-05T06:35:18.063497-06:00"}
{"id":"neo4j-gqfi","title":"RED: Result async iteration - Write failing tests for for-await-of","description":"## Overview\nWrite failing tests for async iteration support using for-await-of on Result.\n\n## Test Cases to Write\n\n```typescript\ndescribe('Result async iteration', () =\u003e {\n  it('should support for-await-of iteration', async () =\u003e {\n    const result = createMockResult([\n      { name: 'Alice' },\n      { name: 'Bob' }\n    ]);\n    \n    const names: string[] = [];\n    for await (const record of result) {\n      names.push(record.get('name'));\n    }\n    \n    expect(names).toEqual(['Alice', 'Bob']);\n  });\n\n  it('should iterate in order', async () =\u003e {\n    const result = createMockResult([\n      { id: 1 },\n      { id: 2 },\n      { id: 3 }\n    ]);\n    \n    const ids: number[] = [];\n    for await (const record of result) {\n      ids.push(record.get('id'));\n    }\n    \n    expect(ids).toEqual([1, 2, 3]);\n  });\n\n  it('should handle empty results', async () =\u003e {\n    const result = createMockResult([]);\n    \n    const records: Record[] = [];\n    for await (const record of result) {\n      records.push(record);\n    }\n    \n    expect(records).toEqual([]);\n  });\n\n  it('should be consumable only once via iteration', async () =\u003e {\n    const result = createMockResult([{ name: 'Alice' }]);\n    \n    const first: string[] = [];\n    for await (const record of result) {\n      first.push(record.get('name'));\n    }\n    \n    // Second iteration should be empty (stream consumed)\n    // OR should work from buffer (implementation choice)\n    const second: string[] = [];\n    for await (const record of result) {\n      second.push(record.get('name'));\n    }\n    \n    expect(first).toEqual(['Alice']);\n  });\n\n  it('should implement Symbol.asyncIterator', () =\u003e {\n    const result = createMockResult([]);\n    expect(result[Symbol.asyncIterator]).toBeDefined();\n    expect(typeof result[Symbol.asyncIterator]).toBe('function');\n  });\n});\n```\n\n## Acceptance Criteria\n- [ ] All tests written and failing (RED phase)\n- [ ] Tests verify async iteration\n- [ ] Tests verify Symbol.asyncIterator\n- [ ] Test file created at src/result/__tests__/result-iteration.test.ts\n\n## TDD Phase\nRED - Tests should fail because async iteration does not exist yet","status":"closed","priority":1,"issue_type":"task","created_at":"2026-01-05T06:48:01.485311-06:00","updated_at":"2026-01-05T07:19:22.169198-06:00","closed_at":"2026-01-05T07:19:22.169198-06:00","close_reason":"Implemented in this Ralph Wiggum session - 662 tests pass"}
{"id":"neo4j-gqv","title":"RED: Neo4jHttpDriver class instantiation fails without implementation","description":"## Test-Driven Development: RED Phase\n\n### Component\nHTTP Client SDK - Neo4jHttpDriver Class\n\n### Test Cases to Write (Expected to FAIL)\n\n```typescript\nimport { describe, it, expect } from 'vitest'\nimport { Neo4jHttpDriver } from '../src/client/http-driver'\n\ndescribe('Neo4jHttpDriver - RED', () =\u003e {\n  it('should create driver with baseUrl', () =\u003e {\n    const driver = new Neo4jHttpDriver('https://neo4j.do/db/mydb')\n    expect(driver).toBeInstanceOf(Neo4jHttpDriver)\n    expect(driver.baseUrl).toBe('https://neo4j.do/db/mydb')\n  })\n\n  it('should create driver with auth credentials', () =\u003e {\n    const driver = new Neo4jHttpDriver('https://neo4j.do/db/mydb', {\n      auth: { username: 'neo4j', password: 'password' }\n    })\n    expect(driver.isAuthenticated).toBe(true)\n  })\n\n  it('should return HttpSession from session()', () =\u003e {\n    const driver = new Neo4jHttpDriver('https://neo4j.do/db/mydb')\n    const session = driver.session()\n    expect(session).toBeInstanceOf(HttpSession)\n  })\n\n  it('should execute query via HTTP', async () =\u003e {\n    const driver = new Neo4jHttpDriver('https://neo4j.do/db/mydb')\n    const result = await driver.executeQuery('RETURN 1 as n')\n    expect(result.records).toHaveLength(1)\n    expect(result.records[0].get('n')).toBe(1)\n  })\n\n  it('should get server info via HTTP', async () =\u003e {\n    const driver = new Neo4jHttpDriver('https://neo4j.do/db/mydb')\n    const info = await driver.getServerInfo()\n    expect(info.address).toBeDefined()\n    expect(info.protocolVersion).toBeDefined()\n  })\n\n  it('should close driver and cleanup resources', async () =\u003e {\n    const driver = new Neo4jHttpDriver('https://neo4j.do/db/mydb')\n    await driver.close()\n    expect(driver.isClosed).toBe(true)\n  })\n\n  it('should support optional connection pooling', () =\u003e {\n    const driver = new Neo4jHttpDriver('https://neo4j.do/db/mydb', {\n      maxConnectionPoolSize: 10\n    })\n    expect(driver.config.maxConnectionPoolSize).toBe(10)\n  })\n})\n```\n\n### Acceptance Criteria\n- [ ] Test file created at `tests/client/http-driver.test.ts`\n- [ ] All tests fail with `module not found` or `class not defined`\n- [ ] Tests cover: instantiation, session creation, query execution, server info, close, pooling\n\n### TDD Cycle\nThis is the RED phase. Next: GREEN phase implementation.","status":"open","priority":2,"issue_type":"task","created_at":"2026-01-05T06:34:28.34202-06:00","updated_at":"2026-01-05T06:34:28.34202-06:00"}
{"id":"neo4j-gu28","title":"RED: AgentFS - Write failing tests for virtual filesystem interface","description":"## Overview\nWrite failing tests for AgentFS - a virtual filesystem interface to graph data.\n\n## Test Cases\n\n```typescript\ndescribe('AgentFS - Virtual Filesystem', () =\u003e {\n  describe('Directory Structure (Labels)', () =\u003e {\n    it('should list labels as directories in root', async () =\u003e {\n      const listing = await agentfs.readdir('/');\n      \n      expect(listing).toContain('Person');\n      expect(listing).toContain('Company');\n      expect(listing).toContain('Article');\n    });\n\n    it('should list nodes as files within label directory', async () =\u003e {\n      const listing = await agentfs.readdir('/Person');\n      \n      // Files named by node ID or unique property\n      expect(listing).toContain('alice.json');\n      expect(listing).toContain('bob.json');\n    });\n\n    it('should support stat on directories', async () =\u003e {\n      const stat = await agentfs.stat('/Person');\n      \n      expect(stat.isDirectory()).toBe(true);\n      expect(stat.size).toBeGreaterThan(0); // Node count\n    });\n  });\n\n  describe('File Operations (Nodes)', () =\u003e {\n    it('should read node as JSON file', async () =\u003e {\n      const content = await agentfs.readFile('/Person/alice.json');\n      const node = JSON.parse(content);\n      \n      expect(node.name).toBe('Alice');\n      expect(node._labels).toContain('Person');\n      expect(node._id).toBeDefined();\n    });\n\n    it('should support stat on node files', async () =\u003e {\n      const stat = await agentfs.stat('/Person/alice.json');\n      \n      expect(stat.isFile()).toBe(true);\n      expect(stat.mtime).toBeDefined(); // Last modified\n    });\n\n    it('should create node via file write', async () =\u003e {\n      await agentfs.writeFile('/Person/carol.json', JSON.stringify({\n        name: 'Carol',\n        age: 28\n      }));\n      \n      const content = await agentfs.readFile('/Person/carol.json');\n      expect(JSON.parse(content).name).toBe('Carol');\n    });\n\n    it('should update node via file write', async () =\u003e {\n      const current = JSON.parse(await agentfs.readFile('/Person/alice.json'));\n      current.age = 31;\n      \n      await agentfs.writeFile('/Person/alice.json', JSON.stringify(current));\n      \n      const updated = JSON.parse(await agentfs.readFile('/Person/alice.json'));\n      expect(updated.age).toBe(31);\n    });\n\n    it('should delete node via unlink', async () =\u003e {\n      await agentfs.writeFile('/Person/temp.json', JSON.stringify({ name: 'Temp' }));\n      await agentfs.unlink('/Person/temp.json');\n      \n      await expect(agentfs.stat('/Person/temp.json')).rejects.toThrow(/ENOENT/);\n    });\n  });\n\n  describe('Relationship Traversal (Paths)', () =\u003e {\n    it('should traverse outgoing relationships as subdirectories', async () =\u003e {\n      const listing = await agentfs.readdir('/Person/alice/WORKS_AT');\n      \n      expect(listing).toContain('techcorp.json');\n    });\n\n    it('should traverse incoming relationships with ~ prefix', async () =\u003e {\n      const listing = await agentfs.readdir('/Company/techcorp/~WORKS_AT');\n      \n      expect(listing).toContain('alice.json');\n      expect(listing).toContain('bob.json');\n    });\n\n    it('should support deep path traversal', async () =\u003e {\n      // Alice -\u003e WORKS_AT -\u003e TechCorp \u003c- WORKS_AT \u003c- Bob\n      const content = await agentfs.readFile('/Person/alice/WORKS_AT/techcorp/~WORKS_AT/bob.json');\n      const bob = JSON.parse(content);\n      \n      expect(bob.name).toBe('Bob');\n    });\n\n    it('should read relationship properties', async () =\u003e {\n      const content = await agentfs.readFile('/Person/alice/WORKS_AT/techcorp.rel.json');\n      const rel = JSON.parse(content);\n      \n      expect(rel.since).toBeDefined();\n      expect(rel._type).toBe('WORKS_AT');\n    });\n  });\n\n  describe('Create Relationships via Filesystem', () =\u003e {\n    it('should create relationship via mkdir', async () =\u003e {\n      await agentfs.mkdir('/Person/alice/KNOWS');\n      await agentfs.symlink('/Person/carol', '/Person/alice/KNOWS/carol');\n      \n      const listing = await agentfs.readdir('/Person/alice/KNOWS');\n      expect(listing).toContain('carol.json');\n    });\n\n    it('should create relationship with properties', async () =\u003e {\n      await agentfs.writeFile('/Person/alice/KNOWS/carol.rel.json', JSON.stringify({\n        since: '2024-01-01',\n        context: 'conference'\n      }));\n      \n      const rel = JSON.parse(await agentfs.readFile('/Person/alice/KNOWS/carol.rel.json'));\n      expect(rel.since).toBe('2024-01-01');\n    });\n  });\n\n  describe('Search Operations', () =\u003e {\n    it('should support glob patterns', async () =\u003e {\n      const matches = await agentfs.glob('/Person/*.json');\n      \n      expect(matches.length).toBeGreaterThan(0);\n      expect(matches.every(m =\u003e m.endsWith('.json'))).toBe(true);\n    });\n\n    it('should support find with filters', async () =\u003e {\n      const matches = await agentfs.find('/Person', {\n        where: { age: { gte: 25 } }\n      });\n      \n      expect(matches.length).toBeGreaterThan(0);\n    });\n  });\n\n  describe('Special Directories', () =\u003e {\n    it('should expose schema at /.schema', async () =\u003e {\n      const schema = JSON.parse(await agentfs.readFile('/.schema/labels.json'));\n      \n      expect(schema).toContain('Person');\n    });\n\n    it('should expose indexes at /.indexes', async () =\u003e {\n      const listing = await agentfs.readdir('/.indexes');\n      \n      expect(listing).toContain('vector');\n      expect(listing).toContain('fulltext');\n    });\n\n    it('should expose query interface at /.query', async () =\u003e {\n      await agentfs.writeFile('/.query/run', 'MATCH (p:Person) RETURN p.name LIMIT 5');\n      const result = JSON.parse(await agentfs.readFile('/.query/result'));\n      \n      expect(Array.isArray(result.records)).toBe(true);\n    });\n  });\n\n  describe('Watch for Changes', () =\u003e {\n    it('should emit events on node changes', async () =\u003e {\n      const events: any[] = [];\n      const watcher = agentfs.watch('/Person', (event) =\u003e events.push(event));\n      \n      await agentfs.writeFile('/Person/new.json', JSON.stringify({ name: 'New' }));\n      \n      expect(events).toContainEqual(expect.objectContaining({\n        type: 'create',\n        path: '/Person/new.json'\n      }));\n      \n      watcher.close();\n    });\n  });\n});\n```\n\n## Acceptance Criteria\n- [ ] All test cases written and failing\n- [ ] AgentFS interface defined\n- [ ] POSIX-like semantics documented\n\n## Tags\nsuperset, agentfs, virtual-filesystem, ai-agents, tdd-red","status":"open","priority":2,"issue_type":"task","created_at":"2026-01-05T06:41:32.807641-06:00","updated_at":"2026-01-05T06:41:32.807641-06:00"}
{"id":"neo4j-gz28","title":"GREEN: Implement cold Observable semantics","description":"## Overview\nImplement proper cold Observable semantics to make all RED tests pass.\n\n## Implementation Requirements\n\n### Cold Observable Behavior\n- Defer execution until subscribe\n- Fresh execution per subscriber\n- Independent results\n- Cancel on unsubscribe\n\n### Implementation Details\n- Use defer() or create()\n- Don't cache results by default\n- Execute query on subscribe\n- Clean slate per subscription\n\n### Hot Transformation Support\n- Allow share() operator\n- Allow shareReplay()\n- Document multicast patterns\n\n## Acceptance Criteria\n- All RED tests now pass (GREEN phase)\n- All Observables are cold by default\n- Hot transformation works\n- Behavior well-defined","status":"open","priority":2,"issue_type":"task","created_at":"2026-01-05T06:45:10.02552-06:00","updated_at":"2026-01-05T06:45:10.02552-06:00"}
{"id":"neo4j-h1uy","title":"RED: Write failing tests for subscription handling","description":"## Overview\nWrite failing tests for proper RxJS subscription handling.\n\n## Test Cases to Write\n\n### Basic Subscription Tests\n- subscribe() starts execution\n- Subscriber receives emissions\n- Complete callback called on finish\n- Error callback called on failure\n\n### Subscription Management\n- unsubscribe() cancels execution\n- Subscription.closed reflects state\n- Multiple subscriptions independent\n- Late subscriptions work correctly\n\n### Execution Semantics\n- Cold observables start fresh each subscription\n- Query not executed without subscription\n- Resources allocated on subscribe\n- Resources released on unsubscribe\n\n### Memory Management\n- No memory leaks on unsubscribe\n- Proper cleanup of pending operations\n- Resources released after complete\n- Resources released after error\n\n## Acceptance Criteria\n- All tests written and failing (RED phase)\n- Tests verify subscription lifecycle\n- Tests cover cleanup scenarios\n- Tests verify memory management","status":"open","priority":2,"issue_type":"task","created_at":"2026-01-05T06:42:47.808703-06:00","updated_at":"2026-01-05T06:42:47.808703-06:00"}
{"id":"neo4j-ha2","title":"RED: Record.toObject() - Write failing tests for converting to plain object","description":"## Overview\nWrite failing tests for the Record.toObject() method that converts a record to a plain JavaScript object.\n\n## Test Cases to Write\n\n```typescript\ndescribe('Record.toObject()', () =\u003e {\n  it('should convert record to plain object', () =\u003e {\n    const record = new Record(['name', 'age'], ['Alice', 30]);\n    expect(record.toObject()).toEqual({ name: 'Alice', age: 30 });\n  });\n\n  it('should handle empty record', () =\u003e {\n    const record = new Record([], []);\n    expect(record.toObject()).toEqual({});\n  });\n\n  it('should preserve null values', () =\u003e {\n    const record = new Record(['name', 'email'], ['Alice', null]);\n    expect(record.toObject()).toEqual({ name: 'Alice', email: null });\n  });\n\n  it('should preserve complex Neo4j types', () =\u003e {\n    const node = new Node(1, ['Person'], { name: 'Alice' });\n    const record = new Record(['person'], [node]);\n    const obj = record.toObject();\n    expect(obj.person).toBe(node);\n  });\n\n  it('should return a new object each time', () =\u003e {\n    const record = new Record(['name'], ['Alice']);\n    const obj1 = record.toObject();\n    const obj2 = record.toObject();\n    expect(obj1).not.toBe(obj2);\n    expect(obj1).toEqual(obj2);\n  });\n});\n```\n\n## Acceptance Criteria\n- [ ] All tests written and failing (RED phase)\n- [ ] Tests cover object conversion scenarios\n- [ ] Tests verify immutability\n- [ ] Test file created at src/result/__tests__/record-to-object.test.ts\n\n## TDD Phase\nRED - Tests should fail because toObject method does not exist yet","status":"closed","priority":1,"issue_type":"task","created_at":"2026-01-05T06:36:48.53671-06:00","updated_at":"2026-01-05T08:54:14.034199-06:00","closed_at":"2026-01-05T08:54:14.034199-06:00","close_reason":"Tests passing - implementation complete"}
{"id":"neo4j-hdy3","title":"RED: MCP Server - Write failing tests for Model Context Protocol integration","description":"## Overview\nWrite failing tests for MCP (Model Context Protocol) server implementation.\n\n## Test Cases\n\n```typescript\ndescribe('MCP Server', () =\u003e {\n  let mcpClient: MCPClient;\n\n  beforeAll(async () =\u003e {\n    mcpClient = await MCPClient.connect('http://localhost:8787/mcp');\n  });\n\n  describe('Schema Introspection Tool', () =\u003e {\n    it('should list all node labels', async () =\u003e {\n      const result = await mcpClient.callTool('graph_schema', { type: 'labels' });\n      \n      expect(result.labels).toContain('Person');\n      expect(result.labels).toContain('Company');\n    });\n\n    it('should list all relationship types', async () =\u003e {\n      const result = await mcpClient.callTool('graph_schema', { type: 'relationships' });\n      \n      expect(result.relationships).toContain('WORKS_AT');\n      expect(result.relationships).toContain('KNOWS');\n    });\n\n    it('should return property schema for label', async () =\u003e {\n      const result = await mcpClient.callTool('graph_schema', { \n        type: 'properties',\n        label: 'Person'\n      });\n      \n      expect(result.properties).toContainEqual({\n        name: 'name',\n        type: 'string',\n        required: true\n      });\n    });\n\n    it('should return full graph schema', async () =\u003e {\n      const result = await mcpClient.callTool('graph_schema', { type: 'full' });\n      \n      expect(result.nodes).toBeDefined();\n      expect(result.relationships).toBeDefined();\n      expect(result.indexes).toBeDefined();\n    });\n  });\n\n  describe('Query Execution Tool', () =\u003e {\n    it('should execute read queries', async () =\u003e {\n      const result = await mcpClient.callTool('execute_cypher', {\n        query: 'MATCH (p:Person) RETURN p.name LIMIT 5'\n      });\n      \n      expect(result.records).toBeDefined();\n      expect(Array.isArray(result.records)).toBe(true);\n    });\n\n    it('should execute parameterized queries', async () =\u003e {\n      const result = await mcpClient.callTool('execute_cypher', {\n        query: 'MATCH (p:Person {name: $name}) RETURN p',\n        parameters: { name: 'Alice' }\n      });\n      \n      expect(result.records[0].p.properties.name).toBe('Alice');\n    });\n\n    it('should reject write queries by default', async () =\u003e {\n      await expect(mcpClient.callTool('execute_cypher', {\n        query: 'CREATE (p:Person {name: \"Hacker\"}) RETURN p'\n      })).rejects.toThrow(/write operations not allowed/);\n    });\n\n    it('should allow write queries with permission', async () =\u003e {\n      const result = await mcpClient.callTool('execute_cypher', {\n        query: 'CREATE (p:Person {name: \"NewPerson\"}) RETURN p',\n        allowWrites: true\n      });\n      \n      expect(result.records[0].p.properties.name).toBe('NewPerson');\n    });\n  });\n\n  describe('Node CRUD Tools', () =\u003e {\n    it('should create node', async () =\u003e {\n      const result = await mcpClient.callTool('create_node', {\n        labels: ['Person'],\n        properties: { name: 'Bob', age: 30 }\n      });\n      \n      expect(result.node.labels).toContain('Person');\n      expect(result.node.properties.name).toBe('Bob');\n    });\n\n    it('should read node by ID', async () =\u003e {\n      const result = await mcpClient.callTool('get_node', {\n        id: 'node-123'\n      });\n      \n      expect(result.node).toBeDefined();\n    });\n\n    it('should update node properties', async () =\u003e {\n      const result = await mcpClient.callTool('update_node', {\n        id: 'node-123',\n        properties: { age: 31 }\n      });\n      \n      expect(result.node.properties.age).toBe(31);\n    });\n\n    it('should delete node', async () =\u003e {\n      const result = await mcpClient.callTool('delete_node', {\n        id: 'node-123'\n      });\n      \n      expect(result.success).toBe(true);\n    });\n\n    it('should find nodes by label and properties', async () =\u003e {\n      const result = await mcpClient.callTool('find_nodes', {\n        label: 'Person',\n        where: { age: { gte: 25 } },\n        limit: 10\n      });\n      \n      expect(Array.isArray(result.nodes)).toBe(true);\n    });\n  });\n\n  describe('Relationship CRUD Tools', () =\u003e {\n    it('should create relationship', async () =\u003e {\n      const result = await mcpClient.callTool('create_relationship', {\n        startNodeId: 'node-1',\n        endNodeId: 'node-2',\n        type: 'KNOWS',\n        properties: { since: '2024-01-01' }\n      });\n      \n      expect(result.relationship.type).toBe('KNOWS');\n    });\n\n    it('should find relationships', async () =\u003e {\n      const result = await mcpClient.callTool('find_relationships', {\n        type: 'WORKS_AT',\n        startLabel: 'Person',\n        endLabel: 'Company'\n      });\n      \n      expect(Array.isArray(result.relationships)).toBe(true);\n    });\n  });\n\n  describe('Search Tools', () =\u003e {\n    it('should perform vector search', async () =\u003e {\n      const result = await mcpClient.callTool('vector_search', {\n        index: 'articles',\n        query: 'machine learning concepts',\n        k: 5\n      });\n      \n      expect(result.results).toHaveLength(5);\n      expect(result.results[0].score).toBeDefined();\n    });\n\n    it('should perform full-text search', async () =\u003e {\n      const result = await mcpClient.callTool('fulltext_search', {\n        index: 'articles',\n        query: 'graph database',\n        limit: 10\n      });\n      \n      expect(Array.isArray(result.results)).toBe(true);\n    });\n  });\n\n  describe('Resource Exposure', () =\u003e {\n    it('should list available resources', async () =\u003e {\n      const resources = await mcpClient.listResources();\n      \n      expect(resources).toContainEqual({\n        uri: 'neo4j://schema',\n        name: 'Graph Schema',\n        mimeType: 'application/json'\n      });\n    });\n\n    it('should read schema resource', async () =\u003e {\n      const resource = await mcpClient.readResource('neo4j://schema');\n      \n      expect(resource.contents[0].mimeType).toBe('application/json');\n      expect(JSON.parse(resource.contents[0].text).nodes).toBeDefined();\n    });\n\n    it('should expose node collections as resources', async () =\u003e {\n      const resource = await mcpClient.readResource('neo4j://nodes/Person');\n      \n      expect(resource.contents[0].mimeType).toBe('application/json');\n    });\n  });\n\n  describe('Prompts', () =\u003e {\n    it('should provide query generation prompt', async () =\u003e {\n      const prompts = await mcpClient.listPrompts();\n      \n      expect(prompts).toContainEqual({\n        name: 'generate_cypher',\n        description: 'Generate Cypher query from natural language'\n      });\n    });\n\n    it('should execute prompt with arguments', async () =\u003e {\n      const result = await mcpClient.getPrompt('generate_cypher', {\n        question: 'Find all people who work at Google'\n      });\n      \n      expect(result.messages[0].content.text).toContain('MATCH');\n    });\n  });\n});\n```\n\n## Acceptance Criteria\n- [ ] All test cases written and failing\n- [ ] MCP client test infrastructure\n- [ ] Mock server for testing\n\n## Tags\nsuperset, mcp, model-context-protocol, ai-agents, tdd-red","status":"open","priority":2,"issue_type":"task","created_at":"2026-01-05T06:39:59.655289-06:00","updated_at":"2026-01-05T06:39:59.655289-06:00"}
{"id":"neo4j-hebo","title":"GREEN: DELETE Translation","description":"## Overview\nImplement DELETE clause translation to make RED tests pass.\n\n## Implementation Tasks\n\n### 1. DeleteClauseTranslator\n- translateDeleteNode(): DELETE with relationship check\n- translateDeleteRelationship(): Simple DELETE\n- translateDetachDelete(): Two-phase deletion\n\n### 2. Relationship Check\n- Query for connected relationships before node delete\n- Throw error if relationships exist and not DETACH\n\n### 3. Detach Delete Implementation\n- DELETE FROM relationships WHERE start_node_id = ? OR end_node_id = ?\n- DELETE FROM nodes WHERE id = ?\n\n### 4. Batch Delete\n- Optimize deletion of multiple entities\n- Use IN clause for batch operations\n\n## Files to Create/Modify\n- src/cypher/translator/delete-clause-translator.ts\n- src/cypher/translator/integrity-checker.ts\n\n## Acceptance Criteria\n- All RED phase tests pass\n- DETACH DELETE works correctly\n- Integrity constraints enforced\n\n## TDD Phase\nGREEN - Make tests pass with minimal code\n\n## Dependencies\n- Depends on: RED: DELETE Translation","status":"closed","priority":1,"issue_type":"task","created_at":"2026-01-05T06:40:15.42353-06:00","updated_at":"2026-01-05T08:55:39.253531-06:00","closed_at":"2026-01-05T08:55:39.253531-06:00","close_reason":"Translation already implemented with tests"}
{"id":"neo4j-hiij","title":"[RED] Integration Tests: kafka.do (CDC)","description":"# [RED] Integration Tests: kafka.do (CDC)\n\n## Overview\nIntegration tests for neo4j.do Change Data Capture (CDC) integration with kafka.do for real-time event streaming.\n\n## CDC Event Types\n\n### Graph Change Events\n```typescript\ninterface NodeCreatedEvent {\n  type: 'NODE_CREATED'\n  timestamp: number\n  transactionId: string\n  node: {\n    id: string\n    labels: string[]\n    properties: Record\u003cstring, any\u003e\n  }\n}\n\ninterface NodeUpdatedEvent {\n  type: 'NODE_UPDATED'\n  timestamp: number\n  transactionId: string\n  node: {\n    id: string\n    labels: string[]\n    before: Record\u003cstring, any\u003e\n    after: Record\u003cstring, any\u003e\n  }\n}\n\ninterface NodeDeletedEvent {\n  type: 'NODE_DELETED'\n  timestamp: number\n  transactionId: string\n  node: {\n    id: string\n    labels: string[]\n    properties: Record\u003cstring, any\u003e\n  }\n}\n\ninterface RelationshipCreatedEvent {\n  type: 'RELATIONSHIP_CREATED'\n  timestamp: number\n  transactionId: string\n  relationship: {\n    id: string\n    type: string\n    startNodeId: string\n    endNodeId: string\n    properties: Record\u003cstring, any\u003e\n  }\n}\n```\n\n## Test Scenarios\n\n### Event Publishing\n```typescript\ndescribe('CDC Event Publishing', () =\u003e {\n  let kafkaConsumer: KafkaConsumer\n  let receivedEvents: CDCEvent[]\n\n  beforeAll(async () =\u003e {\n    kafkaConsumer = new KafkaConsumer({\n      brokers: ['kafka.do'],\n      groupId: 'neo4j-cdc-test'\n    })\n    \n    receivedEvents = []\n    await kafkaConsumer.subscribe({ topic: 'neo4j.do.cdc' })\n    kafkaConsumer.on('message', (event) =\u003e {\n      receivedEvents.push(JSON.parse(event.value))\n    })\n  })\n\n  it('should publish NODE_CREATED event', async () =\u003e {\n    receivedEvents = []\n    \n    await session.run('CREATE (n:CDCTest {name: \"TestNode\"})')\n    \n    // Wait for event\n    await waitFor(() =\u003e receivedEvents.length \u003e 0, { timeout: 5000 })\n    \n    const event = receivedEvents.find(e =\u003e e.type === 'NODE_CREATED')\n    expect(event).toBeDefined()\n    expect(event?.node.labels).toContain('CDCTest')\n    expect(event?.node.properties.name).toBe('TestNode')\n  })\n\n  it('should publish NODE_UPDATED event with before/after', async () =\u003e {\n    await session.run('CREATE (n:CDCUpdate {value: 1})')\n    receivedEvents = []\n    \n    await session.run('MATCH (n:CDCUpdate) SET n.value = 2')\n    \n    await waitFor(() =\u003e receivedEvents.some(e =\u003e e.type === 'NODE_UPDATED'))\n    \n    const event = receivedEvents.find(e =\u003e e.type === 'NODE_UPDATED')\n    expect(event?.node.before.value).toBe(1)\n    expect(event?.node.after.value).toBe(2)\n  })\n\n  it('should publish NODE_DELETED event', async () =\u003e {\n    await session.run('CREATE (n:CDCDelete {id: 1})')\n    receivedEvents = []\n    \n    await session.run('MATCH (n:CDCDelete) DELETE n')\n    \n    await waitFor(() =\u003e receivedEvents.some(e =\u003e e.type === 'NODE_DELETED'))\n    \n    const event = receivedEvents.find(e =\u003e e.type === 'NODE_DELETED')\n    expect(event?.node.labels).toContain('CDCDelete')\n  })\n\n  it('should publish RELATIONSHIP_CREATED event', async () =\u003e {\n    await session.run(`\n      CREATE (a:CDCRel {id: 'a'}), (b:CDCRel {id: 'b'})\n    `)\n    receivedEvents = []\n    \n    await session.run(`\n      MATCH (a:CDCRel {id: 'a'}), (b:CDCRel {id: 'b'})\n      CREATE (a)-[:CONNECTED {weight: 10}]-\u003e(b)\n    `)\n    \n    await waitFor(() =\u003e receivedEvents.some(e =\u003e e.type === 'RELATIONSHIP_CREATED'))\n    \n    const event = receivedEvents.find(e =\u003e e.type === 'RELATIONSHIP_CREATED')\n    expect(event?.relationship.type).toBe('CONNECTED')\n    expect(event?.relationship.properties.weight).toBe(10)\n  })\n\n  it('should batch events within transaction', async () =\u003e {\n    receivedEvents = []\n    \n    await session.executeWrite(async tx =\u003e {\n      await tx.run('CREATE (a:Batch {id: 1})')\n      await tx.run('CREATE (b:Batch {id: 2})')\n      await tx.run(`\n        MATCH (a:Batch {id: 1}), (b:Batch {id: 2})\n        CREATE (a)-[:BATCH_REL]-\u003e(b)\n      `)\n    })\n    \n    await waitFor(() =\u003e receivedEvents.length \u003e= 3)\n    \n    // All events should have same transactionId\n    const txIds = [...new Set(receivedEvents.map(e =\u003e e.transactionId))]\n    expect(txIds).toHaveLength(1)\n  })\n})\n```\n\n### Event Consumption\n```typescript\ndescribe('CDC Event Consumption', () =\u003e {\n  let kafkaProducer: KafkaProducer\n\n  beforeAll(async () =\u003e {\n    kafkaProducer = new KafkaProducer({\n      brokers: ['kafka.do']\n    })\n  })\n\n  it('should process external events to create nodes', async () =\u003e {\n    // Simulate external system publishing event\n    await kafkaProducer.send({\n      topic: 'external.events',\n      messages: [{\n        value: JSON.stringify({\n          type: 'USER_REGISTERED',\n          userId: 'ext-123',\n          name: 'External User'\n        })\n      }]\n    })\n    \n    // neo4j.do consumer should create node\n    await waitFor(async () =\u003e {\n      const result = await session.run(`\n        MATCH (u:ExternalUser {externalId: 'ext-123'})\n        RETURN u\n      `)\n      return result.records.length \u003e 0\n    })\n  })\n\n  it('should process relationship events from external systems', async () =\u003e {\n    // Setup nodes\n    await session.run(`\n      CREATE (:ExtNode {id: 'a'}), (:ExtNode {id: 'b'})\n    `)\n    \n    // External event creates relationship\n    await kafkaProducer.send({\n      topic: 'external.relationships',\n      messages: [{\n        value: JSON.stringify({\n          type: 'NODES_CONNECTED',\n          sourceId: 'a',\n          targetId: 'b',\n          relationType: 'EXTERNAL_REL'\n        })\n      }]\n    })\n    \n    await waitFor(async () =\u003e {\n      const result = await session.run(`\n        MATCH (:ExtNode {id: 'a'})-[r:EXTERNAL_REL]-\u003e(:ExtNode {id: 'b'})\n        RETURN r\n      `)\n      return result.records.length \u003e 0\n    })\n  })\n})\n```\n\n### Event Ordering and Guarantees\n```typescript\ndescribe('CDC Ordering and Guarantees', () =\u003e {\n  it('should maintain event ordering within partition', async () =\u003e {\n    const events: CDCEvent[] = []\n    \n    // Subscribe to partition\n    await kafkaConsumer.subscribe({\n      topic: 'neo4j.do.cdc',\n      partition: 0\n    })\n    \n    kafkaConsumer.on('message', e =\u003e events.push(JSON.parse(e.value)))\n    \n    // Create sequence of changes\n    await session.run('CREATE (n:OrderTest {seq: 1})')\n    await session.run('MATCH (n:OrderTest) SET n.seq = 2')\n    await session.run('MATCH (n:OrderTest) SET n.seq = 3')\n    \n    await waitFor(() =\u003e events.length \u003e= 3)\n    \n    // Events should be in order\n    const timestamps = events.map(e =\u003e e.timestamp)\n    expect(timestamps).toEqual([...timestamps].sort())\n  })\n\n  it('should provide at-least-once delivery', async () =\u003e {\n    // Test that events are not lost even if consumer fails mid-processing\n    // This requires consumer restart simulation\n  })\n\n  it('should include transaction boundaries', async () =\u003e {\n    const events: CDCEvent[] = []\n    kafkaConsumer.on('message', e =\u003e events.push(JSON.parse(e.value)))\n    \n    await session.executeWrite(async tx =\u003e {\n      await tx.run('CREATE (n:TxBoundary {id: 1})')\n      await tx.run('CREATE (n:TxBoundary {id: 2})')\n    })\n    \n    await waitFor(() =\u003e events.filter(e =\u003e \n      e.node?.labels?.includes('TxBoundary')\n    ).length \u003e= 2)\n    \n    const txEvents = events.filter(e =\u003e e.node?.labels?.includes('TxBoundary'))\n    const txId = txEvents[0].transactionId\n    \n    expect(txEvents.every(e =\u003e e.transactionId === txId)).toBe(true)\n  })\n})\n```\n\n### Filter and Transform\n```typescript\ndescribe('CDC Filtering', () =\u003e {\n  it('should filter events by label', async () =\u003e {\n    // Configure CDC to only emit events for certain labels\n    await configureCDC({\n      includeLabels: ['Important'],\n      excludeLabels: ['Internal']\n    })\n    \n    const events: CDCEvent[] = []\n    kafkaConsumer.on('message', e =\u003e events.push(JSON.parse(e.value)))\n    \n    await session.run('CREATE (n:Important {data: 1})')\n    await session.run('CREATE (n:Internal {data: 2})')\n    \n    await new Promise(r =\u003e setTimeout(r, 2000))\n    \n    expect(events.some(e =\u003e e.node?.labels?.includes('Important'))).toBe(true)\n    expect(events.some(e =\u003e e.node?.labels?.includes('Internal'))).toBe(false)\n  })\n\n  it('should filter events by property', async () =\u003e {\n    await configureCDC({\n      excludeProperties: ['password', 'secret']\n    })\n    \n    const events: CDCEvent[] = []\n    kafkaConsumer.on('message', e =\u003e events.push(JSON.parse(e.value)))\n    \n    await session.run(`\n      CREATE (u:User {name: 'Test', password: 'secret123'})\n    `)\n    \n    await waitFor(() =\u003e events.some(e =\u003e e.node?.labels?.includes('User')))\n    \n    const userEvent = events.find(e =\u003e e.node?.labels?.includes('User'))\n    expect(userEvent?.node.properties.name).toBe('Test')\n    expect(userEvent?.node.properties.password).toBeUndefined()\n  })\n})\n```\n\n## Configuration\n```typescript\nconst cdcConfig = {\n  kafka: {\n    brokers: ['kafka.do'],\n    topic: 'neo4j.do.cdc',\n    partitions: 3,\n    replicationFactor: 1\n  },\n  cdc: {\n    enabled: true,\n    includeLabels: [], // Empty = all\n    excludeLabels: ['_internal'],\n    excludeProperties: ['password', 'token'],\n    batchSize: 100,\n    flushIntervalMs: 1000\n  }\n}\n```\n\n## Acceptance Criteria\n- [ ] Event publishing tests written\n- [ ] Event consumption tests written\n- [ ] Ordering guarantee tests written\n- [ ] Filter/transform tests written\n- [ ] Configuration documented\n- [ ] Tests fail initially (RED phase)","status":"open","priority":3,"issue_type":"task","created_at":"2026-01-05T06:51:30.915875-06:00","updated_at":"2026-01-05T06:51:30.915875-06:00"}
{"id":"neo4j-hupw","title":"REFACTOR: Record.has(key) - Document and verify performance","description":"## Overview\nRefactor the Record.has(key) method with documentation and performance verification.\n\n## Refactoring Tasks\n\n1. **Documentation**\n   - Add JSDoc comments\n   - Document O(1) lookup guarantee\n\n2. **Performance**\n   - Verify Map.has is optimal\n   - Add performance test\n\n## Acceptance Criteria\n- [ ] All tests still pass after refactoring\n- [ ] Code is well-documented\n- [ ] Performance characteristics documented\n\n## TDD Phase\nREFACTOR - Improve code without changing behavior\n\n## Dependencies\n- neo4j-0yo (GREEN phase implementation)","status":"closed","priority":1,"issue_type":"task","created_at":"2026-01-05T06:39:21.187762-06:00","updated_at":"2026-01-05T08:55:15.891923-06:00","closed_at":"2026-01-05T08:55:15.891923-06:00","close_reason":"Record methods already implemented with tests"}
{"id":"neo4j-hzo","title":"GREEN: Pattern to JOIN Translation - Single Node Pattern","description":"## Overview\nImplement single node pattern translation to make RED tests pass.\n\n## Implementation Tasks\n\n### 1. Create PatternTranslator Class\n```typescript\nclass PatternTranslator {\n  translateNodePattern(node: NodePattern): SQLFragment {\n    // Generate SELECT from nodes table\n    // Handle variable binding\n    // Generate label WHERE clause\n    // Generate property WHERE clauses\n  }\n}\n```\n\n### 2. Implement Label Filtering\n```typescript\nprivate translateLabelFilter(labels: string[]): string {\n  // Single label: label = 'Person'\n  // Multiple labels: label IN ('Person', 'Employee') or AND\n}\n```\n\n### 3. Implement Property Filtering\n```typescript\nprivate translatePropertyFilter(props: Map\u003cstring, any\u003e): string {\n  // json_extract(properties, '$.name') = 'Alice'\n}\n```\n\n### 4. Variable Binding Registry\n```typescript\nclass VariableRegistry {\n  bind(name: string, tableAlias: string): void;\n  resolve(name: string): string;\n}\n```\n\n## Files to Create/Modify\n- `src/cypher/translator/pattern-translator.ts`\n- `src/cypher/translator/variable-registry.ts`\n- `src/cypher/translator/sql-fragment.ts`\n\n## Acceptance Criteria\n- [ ] All RED phase tests pass\n- [ ] Minimal implementation (no over-engineering)\n- [ ] Code compiles without errors\n\n## TDD Phase\nGREEN - Make tests pass with minimal code\n\n## Dependencies\n- Depends on: RED: Pattern to JOIN Translation - Single Node Pattern","status":"closed","priority":1,"issue_type":"task","created_at":"2026-01-05T06:34:45.630881-06:00","updated_at":"2026-01-05T07:46:37.195762-06:00","closed_at":"2026-01-05T07:46:37.195762-06:00","close_reason":"Completed in Ralph Wiggum session - 987 tests pass"}
{"id":"neo4j-i2k","title":"RED: Record.get(key) - Write failing tests for getting value by column name","description":"## Overview\nWrite failing tests for the Record.get(key) method that retrieves values by column name.\n\n## Test Cases to Write\n\n```typescript\ndescribe('Record.get(key)', () =\u003e {\n  it('should return value for existing column name', () =\u003e {\n    const record = new Record(['name', 'age'], ['Alice', 30]);\n    expect(record.get('name')).toBe('Alice');\n    expect(record.get('age')).toBe(30);\n  });\n\n  it('should return undefined for non-existent column', () =\u003e {\n    const record = new Record(['name'], ['Alice']);\n    expect(record.get('missing')).toBeUndefined();\n  });\n\n  it('should handle null values', () =\u003e {\n    const record = new Record(['name', 'email'], ['Alice', null]);\n    expect(record.get('email')).toBeNull();\n  });\n\n  it('should handle complex types (Node, Relationship, etc.)', () =\u003e {\n    const node = new Node(1, ['Person'], { name: 'Alice' });\n    const record = new Record(['person'], [node]);\n    expect(record.get('person')).toBe(node);\n  });\n\n  it('should be case-sensitive for column names', () =\u003e {\n    const record = new Record(['Name', 'name'], ['Alice', 'Bob']);\n    expect(record.get('Name')).toBe('Alice');\n    expect(record.get('name')).toBe('Bob');\n  });\n});\n```\n\n## Acceptance Criteria\n- [ ] All tests written and failing (RED phase)\n- [ ] Tests cover happy path and edge cases\n- [ ] Tests follow Neo4j driver API behavior\n- [ ] Test file created at `src/result/__tests__/record-get-key.test.ts`\n\n## TDD Phase\nRED - Tests should fail because Record class doesn't exist yet","status":"closed","priority":1,"issue_type":"task","created_at":"2026-01-05T06:34:26.829198-06:00","updated_at":"2026-01-05T07:14:26.740345-06:00","closed_at":"2026-01-05T07:14:26.740345-06:00","close_reason":"Record.get implemented with tests passing"}
{"id":"neo4j-i70y","title":"[GREEN] Index Management - Implement index operations to pass tests","description":"## Overview\nImplement index management operations to make all tests pass.\n\n## Implementation Requirements\n\n### Index Metadata Table\n```sql\nCREATE TABLE IF NOT EXISTS indexes (\n  name TEXT PRIMARY KEY,\n  index_type TEXT NOT NULL, -- 'btree', 'fulltext', 'lookup'\n  entity_type TEXT NOT NULL, -- 'node', 'relationship'\n  label_or_type TEXT, -- label or relationship type\n  properties TEXT NOT NULL, -- JSON array of property names\n  is_constraint BOOLEAN DEFAULT FALSE,\n  constraint_type TEXT, -- 'unique', 'exists', 'node_key'\n  created_at DATETIME DEFAULT CURRENT_TIMESTAMP\n);\n```\n\n### IndexManager Class\n```typescript\ninterface IndexDefinition {\n  name: string;\n  indexType: 'btree' | 'fulltext' | 'lookup';\n  entityType: 'node' | 'relationship';\n  labelOrType?: string;\n  properties: string[];\n  isConstraint: boolean;\n  constraintType?: 'unique' | 'exists' | 'node_key';\n}\n\nclass IndexManager {\n  constructor(private sql: SqlStorage) {}\n\n  createIndex(\n    name: string,\n    entityType: 'node' | 'relationship',\n    labelOrType: string,\n    properties: string[],\n    options: { ifNotExists?: boolean } = {}\n  ): void {\n    if (\\!options.ifNotExists) {\n      const existing = this.getIndex(name);\n      if (existing) throw new Error(`Index ${name} already exists`);\n    }\n    \n    // Create SQLite index on nodes/relationships table\n    const tableName = entityType === 'node' ? 'nodes' : 'relationships';\n    const indexName = `idx_${name}`;\n    \n    // For JSON properties, use json_extract\n    const columns = properties.map(p =\u003e \n      `json_extract(properties, '$.${p}')`\n    ).join(', ');\n    \n    this.sql.exec(`\n      CREATE INDEX IF NOT EXISTS ${indexName} \n      ON ${tableName}(${columns})\n      WHERE json_extract(${entityType === 'node' ? 'labels' : 'type'}, '$') LIKE '%${labelOrType}%'\n    `);\n    \n    // Record in metadata\n    this.sql.exec(\n      'INSERT INTO indexes (name, index_type, entity_type, label_or_type, properties) VALUES (?, ?, ?, ?, ?)',\n      name, 'btree', entityType, labelOrType, JSON.stringify(properties)\n    );\n  }\n\n  dropIndex(name: string, options: { ifExists?: boolean } = {}): void {\n    const index = this.getIndex(name);\n    if (\\!index) {\n      if (options.ifExists) return;\n      throw new Error(`Index ${name} not found`);\n    }\n    \n    this.sql.exec(`DROP INDEX IF EXISTS idx_${name}`);\n    this.sql.exec('DELETE FROM indexes WHERE name = ?', name);\n  }\n\n  createFullTextIndex(name: string, labelOrType: string, properties: string[]): void {\n    // Use FTS5 virtual table\n    const ftsTable = `fts_${name}`;\n    this.sql.exec(`\n      CREATE VIRTUAL TABLE IF NOT EXISTS ${ftsTable} \n      USING fts5(${properties.join(', ')}, content='nodes', content_rowid='id')\n    `);\n    \n    // Record in metadata\n    this.sql.exec(\n      'INSERT INTO indexes (name, index_type, entity_type, label_or_type, properties) VALUES (?, ?, ?, ?, ?)',\n      name, 'fulltext', 'node', labelOrType, JSON.stringify(properties)\n    );\n  }\n\n  createConstraint(\n    name: string,\n    constraintType: 'unique' | 'exists',\n    labelOrType: string,\n    properties: string[]\n  ): void {\n    if (constraintType === 'unique') {\n      // Create unique index\n      this.createIndex(name, 'node', labelOrType, properties);\n      this.sql.exec(\n        'UPDATE indexes SET is_constraint = TRUE, constraint_type = ? WHERE name = ?',\n        'unique', name\n      );\n    }\n  }\n\n  getIndex(name: string): IndexDefinition | null;\n  listIndexes(): IndexDefinition[];\n  listConstraints(): IndexDefinition[];\n}\n```\n\n## Files to Create\n- `src/storage/indexes/index-manager.ts`\n- `src/storage/indexes/fulltext-index.ts`\n- `src/storage/indexes/constraints.ts`\n\n## Acceptance Criteria\n- [ ] All RED phase tests pass\n- [ ] CREATE/DROP INDEX work\n- [ ] Full-text search works\n- [ ] Constraints enforced\n\n## TDD Phase\n**GREEN** - Minimum code to pass tests","status":"closed","priority":1,"issue_type":"task","created_at":"2026-01-05T06:41:59.485237-06:00","updated_at":"2026-01-05T08:53:06.776724-06:00","closed_at":"2026-01-05T08:53:06.776724-06:00","close_reason":"Index management implemented in schema"}
{"id":"neo4j-i82","title":"GREEN: Driver Class Factory \u0026 URI Parsing Implementation","description":"## Overview\nImplement the Driver class factory function and URI parsing to pass all RED phase tests.\n\n## Implementation Requirements\n\n### Factory Function\n```typescript\n// Main entry point matching neo4j-driver API\nexport function driver(\n  uri: string,\n  authToken?: AuthToken,\n  config?: DriverConfig\n): Driver\n\n// Type definitions\ninterface Driver {\n  session(config?: SessionConfig): Session\n  rxSession(config?: SessionConfig): RxSession\n  executeQuery\u003cT\u003e(cypher: string, params?: Record\u003cstring, any\u003e, config?: QueryConfig): Promise\u003cEagerResult\u003cT\u003e\u003e\n  getServerInfo(): Promise\u003cServerInfo\u003e\n  close(): Promise\u003cvoid\u003e\n  verifyConnectivity(): Promise\u003cServerInfo\u003e\n}\n\ninterface DriverConfig {\n  maxTransactionRetryTime?: number\n  connectionTimeout?: number\n  maxConnectionPoolSize?: number\n  connectionAcquisitionTimeout?: number\n  logging?: LoggingConfig\n  encrypted?: boolean\n  trust?: TrustStrategy\n}\n```\n\n### URI Parser\n```typescript\ninterface ParsedUri {\n  scheme: 'neo4j' | 'neo4j+s' | 'bolt' | 'bolt+s'\n  host: string\n  port: number\n  encrypted: boolean\n  routing: boolean\n  params: Record\u003cstring, string\u003e\n}\n\nfunction parseUri(uri: string): ParsedUri\n```\n\n### Auth Tokens\n```typescript\nexport const auth = {\n  basic(username: string, password: string, realm?: string): AuthToken,\n  bearer(token: string): AuthToken,\n  custom(principal: string, credentials: string, realm: string, scheme: string, parameters?: Record\u003cstring, any\u003e): AuthToken\n}\n```\n\n## Files to Create/Modify\n- `src/driver/driver.ts` - Main Driver class\n- `src/driver/uri-parser.ts` - URI parsing logic\n- `src/driver/auth.ts` - Authentication token factories\n- `src/driver/config.ts` - Configuration handling\n- `src/driver/index.ts` - Public exports\n\n## TDD Phase\n**GREEN** - Implement minimum code to pass all tests from RED phase.\n\n## Dependencies\n- Depends on: RED: Driver Class Factory \u0026 URI Parsing Tests\n\n## Acceptance Criteria\n- [ ] All RED phase tests pass\n- [ ] API matches neo4j-driver exactly\n- [ ] TypeScript types are complete\n- [ ] Works in Cloudflare Workers environment","status":"closed","priority":1,"issue_type":"task","created_at":"2026-01-05T06:34:48.176119-06:00","updated_at":"2026-01-05T07:13:11.691841-06:00","closed_at":"2026-01-05T07:13:11.691841-06:00","close_reason":"Implemented in Ralph Wiggum session"}
{"id":"neo4j-ia5g","title":"RED: Write failing tests for rxResult.keys() method","description":"## Overview\nWrite failing tests for rxResult.keys() column name retrieval method.\n\n## Test Cases to Write\n\n### Basic Keys Tests\n- keys() returns Observable of string array\n- Returns column names from query\n- Order matches SELECT/RETURN order\n- Handles queries with no return columns\n\n### Observable Behavior Tests\n- Cold observable (fetches on subscribe)\n- Single emission then complete\n- Available before records consumed\n- Can be subscribed multiple times\n\n### Query Types\n- Simple RETURN queries\n- Queries with aliases (AS)\n- Queries with expressions\n- Aggregation queries\n- Empty result sets\n\n### Error Scenarios\n- Query execution error\n- Connection failure\n- Invalid query\n\n## Acceptance Criteria\n- All tests written and failing (RED phase)\n- Tests cover various query types\n- Tests verify Observable semantics\n- Tests cover error cases","status":"open","priority":2,"issue_type":"task","created_at":"2026-01-05T06:40:42.821157-06:00","updated_at":"2026-01-05T06:40:42.821157-06:00"}
{"id":"neo4j-idar","title":"REFACTOR: Record.entries() - Add TypeScript tuple types","description":"## Overview\nRefactor the Record.entries() method with proper TypeScript tuple types.\n\n## Refactoring Tasks\n\n1. **Type Safety**\n   - Define proper tuple return type\n   - Consider readonly tuple for immutability\n\n2. **Compatibility**\n   - Ensure compatibility with Map and Object.entries patterns\n\n## Acceptance Criteria\n- [ ] All tests still pass after refactoring\n- [ ] TypeScript tuple types properly defined\n- [ ] Compatible with standard iteration patterns\n\n## TDD Phase\nREFACTOR - Improve code without changing behavior\n\n## Dependencies\n- neo4j-3hr8 (GREEN phase implementation)","status":"closed","priority":1,"issue_type":"task","created_at":"2026-01-05T06:41:22.767458-06:00","updated_at":"2026-01-05T08:55:15.888032-06:00","closed_at":"2026-01-05T08:55:15.888032-06:00","close_reason":"Record methods already implemented with tests"}
{"id":"neo4j-idq9","title":"REFACTOR: Optimize retry implementation","description":"## Overview\nRefactor retry support for better patterns.\n\n## Refactoring Tasks\n\n### Code Quality\n- Extract retry utilities\n- Create backoff helpers\n- Document retry patterns\n- Add type helpers\n\n### Retry Patterns\n- Exponential backoff helper\n- Jitter support\n- Circuit breaker pattern\n- Retry budget tracking\n\n### Documentation\n- Document retry strategies\n- Show common patterns\n- Error classification guide\n- Best practices\n\n## Acceptance Criteria\n- All tests still pass\n- Useful retry utilities\n- Clear documentation\n- Good patterns library","status":"open","priority":2,"issue_type":"task","created_at":"2026-01-05T06:47:51.676449-06:00","updated_at":"2026-01-05T06:47:51.676449-06:00"}
{"id":"neo4j-ihhu","title":"REFACTOR: Clean up completion signaling implementation","description":"## Overview\nRefactor completion signaling for consistency.\n\n## Refactoring Tasks\n\n### Code Quality\n- Standardize completion logic\n- Extract completion patterns\n- Add completion state tracking\n- Document completion semantics\n\n### Consistency\n- Consistent completion behavior\n- Predictable timing\n- Clear completion contracts\n- Align with RxJS conventions\n\n### Edge Cases\n- Handle rapid completion\n- Handle concurrent completions\n- Handle completion during error\n- Test completion edge cases\n\n## Acceptance Criteria\n- All tests still pass\n- Consistent completion behavior\n- Well-documented semantics\n- No edge case issues","status":"open","priority":2,"issue_type":"task","created_at":"2026-01-05T06:44:05.096003-06:00","updated_at":"2026-01-05T06:44:05.096003-06:00"}
{"id":"neo4j-iicz","title":"RED: Write failing tests for Observable error emission","description":"## Overview\nWrite failing tests for proper error emission in reactive streams.\n\n## Test Cases to Write\n\n### Basic Error Emission Tests\n- Errors emitted via subscriber error callback\n- Error terminates the Observable\n- Error contains error details\n- Only one error emitted\n\n### Error Types Tests\n- Neo4jError emitted for database errors\n- TypeError for invalid parameters\n- ConnectionError for network issues\n- TimeoutError for timeouts\n\n### Error Context Tests\n- Error includes error code\n- Error includes message\n- Error includes cause\n- Stack trace preserved\n\n### Error Timing Tests\n- Errors during query execution\n- Errors during record streaming\n- Errors during commit\n- Errors during close\n\n## Acceptance Criteria\n- All tests written and failing (RED phase)\n- Tests cover all error types\n- Tests verify error context\n- Tests verify timing","status":"open","priority":2,"issue_type":"task","created_at":"2026-01-05T06:47:07.066027-06:00","updated_at":"2026-01-05T06:47:07.066027-06:00"}
{"id":"neo4j-ijp","title":"[GREEN] AST: Implement Core Node Type Interfaces","description":"## Overview\nImplement all AST node type interfaces.\n\n## Implementation Tasks\n\n### Base Types (src/parser/ast/base.ts)\n```typescript\nexport interface ASTNode {\n  type: string\n  loc: SourceLocation\n}\n\nexport interface SourceLocation {\n  start: Position\n  end: Position\n  source?: string\n}\n\nexport interface Position {\n  line: number\n  column: number\n  offset: number\n}\n```\n\n### Query Types (src/parser/ast/query.ts)\n```typescript\nexport interface Query extends ASTNode {\n  type: 'Query'\n  clauses: Clause[]\n}\n\nexport interface Union extends ASTNode {\n  type: 'Union'\n  left: Query\n  right: Query\n  all: boolean\n}\n```\n\n### Clause Types (src/parser/ast/clauses.ts)\n```typescript\nexport type Clause =\n  | MatchClause\n  | CreateClause\n  | MergeClause\n  | DeleteClause\n  | SetClause\n  | RemoveClause\n  | ReturnClause\n  | WithClause\n  | UnwindClause\n  | CallClause\n\n// Individual clause interfaces...\n```\n\n### Type Guards (src/parser/ast/guards.ts)\n```typescript\nexport function isMatchClause(node: ASTNode): node is MatchClause\nexport function isExpression(node: ASTNode): node is Expression\n```\n\n## Acceptance Criteria\n- [ ] All AST type tests pass\n- [ ] Types are properly discriminated\n- [ ] Type guards work correctly\n- [ ] All types exported from index\n\n## TDD Phase: GREEN\n## Depends On: neo4j-u43","status":"closed","priority":1,"issue_type":"task","created_at":"2026-01-05T06:37:34.65022-06:00","updated_at":"2026-01-05T08:58:01.75655-06:00","closed_at":"2026-01-05T08:58:01.75655-06:00","close_reason":"AST, lexer and types tests passing"}
{"id":"neo4j-ipju","title":"[RED] E2E Aggregation Tests","description":"# [RED] E2E Aggregation Tests\n\n## Overview\nEnd-to-end tests for Cypher aggregation functions and GROUP BY behavior.\n\n## Test Scenarios\n\n### Basic Aggregations\n```typescript\ndescribe('Basic Aggregation E2E', () =\u003e {\n  beforeEach(async () =\u003e {\n    await session.run(`\n      CREATE (:Product {name: 'A', price: 100, category: 'Electronics'}),\n             (:Product {name: 'B', price: 200, category: 'Electronics'}),\n             (:Product {name: 'C', price: 50, category: 'Books'}),\n             (:Product {name: 'D', price: 75, category: 'Books'}),\n             (:Product {name: 'E', price: 150, category: 'Clothing'})\n    `)\n  })\n\n  it('should count all nodes', async () =\u003e {\n    const result = await session.run('MATCH (p:Product) RETURN count(p) as count')\n    expect(result.records[0].get('count').toInt()).toBe(5)\n  })\n\n  it('should count distinct values', async () =\u003e {\n    const result = await session.run('MATCH (p:Product) RETURN count(DISTINCT p.category) as categories')\n    expect(result.records[0].get('categories').toInt()).toBe(3)\n  })\n\n  it('should sum values', async () =\u003e {\n    const result = await session.run('MATCH (p:Product) RETURN sum(p.price) as total')\n    expect(result.records[0].get('total').toInt()).toBe(575)\n  })\n\n  it('should calculate average', async () =\u003e {\n    const result = await session.run('MATCH (p:Product) RETURN avg(p.price) as avg')\n    expect(result.records[0].get('avg')).toBe(115)\n  })\n\n  it('should find min value', async () =\u003e {\n    const result = await session.run('MATCH (p:Product) RETURN min(p.price) as minPrice')\n    expect(result.records[0].get('minPrice').toInt()).toBe(50)\n  })\n\n  it('should find max value', async () =\u003e {\n    const result = await session.run('MATCH (p:Product) RETURN max(p.price) as maxPrice')\n    expect(result.records[0].get('maxPrice').toInt()).toBe(200)\n  })\n\n  it('should collect into list', async () =\u003e {\n    const result = await session.run('MATCH (p:Product) RETURN collect(p.name) as names')\n    const names = result.records[0].get('names')\n    expect(names).toHaveLength(5)\n    expect(names).toContain('A')\n  })\n\n  it('should collect distinct values', async () =\u003e {\n    const result = await session.run('MATCH (p:Product) RETURN collect(DISTINCT p.category) as categories')\n    expect(result.records[0].get('categories')).toHaveLength(3)\n  })\n})\n```\n\n### Grouped Aggregations\n```typescript\ndescribe('Grouped Aggregation E2E', () =\u003e {\n  beforeEach(async () =\u003e {\n    await session.run(`\n      CREATE (:Product {name: 'A', price: 100, category: 'Electronics'}),\n             (:Product {name: 'B', price: 200, category: 'Electronics'}),\n             (:Product {name: 'C', price: 50, category: 'Books'}),\n             (:Product {name: 'D', price: 75, category: 'Books'}),\n             (:Product {name: 'E', price: 150, category: 'Clothing'})\n    `)\n  })\n\n  it('should group by property', async () =\u003e {\n    const result = await session.run(`\n      MATCH (p:Product)\n      RETURN p.category as category, count(p) as count\n      ORDER BY category\n    `)\n    expect(result.records).toHaveLength(3)\n  })\n\n  it('should sum within groups', async () =\u003e {\n    const result = await session.run(`\n      MATCH (p:Product)\n      RETURN p.category as category, sum(p.price) as total\n      ORDER BY category\n    `)\n    const books = result.records.find(r =\u003e r.get('category') === 'Books')\n    expect(books?.get('total').toInt()).toBe(125)\n  })\n\n  it('should collect within groups', async () =\u003e {\n    const result = await session.run(`\n      MATCH (p:Product)\n      RETURN p.category as category, collect(p.name) as products\n    `)\n    const electronics = result.records.find(r =\u003e r.get('category') === 'Electronics')\n    expect(electronics?.get('products')).toHaveLength(2)\n  })\n\n  it('should group by multiple columns', async () =\u003e {\n    await session.run(`\n      CREATE (:Sale {product: 'A', region: 'US', amount: 100}),\n             (:Sale {product: 'A', region: 'EU', amount: 150}),\n             (:Sale {product: 'B', region: 'US', amount: 200})\n    `)\n    const result = await session.run(`\n      MATCH (s:Sale)\n      RETURN s.product as product, s.region as region, sum(s.amount) as total\n    `)\n    expect(result.records).toHaveLength(3)\n  })\n})\n```\n\n### Advanced Aggregations\n```typescript\ndescribe('Advanced Aggregation E2E', () =\u003e {\n  beforeEach(async () =\u003e {\n    await session.run(`\n      CREATE (a:Person {name: 'Alice'})-[:PURCHASED {amount: 100}]-\u003e(:Product {name: 'P1'}),\n             (a)-[:PURCHASED {amount: 200}]-\u003e(:Product {name: 'P2'}),\n             (b:Person {name: 'Bob'})-[:PURCHASED {amount: 150}]-\u003e(:Product {name: 'P1'}),\n             (b)-[:PURCHASED {amount: 50}]-\u003e(:Product {name: 'P3'})\n    `)\n  })\n\n  it('should aggregate over relationships', async () =\u003e {\n    const result = await session.run(`\n      MATCH (p:Person)-[r:PURCHASED]-\u003e()\n      RETURN p.name, sum(r.amount) as totalSpent\n    `)\n    const alice = result.records.find(r =\u003e r.get('p.name') === 'Alice')\n    expect(alice?.get('totalSpent').toInt()).toBe(300)\n  })\n\n  it('should handle HAVING-like filtering with WITH', async () =\u003e {\n    const result = await session.run(`\n      MATCH (p:Person)-[r:PURCHASED]-\u003e()\n      WITH p, sum(r.amount) as total\n      WHERE total \u003e 250\n      RETURN p.name, total\n    `)\n    expect(result.records).toHaveLength(1)\n    expect(result.records[0].get('p.name')).toBe('Alice')\n  })\n\n  it('should use percentileCont', async () =\u003e {\n    await session.run(`\n      CREATE (:Score {value: 10}), (:Score {value: 20}), (:Score {value: 30}),\n             (:Score {value: 40}), (:Score {value: 50})\n    `)\n    const result = await session.run(`\n      MATCH (s:Score)\n      RETURN percentileCont(s.value, 0.5) as median\n    `)\n    expect(result.records[0].get('median')).toBe(30)\n  })\n\n  it('should use stDev', async () =\u003e {\n    await session.run(`\n      CREATE (:Value {n: 10}), (:Value {n: 20}), (:Value {n: 30})\n    `)\n    const result = await session.run(`\n      MATCH (v:Value)\n      RETURN stDev(v.n) as sd\n    `)\n    expect(result.records[0].get('sd')).toBeCloseTo(10, 1)\n  })\n})\n```\n\n### Aggregation with ORDER BY and LIMIT\n```typescript\ndescribe('Aggregation with Ordering E2E', () =\u003e {\n  beforeEach(async () =\u003e {\n    await session.run(`\n      CREATE (:Product {name: 'A', sales: 100}),\n             (:Product {name: 'B', sales: 500}),\n             (:Product {name: 'C', sales: 300}),\n             (:Product {name: 'D', sales: 200}),\n             (:Product {name: 'E', sales: 400})\n    `)\n  })\n\n  it('should order aggregated results', async () =\u003e {\n    const result = await session.run(`\n      MATCH (p:Product)\n      RETURN p.name as name\n      ORDER BY p.sales DESC\n    `)\n    expect(result.records[0].get('name')).toBe('B')\n  })\n\n  it('should get top N by aggregation', async () =\u003e {\n    const result = await session.run(`\n      MATCH (p:Product)\n      RETURN p.name as name, p.sales as sales\n      ORDER BY p.sales DESC\n      LIMIT 3\n    `)\n    expect(result.records).toHaveLength(3)\n    const sales = result.records.map(r =\u003e r.get('sales').toInt())\n    expect(sales).toEqual([500, 400, 300])\n  })\n})\n```\n\n### NULL Handling in Aggregations\n```typescript\ndescribe('NULL Handling in Aggregations E2E', () =\u003e {\n  beforeEach(async () =\u003e {\n    await session.run(`\n      CREATE (:Item {value: 10}),\n             (:Item {value: 20}),\n             (:Item {value: null}),\n             (:Item {})\n    `)\n  })\n\n  it('should ignore nulls in count(property)', async () =\u003e {\n    const result = await session.run('MATCH (i:Item) RETURN count(i.value) as count')\n    expect(result.records[0].get('count').toInt()).toBe(2)\n  })\n\n  it('should count all nodes including nulls with count(*)', async () =\u003e {\n    const result = await session.run('MATCH (i:Item) RETURN count(*) as count')\n    expect(result.records[0].get('count').toInt()).toBe(4)\n  })\n\n  it('should ignore nulls in sum', async () =\u003e {\n    const result = await session.run('MATCH (i:Item) RETURN sum(i.value) as total')\n    expect(result.records[0].get('total').toInt()).toBe(30)\n  })\n})\n```\n\n## Acceptance Criteria\n- [ ] Basic aggregation functions tested\n- [ ] Grouped aggregations tested\n- [ ] Complex aggregations with relationships tested\n- [ ] ORDER BY with aggregations tested\n- [ ] NULL handling tested\n- [ ] Tests fail initially (RED phase)","status":"open","priority":2,"issue_type":"task","created_at":"2026-01-05T06:41:55.508159-06:00","updated_at":"2026-01-05T06:41:55.508159-06:00"}
{"id":"neo4j-irat","title":"GREEN: RETURN/WITH Clause Translation","description":"## Overview\nImplement RETURN and WITH clause translation to make RED tests pass.\n\n## Implementation Tasks\n\n### 1. ReturnClauseTranslator\n- translateReturn(): Generate SELECT columns\n- translateAlias(): AS clause generation\n- translateDistinct(): SELECT DISTINCT\n- translateOrderBy(): ORDER BY clause\n- translateSkipLimit(): LIMIT OFFSET\n\n### 2. WithClauseTranslator\n- translateWith(): Create subquery or CTE scope\n- passVariables(): Forward bound variables\n- handleWithWhere(): Post-aggregation filtering\n\n### 3. Group By Inference\n- Detect aggregations in RETURN\n- Infer grouping keys from non-aggregated columns\n\n### 4. Column Expression Translator\n- Property access to json_extract\n- Full node/relationship to JSON object\n\n## Files to Create/Modify\n- src/cypher/translator/return-clause-translator.ts\n- src/cypher/translator/with-clause-translator.ts\n- src/cypher/translator/groupby-inferrer.ts\n\n## Acceptance Criteria\n- All RED phase tests pass\n- GROUP BY correctly inferred\n- WITH scoping works\n\n## TDD Phase\nGREEN - Make tests pass with minimal code\n\n## Dependencies\n- Depends on: RED: RETURN/WITH Clause Translation","status":"closed","priority":1,"issue_type":"task","created_at":"2026-01-05T06:41:02.316434-06:00","updated_at":"2026-01-05T08:55:39.252419-06:00","closed_at":"2026-01-05T08:55:39.252419-06:00","close_reason":"Translation already implemented with tests"}
{"id":"neo4j-izfo","title":"REFACTOR: Result.summary - Ensure proper timing capture","description":"## Overview\nRefactor the Result.summary implementation to ensure accurate timing measurements.\n\n## Refactoring Tasks\n\n1. **Timing Accuracy**\n   - Capture resultAvailableAfter correctly\n   - Capture resultConsumedAfter correctly\n\n2. **Type Safety**\n   - Ensure ResultSummary type is correct\n   - Add proper generic support\n\n## Acceptance Criteria\n- [ ] All tests still pass after refactoring\n- [ ] Timing measurements are accurate\n- [ ] TypeScript types properly defined\n\n## TDD Phase\nREFACTOR - Improve code without changing behavior\n\n## Dependencies\n- neo4j-82ks (GREEN phase implementation)","status":"closed","priority":1,"issue_type":"task","created_at":"2026-01-05T06:42:54.498879-06:00","updated_at":"2026-01-05T08:52:47.255437-06:00","closed_at":"2026-01-05T08:52:47.255437-06:00","close_reason":"Already implemented with tests passing"}
{"id":"neo4j-j4p","title":"REFACTOR: Clean up rxSession.executeRead() implementation","description":"## Overview\nRefactor `rxSession.executeRead()` for maintainability and performance.\n\n## Refactoring Tasks\n\n### Code Quality\n- Extract common transaction management logic\n- Share code with executeWrite where possible\n- Improve type safety\n- Better error messages\n\n### Retry Logic\n- Extract retry operator composition\n- Make retry strategy configurable\n- Add jitter to retry delays\n\n### Testing\n- Ensure testability with dependency injection\n- Support test scheduler injection\n\n## Acceptance Criteria\n- [ ] All tests still pass\n- [ ] DRY code with executeWrite\n- [ ] Configurable retry behavior\n- [ ] Clean, documented code","status":"open","priority":2,"issue_type":"task","created_at":"2026-01-05T06:35:52.910074-06:00","updated_at":"2026-01-05T06:35:52.910074-06:00"}
{"id":"neo4j-jcd9","title":"[RED] Parser: Path Pattern and Multiple Pattern Tests","description":"## Overview\nWrite failing tests for path patterns and multiple patterns.\n\n## Test Cases to Write\n\n### Named Paths\n- Simple: `p = (a)--\u003e(b)`\n- Complex: `p = (a)-[:KNOWS]-\u003e(b)-[:LIKES]-\u003e(c)`\n- With variable-length: `p = (a)-[*]-\u003e(b)`\n\n### Pattern Chains\n- Simple chain: `(a)--\u003e(b)--\u003e(c)`\n- Mixed directions: `(a)--\u003e(b)\u003c--(c)`\n- Multiple relationships: `(a)-[:A]-\u003e(b)-[:B]-\u003e(c)-[:C]-\u003e(d)`\n\n### Multiple Patterns\n- Comma-separated: `(a), (b)`\n- Mixed: `(a)--\u003e(b), (c)--\u003e(d)`\n- With named paths: `p = (a)--\u003e(b), q = (c)--\u003e(d)`\n\n### Complex Patterns\n- `(a:Person)-[:KNOWS]-\u003e(b:Person)-[:WORKS_AT]-\u003e(c:Company)`\n- `(a)\u003c-[:FROM]-(m)-[:TO]-\u003e(b)`\n- `(a)-[:KNOWS*1..3]-\u003e(b)-[:LIKES]-\u003e(c)`\n\n### Edge Cases\n- Empty pattern list (error)\n- Trailing comma (error)\n- Incomplete pattern (error)\n\n## Acceptance Criteria\n- [ ] All path pattern tests written\n- [ ] Multiple pattern tests written\n- [ ] Pattern chain tests written\n- [ ] Error cases covered\n\n## TDD Phase: RED","status":"closed","priority":1,"issue_type":"task","created_at":"2026-01-05T06:41:16.683653-06:00","updated_at":"2026-01-05T07:19:48.958506-06:00","closed_at":"2026-01-05T07:19:48.958506-06:00","close_reason":"Parser implemented with MATCH, RETURN, node/relationship patterns, expressions - 34 parser tests pass"}
{"id":"neo4j-jee","title":"[GREEN] AST: Implement Pattern Node Types","description":"## Overview\nImplement all pattern AST node types.\n\n## Implementation Tasks\n\n### Pattern Types (src/parser/ast/patterns.ts)\n```typescript\nexport interface Pattern extends ASTNode {\n  type: 'Pattern'\n  elements: PatternElement[]\n}\n\nexport interface NodePattern extends ASTNode {\n  type: 'NodePattern'\n  variable?: Identifier\n  labels: string[]\n  properties?: MapLiteral | Parameter\n}\n\nexport interface RelationshipPattern extends ASTNode {\n  type: 'RelationshipPattern'\n  variable?: Identifier\n  types: string[]\n  properties?: MapLiteral | Parameter\n  direction: RelationshipDirection\n  length?: RelationshipLength\n}\n\nexport type RelationshipDirection = \n  | 'outgoing'   // --\u003e\n  | 'incoming'   // \u003c--\n  | 'both'       // \u003c--\u003e\n  | 'none'       // --\n\nexport interface RelationshipLength {\n  type: 'RelationshipLength'\n  min?: number\n  max?: number\n}\n```\n\n### Named Path\n```typescript\nexport interface NamedPath extends ASTNode {\n  type: 'NamedPath'\n  variable: Identifier\n  pattern: PatternElement[]\n}\n```\n\n### PatternElement Union\n```typescript\nexport type PatternElement = \n  | NodePattern \n  | RelationshipPattern \n  | PatternChain\n\nexport interface PatternChain extends ASTNode {\n  type: 'PatternChain'\n  elements: (NodePattern | RelationshipPattern)[]\n}\n```\n\n## Acceptance Criteria\n- [ ] All pattern type tests pass\n- [ ] Types support all Cypher patterns\n- [ ] Direction enum complete\n- [ ] Variable-length type correct\n\n## TDD Phase: GREEN\n## Depends On: neo4j-5i2","status":"closed","priority":1,"issue_type":"task","created_at":"2026-01-05T06:38:37.109643-06:00","updated_at":"2026-01-05T08:58:01.754612-06:00","closed_at":"2026-01-05T08:58:01.754612-06:00","close_reason":"AST, lexer and types tests passing"}
{"id":"neo4j-jpn","title":"GREEN: Implement rxSession.beginTransaction() method","description":"## Overview\nImplement rxSession.beginTransaction() to make all RED tests pass.\n\n## Implementation Requirements\n\n### Method Signature\n```typescript\ninterface RxSession {\n  beginTransaction(config?: TransactionConfig): Observable\u003cRxTransaction\u003e\n}\n```\n\n### Implementation Details\n- Create Observable that emits RxTransaction\n- Initialize transaction on subscription\n- Track active transaction in session\n- Apply configuration options\n- Handle connection setup\n\n### Observable Semantics\n- Cold observable (lazy creation)\n- Single emission then complete\n- Error propagation on failure\n\n## Acceptance Criteria\n- All RED tests now pass (GREEN phase)\n- Returns Observable of RxTransaction\n- Transaction properly initialized\n- Configuration applied correctly","status":"open","priority":2,"issue_type":"task","created_at":"2026-01-05T06:37:02.848295-06:00","updated_at":"2026-01-05T06:37:02.848295-06:00"}
{"id":"neo4j-jqed","title":"REFACTOR: Document cold/hot Observable patterns","description":"## Overview\nRefactor and document cold/hot Observable patterns.\n\n## Refactoring Tasks\n\n### Code Quality\n- Ensure consistent cold semantics\n- Standardize Observable creation\n- Add type hints for behavior\n- Clear implementation patterns\n\n### Documentation\n- Document cold behavior\n- Document hot transformation\n- Add usage examples\n- Warn about side effects\n\n### Patterns\n- Recommend patterns for sharing\n- Document caching strategies\n- Show multicast examples\n- Best practices guide\n\n## Acceptance Criteria\n- All tests still pass\n- Clear cold semantics\n- Well-documented patterns\n- Good developer guidance","status":"open","priority":2,"issue_type":"task","created_at":"2026-01-05T06:45:16.394915-06:00","updated_at":"2026-01-05T06:45:16.394915-06:00"}
{"id":"neo4j-k04","title":"RED: Managed Transaction Auto-Retry Tests","description":"## Overview\nWrite comprehensive failing tests for managed transaction auto-retry logic with exponential backoff.\n\n## Test Cases\n\n### Auto-Retry Tests\n```typescript\ndescribe('Managed Transaction Retry', () =\u003e {\n  it('should retry on TransientError')\n  it('should retry on ServiceUnavailable')\n  it('should retry on SessionExpired')\n  it('should retry on DeadlockDetected')\n  it('should not retry on ClientError')\n  it('should not retry on ConstraintViolation')\n  it('should not retry on AuthenticationError')\n  it('should respect maxTransactionRetryTime')\n  it('should use exponential backoff')\n  it('should jitter backoff to prevent thundering herd')\n})\n```\n\n### Retry Configuration Tests\n```typescript\ndescribe('Retry Configuration', () =\u003e {\n  it('should use driver maxTransactionRetryTime')\n  it('should override with session config')\n  it('should override with transaction config')\n  it('should default to 30 seconds')\n  it('should handle zero retry time (no retries)')\n})\n```\n\n### Exponential Backoff Tests\n```typescript\ndescribe('Exponential Backoff', () =\u003e {\n  it('should start with initial delay of 1 second')\n  it('should double delay on each retry')\n  it('should cap delay at max delay')\n  it('should add jitter within 20% range')\n  it('should stop retrying when time exceeded')\n})\n```\n\n### Work Function Tests\n```typescript\ndescribe('Transaction Work Function', () =\u003e {\n  it('should receive fresh transaction on each retry')\n  it('should rollback failed transaction before retry')\n  it('should preserve work function return value')\n  it('should propagate non-retryable errors immediately')\n  it('should clean up resources on final failure')\n})\n```\n\n### Error Classification Tests\n```typescript\ndescribe('Error Classification', () =\u003e {\n  it('should classify Neo4jError.TransientError as retryable')\n  it('should classify connection errors as retryable')\n  it('should classify timeout as retryable')\n  it('should classify syntax error as fatal')\n  it('should classify auth error as fatal')\n  it('should classify constraint error as fatal')\n})\n```\n\n## TDD Phase\n**RED** - All tests should fail initially.\n\n## Acceptance Criteria\n- [ ] All retry scenarios tested\n- [ ] Backoff algorithm verified\n- [ ] Error classification complete\n- [ ] Resource cleanup tested","status":"closed","priority":1,"issue_type":"task","created_at":"2026-01-05T06:39:04.188086-06:00","updated_at":"2026-01-05T08:58:13.606999-06:00","closed_at":"2026-01-05T08:58:13.606999-06:00","close_reason":"Implementation complete with tests"}
{"id":"neo4j-k3e","title":"RED: CREATE/MERGE Translation","description":"## Overview\nWrite failing tests for CREATE and MERGE clause translation to INSERT statements.\n\n## Test Cases to Write\n\n### Test 1: CREATE Node\n- CREATE (n:Person {name: 'Alice'}) -\u003e INSERT into nodes\n\n### Test 2: CREATE Node with ID\n- Handle id generation (UUID or auto-increment)\n\n### Test 3: CREATE Relationship\n- CREATE (a)-[r:KNOWS]-\u003e(b) -\u003e INSERT into relationships\n\n### Test 4: CREATE with Existing Variables\n- Use existing node IDs from previous MATCH\n\n### Test 5: MERGE Node (Insert or Match)\n- MERGE (n:Person {name: 'Alice'}) -\u003e INSERT OR IGNORE + SELECT\n\n### Test 6: MERGE Relationship\n- Upsert pattern for relationships\n\n### Test 7: ON CREATE SET\n- SET properties only when creating new\n\n### Test 8: ON MATCH SET\n- SET properties only when matching existing\n\n### Test 9: CREATE Multiple Nodes\n- Batch insert optimization\n\n## Acceptance Criteria\n- All tests written and failing\n- MERGE upsert pattern correct\n- ON CREATE/ON MATCH handled\n\n## TDD Phase\nRED - Write failing tests first","status":"closed","priority":1,"issue_type":"task","created_at":"2026-01-05T06:38:25.089482-06:00","updated_at":"2026-01-05T08:57:46.157609-06:00","closed_at":"2026-01-05T08:57:46.157609-06:00","close_reason":"Translation and session tests passing"}
{"id":"neo4j-kaat","title":"[RED] E2E Relationship CRUD Tests","description":"# [RED] E2E Relationship CRUD Tests\n\n## Overview\nEnd-to-end tests for all relationship operations: Create, Read, Update, Delete.\n\n## Test Scenarios\n\n### Create Operations\n```typescript\ndescribe('Relationship Creation E2E', () =\u003e {\n  beforeEach(async () =\u003e {\n    await session.run(`\n      CREATE (a:Person {name: 'Alice'}), (b:Person {name: 'Bob'})\n    `)\n  })\n\n  it('should create a simple relationship', async () =\u003e {\n    const result = await session.run(`\n      MATCH (a:Person {name: 'Alice'}), (b:Person {name: 'Bob'})\n      CREATE (a)-[r:KNOWS]-\u003e(b)\n      RETURN r\n    `)\n    expect(result.records).toHaveLength(1)\n    expect(result.records[0].get('r').type).toBe('KNOWS')\n  })\n\n  it('should create relationship with properties', async () =\u003e {\n    const result = await session.run(`\n      MATCH (a:Person {name: 'Alice'}), (b:Person {name: 'Bob'})\n      CREATE (a)-[r:KNOWS {since: 2020, strength: 'strong'}]-\u003e(b)\n      RETURN r\n    `)\n    const rel = result.records[0].get('r')\n    expect(rel.properties.since.toInt()).toBe(2020)\n    expect(rel.properties.strength).toBe('strong')\n  })\n\n  it('should create relationship inline with nodes', async () =\u003e {\n    const result = await session.run(`\n      CREATE (a:Person {name: 'Charlie'})-[r:WORKS_WITH]-\u003e(b:Person {name: 'Diana'})\n      RETURN a, r, b\n    `)\n    expect(result.records[0].get('r').type).toBe('WORKS_WITH')\n  })\n\n  it('should create multiple relationships', async () =\u003e {\n    await session.run('CREATE (c:Person {name: \"Charlie\"})')\n    const result = await session.run(`\n      MATCH (a:Person {name: 'Alice'}), (b:Person {name: 'Bob'}), (c:Person {name: 'Charlie'})\n      CREATE (a)-[r1:KNOWS]-\u003e(b), (b)-[r2:KNOWS]-\u003e(c)\n      RETURN r1, r2\n    `)\n    expect(result.records[0].get('r1')).toBeDefined()\n    expect(result.records[0].get('r2')).toBeDefined()\n  })\n\n  it('should create bidirectional relationships', async () =\u003e {\n    await session.run(`\n      MATCH (a:Person {name: 'Alice'}), (b:Person {name: 'Bob'})\n      CREATE (a)-[:KNOWS]-\u003e(b), (b)-[:KNOWS]-\u003e(a)\n    `)\n    const result = await session.run('MATCH ()-[r:KNOWS]-\u003e() RETURN count(r) as count')\n    expect(result.records[0].get('count').toInt()).toBe(2)\n  })\n\n  it('should create self-referencing relationship', async () =\u003e {\n    const result = await session.run(`\n      MATCH (a:Person {name: 'Alice'})\n      CREATE (a)-[r:LIKES]-\u003e(a)\n      RETURN r\n    `)\n    expect(result.records[0].get('r').type).toBe('LIKES')\n  })\n})\n```\n\n### Read Operations\n```typescript\ndescribe('Relationship Reading E2E', () =\u003e {\n  beforeEach(async () =\u003e {\n    await session.run(`\n      CREATE (a:Person {name: 'Alice'})-[:KNOWS {since: 2018}]-\u003e(b:Person {name: 'Bob'}),\n             (b)-[:WORKS_WITH {role: 'peer'}]-\u003e(c:Person {name: 'Charlie'}),\n             (a)-[:MANAGES]-\u003e(c)\n    `)\n  })\n\n  it('should read relationships by type', async () =\u003e {\n    const result = await session.run('MATCH ()-[r:KNOWS]-\u003e() RETURN r')\n    expect(result.records).toHaveLength(1)\n  })\n\n  it('should read all relationship types', async () =\u003e {\n    const result = await session.run('MATCH ()-[r]-\u003e() RETURN type(r) as type')\n    const types = result.records.map(r =\u003e r.get('type'))\n    expect(types).toContain('KNOWS')\n    expect(types).toContain('WORKS_WITH')\n    expect(types).toContain('MANAGES')\n  })\n\n  it('should filter by relationship properties', async () =\u003e {\n    const result = await session.run('MATCH ()-[r:KNOWS {since: 2018}]-\u003e() RETURN r')\n    expect(result.records).toHaveLength(1)\n  })\n\n  it('should read relationship with endpoints', async () =\u003e {\n    const result = await session.run(`\n      MATCH (a)-[r:KNOWS]-\u003e(b)\n      RETURN a.name as from, b.name as to, r\n    `)\n    expect(result.records[0].get('from')).toBe('Alice')\n    expect(result.records[0].get('to')).toBe('Bob')\n  })\n\n  it('should read relationships in either direction', async () =\u003e {\n    const result = await session.run(`\n      MATCH (a:Person {name: 'Bob'})-[r]-(other)\n      RETURN other.name as name\n    `)\n    const names = result.records.map(r =\u003e r.get('name'))\n    expect(names).toContain('Alice')\n    expect(names).toContain('Charlie')\n  })\n\n  it('should filter by multiple relationship types', async () =\u003e {\n    const result = await session.run('MATCH ()-[r:KNOWS|MANAGES]-\u003e() RETURN r')\n    expect(result.records).toHaveLength(2)\n  })\n})\n```\n\n### Update Operations\n```typescript\ndescribe('Relationship Update E2E', () =\u003e {\n  beforeEach(async () =\u003e {\n    await session.run(`\n      CREATE (a:Person {name: 'Alice'})-[:KNOWS {since: 2018, strength: 'weak'}]-\u003e(b:Person {name: 'Bob'})\n    `)\n  })\n\n  it('should update relationship property', async () =\u003e {\n    await session.run('MATCH ()-[r:KNOWS]-\u003e() SET r.since = 2020')\n    const result = await session.run('MATCH ()-[r:KNOWS]-\u003e() RETURN r.since as since')\n    expect(result.records[0].get('since').toInt()).toBe(2020)\n  })\n\n  it('should add new relationship property', async () =\u003e {\n    await session.run('MATCH ()-[r:KNOWS]-\u003e() SET r.frequency = \"daily\"')\n    const result = await session.run('MATCH ()-[r:KNOWS]-\u003e() RETURN r.frequency as freq')\n    expect(result.records[0].get('freq')).toBe('daily')\n  })\n\n  it('should remove relationship property', async () =\u003e {\n    await session.run('MATCH ()-[r:KNOWS]-\u003e() REMOVE r.strength')\n    const result = await session.run('MATCH ()-[r:KNOWS]-\u003e() RETURN r.strength as strength')\n    expect(result.records[0].get('strength')).toBeNull()\n  })\n\n  it('should replace all properties', async () =\u003e {\n    await session.run('MATCH ()-[r:KNOWS]-\u003e() SET r = {year: 2021}')\n    const result = await session.run('MATCH ()-[r:KNOWS]-\u003e() RETURN r')\n    const rel = result.records[0].get('r')\n    expect(rel.properties.year.toInt()).toBe(2021)\n    expect(rel.properties.since).toBeUndefined()\n    expect(rel.properties.strength).toBeUndefined()\n  })\n\n  // Note: Relationship type cannot be changed in Neo4j - must delete and recreate\n  it('should not allow changing relationship type directly', async () =\u003e {\n    // This should require delete + create pattern\n    await session.run(`\n      MATCH (a)-[r:KNOWS]-\u003e(b)\n      CREATE (a)-[:FRIENDS {since: r.since}]-\u003e(b)\n      DELETE r\n    `)\n    const result = await session.run('MATCH ()-[r:FRIENDS]-\u003e() RETURN r')\n    expect(result.records).toHaveLength(1)\n  })\n})\n```\n\n### Delete Operations\n```typescript\ndescribe('Relationship Deletion E2E', () =\u003e {\n  beforeEach(async () =\u003e {\n    await session.run(`\n      CREATE (a:Person {name: 'Alice'})-[:KNOWS]-\u003e(b:Person {name: 'Bob'}),\n             (a)-[:WORKS_WITH]-\u003e(b),\n             (b)-[:KNOWS]-\u003e(c:Person {name: 'Charlie'})\n    `)\n  })\n\n  it('should delete specific relationship', async () =\u003e {\n    await session.run('MATCH (:Person {name: \"Alice\"})-[r:KNOWS]-\u003e() DELETE r')\n    const result = await session.run('MATCH (:Person {name: \"Alice\"})-[r:KNOWS]-\u003e() RETURN r')\n    expect(result.records).toHaveLength(0)\n  })\n\n  it('should delete relationships by type', async () =\u003e {\n    await session.run('MATCH ()-[r:KNOWS]-\u003e() DELETE r')\n    const result = await session.run('MATCH ()-[r:KNOWS]-\u003e() RETURN r')\n    expect(result.records).toHaveLength(0)\n  })\n\n  it('should delete all relationships between nodes', async () =\u003e {\n    await session.run(`\n      MATCH (a:Person {name: 'Alice'})-[r]-\u003e(b:Person {name: 'Bob'})\n      DELETE r\n    `)\n    const result = await session.run('MATCH (:Person {name: \"Alice\"})-[r]-\u003e(:Person {name: \"Bob\"}) RETURN r')\n    expect(result.records).toHaveLength(0)\n  })\n\n  it('should preserve nodes when deleting relationships', async () =\u003e {\n    await session.run('MATCH ()-[r]-\u003e() DELETE r')\n    const result = await session.run('MATCH (n:Person) RETURN count(n) as count')\n    expect(result.records[0].get('count').toInt()).toBe(3)\n  })\n})\n```\n\n## Acceptance Criteria\n- [ ] All CREATE tests written and failing\n- [ ] All READ tests written and failing\n- [ ] All UPDATE tests written and failing\n- [ ] All DELETE tests written and failing\n- [ ] Edge cases covered (self-refs, bidirectional)\n- [ ] Property handling tested","status":"open","priority":2,"issue_type":"task","created_at":"2026-01-05T06:40:43.764392-06:00","updated_at":"2026-01-05T06:40:43.764392-06:00"}
{"id":"neo4j-kdy","title":"[RED] Lexer: Define Token Types and Basic Tokenization Tests","description":"## Overview\nWrite failing tests for the Cypher lexer's token type definitions and basic tokenization.\n\n## Test Cases to Write\n\n### Token Type Definitions\n- Test that all Cypher keywords are recognized (MATCH, CREATE, RETURN, WHERE, etc.)\n- Test identifier tokens (variable names, labels, property names)\n- Test operator tokens (+, -, *, /, =, \u003c\u003e, \u003c, \u003e, \u003c=, \u003e=, etc.)\n- Test punctuation tokens ((, ), [, ], {, }, :, ., ,, |, etc.)\n- Test special tokens (parameter $param, property access)\n\n### Basic Tokenization\n- Test tokenizing simple query: `MATCH (n) RETURN n`\n- Test tokenizing with whitespace preservation awareness\n- Test token position tracking (line, column)\n- Test token span tracking (start, end offsets)\n\n## Acceptance Criteria\n- [ ] All tests written and failing (RED phase)\n- [ ] Tests cover all token type categories\n- [ ] Tests include edge cases (empty input, single token)\n- [ ] Test file created at `src/parser/__tests__/lexer-tokens.test.ts`\n\n## TDD Phase: RED","status":"closed","priority":1,"issue_type":"task","created_at":"2026-01-05T06:34:24.922099-06:00","updated_at":"2026-01-05T06:49:46.732669-06:00","closed_at":"2026-01-05T06:49:46.732669-06:00","close_reason":"Closed"}
{"id":"neo4j-kljy","title":"GREEN: Implement Streaming support","description":"## Test-Driven Development: GREEN Phase\n\n### Component\nHTTP Client SDK - Streaming Support\n\n### Implementation Requirements\n\nImplement src/client/streaming.ts with:\n- SSEClient for Server-Sent Events\n- ChunkedResponseParser for chunked transfer encoding\n- StreamingResult with async iterator interface\n- ProgressTracker for progress callbacks\n- Support AbortSignal for cancellation\n\n### Acceptance Criteria\n- All RED phase tests pass\n- SSE connection works\n- Chunked responses parsed correctly\n- Progress callbacks fire\n- Cancellation works via AbortSignal\n- AsyncIterator pattern for results\n\n### Dependencies\n- RED: Streaming support fails without implementation\n\n### TDD Cycle\nThis is the GREEN phase. Next: REFACTOR phase.","status":"open","priority":2,"issue_type":"task","created_at":"2026-01-05T06:48:11.386233-06:00","updated_at":"2026-01-05T06:48:11.386233-06:00"}
{"id":"neo4j-krk","title":"RED: Write failing tests for rxTx.commit() method","description":"## Overview\nWrite failing tests for rxTx.commit() transaction commit method.\n\n## Test Cases to Write\n\n### Basic Commit Tests\n- commit() returns Observable of void\n- Changes persisted after commit\n- Transaction closed after commit\n- Bookmarks updated after commit\n\n### Observable Behavior Tests\n- Cold observable (commit on subscribe)\n- Completes on successful commit\n- Error emission on commit failure\n- Single emission semantics\n\n### State Tests\n- Transaction marked as closed after commit\n- Cannot run queries after commit\n- Cannot commit twice (error)\n- Cannot rollback after commit\n\n### Error Scenarios\n- Constraint violation during commit\n- Connection lost during commit\n- Timeout during commit\n\n## Acceptance Criteria\n- All tests written and failing (RED phase)\n- Tests verify commit behavior\n- Tests cover Observable semantics\n- Tests cover error scenarios","status":"open","priority":2,"issue_type":"task","created_at":"2026-01-05T06:39:08.718894-06:00","updated_at":"2026-01-05T06:39:08.718894-06:00"}
{"id":"neo4j-kro0","title":"[RED] Parser: FOREACH Tests","description":"## Overview\nWrite failing tests for FOREACH clause parsing.\n\n## Test Cases to Write\n\n### Basic FOREACH\n```cypher\nFOREACH (x IN [1, 2, 3] | CREATE (n:Node {value: x}))\n```\n\n### FOREACH with SET\n```cypher\nFOREACH (n IN nodes | SET n.processed = true)\n```\n\n### FOREACH with Multiple Operations\n```cypher\nFOREACH (item IN items |\n  CREATE (n:Node {id: item.id})\n  SET n.name = item.name\n)\n```\n\n### Nested FOREACH\n```cypher\nFOREACH (x IN [1,2] |\n  FOREACH (y IN [3,4] |\n    CREATE (n:Node {x: x, y: y})\n  )\n)\n```\n\n### FOREACH in Context\n```cypher\nMATCH p = (a)-[*]-\u003e(b)\nFOREACH (r IN relationships(p) | SET r.visited = true)\n```\n\n### Error Cases\n- Missing |\n- Missing closing )\n- Invalid operations in FOREACH body\n\n## Acceptance Criteria\n- [ ] All FOREACH tests written and failing\n- [ ] Multiple operations tested\n- [ ] Nested FOREACH tested\n- [ ] Error cases covered\n\n## TDD Phase: RED","status":"open","priority":2,"issue_type":"task","created_at":"2026-01-05T06:52:39.862782-06:00","updated_at":"2026-01-05T06:52:39.862782-06:00"}
{"id":"neo4j-kzx4","title":"GREEN: Implement buffer management","description":"## Overview\nImplement buffer management to make all RED tests pass.\n\n## Implementation Requirements\n\n### Buffer Implementation\n- Create bounded buffer\n- Track buffer occupancy\n- Handle overflow strategies\n- Drain on consumer request\n\n### Configuration\n- Default buffer size\n- Configurable size\n- Strategy selection\n- Metrics exposure\n\n### Memory Management\n- Bound memory usage\n- Release buffer memory\n- Handle large results\n- Prevent OOM\n\n## Acceptance Criteria\n- All RED tests now pass (GREEN phase)\n- Buffers work correctly\n- Memory bounded\n- Configuration works","status":"open","priority":2,"issue_type":"task","created_at":"2026-01-05T06:46:12.619671-06:00","updated_at":"2026-01-05T06:46:12.619671-06:00"}
{"id":"neo4j-l2k","title":"[GREEN] ID Generation - Implement ID encoding and decoding to pass tests","description":"## Overview\nImplement ID generation system to make all tests pass.\n\n## Implementation Requirements\n\n### Element ID Format\nNeo4j element IDs follow this format: `\u003ctype\u003e:\u003cdatabase-uuid\u003e:\u003cinternal-id\u003e`\n- Type 4: Node\n- Type 5: Relationship\n\nExample: `4:c47f4a0a-9f8a-4e3c-b5d4-123456789abc:42`\n\n### ID Generator Class\n```typescript\nconst ELEMENT_ID_REGEX = /^([45]):([a-f0-9-]+):(\\d+)$/;\n\nclass IdGenerator {\n  constructor(private databaseUuid: string) {}\n\n  encodeNodeId(internalId: number): string {\n    return `4:${this.databaseUuid}:${internalId}`;\n  }\n\n  encodeRelationshipId(internalId: number): string {\n    return `5:${this.databaseUuid}:${internalId}`;\n  }\n\n  decodeElementId(elementId: string): {\n    type: 'node' | 'relationship';\n    databaseUuid: string;\n    internalId: number;\n  } {\n    const match = elementId.match(ELEMENT_ID_REGEX);\n    if (\\!match) {\n      throw new Error('Invalid element ID format');\n    }\n    \n    const [, typeCode, uuid, id] = match;\n    return {\n      type: typeCode === '4' ? 'node' : 'relationship',\n      databaseUuid: uuid,\n      internalId: parseInt(id, 10)\n    };\n  }\n\n  extractInternalId(elementId: string): number {\n    return this.decodeElementId(elementId).internalId;\n  }\n\n  validateElementId(elementId: string): boolean {\n    try {\n      const decoded = this.decodeElementId(elementId);\n      return decoded.databaseUuid === this.databaseUuid;\n    } catch {\n      return false;\n    }\n  }\n}\n```\n\n### Database UUID Generation\n```typescript\n// Generate once per Durable Object and store\nasync function getOrCreateDatabaseUuid(storage: DurableObjectStorage): Promise\u003cstring\u003e {\n  let uuid = await storage.get\u003cstring\u003e('database_uuid');\n  if (\\!uuid) {\n    uuid = crypto.randomUUID();\n    await storage.put('database_uuid', uuid);\n  }\n  return uuid;\n}\n```\n\n## Files to Create\n- `src/storage/id-generator.ts`\n\n## Acceptance Criteria\n- [ ] All RED phase tests pass\n- [ ] Element ID format matches Neo4j\n- [ ] Encoding/decoding works correctly\n- [ ] UUID persists across restarts\n\n## TDD Phase\n**GREEN** - Minimum code to pass tests","status":"closed","priority":1,"issue_type":"task","created_at":"2026-01-05T06:38:40.292107-06:00","updated_at":"2026-01-05T08:58:13.608607-06:00","closed_at":"2026-01-05T08:58:13.608607-06:00","close_reason":"Implementation complete with tests"}
{"id":"neo4j-l39f","title":"REFACTOR: Request/Response serialization optimization","description":"## Test-Driven Development: REFACTOR Phase\n\n### Component\nHTTP Client SDK - Request/Response Serialization\n\n### Refactoring Goals\n\n1. **Type registry pattern**\n   - Create extensible type registry\n   - Support custom type serializers\n\n2. **Performance optimization**\n   - Use WeakMap for caching\n   - Lazy deserialization for large results\n\n3. **Validation**\n   - Add runtime type validation\n   - Better error messages for type mismatches\n\n4. **Streaming support preparation**\n   - Incremental deserialization\n   - Iterator-based record access\n\n### Code Improvements\n\n```typescript\n// Type registry for extensibility\nexport class TypeRegistry {\n  private serializers = new Map\u003cstring, TypeSerializer\u003e()\n  private deserializers = new Map\u003cstring, TypeDeserializer\u003e()\n\n  register(typeName: string, serializer: TypeSerializer, deserializer: TypeDeserializer): void {\n    this.serializers.set(typeName, serializer)\n    this.deserializers.set(typeName, deserializer)\n  }\n\n  serialize(value: unknown, typeName: string): unknown {\n    const serializer = this.serializers.get(typeName)\n    if (!serializer) throw new Error(`Unknown type: ${typeName}`)\n    return serializer(value)\n  }\n\n  deserialize(value: unknown, typeName: string): unknown {\n    const deserializer = this.deserializers.get(typeName)\n    if (!deserializer) throw new Error(`Unknown type: ${typeName}`)\n    return deserializer(value)\n  }\n}\n\n// Default registry with built-in types\nexport const defaultRegistry = new TypeRegistry()\ndefaultRegistry.register('Integer', serializeInteger, deserializeInteger)\ndefaultRegistry.register('DateTime', serializeDateTime, deserializeDateTime)\ndefaultRegistry.register('Node', serializeNode, deserializeNode)\n// ... etc\n\n// Lazy record deserialization\nexport class LazyRecord {\n  private cache = new Map\u003cstring, unknown\u003e()\n  \n  constructor(\n    private keys: string[],\n    private rawValues: unknown[],\n    private registry: TypeRegistry\n  ) {}\n\n  get(key: string): unknown {\n    if (this.cache.has(key)) return this.cache.get(key)\n    \n    const index = this.keys.indexOf(key)\n    if (index === -1) throw new Error(`Unknown key: ${key}`)\n    \n    const value = this.registry.deserialize(this.rawValues[index])\n    this.cache.set(key, value)\n    return value\n  }\n}\n\n// Streaming result iterator\nexport async function* streamResults(\n  response: ReadableStream\u003cUint8Array\u003e,\n  registry: TypeRegistry\n): AsyncGenerator\u003cRecord\u003e {\n  const decoder = new TextDecoder()\n  let buffer = ''\n  \n  for await (const chunk of response) {\n    buffer += decoder.decode(chunk, { stream: true })\n    const lines = buffer.split('\\n')\n    buffer = lines.pop() ?? ''\n    \n    for (const line of lines) {\n      if (line.trim()) {\n        yield deserializeRecord(JSON.parse(line), registry)\n      }\n    }\n  }\n}\n```\n\n### Acceptance Criteria\n- [ ] All existing tests still pass\n- [ ] TypeRegistry is extensible\n- [ ] Lazy deserialization implemented\n- [ ] Performance benchmarks show improvement\n- [ ] Custom type registration works\n\n### Dependencies\n- GREEN: Implement Request/Response serialization\n\n### TDD Cycle\nThis completes the RED-\u003eGREEN-\u003eREFACTOR cycle for Serialization.","status":"open","priority":2,"issue_type":"task","created_at":"2026-01-05T06:40:16.674623-06:00","updated_at":"2026-01-05T06:40:16.674623-06:00"}
{"id":"neo4j-l41","title":"[RED] Neo4j Driver API Surface Comparison Tests","description":"# [RED] Neo4j Driver API Surface Comparison Tests\n\n## Overview\nCreate tests that verify neo4j.do exposes the same API surface as the official neo4j-driver package.\n\n## Test Strategy\nRun the same test code against both neo4j-driver and neo4j.do to ensure API compatibility.\n\n## API Surface to Test\n\n### Driver Level\n```typescript\ndescribe('Driver API Surface', () =\u003e {\n  it('should export driver function', () =\u003e {\n    expect(typeof driver).toBe('function')\n  })\n\n  it('should create driver with URI and auth', () =\u003e {\n    const d = driver('bolt://localhost', auth.basic('user', 'pass'))\n    expect(d).toBeDefined()\n    expect(typeof d.session).toBe('function')\n    expect(typeof d.close).toBe('function')\n  })\n\n  it('should support all auth methods', () =\u003e {\n    expect(typeof auth.basic).toBe('function')\n    expect(typeof auth.bearer).toBe('function')\n    expect(typeof auth.kerberos).toBe('function')\n    expect(typeof auth.custom).toBe('function')\n  })\n})\n```\n\n### Session Level\n```typescript\ndescribe('Session API Surface', () =\u003e {\n  it('should have run method', () =\u003e {\n    const session = driver.session()\n    expect(typeof session.run).toBe('function')\n  })\n\n  it('should have transaction methods', () =\u003e {\n    const session = driver.session()\n    expect(typeof session.beginTransaction).toBe('function')\n    expect(typeof session.readTransaction).toBe('function')\n    expect(typeof session.writeTransaction).toBe('function')\n    expect(typeof session.executeRead).toBe('function')\n    expect(typeof session.executeWrite).toBe('function')\n  })\n\n  it('should support session config', () =\u003e {\n    const session = driver.session({\n      database: 'neo4j',\n      defaultAccessMode: 'READ',\n      bookmarks: []\n    })\n    expect(session).toBeDefined()\n  })\n})\n```\n\n### Result Level\n```typescript\ndescribe('Result API Surface', () =\u003e {\n  it('should return Result from run', async () =\u003e {\n    const result = await session.run('RETURN 1')\n    expect(result.records).toBeDefined()\n    expect(result.summary).toBeDefined()\n  })\n\n  it('should support streaming', async () =\u003e {\n    const result = session.run('RETURN 1')\n    const records = []\n    for await (const record of result) {\n      records.push(record)\n    }\n    expect(records.length).toBeGreaterThan(0)\n  })\n})\n```\n\n## Test File Structure\n```\ntests/compatibility/\n api-surface.test.ts\n driver-api.test.ts\n session-api.test.ts\n result-api.test.ts\n types-api.test.ts\n helpers/\n     dual-driver.ts  # Helper to run tests against both drivers\n```\n\n## Acceptance Criteria\n- [ ] Tests written for all public API methods\n- [ ] Tests fail initially (RED phase)\n- [ ] Test helper created for dual-driver testing\n- [ ] API coverage documented","status":"open","priority":2,"issue_type":"task","created_at":"2026-01-05T06:37:02.476773-06:00","updated_at":"2026-01-05T06:37:02.476773-06:00"}
{"id":"neo4j-l65b","title":"REFACTOR: Result.single() - Use proper Neo4jError type","description":"## Overview\nRefactor Result.single() to use proper Neo4j error types.\n\n## Refactoring Tasks\n\n1. **Error Types**\n   - Use Neo4jError with appropriate code\n   - Match official driver error behavior\n\n2. **Error Messages**\n   - Match Neo4j driver error message format\n   - Include helpful context\n\n## Acceptance Criteria\n- [ ] All tests still pass after refactoring\n- [ ] Uses proper Neo4jError type\n- [ ] Error messages match Neo4j driver\n\n## TDD Phase\nREFACTOR - Improve code without changing behavior\n\n## Dependencies\n- neo4j-8y8o (GREEN phase implementation)","status":"closed","priority":1,"issue_type":"task","created_at":"2026-01-05T06:49:41.158199-06:00","updated_at":"2026-01-05T07:19:22.16761-06:00","closed_at":"2026-01-05T07:19:22.16761-06:00","close_reason":"Implemented in this Ralph Wiggum session - 662 tests pass"}
{"id":"neo4j-l6fq","title":"[RED] Parser: DELETE and UNWIND Clause Tests","description":"## Overview\nWrite failing tests for DELETE and UNWIND clause parsing.\n\n## Test Cases to Write\n\n### Basic DELETE\n- Single: `DELETE n`\n- Multiple: `DELETE a, b, c`\n- Expression: `DELETE n.prop` (should error - can only delete nodes/rels)\n\n### DETACH DELETE\n- Simple: `DETACH DELETE n`\n- Multiple: `DETACH DELETE a, b`\n\n### DELETE Context\n- After MATCH: `MATCH (n) DELETE n`\n- Conditional: `MATCH (n) WHERE n.temp = true DELETE n`\n- With relationships: `MATCH (n)-[r]-\u003e() DELETE r`\n\n### Basic UNWIND\n- Simple: `UNWIND [1, 2, 3] AS x`\n- Variable: `UNWIND list AS item`\n- Property: `UNWIND n.items AS item`\n\n### UNWIND with Expressions\n- Range: `UNWIND range(1, 10) AS x`\n- Nested: `UNWIND [1, [2, 3]] AS x UNWIND x AS y`\n\n### UNWIND Context\n- Before MATCH: `UNWIND [1,2,3] AS x MATCH (n {id: x})`\n- After MATCH: `MATCH (n) UNWIND n.items AS i RETURN i`\n- With CREATE: `UNWIND $items AS item CREATE (n:Node {value: item})`\n\n## Acceptance Criteria\n- [ ] All DELETE tests written and failing\n- [ ] All UNWIND tests written and failing\n- [ ] DETACH DELETE tested\n- [ ] Error cases covered\n\n## TDD Phase: RED","status":"closed","priority":1,"issue_type":"task","created_at":"2026-01-05T06:44:30.66751-06:00","updated_at":"2026-01-05T08:46:40.404289-06:00","closed_at":"2026-01-05T08:46:40.404289-06:00","close_reason":"Tests passing - implementation complete"}
{"id":"neo4j-l7v2","title":"[RED] Index Management - Write failing tests for CREATE/DROP INDEX","description":"## Overview\nWrite failing tests for index management operations before implementation.\n\n## Test Cases to Write\n\n### CREATE INDEX Tests\n- `test_create_index_on_single_property`\n- `test_create_index_on_multiple_properties`\n- `test_create_index_with_name`\n- `test_create_index_for_label`\n- `test_create_index_for_relationship_type`\n- `test_create_duplicate_index_throws`\n- `test_create_index_if_not_exists`\n\n### DROP INDEX Tests\n- `test_drop_index_by_name`\n- `test_drop_nonexistent_index_throws`\n- `test_drop_index_if_exists`\n\n### Index Query Usage Tests\n- `test_index_used_for_property_equality`\n- `test_index_used_for_range_query`\n- `test_index_used_for_prefix_query`\n- `test_composite_index_used_correctly`\n- `test_query_without_index_still_works`\n\n### Full-Text Index Tests (FTS5)\n- `test_create_fulltext_index`\n- `test_fulltext_search_returns_matches`\n- `test_fulltext_search_with_wildcards`\n- `test_fulltext_search_phrase`\n- `test_drop_fulltext_index`\n\n### CONSTRAINT Tests\n- `test_create_uniqueness_constraint`\n- `test_uniqueness_constraint_prevents_duplicate`\n- `test_create_existence_constraint`\n- `test_existence_constraint_enforced`\n- `test_drop_constraint`\n\n### Index Listing Tests\n- `test_list_all_indexes`\n- `test_list_indexes_for_label`\n- `test_list_constraints`\n- `test_index_info_includes_properties`\n\n## Acceptance Criteria\n- [ ] All tests written and failing\n- [ ] All index types tested\n- [ ] Constraints tested\n- [ ] Query usage tested\n\n## TDD Phase\n**RED** - Write failing tests first","status":"closed","priority":1,"issue_type":"task","created_at":"2026-01-05T06:41:52.339901-06:00","updated_at":"2026-01-05T08:53:06.778479-06:00","closed_at":"2026-01-05T08:53:06.778479-06:00","close_reason":"Index management implemented in schema"}
{"id":"neo4j-lda1","title":"[GREEN] Parser: Implement List Comprehension Parsing","description":"## Overview\nImplement list comprehension and pattern comprehension parsing.\n\n## Implementation Tasks\n\n### List Comprehension Parser\n```typescript\nparseListComprehension(): ListComprehension {\n  const start = this.pos\n  this.expect('[')\n  \n  const variable = this.parseIdentifier()\n  this.expect('IN')\n  const source = this.parseExpression()\n  \n  // Optional WHERE\n  let filter: Expression | undefined\n  if (this.match('WHERE')) {\n    filter = this.parseExpression()\n  }\n  \n  // Optional transform\n  let transform: Expression | undefined\n  if (this.match('|')) {\n    transform = this.parseExpression()\n  }\n  \n  this.expect(']')\n  \n  return {\n    type: 'ListComprehension',\n    variable,\n    source,\n    filter,\n    transform,\n    loc: this.getLoc(start)\n  }\n}\n```\n\n### Pattern Comprehension Parser\n```typescript\nparsePatternComprehension(): PatternComprehension {\n  const start = this.pos\n  this.expect('[')\n  \n  // Parse the pattern\n  const pattern = this.patternParser.parsePatternChain()\n  \n  // Optional WHERE\n  let filter: Expression | undefined\n  if (this.match('WHERE')) {\n    filter = this.parseExpression()\n  }\n  \n  // Transform is required for pattern comprehensions\n  this.expect('|')\n  const transform = this.parseExpression()\n  \n  this.expect(']')\n  \n  return {\n    type: 'PatternComprehension',\n    pattern,\n    filter,\n    transform,\n    loc: this.getLoc(start)\n  }\n}\n```\n\n### Detection Logic\nDetect whether it is list or pattern comprehension by looking ahead.\n\n## Acceptance Criteria\n- [ ] All comprehension tests pass\n- [ ] List comprehensions work\n- [ ] Pattern comprehensions work\n- [ ] Proper AST nodes created\n\n## TDD Phase: GREEN\n## Depends On: neo4j-2b64","status":"open","priority":2,"issue_type":"task","created_at":"2026-01-05T06:49:53.538994-06:00","updated_at":"2026-01-05T06:49:53.538994-06:00"}
{"id":"neo4j-lhv","title":"RED: AI Functions in Cypher - Write failing tests for AI-powered functions","description":"## Overview\nWrite failing tests for AI-powered functions integrated into Cypher queries.\n\n## Test Cases\n\n```typescript\ndescribe('AI Functions in Cypher', () =\u003e {\n  describe('$ai.embed()', () =\u003e {\n    it('should generate embedding for text', async () =\u003e {\n      const result = await session.run(\n        'RETURN $ai.embed(\"Hello world\") as embedding'\n      );\n      \n      const embedding = result.records[0].get('embedding');\n      expect(Array.isArray(embedding)).toBe(true);\n      expect(embedding).toHaveLength(1024); // BGE-M3 dimension\n      expect(embedding.every(v =\u003e typeof v === 'number')).toBe(true);\n    });\n\n    it('should embed with custom model', async () =\u003e {\n      const result = await session.run(\n        'RETURN $ai.embed(\"Hello\", { model: \"@cf/baai/bge-small-en-v1.5\" }) as embedding'\n      );\n      \n      expect(result.records[0].get('embedding')).toHaveLength(384);\n    });\n\n    it('should use embedding in WHERE clause for similarity', async () =\u003e {\n      await session.run('CREATE (:Doc {text: \"Graph databases are powerful\", embedding: $e})', \n        { e: graphEmbedding });\n      \n      const result = await session.run(`\n        MATCH (d:Doc)\n        WHERE $ai.similarity(d.embedding, $ai.embed(\"database technology\")) \u003e 0.7\n        RETURN d.text\n      `);\n      \n      expect(result.records.length).toBeGreaterThan(0);\n    });\n  });\n\n  describe('$ai.generate()', () =\u003e {\n    it('should generate text from prompt', async () =\u003e {\n      const result = await session.run(\n        'RETURN $ai.generate(\"What is a graph database? Answer in one sentence.\") as response'\n      );\n      \n      const response = result.records[0].get('response');\n      expect(typeof response).toBe('string');\n      expect(response.length).toBeGreaterThan(10);\n    });\n\n    it('should generate with context from query', async () =\u003e {\n      const result = await session.run(`\n        MATCH (p:Person)-[:WORKS_AT]-\u003e(c:Company)\n        WITH collect(p.name + \" works at \" + c.name) as facts\n        RETURN $ai.generate(\"Summarize these employment relationships: \" + facts) as summary\n      `);\n      \n      expect(result.records[0].get('summary')).toBeDefined();\n    });\n\n    it('should support model configuration', async () =\u003e {\n      const result = await session.run(\n        'RETURN $ai.generate(\"Hello\", { model: \"@cf/meta/llama-3-8b-instruct\", maxTokens: 50 }) as response'\n      );\n      \n      expect(result.records[0].get('response')).toBeDefined();\n    });\n  });\n\n  describe('$ai.classify()', () =\u003e {\n    it('should classify text into categories', async () =\u003e {\n      const result = await session.run(\n        'RETURN $ai.classify(\"This product is amazing!\", [\"positive\", \"negative\", \"neutral\"]) as classification'\n      );\n      \n      const classification = result.records[0].get('classification');\n      expect(classification.label).toBe('positive');\n      expect(classification.score).toBeGreaterThan(0.5);\n    });\n\n    it('should classify node properties', async () =\u003e {\n      await session.run('CREATE (:Review {text: \"Terrible experience, would not recommend\"})');\n      \n      const result = await session.run(`\n        MATCH (r:Review)\n        RETURN r.text, $ai.classify(r.text, [\"positive\", \"negative\"]) as sentiment\n      `);\n      \n      expect(result.records[0].get('sentiment').label).toBe('negative');\n    });\n\n    it('should support batch classification', async () =\u003e {\n      const result = await session.run(`\n        MATCH (r:Review)\n        RETURN r.text, $ai.classify(r.text, [\"positive\", \"negative\"]) as sentiment\n        LIMIT 100\n      `);\n      \n      // Should batch API calls for efficiency\n    });\n  });\n\n  describe('$ai.extract()', () =\u003e {\n    it('should extract structured data from text', async () =\u003e {\n      const result = await session.run(`\n        RETURN $ai.extract(\n          \"John Smith (john@example.com) is the CEO of Acme Corp. He can be reached at 555-1234.\",\n          { name: \"string\", email: \"string\", company: \"string\", phone: \"string\", role: \"string\" }\n        ) as extracted\n      `);\n      \n      const extracted = result.records[0].get('extracted');\n      expect(extracted.name).toBe('John Smith');\n      expect(extracted.email).toBe('john@example.com');\n      expect(extracted.company).toBe('Acme Corp');\n    });\n\n    it('should extract and create nodes', async () =\u003e {\n      const result = await session.run(`\n        WITH \"Alice works at TechCo as an Engineer\" as text\n        WITH $ai.extract(text, { name: \"string\", company: \"string\", role: \"string\" }) as data\n        CREATE (p:Person {name: data.name})\n        CREATE (c:Company {name: data.company})\n        CREATE (p)-[:WORKS_AT {role: data.role}]-\u003e(c)\n        RETURN p, c\n      `);\n      \n      expect(result.records[0].get('p').properties.name).toBe('Alice');\n    });\n\n    it('should handle extraction from multiple nodes', async () =\u003e {\n      const result = await session.run(`\n        MATCH (e:Email)\n        RETURN e.subject, $ai.extract(e.body, { \n          action_items: \"string[]\",\n          mentioned_people: \"string[]\",\n          deadline: \"string?\"\n        }) as extracted\n      `);\n    });\n  });\n\n  describe('$ai.similarity()', () =\u003e {\n    it('should compute cosine similarity between vectors', async () =\u003e {\n      const result = await session.run(\n        'RETURN $ai.similarity([1,0,0], [1,0,0]) as score'\n      );\n      expect(result.records[0].get('score')).toBe(1.0);\n    });\n\n    it('should compute similarity between embeddings', async () =\u003e {\n      const result = await session.run(`\n        RETURN $ai.similarity(\n          $ai.embed(\"dog\"),\n          $ai.embed(\"puppy\")\n        ) as score\n      `);\n      \n      expect(result.records[0].get('score')).toBeGreaterThan(0.7);\n    });\n  });\n\n  describe('Error Handling', () =\u003e {\n    it('should handle rate limiting gracefully', async () =\u003e {\n      // Test rate limit behavior\n    });\n\n    it('should provide meaningful errors for invalid inputs', async () =\u003e {\n      await expect(session.run(\n        'RETURN $ai.classify(\"text\", []) as result'\n      )).rejects.toThrow(/categories cannot be empty/);\n    });\n\n    it('should timeout long-running AI calls', async () =\u003e {\n      // Test timeout behavior\n    });\n  });\n});\n```\n\n## Acceptance Criteria\n- [ ] All test cases written and failing\n- [ ] Mock Workers AI infrastructure\n- [ ] Test fixtures for various AI scenarios\n\n## Tags\nsuperset, ai-functions, workers-ai, cypher, tdd-red","status":"open","priority":2,"issue_type":"task","created_at":"2026-01-05T06:38:33.06851-06:00","updated_at":"2026-01-05T06:38:33.06851-06:00"}
{"id":"neo4j-lk5i","title":"[GREEN] Parser: Implement CREATE and MERGE Clauses","description":"## Overview\nImplement CREATE and MERGE clause parsing.\n\n## Implementation Tasks\n\n### CREATE Clause\n```typescript\nparseCreateClause(): CreateClause {\n  const start = this.pos\n  this.expect('CREATE')\n  \n  const patterns = this.patternParser.parsePatternList()\n  \n  return {\n    type: 'CreateClause',\n    patterns,\n    loc: this.getLoc(start)\n  }\n}\n```\n\n### MERGE Clause\n```typescript\nparseMergeClause(): MergeClause {\n  const start = this.pos\n  this.expect('MERGE')\n  \n  const pattern = this.patternParser.parsePattern()\n  \n  let onCreate: SetItem[] | undefined\n  let onMatch: SetItem[] | undefined\n  \n  while (this.match('ON')) {\n    if (this.match('CREATE')) {\n      this.expect('SET')\n      onCreate = this.parseSetItems()\n    } else if (this.match('MATCH')) {\n      this.expect('SET')\n      onMatch = this.parseSetItems()\n    } else {\n      this.error('Expected CREATE or MATCH after ON')\n    }\n  }\n  \n  return {\n    type: 'MergeClause',\n    pattern,\n    onCreate,\n    onMatch,\n    loc: this.getLoc(start)\n  }\n}\n```\n\n### Set Items Parser\n```typescript\nparseSetItems(): SetItem[] {\n  const items: SetItem[] = []\n  do {\n    items.push(this.parseSetItem())\n  } while (this.match(','))\n  return items\n}\n\nparseSetItem(): SetItem {\n  const property = this.expressionParser.parsePropertyAccess()\n  this.expect('=')\n  const value = this.expressionParser.parseExpression()\n  return { property, value }\n}\n```\n\n## Acceptance Criteria\n- [ ] All CREATE tests pass\n- [ ] All MERGE tests pass\n- [ ] ON CREATE/ON MATCH work correctly\n- [ ] Pattern parsing integrated\n\n## TDD Phase: GREEN\n## Depends On: neo4j-csli","status":"closed","priority":1,"issue_type":"task","created_at":"2026-01-05T06:43:35.511934-06:00","updated_at":"2026-01-05T08:46:40.403075-06:00","closed_at":"2026-01-05T08:46:40.403075-06:00","close_reason":"Tests passing - implementation complete"}
{"id":"neo4j-lni1","title":"RED: Write failing tests for unsubscription cleanup","description":"## Overview\nWrite failing tests for proper cleanup on unsubscription.\n\n## Test Cases to Write\n\n### Basic Unsubscription Tests\n- Unsubscribe stops pending query\n- Unsubscribe releases resources\n- Unsubscribe cancels network requests\n- Subscription.closed becomes true\n\n### Resource Cleanup Tests\n- Connection returned to pool\n- Memory released\n- Pending buffers cleared\n- Transaction rolled back if active\n\n### Timing Tests\n- Unsubscribe during query execution\n- Unsubscribe during record streaming\n- Unsubscribe during commit\n- Rapid subscribe/unsubscribe\n\n### Cleanup Verification\n- No memory leaks after unsubscribe\n- No dangling connections\n- No orphaned transactions\n- Clean state after unsubscribe\n\n## Acceptance Criteria\n- All tests written and failing (RED phase)\n- Tests verify resource cleanup\n- Tests cover timing scenarios\n- Tests verify no leaks","status":"open","priority":2,"issue_type":"task","created_at":"2026-01-05T06:44:22.533636-06:00","updated_at":"2026-01-05T06:44:22.533636-06:00"}
{"id":"neo4j-lo8","title":"[REFACTOR] Lexer: Optimize Token Types and Tokenization","description":"## Overview\nRefactor the lexer implementation for performance and maintainability.\n\n## Refactoring Tasks\n\n### Performance Optimizations\n- Use lookup tables for keyword recognition instead of switch/if-else chains\n- Implement lazy tokenization (generator/iterator pattern)\n- Consider string interning for common tokens\n- Benchmark and optimize hot paths\n\n### Code Quality\n- Extract token matchers into composable functions\n- Add comprehensive JSDoc documentation\n- Ensure consistent error handling\n- Add debug mode for token stream inspection\n\n### Type Safety\n- Narrow token types for better TypeScript inference\n- Create branded types for different identifier categories\n- Add type guards for token type checking\n\n## Acceptance Criteria\n- [ ] All tests still pass\n- [ ] Performance improved or maintained\n- [ ] Code is well-documented\n- [ ] No code duplication\n\n## TDD Phase: REFACTOR\n## Depends On: neo4j-nzr","status":"closed","priority":1,"issue_type":"task","created_at":"2026-01-05T06:34:57.338424-06:00","updated_at":"2026-01-05T07:46:37.196596-06:00","closed_at":"2026-01-05T07:46:37.196596-06:00","close_reason":"Completed in Ralph Wiggum session - 987 tests pass"}
{"id":"neo4j-lpm","title":"RED: Write failing tests for rxSession.run() returning RxResult","description":"## Overview\nWrite failing tests for `rxSession.run()` method that executes Cypher queries and returns RxResult.\n\n## Test Cases to Write\n\n### Basic Execution Tests\n- `rxSession.run(cypher)` returns RxResult\n- `rxSession.run(cypher, params)` accepts parameters\n- Returns Observable-based result\n- Query is not executed until subscribed (cold observable)\n\n### Parameter Tests\n- Handles string parameters\n- Handles number parameters\n- Handles boolean parameters\n- Handles array parameters\n- Handles object/map parameters\n- Handles null parameters\n- Handles Date parameters\n\n### Observable Behavior Tests\n- Result is cold observable (lazy execution)\n- Multiple subscriptions create multiple executions\n- Unsubscription cancels pending query\n- Proper completion signaling\n\n### Error Tests\n- Invalid Cypher syntax emits error\n- Connection errors propagate to subscriber\n- Parameter type errors handled appropriately\n\n## Acceptance Criteria\n- [ ] All tests written and failing (RED phase)\n- [ ] Tests verify RxResult interface\n- [ ] Tests verify Observable semantics\n- [ ] Tests cover parameter handling","status":"open","priority":2,"issue_type":"task","created_at":"2026-01-05T06:35:05.039547-06:00","updated_at":"2026-01-05T06:35:05.039547-06:00"}
{"id":"neo4j-lps","title":"GREEN: Session Bookmarks \u0026 Lifecycle Implementation","description":"## Overview\nImplement Session bookmarks, causal consistency, and lifecycle management to pass all RED phase tests.\n\n## Implementation Requirements\n\n### Bookmark Management\n```typescript\nclass Session {\n  private bookmarks: string[] = []\n  private lastBookmark_: string | null = null\n\n  lastBookmark(): string | null {\n    return this.lastBookmark_\n  }\n\n  lastBookmarks(): string[] {\n    return [...this.bookmarks]\n  }\n\n  // Internal method to update bookmarks after write\n  _updateBookmarks(newBookmark: string): void {\n    this.lastBookmark_ = newBookmark\n    this.bookmarks = [newBookmark]\n  }\n}\n```\n\n### Bookmark Format\n```typescript\ninterface Bookmark {\n  database: string\n  txId: number\n  timestamp: number\n}\n\nfunction generateBookmark(database: string, txId: number): string {\n  // Format: neo4j:bookmark:v1:tx{txId}\n  return `neo4j:bookmark:v1:tx${txId}`\n}\n\nfunction parseBookmark(bookmark: string): Bookmark | null {\n  // Parse and validate bookmark format\n}\n```\n\n### Session Lifecycle\n```typescript\nclass Session {\n  async close(): Promise\u003cvoid\u003e {\n    if (this.closed) return\n    \n    // Rollback any open transaction\n    if (this.currentTransaction?.isOpen()) {\n      await this.currentTransaction.rollback()\n    }\n    \n    // Wait for in-flight queries\n    await this.waitForQueries()\n    \n    this.closed = true\n    this.driver._removeSession(this)\n  }\n\n  private ensureOpen(): void {\n    if (this.closed) {\n      throw new SessionExpired('Session has been closed')\n    }\n  }\n}\n```\n\n### Causal Consistency\n```typescript\n// When creating session with bookmarks\nprivate async waitForBookmarks(): Promise\u003cvoid\u003e {\n  if (this.config.bookmarks?.length) {\n    // Verify bookmarks are reachable\n    // This ensures causal consistency\n  }\n}\n```\n\n## Files to Create/Modify\n- `src/session/session.ts`\n- `src/session/bookmarks.ts`\n- `src/session/types.ts`\n- `src/errors/session-expired.ts`\n\n## TDD Phase\n**GREEN** - Implement to pass tests.\n\n## Dependencies\n- Depends on: RED: Session Bookmarks \u0026 Lifecycle Tests\n- Depends on: GREEN: Session Class Query Execution Implementation\n\n## Acceptance Criteria\n- [ ] All RED phase tests pass\n- [ ] Bookmarks correctly track transaction history\n- [ ] Causal consistency maintained\n- [ ] Clean session lifecycle","status":"closed","priority":1,"issue_type":"task","created_at":"2026-01-05T06:37:33.462955-06:00","updated_at":"2026-01-05T08:57:46.160026-06:00","closed_at":"2026-01-05T08:57:46.160026-06:00","close_reason":"Translation and session tests passing"}
{"id":"neo4j-m1zs","title":"REFACTOR: Improve test scheduler integration","description":"## Overview\nRefactor test scheduler support for better testing experience.\n\n## Refactoring Tasks\n\n### Code Quality\n- Clean scheduler API\n- Type-safe scheduler injection\n- Document scheduler usage\n- Test examples\n\n### Test Utilities\n- Create test helpers\n- Marble test utilities\n- Time assertion helpers\n- Common test patterns\n\n### Documentation\n- Testing guide\n- Marble syntax reference\n- Common patterns\n- Performance testing\n\n## Acceptance Criteria\n- All tests still pass\n- Clean scheduler API\n- Useful test utilities\n- Good documentation","status":"open","priority":2,"issue_type":"task","created_at":"2026-01-05T06:49:27.282991-06:00","updated_at":"2026-01-05T06:49:27.282991-06:00"}
{"id":"neo4j-m20","title":"[GREEN] In-Memory Graph - Implement storage structures to pass tests","description":"## Overview\nImplement in-memory graph storage to make all tests pass.\n\n## Implementation Requirements\n\n### Core Data Structures\n```typescript\ninterface InMemoryGraph {\n  nodes: Map\u003cnumber, Node\u003e;\n  relationships: Map\u003cnumber, Relationship\u003e;\n  \n  // Adjacency lists\n  outgoing: Map\u003cnumber, Set\u003cnumber\u003e\u003e; // nodeId -\u003e relationshipIds\n  incoming: Map\u003cnumber, Set\u003cnumber\u003e\u003e; // nodeId -\u003e relationshipIds\n  \n  // Indexes\n  labelIndex: Map\u003cstring, Set\u003cnumber\u003e\u003e; // label -\u003e nodeIds\n  typeIndex: Map\u003cstring, Set\u003cnumber\u003e\u003e;  // type -\u003e relationshipIds\n}\n```\n\n### Node Operations\n```typescript\nclass InMemoryNodeStore {\n  private nodes = new Map\u003cnumber, Node\u003e();\n  private labelIndex = new Map\u003cstring, Set\u003cnumber\u003e\u003e();\n  \n  create(labels: string[], properties: object): Node;\n  get(id: number): Node | null;\n  update(id: number, properties: object): void;\n  delete(id: number): boolean;\n  getByLabel(label: string): Node[];\n}\n```\n\n### Relationship Operations\n```typescript\nclass InMemoryRelationshipStore {\n  private relationships = new Map\u003cnumber, Relationship\u003e();\n  private typeIndex = new Map\u003cstring, Set\u003cnumber\u003e\u003e();\n  private outgoing = new Map\u003cnumber, Set\u003cnumber\u003e\u003e();\n  private incoming = new Map\u003cnumber, Set\u003cnumber\u003e\u003e();\n  \n  create(type: string, startId: number, endId: number, properties: object): Relationship;\n  get(id: number): Relationship | null;\n  getByType(type: string): Relationship[];\n  getForNode(nodeId: number, direction: 'in' | 'out' | 'both'): Relationship[];\n}\n```\n\n## Files to Create\n- `src/storage/memory/graph.ts`\n- `src/storage/memory/node-store.ts`\n- `src/storage/memory/relationship-store.ts`\n- `src/storage/memory/indexes.ts`\n\n## Acceptance Criteria\n- [ ] All RED phase tests pass\n- [ ] O(1) node/relationship lookup\n- [ ] Indexes maintained automatically\n- [ ] Memory-efficient implementation\n\n## TDD Phase\n**GREEN** - Minimum code to pass tests","status":"closed","priority":1,"issue_type":"task","created_at":"2026-01-05T06:35:25.543649-06:00","updated_at":"2026-01-05T08:46:57.51736-06:00","closed_at":"2026-01-05T08:46:57.51736-06:00","close_reason":"Tests passing - implementation complete"}
{"id":"neo4j-m40","title":"REFACTOR: Session Class Query Execution Optimization","description":"## Overview\nRefactor Session class query execution for performance, reliability, and edge cases.\n\n## Refactoring Goals\n\n### Performance Optimizations\n- Query result streaming\n- Batch parameter processing\n- Connection pooling integration\n- Result caching for repeated queries\n\n### Reliability Improvements\n- Better error classification\n- Improved retry strategies\n- Deadlock detection\n- Query timeout handling\n\n### Edge Cases\n```typescript\ndescribe('Session Query Edge Cases', () =\u003e {\n  it('should handle very long queries')\n  it('should handle many parameters')\n  it('should handle concurrent runs')\n  it('should handle run during executeRead')\n  it('should handle session timeout during query')\n  it('should handle result consumption after session close')\n  it('should handle streaming large results')\n  it('should handle queries returning no columns')\n  it('should handle queries with null parameters')\n})\n```\n\n### Code Quality\n- Extract retry logic into separate component\n- Create query builder for internal queries\n- Add query logging middleware\n- Improve error messages with query context\n\n## TDD Phase\n**REFACTOR** - Improve without breaking tests.\n\n## Dependencies\n- Depends on: GREEN: Session Class Query Execution Implementation\n\n## Acceptance Criteria\n- [ ] All tests pass\n- [ ] Performance benchmarks improved\n- [ ] Edge cases handled gracefully\n- [ ] Code is maintainable","status":"open","priority":2,"issue_type":"task","created_at":"2026-01-05T06:36:53.210323-06:00","updated_at":"2026-01-05T06:36:53.210323-06:00"}
{"id":"neo4j-m9m0","title":"[GREEN] Parser: Implement Predicate Expression Parsing","description":"## Overview\nImplement predicate expression parsing.\n\n## Implementation Tasks\n\n### IS NULL / IS NOT NULL\n```typescript\nparseIsNullPredicate(left: Expression): Expression {\n  this.expect('IS')\n  const negated = this.match('NOT')\n  this.expect('NULL')\n  \n  return {\n    type: 'IsNullExpression',\n    expression: left,\n    negated,\n    loc: this.getLoc(left.loc.start)\n  }\n}\n```\n\n### String Predicates\n```typescript\nparseStringPredicate(left: Expression): Expression {\n  let operator: string\n  \n  if (this.match('STARTS')) {\n    this.expect('WITH')\n    operator = 'STARTS WITH'\n  } else if (this.match('ENDS')) {\n    this.expect('WITH')\n    operator = 'ENDS WITH'\n  } else if (this.match('CONTAINS')) {\n    operator = 'CONTAINS'\n  }\n  \n  const right = this.parseExpression()\n  \n  return {\n    type: 'BinaryExpression',\n    operator,\n    left,\n    right,\n    loc: this.getLoc(left.loc.start)\n  }\n}\n```\n\n### Quantified Predicates\n```typescript\nparseQuantifiedPredicate(): QuantifiedExpression {\n  const quantifier = this.advance().value // ANY, ALL, NONE, SINGLE\n  this.expect('(')\n  \n  const variable = this.parseIdentifier()\n  this.expect('IN')\n  const list = this.parseExpression()\n  \n  let filter: Expression | undefined\n  if (this.match('WHERE')) {\n    filter = this.parseExpression()\n  }\n  \n  this.expect(')')\n  \n  return {\n    type: 'QuantifiedExpression',\n    quantifier,\n    variable,\n    list,\n    filter,\n    loc: this.getLoc(start)\n  }\n}\n```\n\n## Acceptance Criteria\n- [ ] All predicate tests pass\n- [ ] Multi-word operators work\n- [ ] Quantified predicates work\n- [ ] Proper AST nodes created\n\n## TDD Phase: GREEN\n## Depends On: neo4j-6n87","status":"closed","priority":1,"issue_type":"task","created_at":"2026-01-05T06:50:30.765744-06:00","updated_at":"2026-01-05T07:19:48.958881-06:00","closed_at":"2026-01-05T07:19:48.958881-06:00","close_reason":"Parser implemented with MATCH, RETURN, node/relationship patterns, expressions - 34 parser tests pass"}
{"id":"neo4j-mbfr","title":"GREEN: Implement Browser compatibility","description":"## Test-Driven Development: GREEN Phase\n\n### Component\nHTTP Client SDK - Browser Compatibility\n\n### Implementation Requirements\n\nImplement browser-compatible client:\n- Use only Web APIs (fetch, crypto.randomUUID, etc.)\n- Avoid Node.js-specific imports\n- Provide CORS error detection and helpful messages\n- Export ESM and UMD bundles\n- Ensure tree-shaking works correctly\n\n### Acceptance Criteria\n- All RED phase tests pass\n- No Node.js dependencies\n- Fetch API used correctly\n- CORS errors detected with helpful messages\n- Bundle size under target (e.g., \u003c20KB gzipped)\n\n### Dependencies\n- RED: Browser compatibility fails without implementation\n\n### TDD Cycle\nThis is the GREEN phase. Next: REFACTOR phase.","status":"open","priority":2,"issue_type":"task","created_at":"2026-01-05T06:48:52.44733-06:00","updated_at":"2026-01-05T06:48:52.44733-06:00"}
{"id":"neo4j-mga","title":"RED: Auto Vector Embeddings - Write failing tests for automatic embedding generation","description":"## Overview\nWrite failing tests for automatic vector embedding generation on node/relationship creation.\n\n## Test Cases\n\n### Embedding Generation Tests\n```typescript\ndescribe('Auto Vector Embeddings', () =\u003e {\n  describe('Node Creation Embedding', () =\u003e {\n    it('should auto-generate embedding when node has configured text field', async () =\u003e {\n      // Configure embedding for Person.bio field\n      await session.run('CALL db.index.vector.create(\"person_bio\", \"Person\", \"bioEmbedding\", 1024, \"cosine\")');\n      await session.run('CALL db.index.vector.configure(\"person_bio\", { sourceField: \"bio\", model: \"@cf/baai/bge-m3\" })');\n      \n      const result = await session.run(\n        'CREATE (p:Person {name: \"Alice\", bio: \"Software engineer passionate about graphs\"}) RETURN p'\n      );\n      \n      const node = result.records[0].get('p');\n      expect(node.properties.bioEmbedding).toBeDefined();\n      expect(node.properties.bioEmbedding).toHaveLength(1024);\n    });\n\n    it('should not generate embedding when source field is missing', async () =\u003e {\n      const result = await session.run(\n        'CREATE (p:Person {name: \"Bob\"}) RETURN p'\n      );\n      expect(result.records[0].get('p').properties.bioEmbedding).toBeUndefined();\n    });\n\n    it('should regenerate embedding when source field is updated', async () =\u003e {\n      const create = await session.run(\n        'CREATE (p:Person {name: \"Carol\", bio: \"Original bio\"}) RETURN p, id(p) as id'\n      );\n      const originalEmbedding = create.records[0].get('p').properties.bioEmbedding;\n      \n      await session.run(\n        'MATCH (p:Person {name: \"Carol\"}) SET p.bio = \"Updated bio about data science\" RETURN p'\n      );\n      \n      const updated = await session.run('MATCH (p:Person {name: \"Carol\"}) RETURN p');\n      const newEmbedding = updated.records[0].get('p').properties.bioEmbedding;\n      \n      expect(newEmbedding).not.toEqual(originalEmbedding);\n    });\n  });\n\n  describe('Configurable Embedding Fields', () =\u003e {\n    it('should support multiple embedding fields per label', async () =\u003e {\n      await session.run('CALL db.index.vector.configure(\"article_title\", { sourceField: \"title\", targetField: \"titleEmbedding\" })');\n      await session.run('CALL db.index.vector.configure(\"article_content\", { sourceField: \"content\", targetField: \"contentEmbedding\" })');\n      \n      const result = await session.run(\n        'CREATE (a:Article {title: \"Graph Databases\", content: \"Long article content...\"}) RETURN a'\n      );\n      \n      const node = result.records[0].get('a');\n      expect(node.properties.titleEmbedding).toBeDefined();\n      expect(node.properties.contentEmbedding).toBeDefined();\n    });\n\n    it('should support composite field embedding', async () =\u003e {\n      await session.run('CALL db.index.vector.configure(\"person_full\", { sourceFields: [\"name\", \"bio\", \"skills\"], separator: \" | \" })');\n      \n      const result = await session.run(\n        'CREATE (p:Person {name: \"Dan\", bio: \"Engineer\", skills: \"TypeScript, Neo4j\"}) RETURN p'\n      );\n      \n      expect(result.records[0].get('p').properties.fullEmbedding).toBeDefined();\n    });\n  });\n\n  describe('Workers AI Integration', () =\u003e {\n    it('should use configured embedding model', async () =\u003e {\n      await session.run('CALL db.index.vector.configure(\"test\", { model: \"@cf/baai/bge-m3\" })');\n      // Verify model is called with correct parameters\n    });\n\n    it('should handle rate limiting gracefully', async () =\u003e {\n      // Simulate rate limit scenario\n    });\n\n    it('should retry on transient failures', async () =\u003e {\n      // Verify retry logic\n    });\n  });\n\n  describe('Batch Embedding', () =\u003e {\n    it('should batch embed multiple nodes efficiently', async () =\u003e {\n      const nodes = Array.from({ length: 100 }, (_, i) =\u003e \n        `CREATE (:Article {title: \"Article ${i}\", content: \"Content ${i}\"})`\n      ).join(' ');\n      \n      const start = Date.now();\n      await session.run(nodes);\n      const duration = Date.now() - start;\n      \n      // Should batch API calls, not 100 individual calls\n      expect(duration).toBeLessThan(5000);\n    });\n\n    it('should support bulk import with embeddings', async () =\u003e {\n      await session.run('CALL db.embeddings.bulkGenerate(\"Person\", \"bio\", { batchSize: 50 })');\n      \n      const result = await session.run('MATCH (p:Person) WHERE p.bioEmbedding IS NULL RETURN count(p) as missing');\n      expect(result.records[0].get('missing').toNumber()).toBe(0);\n    });\n  });\n\n  describe('Relationship Embeddings', () =\u003e {\n    it('should auto-embed relationship properties', async () =\u003e {\n      await session.run('CALL db.index.vector.configure(\"review_text\", { type: \"relationship\", relType: \"REVIEWED\", sourceField: \"text\" })');\n      \n      const result = await session.run(\n        'CREATE (u:User)-[r:REVIEWED {text: \"Great product\\!\"}]-\u003e(p:Product) RETURN r'\n      );\n      \n      expect(result.records[0].get('r').properties.textEmbedding).toBeDefined();\n    });\n  });\n});\n```\n\n## Acceptance Criteria\n- [ ] All test cases written and failing\n- [ ] Test infrastructure for mocking Workers AI\n- [ ] Test fixtures for various embedding scenarios\n- [ ] Performance benchmarks defined\n\n## Dependencies\n- Workers AI binding setup\n- Vector storage schema\n\n## Tags\nsuperset, embeddings, workers-ai, tdd-red","status":"open","priority":2,"issue_type":"task","created_at":"2026-01-05T06:34:42.604016-06:00","updated_at":"2026-01-05T06:34:42.604016-06:00"}
{"id":"neo4j-mhly","title":"RED: Write failing tests for RxJS operators integration","description":"## Overview\nWrite failing tests for proper RxJS operators integration with reactive API.\n\n## Test Cases to Write\n\n### Transformation Operators\n- map() works with records()\n- filter() works with records()\n- scan() for accumulating results\n- reduce() for single result\n- pluck() for field extraction\n\n### Filtering Operators\n- take(n) limits records\n- takeWhile() conditional limiting\n- skip(n) skips records\n- first() gets first record\n- last() gets last record\n\n### Combination Operators\n- concat() for sequential queries\n- merge() for parallel queries\n- forkJoin() for multiple results\n- combineLatest() scenarios\n\n### Error Handling Operators\n- catchError() for recovery\n- retry() for transient failures\n- retryWhen() for custom retry logic\n- finalize() for cleanup\n\n### Utility Operators\n- tap() for side effects\n- delay() for timing\n- timeout() for limits\n- toArray() for collection\n\n## Acceptance Criteria\n- All tests written and failing (RED phase)\n- Tests cover common operators\n- Tests verify correct behavior\n- Tests demonstrate patterns","status":"open","priority":2,"issue_type":"task","created_at":"2026-01-05T06:42:17.029947-06:00","updated_at":"2026-01-05T06:42:17.029947-06:00"}
{"id":"neo4j-mknq","title":"RED: Write failing tests for retry operators compatibility","description":"## Overview\nWrite failing tests for compatibility with RxJS retry operators.\n\n## Test Cases to Write\n\n### Basic Retry Tests\n- retry() works with failed queries\n- retry(n) limits retry attempts\n- Successful retry resolves normally\n- Exhausted retries emit error\n\n### retryWhen Tests\n- retryWhen() with custom logic\n- Delay between retries\n- Conditional retry based on error\n- Backoff strategies work\n\n### Transient Error Tests\n- Transient errors retried\n- Non-transient errors not retried\n- ServiceUnavailable retried\n- ConstraintViolation not retried\n\n### Retry State Tests\n- Fresh connection per retry\n- Transaction recreated on retry\n- State reset between retries\n- Resources cleaned up\n\n## Acceptance Criteria\n- All tests written and failing (RED phase)\n- Tests verify retry behavior\n- Tests cover error classification\n- Tests verify state reset","status":"open","priority":2,"issue_type":"task","created_at":"2026-01-05T06:47:39.357675-06:00","updated_at":"2026-01-05T06:47:39.357675-06:00"}
{"id":"neo4j-mkq","title":"GREEN: Implement rxSession.lastBookmarks() method","description":"## Overview\nImplement rxSession.lastBookmarks() to make all RED tests pass.\n\n## Implementation Requirements\n\n### Method Signature\n```typescript\ninterface RxSession {\n  lastBookmarks(): string[]\n}\n```\n\n### Implementation Details\n- Return current session bookmarks\n- Track bookmark updates from transactions\n- Initialize from session config\n- Synchronous access to current state\n\n### Bookmark Management\n- Update bookmarks on transaction commit\n- Preserve bookmarks on rollback\n- Handle multiple bookmark sources\n\n## Acceptance Criteria\n- All RED tests now pass (GREEN phase)\n- Returns correct bookmark array\n- Bookmarks properly tracked\n- Synchronous access works","status":"open","priority":2,"issue_type":"task","created_at":"2026-01-05T06:37:34.340573-06:00","updated_at":"2026-01-05T06:37:34.340573-06:00"}
{"id":"neo4j-mmc","title":"REFACTOR: Pattern to JOIN Translation - Relationship Patterns","description":"## Overview\nRefactor relationship pattern translation for maintainability.\n\n## Refactoring Tasks\n\n### 1. Unified Pattern Visitor\n```typescript\ninterface PatternVisitor\u003cT\u003e {\n  visitNodePattern(node: NodePattern): T;\n  visitRelationshipPattern(rel: RelationshipPattern): T;\n  visitPathPattern(path: PathPattern): T;\n}\n\nclass SQLPatternVisitor implements PatternVisitor\u003cSQLFragment\u003e { }\n```\n\n### 2. JOIN Builder Abstraction\n```typescript\nclass JoinBuilder {\n  innerJoin(table: string, alias: string): JoinClause;\n  leftJoin(table: string, alias: string): JoinClause;\n  on(condition: string): this;\n  build(): string;\n}\n```\n\n### 3. Direction Strategy\n```typescript\ninterface DirectionStrategy {\n  getStartNodeColumn(): string;\n  getEndNodeColumn(): string;\n  needsBidirectional(): boolean;\n}\n```\n\n### 4. Optimize Generated SQL\n- Reduce unnecessary parentheses\n- Use table aliases consistently\n- Minimize subqueries where possible\n\n## Quality Improvements\n- [ ] Consistent visitor pattern throughout\n- [ ] Reusable JOIN builder\n- [ ] Clean separation of concerns\n- [ ] Comprehensive type definitions\n\n## Acceptance Criteria\n- [ ] All tests still pass\n- [ ] Code is more readable and maintainable\n- [ ] Performance not degraded\n\n## TDD Phase\nREFACTOR - Improve code quality while keeping tests green\n\n## Dependencies\n- Depends on: GREEN: Pattern to JOIN Translation - Relationship Patterns","status":"closed","priority":1,"issue_type":"task","created_at":"2026-01-05T06:35:55.956703-06:00","updated_at":"2026-01-05T08:47:39.630152-06:00","closed_at":"2026-01-05T08:47:39.630152-06:00","close_reason":"Tests passing - implementation complete"}
{"id":"neo4j-mnp","title":"GREEN: Full-Text Search - Implement FTS5 procedures","description":"## Overview\nImplement full-text search using SQLite FTS5 to make all RED tests pass.\n\n## Implementation Requirements\n\n### Core Components\n\n#### 1. FTS5 Schema Management\n```sql\n-- FTS5 virtual table per index\nCREATE VIRTUAL TABLE fts_{indexName} USING fts5(\n  entity_id,\n  {columns...},\n  content='',  -- External content mode\n  tokenize='porter unicode61'\n);\n\n-- Index metadata\nCREATE TABLE fulltext_indexes (\n  id TEXT PRIMARY KEY,\n  name TEXT NOT NULL UNIQUE,\n  entity_type TEXT NOT NULL CHECK (entity_type IN ('node', 'relationship')),\n  labels TEXT,  -- JSON array for nodes\n  rel_types TEXT,  -- JSON array for relationships  \n  properties TEXT NOT NULL,  -- JSON array of indexed properties\n  tokenizer TEXT DEFAULT 'porter unicode61',\n  created_at TEXT DEFAULT (datetime('now'))\n);\n\n-- Triggers for auto-indexing\nCREATE TRIGGER fts_{indexName}_insert AFTER INSERT ON nodes\nWHEN NEW.labels LIKE '%{label}%'\nBEGIN\n  INSERT INTO fts_{indexName}(entity_id, {columns}) \n  VALUES (NEW.id, {property_extractions});\nEND;\n```\n\n#### 2. Fulltext Index Manager\n```typescript\ninterface FulltextIndexConfig {\n  name: string;\n  entityType: 'node' | 'relationship';\n  labels?: string[];\n  relTypes?: string[];\n  properties: string[];\n  tokenizer?: 'porter' | 'unicode61' | 'trigram';\n}\n\nclass FulltextIndexManager {\n  async createIndex(config: FulltextIndexConfig): Promise\u003cvoid\u003e;\n  async dropIndex(name: string): Promise\u003cvoid\u003e;\n  async listIndexes(): Promise\u003cFulltextIndexConfig[]\u003e;\n  async rebuildIndex(name: string): Promise\u003cvoid\u003e;\n}\n```\n\n#### 3. Fulltext Search Service\n```typescript\ninterface FulltextSearchOptions {\n  limit?: number;\n  offset?: number;\n  highlight?: boolean;\n  snippetLength?: number;\n}\n\ninterface FulltextSearchResult {\n  entityId: string;\n  score: number;\n  highlights?: Record\u003cstring, string\u003e;\n}\n\nclass FulltextSearchService {\n  async queryNodes(\n    indexName: string,\n    query: string,\n    options?: FulltextSearchOptions\n  ): Promise\u003cFulltextSearchResult[]\u003e;\n\n  async queryRelationships(\n    indexName: string,\n    query: string,\n    options?: FulltextSearchOptions\n  ): Promise\u003cFulltextSearchResult[]\u003e;\n}\n```\n\n#### 4. Query Parser\n```typescript\nclass FTS5QueryParser {\n  // Convert user-friendly syntax to FTS5 syntax\n  parse(query: string): string;\n  \n  // Handle:\n  // - Phrase search: \"exact phrase\"\n  // - Boolean: AND, OR, NOT\n  // - Prefix: word*\n  // - Fuzzy: word~ (convert to NEAR or similar)\n  // - Field-specific: title:word\n}\n```\n\n### Procedures to Implement\n```typescript\n// db.index.fulltext.create\nasync function createFulltextIndex(\n  indexName: string,\n  labels: string[],\n  properties: string[],\n  options?: { entityType?: string; relTypes?: string[] }\n): Promise\u003cvoid\u003e;\n\n// db.index.fulltext.drop\nasync function dropFulltextIndex(indexName: string): Promise\u003cvoid\u003e;\n\n// db.index.fulltext.list\nasync function* listFulltextIndexes(): AsyncGenerator\u003cFulltextIndexInfo\u003e;\n\n// db.index.fulltext.queryNodes\nasync function* queryNodes(\n  indexName: string,\n  query: string\n): AsyncGenerator\u003c{ node: Node; score: number }\u003e;\n\n// db.index.fulltext.queryRelationships  \nasync function* queryRelationships(\n  indexName: string,\n  query: string\n): AsyncGenerator\u003c{ relationship: Relationship; score: number }\u003e;\n```\n\n### FTS5 Features to Support\n- BM25 ranking (default in FTS5)\n- Porter stemming\n- Unicode tokenization\n- Phrase queries\n- Boolean operators (AND, OR, NOT)\n- Prefix queries (word*)\n- Column filtering\n- Highlight/snippet functions\n\n## Acceptance Criteria\n- [ ] All RED phase tests passing\n- [ ] FTS5 indexes created correctly\n- [ ] Auto-indexing on node/relationship changes\n- [ ] Relevance scoring working\n- [ ] Fuzzy matching via trigram fallback\n\n## Dependencies\n- RED: Full-Text Search tests\n- D1 database binding\n\n## Tags\nsuperset, fulltext-search, fts5, sqlite, tdd-green","status":"open","priority":2,"issue_type":"task","created_at":"2026-01-05T06:37:40.400323-06:00","updated_at":"2026-01-05T06:37:40.400323-06:00"}
{"id":"neo4j-mw37","title":"RED: Expression Translation","description":"## Overview\nWrite failing tests for Cypher expression translation to SQL.\n\n## Test Cases to Write\n\n### Test 1: Property Access\n- n.name -\u003e json_extract(n.properties, '$.name')\n\n### Test 2: Nested Property Access\n- n.address.city -\u003e json_extract with nested path\n\n### Test 3: Arithmetic Operators\n- n.age + 1, n.price * 0.9 -\u003e SQL arithmetic\n\n### Test 4: Comparison Operators\n- n.age \u003e 21, n.name = 'Alice' -\u003e SQL comparisons\n\n### Test 5: Boolean Operators\n- a AND b, a OR b, NOT a -\u003e SQL boolean\n\n### Test 6: String Operations\n- n.name STARTS WITH 'A' -\u003e LIKE 'A%'\n- n.name CONTAINS 'son' -\u003e LIKE '%son%'\n- n.name ENDS WITH 'son' -\u003e LIKE '%son'\n\n### Test 7: NULL Handling\n- n.name IS NULL, n.name IS NOT NULL\n\n### Test 8: List Operations\n- n.tags[0] -\u003e JSON array access\n- size(n.tags) -\u003e json_array_length\n\n### Test 9: IN Operator\n- n.status IN ['active', 'pending']\n\n### Test 10: Type Coercion\n- toString(n.age), toInteger(n.score)\n\n### Test 11: CASE Expression\n- CASE WHEN n.age \u003e 21 THEN 'adult' ELSE 'minor' END\n\n## Acceptance Criteria\n- All tests written and failing\n- All operators covered\n- Edge cases for NULL handling\n\n## TDD Phase\nRED - Write failing tests first","status":"closed","priority":1,"issue_type":"task","created_at":"2026-01-05T06:41:36.56206-06:00","updated_at":"2026-01-05T08:55:39.251211-06:00","closed_at":"2026-01-05T08:55:39.251211-06:00","close_reason":"Translation already implemented with tests"}
{"id":"neo4j-n0r","title":"REFACTOR: Clean up driver.rxSession() factory implementation","description":"## Overview\nRefactor the `driver.rxSession()` factory implementation for better code quality.\n\n## Refactoring Tasks\n\n### Code Quality\n- Extract common session creation logic\n- Ensure consistent config handling with sync sessions\n- Add proper TypeScript types and generics\n- Improve error messages\n\n### Documentation\n- Add JSDoc comments\n- Document config options\n- Add usage examples in comments\n\n### Performance\n- Optimize instance creation\n- Consider lazy initialization patterns\n- Review memory allocation\n\n## Acceptance Criteria\n- [ ] All tests still pass after refactoring\n- [ ] Code follows project style guidelines\n- [ ] No code duplication with sync session factory\n- [ ] Clear separation of concerns","status":"open","priority":2,"issue_type":"task","created_at":"2026-01-05T06:34:45.912732-06:00","updated_at":"2026-01-05T06:34:45.912732-06:00"}
{"id":"neo4j-n3u","title":"GREEN: Session Class Query Execution Implementation","description":"## Overview\nImplement Session class query execution methods to pass all RED phase tests.\n\n## Implementation Requirements\n\n### Session Class\n```typescript\nclass Session {\n  private driver: Driver\n  private config: SessionConfig\n  private currentTransaction: Transaction | null = null\n  private lastBookmarks: string[] = []\n  private closed: boolean = false\n\n  constructor(driver: Driver, config?: SessionConfig) {\n    this.driver = driver\n    this.config = {\n      database: config?.database ?? 'neo4j',\n      defaultAccessMode: config?.defaultAccessMode ?? 'WRITE',\n      bookmarks: normalizeBookmarks(config?.bookmarks),\n      fetchSize: config?.fetchSize ?? 1000,\n      impersonatedUser: config?.impersonatedUser\n    }\n  }\n}\n```\n\n### run() Method\n```typescript\nasync run(cypher: string, params?: Record\u003cstring, any\u003e): Promise\u003cResult\u003e {\n  this.ensureOpen()\n  this.ensureNoTransaction()\n  \n  const result = await this.executeAutoCommit(cypher, params)\n  return result\n}\n```\n\n### executeRead() / executeWrite() Methods\n```typescript\nasync executeRead\u003cT\u003e(\n  work: (tx: ManagedTransaction) =\u003e Promise\u003cT\u003e,\n  config?: TransactionConfig\n): Promise\u003cT\u003e {\n  return this.executeInTransaction(work, 'READ', config)\n}\n\nasync executeWrite\u003cT\u003e(\n  work: (tx: ManagedTransaction) =\u003e Promise\u003cT\u003e,\n  config?: TransactionConfig\n): Promise\u003cT\u003e {\n  return this.executeInTransaction(work, 'WRITE', config)\n}\n\nprivate async executeInTransaction\u003cT\u003e(\n  work: (tx: ManagedTransaction) =\u003e Promise\u003cT\u003e,\n  accessMode: AccessMode,\n  config?: TransactionConfig\n): Promise\u003cT\u003e {\n  // Implement retry logic\n}\n```\n\n### beginTransaction() Method\n```typescript\nbeginTransaction(config?: TransactionConfig): Transaction {\n  this.ensureOpen()\n  this.ensureNoTransaction()\n  \n  this.currentTransaction = new Transaction(this, config)\n  return this.currentTransaction\n}\n```\n\n## Files to Create/Modify\n- `src/session/session.ts`\n- `src/session/result.ts`\n- `src/transaction/transaction.ts` (stub)\n- `src/session/types.ts`\n\n## TDD Phase\n**GREEN** - Implement to pass tests.\n\n## Dependencies\n- Depends on: RED: Session Class Query Execution Tests\n- Depends on: GREEN: Driver Lifecycle Methods Implementation\n\n## Acceptance Criteria\n- [ ] All RED phase tests pass\n- [ ] Query execution works with graph engine\n- [ ] Transaction modes are respected\n- [ ] Error handling is correct","status":"closed","priority":1,"issue_type":"task","created_at":"2026-01-05T06:36:35.940921-06:00","updated_at":"2026-01-05T08:54:14.035604-06:00","closed_at":"2026-01-05T08:54:14.035604-06:00","close_reason":"Tests passing - implementation complete"}
{"id":"neo4j-n7a0","title":"REFACTOR: AI Functions in Cypher - Optimize AI calls and add caching","description":"## Overview\nRefactor AI functions for production performance and reliability.\n\n## Refactoring Goals\n\n### 1. Performance Optimization\n- Implement embedding cache with content hashing\n- Batch API calls within transactions\n- Request deduplication across concurrent queries\n- Lazy evaluation for unused AI results\n\n### 2. Caching Strategy\n```typescript\ninterface AICacheConfig {\n  embed: {\n    enabled: boolean;\n    ttl: number; // seconds\n    maxSize: number; // entries\n  };\n  generate: {\n    enabled: boolean;\n    ttl: number;\n    keyFn: (prompt: string, options: any) =\u003e string;\n  };\n}\n\nclass AICacheService {\n  private cache: KVNamespace;\n  \n  async getCachedEmbedding(text: string, model: string): Promise\u003cnumber[] | null\u003e;\n  async cacheEmbedding(text: string, model: string, embedding: number[]): Promise\u003cvoid\u003e;\n  \n  // Content-based cache key\n  private hashContent(text: string, model: string): string {\n    return crypto.subtle.digest('SHA-256', text + model);\n  }\n}\n```\n\n### 3. Reliability Improvements\n- Circuit breaker for AI service failures\n- Fallback models for unavailable primary models\n- Request timeout configuration\n- Retry with exponential backoff\n\n### 4. Cost Optimization\n- Track token/embedding usage\n- Implement usage quotas per tenant\n- Cost estimation before execution\n- Usage analytics dashboard\n\n### 5. Advanced Features\n```typescript\n// Streaming generation\nasync function* streamGenerate(prompt: string): AsyncGenerator\u003cstring\u003e;\n\n// Structured output with validation\nasync function generateStructured\u003cT\u003e(prompt: string, schema: JSONSchema): Promise\u003cT\u003e;\n\n// Chain of thought\nasync function reasonAndAnswer(question: string, context: string): Promise\u003c{\n  reasoning: string;\n  answer: string;\n}\u003e;\n```\n\n### 6. Observability\n- AI function call metrics\n- Latency percentiles by function\n- Cache hit rates\n- Error rates by model\n\n## Tasks\n- [ ] Implement content-hash embedding cache\n- [ ] Add circuit breaker pattern\n- [ ] Build usage tracking\n- [ ] Create streaming generation\n- [ ] Add structured output validation\n- [ ] Implement fallback models\n- [ ] Add comprehensive metrics\n\n## Acceptance Criteria\n- [ ] All tests still passing\n- [ ] 80%+ cache hit rate for repeated embeddings\n- [ ] \u003c 100ms p99 for cached operations\n- [ ] Graceful degradation on AI failures\n\n## Tags\nsuperset, ai-functions, workers-ai, tdd-refactor, performance, caching","status":"open","priority":3,"issue_type":"task","created_at":"2026-01-05T06:39:25.750687-06:00","updated_at":"2026-01-05T06:39:25.750687-06:00"}
{"id":"neo4j-n99h","title":"RED: Result.single() - Write failing tests for single record expectation","description":"## Overview\nWrite failing tests for the Result.single() method that expects exactly one record.\n\n## Test Cases to Write\n\n```typescript\ndescribe('Result.single()', () =\u003e {\n  it('should return the single record', async () =\u003e {\n    const result = createMockResult([{ name: 'Alice' }]);\n    \n    const record = await result.single();\n    expect(record.get('name')).toBe('Alice');\n  });\n\n  it('should throw for empty result', async () =\u003e {\n    const result = createMockResult([]);\n    \n    await expect(result.single()).rejects.toThrow();\n    await expect(result.single()).rejects.toThrow(/no records/i);\n  });\n\n  it('should throw for multiple records', async () =\u003e {\n    const result = createMockResult([\n      { name: 'Alice' },\n      { name: 'Bob' }\n    ]);\n    \n    await expect(result.single()).rejects.toThrow();\n    await expect(result.single()).rejects.toThrow(/more than one record/i);\n  });\n\n  it('should return Record instance', async () =\u003e {\n    const result = createMockResult([{ name: 'Alice' }]);\n    \n    const record = await result.single();\n    expect(record).toBeInstanceOf(Record);\n  });\n\n  it('should consume the result', async () =\u003e {\n    const result = createMockResult([{ name: 'Alice' }]);\n    \n    await result.single();\n    \n    // Records should still be accessible (buffered)\n    const records = await result.records;\n    expect(records).toHaveLength(1);\n  });\n});\n```\n\n## Acceptance Criteria\n- [ ] All tests written and failing (RED phase)\n- [ ] Tests verify single record return\n- [ ] Tests verify error on 0 or \u003e1 records\n- [ ] Test file created at src/result/__tests__/result-single.test.ts\n\n## TDD Phase\nRED - Tests should fail because single method does not exist yet","status":"closed","priority":1,"issue_type":"task","created_at":"2026-01-05T06:49:17.175331-06:00","updated_at":"2026-01-05T07:19:22.166216-06:00","closed_at":"2026-01-05T07:19:22.166216-06:00","close_reason":"Implemented in this Ralph Wiggum session - 662 tests pass"}
{"id":"neo4j-na4","title":"GREEN: Record.toObject() - Implement conversion to plain object","description":"## Overview\nImplement the Record.toObject() method to make all RED phase tests pass.\n\n## Implementation\n\n```typescript\ntoObject(): Record\u003cstring, any\u003e {\n  const obj: Record\u003cstring, any\u003e = {};\n  for (let i = 0; i \u003c this._keys.length; i++) {\n    obj[this._keys[i]] = this._values[i];\n  }\n  return obj;\n}\n```\n\n## Acceptance Criteria\n- [ ] All RED phase tests now pass (GREEN phase)\n- [ ] Returns new object each call\n- [ ] Preserves all value types including Neo4j types\n- [ ] Implementation is minimal\n\n## TDD Phase\nGREEN - Minimal implementation to pass tests\n\n## Dependencies\n- neo4j-ha2 (RED phase tests)","status":"closed","priority":1,"issue_type":"task","created_at":"2026-01-05T06:37:02.776985-06:00","updated_at":"2026-01-05T08:57:33.740413-06:00","closed_at":"2026-01-05T08:57:33.740413-06:00","close_reason":"Record methods already implemented with tests"}
{"id":"neo4j-naf","title":"RED: Write failing tests for driver.rxSession() factory method","description":"## Overview\nWrite failing tests for the `driver.rxSession()` factory method that creates reactive sessions.\n\n## Test Cases to Write\n\n### Basic Factory Tests\n- `driver.rxSession()` returns RxSession instance\n- `driver.rxSession(config)` accepts session configuration\n- Factory method is available on Driver instance\n- Returns new RxSession for each call\n\n### Configuration Tests\n- Accepts `database` option\n- Accepts `defaultAccessMode` option (READ/WRITE)\n- Accepts `bookmarks` option\n- Accepts `fetchSize` option\n- Invalid config throws appropriate error\n\n### Type Tests\n- RxSession has correct interface methods\n- Return type is RxSession (not Session)\n- Config type matches RxSessionConfig interface\n\n## Acceptance Criteria\n- [ ] All tests written and failing (RED phase)\n- [ ] Tests cover happy path and edge cases\n- [ ] Tests are properly isolated\n- [ ] Test file created at appropriate location\n- [ ] Tests follow project conventions","status":"open","priority":2,"issue_type":"task","created_at":"2026-01-05T06:34:32.926885-06:00","updated_at":"2026-01-05T06:34:32.926885-06:00"}
{"id":"neo4j-nfdy","title":"[RED] Types Module Export \u0026 API Surface - Write Failing Tests","description":"## Overview\nWrite tests for the unified types module export that matches neo4j-driver API.\n\n## TDD Phase: RED (Write Failing Tests)\n\n### Test Cases to Write\n\n#### Main Export Structure\n```typescript\nimport neo4j from 'neo4j.do';\n\n// Integer\nneo4j.int(42)\nneo4j.integer(42)\nneo4j.integer.inSafeRange(bigInt)\nneo4j.integer.toNumber(bigInt)\nneo4j.isInt(value)\n\n// Temporal\nneo4j.types.Date\nneo4j.types.Time\nneo4j.types.LocalTime\nneo4j.types.DateTime\nneo4j.types.LocalDateTime\nneo4j.types.Duration\nneo4j.isDate(value)\nneo4j.isTime(value)\nneo4j.isLocalTime(value)\nneo4j.isDateTime(value)\nneo4j.isLocalDateTime(value)\nneo4j.isDuration(value)\n\n// Spatial\nneo4j.types.Point\nneo4j.isPoint(value)\n\n// Vector (superset)\nneo4j.vector(data)\nneo4j.isVector(value)\n\n// Graph\nneo4j.types.Node\nneo4j.types.Relationship\nneo4j.types.Path\nneo4j.types.PathSegment\nneo4j.isNode(value)\nneo4j.isRelationship(value)\nneo4j.isPath(value)\nneo4j.isPathSegment(value)\n```\n\n#### Named Exports\n```typescript\nimport { \n  int, integer, isInt,\n  Date, Time, LocalTime, DateTime, LocalDateTime, Duration,\n  isDate, isTime, isLocalTime, isDateTime, isLocalDateTime, isDuration,\n  Point, isPoint, SRID,\n  vector, isVector, Vector,\n  Node, Relationship, Path, PathSegment,\n  isNode, isRelationship, isPath, isPathSegment\n} from 'neo4j.do/types';\n```\n\n#### Type Exports\n```typescript\nimport type {\n  Integer,\n  Date, Time, LocalTime, DateTime, LocalDateTime, Duration,\n  Point, SRIDValue,\n  Vector, VectorDType,\n  Node, Relationship, Path, PathSegment\n} from 'neo4j.do/types';\n```\n\n### Tests for API Compatibility\n- [ ] All neo4j-driver type exports present\n- [ ] Factory functions work identically\n- [ ] Type guards have correct signatures\n- [ ] No breaking differences from neo4j-driver\n\n### Test File\n```\nsrc/types/index.test.ts\n```\n\n### Acceptance Criteria\n- [ ] All export tests written and failing\n- [ ] API surface matches neo4j-driver\n- [ ] TypeScript types correct\n\n### Dependencies\n- All other RED phase issues should complete first","status":"closed","priority":1,"issue_type":"task","created_at":"2026-01-05T06:39:56.712291-06:00","updated_at":"2026-01-05T08:55:59.06269-06:00","closed_at":"2026-01-05T08:55:59.06269-06:00","close_reason":"Types implemented with tests"}
{"id":"neo4j-nglh","title":"[GREEN] Parser: Implement Schema Commands Parsing","description":"## Overview\nImplement schema command parsing.\n\n## Implementation Tasks\n\n### CREATE CONSTRAINT\n```typescript\nparseCreateConstraint(): CreateConstraintClause {\n  const start = this.pos\n  this.expect('CREATE')\n  this.expect('CONSTRAINT')\n  \n  let name: string | undefined\n  let ifNotExists = false\n  \n  // Optional name\n  if (\\!this.check('FOR') \u0026\u0026 \\!this.check('IF')) {\n    name = this.parseIdentifier().name\n  }\n  \n  // Optional IF NOT EXISTS\n  if (this.match('IF')) {\n    this.expect('NOT')\n    this.expect('EXISTS')\n    ifNotExists = true\n  }\n  \n  this.expect('FOR')\n  \n  const pattern = this.parseNodeOrRelPattern()\n  \n  this.expect('REQUIRE')\n  \n  const constraint = this.parseConstraintExpression()\n  \n  return {\n    type: 'CreateConstraintClause',\n    name,\n    ifNotExists,\n    pattern,\n    constraint,\n    loc: this.getLoc(start)\n  }\n}\n```\n\n### CREATE INDEX\n```typescript\nparseCreateIndex(): CreateIndexClause {\n  const start = this.pos\n  this.expect('CREATE')\n  \n  const fulltext = this.match('FULLTEXT')\n  this.expect('INDEX')\n  \n  let name: string | undefined\n  let ifNotExists = false\n  \n  // Similar parsing to constraints...\n  \n  this.expect('FOR')\n  const pattern = this.parseNodeOrRelPattern()\n  \n  this.expect('ON')\n  const properties = this.parsePropertyList()\n  \n  return {\n    type: 'CreateIndexClause',\n    name,\n    fulltext,\n    ifNotExists,\n    pattern,\n    properties,\n    loc: this.getLoc(start)\n  }\n}\n```\n\n### DROP Commands\n```typescript\nparseDropConstraint(): DropConstraintClause\nparseDropIndex(): DropIndexClause\n```\n\n## Acceptance Criteria\n- [ ] All schema command tests pass\n- [ ] Constraint parsing works\n- [ ] Index parsing works\n- [ ] Drop commands work\n\n## TDD Phase: GREEN\n## Depends On: neo4j-s0s9","status":"open","priority":2,"issue_type":"task","created_at":"2026-01-05T06:51:46.838382-06:00","updated_at":"2026-01-05T06:51:46.838382-06:00"}
{"id":"neo4j-nlj9","title":"[RED] Parser: EXPLAIN/PROFILE Tests","description":"## Overview\nWrite failing tests for EXPLAIN and PROFILE prefix parsing.\n\n## Test Cases to Write\n\n### EXPLAIN\n```cypher\nEXPLAIN MATCH (n) RETURN n\n\nEXPLAIN\nMATCH (n:Person)\nWHERE n.age \u003e 21\nRETURN n.name\n```\n\n### PROFILE\n```cypher\nPROFILE MATCH (n) RETURN n\n\nPROFILE\nMATCH (n:Person)-[:KNOWS]-\u003e(m)\nRETURN count(m)\n```\n\n### With Complex Queries\n```cypher\nEXPLAIN MATCH (a)-[:X]-\u003e(b)-[:Y]-\u003e(c)\nWHERE a.id = 1\nWITH b, collect(c) AS cs\nRETURN b.name, size(cs)\n\nPROFILE\nMATCH (n)\nCALL {\n  WITH n\n  MATCH (n)-[:KNOWS]-\u003e(m)\n  RETURN count(m) AS friendCount\n}\nRETURN n.name, friendCount\n```\n\n### Error Cases\n- EXPLAIN EXPLAIN (double prefix)\n- PROFILE EXPLAIN (conflicting)\n- EXPLAIN without query\n\n## Acceptance Criteria\n- [ ] All EXPLAIN tests written and failing\n- [ ] All PROFILE tests written and failing\n- [ ] Complex queries tested\n- [ ] Error cases covered\n\n## TDD Phase: RED","status":"open","priority":2,"issue_type":"task","created_at":"2026-01-05T06:53:20.571779-06:00","updated_at":"2026-01-05T06:53:20.571779-06:00"}
{"id":"neo4j-nm1o","title":"REFACTOR: UPDATE Translation (SET/REMOVE)","description":"## Overview\nRefactor SET/REMOVE translation for cleanliness and efficiency.\n\n## Refactoring Tasks\n\n### 1. JSON Operation Builder\n- Fluent API for json_set, json_remove, json_patch\n- Chainable operations\n- Optimized SQL generation\n\n### 2. Property Mutation Strategy\n- SinglePropertyMutation\n- MultiPropertyMutation\n- FullReplacementMutation\n- MergeMutation\n\n### 3. Label Manager\n- Centralized label array operations\n- Efficient add/remove without full replacement\n\n### 4. Update Batching\n- Combine multiple SETs into single UPDATE\n- Minimize round trips\n\n## Quality Improvements\n- DRY property access code\n- Consistent JSON function usage\n- Type-safe property paths\n- Efficient SQL generation\n\n## Acceptance Criteria\n- All tests still pass\n- JSON operations optimized\n- Code is maintainable\n\n## TDD Phase\nREFACTOR - Improve code quality while keeping tests green\n\n## Dependencies\n- Depends on: GREEN: UPDATE Translation (SET/REMOVE)","status":"closed","priority":1,"issue_type":"task","created_at":"2026-01-05T06:39:43.320219-06:00","updated_at":"2026-01-05T08:55:39.254226-06:00","closed_at":"2026-01-05T08:55:39.254226-06:00","close_reason":"Translation already implemented with tests"}
{"id":"neo4j-nov6","title":"REFACTOR: Result async iteration - Handle multiple iterations","description":"## Overview\nRefactor async iteration to handle multiple iteration attempts gracefully.\n\n## Refactoring Tasks\n\n1. **Multiple Iteration**\n   - Decide: buffer for re-iteration OR throw on second iteration\n   - Match Neo4j driver behavior\n\n2. **Stream Management**\n   - Properly track stream consumption state\n   - Handle iteration abort\n\n## Acceptance Criteria\n- [ ] All tests still pass after refactoring\n- [ ] Multiple iteration behavior defined\n- [ ] Stream state properly managed\n\n## TDD Phase\nREFACTOR - Improve code without changing behavior\n\n## Dependencies\n- neo4j-7dvi (GREEN phase implementation)","status":"closed","priority":1,"issue_type":"task","created_at":"2026-01-05T06:48:25.879151-06:00","updated_at":"2026-01-05T07:19:22.169956-06:00","closed_at":"2026-01-05T07:19:22.169956-06:00","close_reason":"Implemented in this Ralph Wiggum session - 662 tests pass"}
{"id":"neo4j-np94","title":"GREEN: Implement slow consumer handling","description":"## Overview\nImplement slow consumer handling to make all RED tests pass.\n\n## Implementation Requirements\n\n### Detection\n- Track consumer rate\n- Compare to producer rate\n- Identify backpressure situations\n- Measure lag\n\n### Handling Strategies\n- Apply backpressure\n- Buffer within limits\n- Drop or sample if configured\n- Never OOM\n\n### Implementation Details\n- Rate tracking\n- Adaptive behavior\n- Configurable thresholds\n- Graceful degradation\n\n## Acceptance Criteria\n- All RED tests now pass (GREEN phase)\n- Slow consumers handled gracefully\n- No crashes or OOM\n- Metrics available","status":"open","priority":2,"issue_type":"task","created_at":"2026-01-05T06:46:43.382306-06:00","updated_at":"2026-01-05T06:46:43.382306-06:00"}
{"id":"neo4j-nu46","title":"[RED] E2E Path Finding Tests","description":"# [RED] E2E Path Finding Tests\n\n## Overview\nEnd-to-end tests for path finding algorithms and path queries in Cypher.\n\n## Test Scenarios\n\n### Shortest Path\n```typescript\ndescribe('Shortest Path E2E', () =\u003e {\n  beforeEach(async () =\u003e {\n    // Create a graph with multiple paths\n    await session.run(`\n      CREATE (a:City {name: 'A'}),\n             (b:City {name: 'B'}),\n             (c:City {name: 'C'}),\n             (d:City {name: 'D'}),\n             (e:City {name: 'E'}),\n             (a)-[:ROAD {distance: 10}]-\u003e(b),\n             (a)-[:ROAD {distance: 5}]-\u003e(c),\n             (b)-[:ROAD {distance: 5}]-\u003e(d),\n             (c)-[:ROAD {distance: 10}]-\u003e(d),\n             (c)-[:ROAD {distance: 15}]-\u003e(e),\n             (d)-[:ROAD {distance: 5}]-\u003e(e)\n    `)\n  })\n\n  it('should find shortest path by hops', async () =\u003e {\n    const result = await session.run(`\n      MATCH p = shortestPath((a:City {name: 'A'})-[*]-(e:City {name: 'E'}))\n      RETURN length(p) as hops, [n IN nodes(p) | n.name] as route\n    `)\n    expect(result.records[0].get('hops').toInt()).toBeLessThanOrEqual(3)\n  })\n\n  it('should return path nodes and relationships', async () =\u003e {\n    const result = await session.run(`\n      MATCH p = shortestPath((a:City {name: 'A'})-[*]-(e:City {name: 'E'}))\n      RETURN nodes(p) as nodes, relationships(p) as rels\n    `)\n    const nodes = result.records[0].get('nodes')\n    const rels = result.records[0].get('rels')\n    expect(nodes.length).toBeGreaterThan(0)\n    expect(rels.length).toBe(nodes.length - 1)\n  })\n\n  it('should find all shortest paths', async () =\u003e {\n    const result = await session.run(`\n      MATCH p = allShortestPaths((a:City {name: 'A'})-[*]-(e:City {name: 'E'}))\n      RETURN p\n    `)\n    expect(result.records.length).toBeGreaterThanOrEqual(1)\n  })\n\n  it('should respect relationship type filter', async () =\u003e {\n    const result = await session.run(`\n      MATCH p = shortestPath((a:City {name: 'A'})-[:ROAD*]-(e:City {name: 'E'}))\n      RETURN p\n    `)\n    expect(result.records).toHaveLength(1)\n  })\n\n  it('should respect max depth', async () =\u003e {\n    const result = await session.run(`\n      MATCH p = shortestPath((a:City {name: 'A'})-[*..2]-(e:City {name: 'E'}))\n      RETURN p\n    `)\n    // May or may not find path depending on graph structure\n  })\n})\n```\n\n### Weighted Shortest Path (Using reduce)\n```typescript\ndescribe('Weighted Path E2E', () =\u003e {\n  beforeEach(async () =\u003e {\n    await session.run(`\n      CREATE (a:City {name: 'A'}),\n             (b:City {name: 'B'}),\n             (c:City {name: 'C'}),\n             (d:City {name: 'D'}),\n             (a)-[:ROAD {distance: 1}]-\u003e(b),\n             (b)-[:ROAD {distance: 1}]-\u003e(d),\n             (a)-[:ROAD {distance: 5}]-\u003e(c),\n             (c)-[:ROAD {distance: 1}]-\u003e(d)\n    `)\n  })\n\n  it('should calculate total path weight', async () =\u003e {\n    const result = await session.run(`\n      MATCH p = (a:City {name: 'A'})-[:ROAD*]-\u003e(d:City {name: 'D'})\n      RETURN \n        [n IN nodes(p) | n.name] as route,\n        reduce(total = 0, r IN relationships(p) | total + r.distance) as totalDistance\n      ORDER BY totalDistance ASC\n    `)\n    // Path A-\u003eB-\u003eD should have distance 2\n    // Path A-\u003eC-\u003eD should have distance 6\n    expect(result.records[0].get('totalDistance').toInt()).toBe(2)\n  })\n\n  it('should find minimum weight path', async () =\u003e {\n    const result = await session.run(`\n      MATCH p = (a:City {name: 'A'})-[:ROAD*]-\u003e(d:City {name: 'D'})\n      WITH p, reduce(total = 0, r IN relationships(p) | total + r.distance) as cost\n      ORDER BY cost ASC\n      LIMIT 1\n      RETURN [n IN nodes(p) | n.name] as route, cost\n    `)\n    expect(result.records[0].get('route')).toEqual(['A', 'B', 'D'])\n  })\n})\n```\n\n### Path Enumeration\n```typescript\ndescribe('Path Enumeration E2E', () =\u003e {\n  beforeEach(async () =\u003e {\n    await session.run(`\n      CREATE (a:Node {id: 1})-[:NEXT]-\u003e(b:Node {id: 2})-[:NEXT]-\u003e(c:Node {id: 3}),\n             (a)-[:NEXT]-\u003e(d:Node {id: 4})-[:NEXT]-\u003e(c),\n             (d)-[:NEXT]-\u003e(b)\n    `)\n  })\n\n  it('should enumerate all paths', async () =\u003e {\n    const result = await session.run(`\n      MATCH p = (a:Node {id: 1})-[:NEXT*]-\u003e(c:Node {id: 3})\n      RETURN [n IN nodes(p) | n.id] as path\n    `)\n    expect(result.records.length).toBeGreaterThan(1)\n  })\n\n  it('should filter paths by length', async () =\u003e {\n    const result = await session.run(`\n      MATCH p = (a:Node {id: 1})-[:NEXT*2]-\u003e(c:Node {id: 3})\n      RETURN [n IN nodes(p) | n.id] as path\n    `)\n    result.records.forEach(r =\u003e {\n      expect(r.get('path')).toHaveLength(3) // start + 2 hops\n    })\n  })\n\n  it('should handle cyclic paths with uniqueness', async () =\u003e {\n    // Cypher prevents traversing same relationship twice by default\n    const result = await session.run(`\n      MATCH p = (a:Node {id: 1})-[:NEXT*1..10]-\u003e(c:Node {id: 3})\n      RETURN count(p) as pathCount\n    `)\n    // Should not infinitely loop\n    expect(result.records[0].get('pathCount').toInt()).toBeLessThan(100)\n  })\n})\n```\n\n### Path Functions\n```typescript\ndescribe('Path Functions E2E', () =\u003e {\n  beforeEach(async () =\u003e {\n    await session.run(`\n      CREATE (a:Person {name: 'Alice'})-[:KNOWS]-\u003e(b:Person {name: 'Bob'})-[:KNOWS]-\u003e(c:Person {name: 'Charlie'})\n    `)\n  })\n\n  it('should extract nodes from path', async () =\u003e {\n    const result = await session.run(`\n      MATCH p = (:Person {name: 'Alice'})-[*]-\u003e(:Person {name: 'Charlie'})\n      RETURN nodes(p) as n\n    `)\n    expect(result.records[0].get('n')).toHaveLength(3)\n  })\n\n  it('should extract relationships from path', async () =\u003e {\n    const result = await session.run(`\n      MATCH p = (:Person {name: 'Alice'})-[*]-\u003e(:Person {name: 'Charlie'})\n      RETURN relationships(p) as r\n    `)\n    expect(result.records[0].get('r')).toHaveLength(2)\n  })\n\n  it('should get path length', async () =\u003e {\n    const result = await session.run(`\n      MATCH p = (:Person {name: 'Alice'})-[*]-\u003e(:Person {name: 'Charlie'})\n      RETURN length(p) as len\n    `)\n    expect(result.records[0].get('len').toInt()).toBe(2)\n  })\n\n  it('should access start and end nodes', async () =\u003e {\n    const result = await session.run(`\n      MATCH p = (:Person {name: 'Alice'})-[*]-\u003e(:Person {name: 'Charlie'})\n      RETURN \n        head(nodes(p)).name as first,\n        last(nodes(p)).name as last\n    `)\n    expect(result.records[0].get('first')).toBe('Alice')\n    expect(result.records[0].get('last')).toBe('Charlie')\n  })\n})\n```\n\n### Graph Algorithms Prep\n```typescript\ndescribe('Graph Algorithm Patterns E2E', () =\u003e {\n  beforeEach(async () =\u003e {\n    // Create a social network graph\n    await session.run(`\n      CREATE (a:User {name: 'A'}), (b:User {name: 'B'}), (c:User {name: 'C'}),\n             (d:User {name: 'D'}), (e:User {name: 'E'}),\n             (a)-[:FOLLOWS]-\u003e(b), (a)-[:FOLLOWS]-\u003e(c),\n             (b)-[:FOLLOWS]-\u003e(d), (c)-[:FOLLOWS]-\u003e(d),\n             (d)-[:FOLLOWS]-\u003e(e)\n    `)\n  })\n\n  it('should find friends of friends', async () =\u003e {\n    const result = await session.run(`\n      MATCH (me:User {name: 'A'})-[:FOLLOWS*2]-\u003e(fof:User)\n      WHERE NOT (me)-[:FOLLOWS]-\u003e(fof) AND me \u003c\u003e fof\n      RETURN DISTINCT fof.name as recommendation\n    `)\n    expect(result.records.map(r =\u003e r.get('recommendation'))).toContain('D')\n  })\n\n  it('should count incoming connections (in-degree)', async () =\u003e {\n    const result = await session.run(`\n      MATCH (u:User)\n      OPTIONAL MATCH (other)-[:FOLLOWS]-\u003e(u)\n      RETURN u.name as user, count(other) as inDegree\n      ORDER BY inDegree DESC\n    `)\n    expect(result.records[0].get('user')).toBe('D') // Most followed\n  })\n\n  it('should find mutual connections', async () =\u003e {\n    await session.run('MATCH (b:User {name: \"B\"}), (c:User {name: \"C\"}) CREATE (b)-[:FOLLOWS]-\u003e(c)')\n    const result = await session.run(`\n      MATCH (a:User {name: 'A'})-[:FOLLOWS]-\u003e(mutual)\u003c-[:FOLLOWS]-(b:User {name: 'B'})\n      RETURN mutual.name\n    `)\n    expect(result.records.map(r =\u003e r.get('mutual.name'))).toContain('C')\n  })\n})\n```\n\n## Acceptance Criteria\n- [ ] Shortest path tests written\n- [ ] Weighted path tests written\n- [ ] Path enumeration tests written\n- [ ] Path function tests written\n- [ ] Graph algorithm pattern tests written\n- [ ] Tests fail initially (RED phase)","status":"open","priority":2,"issue_type":"task","created_at":"2026-01-05T06:42:35.448693-06:00","updated_at":"2026-01-05T06:42:35.448693-06:00"}
{"id":"neo4j-nvir","title":"[GREEN] Parser: Implement FOREACH Parsing","description":"## Overview\nImplement FOREACH clause parsing.\n\n## Implementation Tasks\n\n### FOREACH Parser\n```typescript\nparseForeachClause(): ForeachClause {\n  const start = this.pos\n  this.expect('FOREACH')\n  this.expect('(')\n  \n  const variable = this.parseIdentifier()\n  this.expect('IN')\n  const list = this.parseExpression()\n  this.expect('|')\n  \n  // Parse update clauses (CREATE, SET, REMOVE, DELETE, MERGE, FOREACH)\n  const operations = this.parseForeachOperations()\n  \n  this.expect(')')\n  \n  return {\n    type: 'ForeachClause',\n    variable,\n    list,\n    operations,\n    loc: this.getLoc(start)\n  }\n}\n\nparseForeachOperations(): UpdateClause[] {\n  const operations: UpdateClause[] = []\n  \n  while (\\!this.check(')')) {\n    const clause = this.parseUpdateClause()\n    operations.push(clause)\n  }\n  \n  return operations\n}\n\nparseUpdateClause(): UpdateClause {\n  const token = this.peek()\n  \n  switch (token.value.toUpperCase()) {\n    case 'CREATE': return this.parseCreateClause()\n    case 'SET': return this.parseSetClause()\n    case 'REMOVE': return this.parseRemoveClause()\n    case 'DELETE': return this.parseDeleteClause()\n    case 'MERGE': return this.parseMergeClause()\n    case 'FOREACH': return this.parseForeachClause()\n    default:\n      this.error('Expected update clause in FOREACH body')\n  }\n}\n```\n\n### AST Types\n```typescript\ninterface ForeachClause extends ASTNode {\n  type: 'ForeachClause'\n  variable: Identifier\n  list: Expression\n  operations: UpdateClause[]\n}\n\ntype UpdateClause = \n  | CreateClause \n  | SetClause \n  | RemoveClause \n  | DeleteClause \n  | MergeClause \n  | ForeachClause\n```\n\n## Acceptance Criteria\n- [ ] All FOREACH tests pass\n- [ ] Multiple operations work\n- [ ] Nested FOREACH works\n- [ ] Only update clauses allowed\n\n## TDD Phase: GREEN\n## Depends On: neo4j-kro0","status":"open","priority":2,"issue_type":"task","created_at":"2026-01-05T06:53:02.639806-06:00","updated_at":"2026-01-05T06:53:02.639806-06:00"}
{"id":"neo4j-nzr","title":"[GREEN] Lexer: Implement Token Types and Basic Tokenization","description":"## Overview\nImplement the lexer to make all token type tests pass.\n\n## Implementation Tasks\n\n### Token Type Enum/Union\n```typescript\ntype TokenType =\n  | 'KEYWORD'      // MATCH, CREATE, RETURN, etc.\n  | 'IDENTIFIER'   // variable names, unquoted\n  | 'STRING'       // 'string' or \"string\"\n  | 'INTEGER'      // 123\n  | 'FLOAT'        // 1.23\n  | 'BOOLEAN'      // true, false\n  | 'NULL'         // null\n  | 'OPERATOR'     // +, -, *, /, =, \u003c\u003e, etc.\n  | 'PUNCTUATION'  // (, ), [, ], {, }, :, etc.\n  | 'PARAMETER'    // $param\n  | 'COMMENT'      // // or /* */\n  | 'WHITESPACE'   // spaces, tabs, newlines\n  | 'EOF'          // end of input\n```\n\n### Token Interface\n```typescript\ninterface Token {\n  type: TokenType\n  value: string\n  line: number\n  column: number\n  start: number\n  end: number\n}\n```\n\n### Lexer Class\n- `tokenize(input: string): Token[]`\n- Cursor management (position, line, column)\n- Peek and advance methods\n\n## Acceptance Criteria\n- [ ] All RED phase tests pass\n- [ ] Lexer correctly identifies all token types\n- [ ] Position tracking is accurate\n- [ ] File: `src/parser/lexer.ts`\n\n## TDD Phase: GREEN\n## Depends On: neo4j-kdy","status":"closed","priority":1,"issue_type":"task","created_at":"2026-01-05T06:34:42.446931-06:00","updated_at":"2026-01-05T07:13:11.687817-06:00","closed_at":"2026-01-05T07:13:11.687817-06:00","close_reason":"Implemented in Ralph Wiggum session"}
{"id":"neo4j-o0v","title":"RED: Vector Search - Write failing tests for vector query procedures","description":"## Overview\nWrite failing tests for vector search capabilities using Vectorize integration.\n\n## Test Cases\n\n### Node Vector Search\n```typescript\ndescribe('Vector Search', () =\u003e {\n  beforeAll(async () =\u003e {\n    // Create test data with embeddings\n    await session.run('CALL db.index.vector.create(\"articles\", \"Article\", \"embedding\", 1024, \"cosine\")');\n    await session.run(`\n      CREATE (:Article {title: \"Graph Databases\", embedding: $e1})\n      CREATE (:Article {title: \"SQL Optimization\", embedding: $e2})\n      CREATE (:Article {title: \"Neo4j Tutorial\", embedding: $e3})\n    `, { e1: graphEmbedding, e2: sqlEmbedding, e3: neo4jEmbedding });\n  });\n\n  describe('queryNodes Procedure', () =\u003e {\n    it('should return k nearest neighbors', async () =\u003e {\n      const result = await session.run(\n        'CALL db.index.vector.queryNodes(\"articles\", 2, $queryVector) YIELD node, score RETURN node.title, score',\n        { queryVector: graphQueryVector }\n      );\n      \n      expect(result.records).toHaveLength(2);\n      expect(result.records[0].get('node.title')).toBe('Graph Databases');\n      expect(result.records[0].get('score')).toBeGreaterThan(0.9);\n    });\n\n    it('should support distance metrics', async () =\u003e {\n      const cosine = await session.run(\n        'CALL db.index.vector.queryNodes(\"articles\", 5, $v, { metric: \"cosine\" }) YIELD score RETURN score',\n        { v: queryVector }\n      );\n      \n      const euclidean = await session.run(\n        'CALL db.index.vector.queryNodes(\"articles_euclidean\", 5, $v, { metric: \"euclidean\" }) YIELD score RETURN score',\n        { v: queryVector }\n      );\n      \n      // Scores should differ based on metric\n      expect(cosine.records[0].get('score')).not.toEqual(euclidean.records[0].get('score'));\n    });\n\n    it('should return empty results for no matches above threshold', async () =\u003e {\n      const result = await session.run(\n        'CALL db.index.vector.queryNodes(\"articles\", 5, $v, { minScore: 0.99 }) YIELD node RETURN node',\n        { v: unrelatedVector }\n      );\n      \n      expect(result.records).toHaveLength(0);\n    });\n  });\n\n  describe('queryRelationships Procedure', () =\u003e {\n    it('should search relationship embeddings', async () =\u003e {\n      await session.run('CALL db.index.vector.create(\"reviews\", \"REVIEWED\", \"embedding\", 1024, \"cosine\")');\n      await session.run(`\n        CREATE (u:User)-[:REVIEWED {text: \"Excellent product\", embedding: $e}]-\u003e(p:Product)\n      `, { e: reviewEmbedding });\n      \n      const result = await session.run(\n        'CALL db.index.vector.queryRelationships(\"reviews\", 5, $v) YIELD relationship, score RETURN relationship.text, score',\n        { v: positiveReviewQuery }\n      );\n      \n      expect(result.records[0].get('relationship.text')).toBe('Excellent product');\n    });\n  });\n\n  describe('Hybrid Search', () =\u003e {\n    it('should combine vector search with graph filters', async () =\u003e {\n      const result = await session.run(`\n        CALL db.index.vector.queryNodes(\"articles\", 10, $v) YIELD node, score\n        WHERE node.published = true AND node.category = \"technology\"\n        RETURN node.title, score\n        ORDER BY score DESC\n        LIMIT 5\n      `, { v: queryVector });\n      \n      result.records.forEach(r =\u003e {\n        // All results should match filter criteria\n      });\n    });\n\n    it('should support pre-filtering for efficiency', async () =\u003e {\n      const result = await session.run(`\n        CALL db.index.vector.queryNodes(\"articles\", 5, $v, { \n          filter: { category: \"technology\", published: true }\n        }) YIELD node, score\n        RETURN node.title, score\n      `, { v: queryVector });\n      \n      // Pre-filtering should be more efficient than post-filtering\n    });\n\n    it('should combine with graph traversal', async () =\u003e {\n      const result = await session.run(`\n        CALL db.index.vector.queryNodes(\"articles\", 3, $v) YIELD node as article, score\n        MATCH (article)\u003c-[:WROTE]-(author:Author)\n        MATCH (author)-[:WROTE]-\u003e(other:Article)\n        WHERE other \u003c\u003e article\n        RETURN article.title, author.name, collect(other.title) as otherArticles, score\n      `, { v: queryVector });\n      \n      expect(result.records[0].get('otherArticles')).toBeDefined();\n    });\n  });\n\n  describe('Text-to-Vector Search', () =\u003e {\n    it('should auto-embed search query text', async () =\u003e {\n      const result = await session.run(\n        'CALL db.index.vector.searchText(\"articles\", \"graph database concepts\", 5) YIELD node, score RETURN node.title, score'\n      );\n      \n      expect(result.records[0].get('node.title')).toContain('Graph');\n    });\n  });\n\n  describe('Vectorize Integration', () =\u003e {\n    it('should use Vectorize index for efficient search', async () =\u003e {\n      // Verify Vectorize is being used, not brute force\n    });\n\n    it('should handle index not found gracefully', async () =\u003e {\n      await expect(session.run(\n        'CALL db.index.vector.queryNodes(\"nonexistent\", 5, $v) YIELD node RETURN node',\n        { v: queryVector }\n      )).rejects.toThrow(/Index .* not found/);\n    });\n  });\n});\n```\n\n## Acceptance Criteria\n- [ ] All test cases written and failing\n- [ ] Vectorize mock infrastructure\n- [ ] Test vectors with known similarity scores\n- [ ] Performance benchmarks defined\n\n## Tags\nsuperset, vector-search, vectorize, tdd-red","status":"open","priority":2,"issue_type":"task","created_at":"2026-01-05T06:35:56.349855-06:00","updated_at":"2026-01-05T06:35:56.349855-06:00"}
{"id":"neo4j-o66","title":"RED: Session Class Query Execution Tests","description":"## Overview\nWrite comprehensive failing tests for Session class query execution: run(), executeRead(), executeWrite(), and beginTransaction().\n\n## Test Cases\n\n### Session.run() Tests\n```typescript\ndescribe('session.run()', () =\u003e {\n  it('should execute Cypher query')\n  it('should execute query with parameters')\n  it('should return Result object')\n  it('should allow iteration over records')\n  it('should provide result summary')\n  it('should handle empty results')\n  it('should handle large result sets')\n  it('should throw on syntax errors')\n  it('should throw on constraint violations')\n  it('should auto-commit single statements')\n  it('should track query execution time')\n})\n```\n\n### Session.executeRead() Tests\n```typescript\ndescribe('session.executeRead()', () =\u003e {\n  it('should execute work function in read transaction')\n  it('should pass transaction to work function')\n  it('should auto-commit on success')\n  it('should auto-rollback on error')\n  it('should retry on transient errors')\n  it('should respect maxTransactionRetryTime')\n  it('should not retry on fatal errors')\n  it('should return work function result')\n  it('should use READ access mode')\n})\n```\n\n### Session.executeWrite() Tests\n```typescript\ndescribe('session.executeWrite()', () =\u003e {\n  it('should execute work function in write transaction')\n  it('should pass transaction to work function')\n  it('should auto-commit on success')\n  it('should auto-rollback on error')\n  it('should retry on transient errors')\n  it('should not retry after max retries')\n  it('should return work function result')\n  it('should use WRITE access mode')\n  it('should generate bookmark on success')\n})\n```\n\n### Session.beginTransaction() Tests\n```typescript\ndescribe('session.beginTransaction()', () =\u003e {\n  it('should create explicit transaction')\n  it('should return Transaction object')\n  it('should accept transaction metadata')\n  it('should accept timeout configuration')\n  it('should throw if transaction already open')\n  it('should respect session access mode')\n})\n```\n\n## TDD Phase\n**RED** - All tests should fail initially.\n\n## Acceptance Criteria\n- [ ] All test cases written with clear assertions\n- [ ] Tests cover auto-commit and explicit transaction modes\n- [ ] Tests verify retry behavior\n- [ ] Tests check error handling","status":"closed","priority":1,"issue_type":"task","created_at":"2026-01-05T06:36:17.296801-06:00","updated_at":"2026-01-05T08:53:44.636934-06:00","closed_at":"2026-01-05T08:53:44.636934-06:00","close_reason":"Tests passing - implementation complete"}
{"id":"neo4j-o9n","title":"TypeScript configuration (tsconfig.json)","description":"# TypeScript Configuration\n\n## Overview\nConfigure TypeScript for the neo4j.do project with strict settings appropriate for a library targeting Cloudflare Workers.\n\n## Configuration Requirements\n- Target: ES2022\n- Module: ESNext\n- Module Resolution: Bundler\n- Strict mode enabled\n- Declaration files generation\n- Source maps for debugging\n- Cloudflare Workers types integration\n\n## Compiler Options\n```json\n{\n  \"compilerOptions\": {\n    \"target\": \"ES2022\",\n    \"module\": \"ESNext\",\n    \"moduleResolution\": \"bundler\",\n    \"lib\": [\"ES2022\"],\n    \"types\": [\"@cloudflare/workers-types\"],\n    \"strict\": true,\n    \"noEmit\": true,\n    \"declaration\": true,\n    \"declarationMap\": true,\n    \"sourceMap\": true,\n    \"esModuleInterop\": true,\n    \"skipLibCheck\": true,\n    \"forceConsistentCasingInFileNames\": true,\n    \"resolveJsonModule\": true,\n    \"isolatedModules\": true,\n    \"noUnusedLocals\": true,\n    \"noUnusedParameters\": true,\n    \"noFallthroughCasesInSwitch\": true\n  },\n  \"include\": [\"src/**/*\"],\n  \"exclude\": [\"node_modules\", \"dist\"]\n}\n```\n\n## Acceptance Criteria\n- [ ] tsconfig.json created and validated\n- [ ] Types compile without errors\n- [ ] Cloudflare Workers types are recognized\n- [ ] IDE intellisense works correctly","status":"closed","priority":1,"issue_type":"task","created_at":"2026-01-05T06:34:41.116154-06:00","updated_at":"2026-01-05T06:50:32.982593-06:00","closed_at":"2026-01-05T06:50:32.982593-06:00","close_reason":"tsconfig.json created with strict TypeScript settings for ES2022, ESNext modules, bundler resolution, and Cloudflare Workers types"}
{"id":"neo4j-oa13","title":"RED: Write failing tests for cold vs hot Observable semantics","description":"## Overview\nWrite failing tests for proper cold vs hot Observable semantics.\n\n## Test Cases to Write\n\n### Cold Observable Tests\n- Query not executed until subscribed\n- Each subscription triggers new execution\n- Unsubscription cancels that execution only\n- Independent results per subscription\n\n### Cold Observable Verification\n- rxSession.run() is cold\n- rxSession.executeRead() is cold\n- rxSession.executeWrite() is cold\n- rxSession.beginTransaction() is cold\n\n### Hot Observable Scenarios\n- Shared execution with share()\n- Shared execution with shareReplay()\n- Multicast scenarios\n- Late subscriber behavior\n\n### Side Effect Tests\n- Side effects occur per subscription (cold)\n- Side effects shared (hot)\n- Database writes per subscription\n- Idempotency considerations\n\n## Acceptance Criteria\n- All tests written and failing (RED phase)\n- Tests verify cold semantics\n- Tests verify hot transformation\n- Tests document expected behavior","status":"open","priority":2,"issue_type":"task","created_at":"2026-01-05T06:45:03.328241-06:00","updated_at":"2026-01-05T06:45:03.328241-06:00"}
{"id":"neo4j-oagp","title":"REFACTOR: Query Optimization - Predicate Pushdown","description":"## Overview\nRefactor query optimization for extensibility and correctness.\n\n## Refactoring Tasks\n\n### 1. Optimization Pipeline\n- Chain of optimization passes\n- Each pass is independent\n- Configurable optimization levels\n\n### 2. Cost Model (Basic)\n- Simple cardinality estimation\n- Cost-based optimization decisions\n- Configurable cost factors\n\n### 3. Query Plan Analyzer\n- Explain generated SQL\n- Identify optimization opportunities\n- Performance profiling hooks\n\n### 4. Optimization Rules Engine\n- Rule-based transformations\n- Easy to add new optimizations\n- Rule ordering and dependencies\n\n## Quality Improvements\n- Clean optimization pipeline\n- Extensible rules\n- Performance metrics\n- Debug/explain support\n\n## Acceptance Criteria\n- All tests still pass\n- Optimization is extensible\n- Performance measurable\n\n## TDD Phase\nREFACTOR - Improve code quality while keeping tests green\n\n## Dependencies\n- Depends on: GREEN: Query Optimization - Predicate Pushdown","status":"open","priority":2,"issue_type":"task","created_at":"2026-01-05T06:44:40.099692-06:00","updated_at":"2026-01-05T06:44:40.099692-06:00"}
{"id":"neo4j-ocf","title":"[REFACTOR] Node Operations - Optimize queries and add validation","description":"## Overview\nRefactor node operations for better performance and robustness.\n\n## Refactoring Tasks\n\n### Query Optimization\n- Use prepared statements\n- Optimize label queries with proper indexing\n- Add query result caching\n- Batch operations support\n\n```typescript\n// Optimized label query using JSON index\nthis.sql.exec(`\n  SELECT n.* FROM nodes n, json_each(n.labels) AS l\n  WHERE l.value = ?\n`, label);\n```\n\n### Input Validation\n```typescript\nfunction validateNodeInput(labels: string[], properties: object): void {\n  if (\\!Array.isArray(labels)) {\n    throw new ValidationError('Labels must be an array');\n  }\n  labels.forEach(label =\u003e {\n    if (typeof label \\!== 'string' || \\!label.match(/^[A-Za-z_][A-Za-z0-9_]*$/)) {\n      throw new ValidationError('Invalid label format');\n    }\n  });\n  validateProperties(properties);\n}\n```\n\n### Batch Operations\n```typescript\ncreateNodes(nodes: NodeInput[]): Node[] {\n  return this.sql.transaction(() =\u003e {\n    return nodes.map(n =\u003e this.createNode(n.labels, n.properties));\n  });\n}\n\ndeleteNodes(ids: number[]): number {\n  // Validate no relationships exist\n  return this.sql.transaction(() =\u003e {\n    let deleted = 0;\n    for (const id of ids) {\n      if (this.deleteNode(id)) deleted++;\n    }\n    return deleted;\n  });\n}\n```\n\n### Code Quality\n- Extract SQL queries to constants\n- Add comprehensive JSDoc\n- Implement result type helpers\n- Add performance logging\n\n## Acceptance Criteria\n- [ ] All tests still pass\n- [ ] Queries are optimized\n- [ ] Input validation is thorough\n- [ ] Batch operations available\n- [ ] Code is clean and documented\n\n## TDD Phase\n**REFACTOR** - Improve without changing behavior","status":"open","priority":2,"issue_type":"task","created_at":"2026-01-05T06:37:02.489567-06:00","updated_at":"2026-01-05T06:37:02.489567-06:00"}
{"id":"neo4j-oep3","title":"[RED] Parser: Subquery Tests","description":"## Overview\nWrite failing tests for subquery parsing.\n\n## Test Cases to Write\n\n### EXISTS Subquery\n```cypher\nWHERE EXISTS {\n  MATCH (n)-[:KNOWS]-\u003e(m)\n  WHERE m.age \u003e 21\n}\n```\n\n### COUNT Subquery\n```cypher\nWHERE COUNT {\n  MATCH (n)-[:KNOWS]-\u003e(m)\n} \u003e 5\n```\n\n### CALL Subquery\n```cypher\nCALL {\n  MATCH (n:Person)\n  RETURN n\n}\nRETURN n.name\n```\n\n### CALL with UNION\n```cypher\nCALL {\n  MATCH (n:Person) RETURN n.name AS name\n  UNION\n  MATCH (c:Company) RETURN c.name AS name\n}\nRETURN name\n```\n\n### CALL IN TRANSACTIONS\n```cypher\nCALL {\n  CREATE (n:Node)\n} IN TRANSACTIONS OF 1000 ROWS\n```\n\n### Correlated Subqueries\n```cypher\nMATCH (p:Person)\nCALL {\n  WITH p\n  MATCH (p)-[:KNOWS]-\u003e(friend)\n  RETURN count(friend) AS friendCount\n}\nRETURN p.name, friendCount\n```\n\n### Nested Subqueries\n```cypher\nEXISTS {\n  MATCH (n)\n  WHERE EXISTS {\n    MATCH (n)-[:X]-\u003e(m)\n  }\n}\n```\n\n## Acceptance Criteria\n- [ ] All subquery tests written and failing\n- [ ] EXISTS subquery tested\n- [ ] CALL subquery tested\n- [ ] IN TRANSACTIONS tested\n\n## TDD Phase: RED","status":"open","priority":2,"issue_type":"task","created_at":"2026-01-05T06:50:47.994054-06:00","updated_at":"2026-01-05T06:50:47.994054-06:00"}
{"id":"neo4j-oh7e","title":"[RED] Parser: Operator Expression Tests","description":"## Overview\nWrite failing tests for operator expression parsing with precedence.\n\n## Test Cases to Write\n\n### Arithmetic Operators\n- Addition: `1 + 2`\n- Subtraction: `5 - 3`\n- Multiplication: `2 * 3`\n- Division: `10 / 2`\n- Modulo: `10 % 3`\n- Power: `2 ^ 3`\n- Unary minus: `-5`\n\n### Comparison Operators\n- Equality: `a = b`\n- Inequality: `a \u003c\u003e b`\n- Less than: `a \u003c b`\n- Greater than: `a \u003e b`\n- Less or equal: `a \u003c= b`\n- Greater or equal: `a \u003e= b`\n\n### Logical Operators\n- AND: `a AND b`\n- OR: `a OR b`\n- XOR: `a XOR b`\n- NOT: `NOT a`\n\n### String Operators\n- STARTS WITH: `a STARTS WITH 'x'`\n- ENDS WITH: `a ENDS WITH 'x'`\n- CONTAINS: `a CONTAINS 'x'`\n- Regex: `a =~ 'pattern'`\n\n### Precedence Tests\n- `1 + 2 * 3` = `1 + (2 * 3)`\n- `a AND b OR c` = `(a AND b) OR c`\n- `NOT a AND b` = `(NOT a) AND b`\n- `a = b AND c = d` = `(a = b) AND (c = d)`\n- Parentheses override: `(1 + 2) * 3`\n\n### Associativity Tests\n- `1 - 2 - 3` = `(1 - 2) - 3` (left)\n- `2 ^ 3 ^ 2` = `2 ^ (3 ^ 2)` (right)\n\n## Acceptance Criteria\n- [ ] All operator tests written and failing\n- [ ] Precedence tests comprehensive\n- [ ] Associativity tested\n- [ ] Complex expressions tested\n\n## TDD Phase: RED","status":"closed","priority":1,"issue_type":"task","created_at":"2026-01-05T06:46:39.142957-06:00","updated_at":"2026-01-05T07:19:22.172878-06:00","closed_at":"2026-01-05T07:19:22.172878-06:00","close_reason":"Implemented in this Ralph Wiggum session - 662 tests pass"}
{"id":"neo4j-oji8","title":"GREEN: Implement Client configuration","description":"## Test-Driven Development: GREEN Phase\n\n### Component\nHTTP Client SDK - Client Configuration\n\n### Implementation Requirements\n\nImplement src/client/config.ts with:\n- HttpClientConfig interface with all options\n- ConfigBuilder for fluent configuration\n- URL validation and normalization\n- Timeout configuration (connection, request, query)\n- Header merging utilities\n- TLS/SSL option handling\n\n### Acceptance Criteria\n- All RED phase tests pass\n- baseUrl properly validated\n- Custom fetch works\n- Timeouts are respected\n- Headers merge correctly\n- TLS options supported\n\n### Dependencies\n- RED: Client configuration fails without implementation\n\n### TDD Cycle\nThis is the GREEN phase. Next: REFACTOR phase.","status":"open","priority":2,"issue_type":"task","created_at":"2026-01-05T06:43:17.460728-06:00","updated_at":"2026-01-05T06:43:17.460728-06:00"}
{"id":"neo4j-omto","title":"REFACTOR: Improve subscription handling robustness","description":"## Overview\nRefactor subscription handling for maximum robustness.\n\n## Refactoring Tasks\n\n### Code Quality\n- Extract subscription management\n- Standardize teardown logic\n- Add proper typing\n- Document subscription semantics\n\n### Robustness\n- Handle edge cases\n- Ensure cleanup in all paths\n- Add subscription tracking\n- Consider using finalize()\n\n### Testing\n- Add memory leak tests\n- Add stress tests\n- Verify concurrent access\n- Test rapid subscribe/unsubscribe\n\n## Acceptance Criteria\n- All tests still pass\n- Robust subscription handling\n- No edge case failures\n- Well-documented behavior","status":"open","priority":2,"issue_type":"task","created_at":"2026-01-05T06:43:00.244399-06:00","updated_at":"2026-01-05T06:43:00.244399-06:00"}
{"id":"neo4j-ou52","title":"REFACTOR: Document error recovery patterns","description":"## Overview\nRefactor and document error recovery patterns.\n\n## Refactoring Tasks\n\n### Code Quality\n- Extract recovery helpers\n- Create pattern utilities\n- Improve error handling\n- Add recovery types\n\n### Pattern Library\n- Document common patterns\n- Create reusable utilities\n- Show best practices\n- Warning about anti-patterns\n\n### Documentation\n- Recovery pattern guide\n- Code examples\n- Troubleshooting guide\n- Performance considerations\n\n## Acceptance Criteria\n- All tests still pass\n- Clear recovery patterns\n- Useful utilities\n- Comprehensive documentation","status":"open","priority":2,"issue_type":"task","created_at":"2026-01-05T06:48:25.834346-06:00","updated_at":"2026-01-05T06:48:25.834346-06:00"}
{"id":"neo4j-p0jv","title":"REFACTOR: Client configuration optimization","description":"## Test-Driven Development: REFACTOR Phase\n\n### Component\nHTTP Client SDK - Client Configuration\n\n### Refactoring Goals\n\n1. Environment-based configuration - Support env vars and config files\n2. Configuration validation - Zod schema validation\n3. Configuration presets - Common configurations for different environments\n4. Immutable configuration - Frozen config objects after creation\n\n### Acceptance Criteria\n- All existing tests still pass\n- Environment config supported\n- Validation with clear errors\n- Presets for dev/staging/prod\n- Config objects are immutable\n\n### Dependencies\n- GREEN: Implement Client configuration\n\n### TDD Cycle\nThis completes the RED-\u003eGREEN-\u003eREFACTOR cycle for Client Configuration.","status":"open","priority":2,"issue_type":"task","created_at":"2026-01-05T06:43:29.185384-06:00","updated_at":"2026-01-05T06:43:29.185384-06:00"}
{"id":"neo4j-p5u8","title":"REFACTOR: Subquery Translation","description":"## Overview\nRefactor subquery translation for clarity and optimization.\n\n## Refactoring Tasks\n\n### 1. Subquery Strategy Pattern\n- ExistsStrategy\n- ComprehensionStrategy\n- CallStrategy\n- Clean strategy selection\n\n### 2. Correlation Manager\n- Clean variable correlation\n- Scope inheritance\n- Reference validation\n\n### 3. CTE Builder Integration\n- Reuse CTE builder for CALL\n- Optimize CTE generation\n- Handle multiple CTEs\n\n### 4. Subquery Optimization\n- Detect simple patterns that dont need subquery\n- Inline where possible\n- Minimize correlated queries\n\n## Quality Improvements\n- Clean subquery generation\n- Optimized correlation\n- Reusable components\n- Type safety\n\n## Acceptance Criteria\n- All tests still pass\n- Subqueries optimized where possible\n- Code is maintainable\n\n## TDD Phase\nREFACTOR - Improve code quality while keeping tests green\n\n## Dependencies\n- Depends on: GREEN: Subquery Translation","status":"open","priority":2,"issue_type":"task","created_at":"2026-01-05T06:43:52.467717-06:00","updated_at":"2026-01-05T06:43:52.467717-06:00"}
{"id":"neo4j-p821","title":"[GREEN] AST: Implement Pretty-Print","description":"## Overview\nImplement AST pretty-printing for debugging and code generation.\n\n## Implementation Tasks\n\n### Pretty-Print Function (src/parser/ast/printer.ts)\n```typescript\nexport function prettyPrint(\n  node: ASTNode,\n  options: PrettyPrintOptions = {}\n): string {\n  const printer = new Printer(options)\n  return printer.print(node)\n}\n\nclass Printer {\n  private indent: string\n  private lineWidth: number\n  private uppercase: boolean\n  \n  print(node: ASTNode): string {\n    switch (node.type) {\n      case 'Query': return this.printQuery(node)\n      case 'MatchClause': return this.printMatch(node)\n      // ... all node types\n    }\n  }\n  \n  private printQuery(node: Query): string {\n    return node.clauses.map(c =\u003e this.print(c)).join('\\n')\n  }\n  \n  private printMatch(node: MatchClause): string {\n    const optional = node.optional ? 'OPTIONAL ' : ''\n    const keyword = this.keyword('MATCH')\n    const pattern = this.printPattern(node.pattern)\n    const where = node.where ? this.printWhere(node.where) : ''\n    return `${optional}${keyword} ${pattern}${where}`\n  }\n}\n```\n\n### Pattern Printing\n```typescript\nprivate printNodePattern(node: NodePattern): string {\n  let result = '('\n  if (node.variable) result += node.variable.name\n  for (const label of node.labels) result += `:${label}`\n  if (node.properties) result += ` ${this.printMap(node.properties)}`\n  return result + ')'\n}\n```\n\n## Acceptance Criteria\n- [ ] All pretty-print tests pass\n- [ ] All node types printable\n- [ ] Options work correctly\n- [ ] Output is valid Cypher\n\n## TDD Phase: GREEN\n## Depends On: neo4j-s8z1","status":"closed","priority":1,"issue_type":"task","created_at":"2026-01-05T06:39:44.237082-06:00","updated_at":"2026-01-05T08:56:54.394402-06:00","closed_at":"2026-01-05T08:56:54.394402-06:00","close_reason":"Features implemented with tests"}
{"id":"neo4j-pasb","title":"[RED] E2E Concurrent Operations Tests","description":"# [RED] E2E Concurrent Operations Tests\n\n## Overview\nEnd-to-end tests for handling concurrent operations, race conditions, and parallel execution.\n\n## Test Scenarios\n\n### Parallel Session Operations\n```typescript\ndescribe('Parallel Session Operations E2E', () =\u003e {\n  it('should handle multiple concurrent sessions', async () =\u003e {\n    const sessions = Array.from({ length: 10 }, () =\u003e driver.session())\n    \n    const results = await Promise.all(\n      sessions.map((session, i) =\u003e\n        session.run('CREATE (n:ConcurrentSession {id: $id}) RETURN n', { id: i })\n      )\n    )\n    \n    expect(results).toHaveLength(10)\n    results.forEach(r =\u003e expect(r.records).toHaveLength(1))\n    \n    const countResult = await session.run('MATCH (n:ConcurrentSession) RETURN count(n) as count')\n    expect(countResult.records[0].get('count').toInt()).toBe(10)\n    \n    await Promise.all(sessions.map(s =\u003e s.close()))\n  })\n\n  it('should handle concurrent reads', async () =\u003e {\n    await session.run(`\n      UNWIND range(1, 100) AS i\n      CREATE (n:ReadTarget {id: i})\n    `)\n    \n    const sessions = Array.from({ length: 20 }, () =\u003e driver.session())\n    \n    const results = await Promise.all(\n      sessions.map(s =\u003e \n        s.run('MATCH (n:ReadTarget) RETURN count(n) as count')\n      )\n    )\n    \n    results.forEach(r =\u003e {\n      expect(r.records[0].get('count').toInt()).toBe(100)\n    })\n    \n    await Promise.all(sessions.map(s =\u003e s.close()))\n  })\n\n  it('should handle concurrent writes to different nodes', async () =\u003e {\n    const sessions = Array.from({ length: 10 }, () =\u003e driver.session())\n    \n    await Promise.all(\n      sessions.map((session, i) =\u003e\n        session.executeWrite(async tx =\u003e {\n          await tx.run('CREATE (n:IndependentWrite {id: $id})', { id: i })\n        })\n      )\n    )\n    \n    const result = await session.run('MATCH (n:IndependentWrite) RETURN count(n) as count')\n    expect(result.records[0].get('count').toInt()).toBe(10)\n    \n    await Promise.all(sessions.map(s =\u003e s.close()))\n  })\n})\n```\n\n### Concurrent Writes to Same Node\n```typescript\ndescribe('Concurrent Writes to Same Node E2E', () =\u003e {\n  it('should handle concurrent increments (optimistic)', async () =\u003e {\n    await session.run('CREATE (n:Counter {value: 0})')\n    \n    const sessions = Array.from({ length: 10 }, () =\u003e driver.session())\n    \n    await Promise.all(\n      sessions.map(s =\u003e\n        s.executeWrite(async tx =\u003e {\n          await tx.run('MATCH (n:Counter) SET n.value = n.value + 1')\n        })\n      )\n    )\n    \n    const result = await session.run('MATCH (n:Counter) RETURN n.value as value')\n    // Due to concurrent updates, final value should be 10 (with proper locking)\n    // or less if some updates were lost (without proper locking)\n    expect(result.records[0].get('value').toInt()).toBeGreaterThan(0)\n    \n    await Promise.all(sessions.map(s =\u003e s.close()))\n  })\n\n  it('should serialize writes with MERGE', async () =\u003e {\n    const sessions = Array.from({ length: 5 }, () =\u003e driver.session())\n    \n    await Promise.all(\n      sessions.map(s =\u003e\n        s.executeWrite(async tx =\u003e {\n          await tx.run(`\n            MERGE (n:Singleton {id: 'unique'})\n            ON CREATE SET n.created = timestamp()\n            ON MATCH SET n.updated = timestamp()\n          `)\n        })\n      )\n    )\n    \n    const result = await session.run('MATCH (n:Singleton) RETURN count(n) as count')\n    expect(result.records[0].get('count').toInt()).toBe(1)\n    \n    await Promise.all(sessions.map(s =\u003e s.close()))\n  })\n})\n```\n\n### Race Condition Handling\n```typescript\ndescribe('Race Condition Handling E2E', () =\u003e {\n  it('should handle create-if-not-exists pattern', async () =\u003e {\n    const sessions = Array.from({ length: 10 }, () =\u003e driver.session())\n    \n    // All try to create the same node\n    const results = await Promise.allSettled(\n      sessions.map(s =\u003e\n        s.executeWrite(async tx =\u003e {\n          return tx.run(`\n            MERGE (n:Unique {key: 'test'})\n            ON CREATE SET n.creator = randomUUID()\n            RETURN n.creator as creator\n          `)\n        })\n      )\n    )\n    \n    // All should succeed with MERGE\n    const successes = results.filter(r =\u003e r.status === 'fulfilled')\n    expect(successes.length).toBe(10)\n    \n    // But only one node should exist\n    const count = await session.run('MATCH (n:Unique) RETURN count(n) as count')\n    expect(count.records[0].get('count').toInt()).toBe(1)\n    \n    await Promise.all(sessions.map(s =\u003e s.close()))\n  })\n\n  it('should handle relationship creation race', async () =\u003e {\n    await session.run(`\n      CREATE (a:RaceNode {id: 'A'}), (b:RaceNode {id: 'B'})\n    `)\n    \n    const sessions = Array.from({ length: 5 }, () =\u003e driver.session())\n    \n    await Promise.all(\n      sessions.map(s =\u003e\n        s.executeWrite(async tx =\u003e {\n          await tx.run(`\n            MATCH (a:RaceNode {id: 'A'}), (b:RaceNode {id: 'B'})\n            MERGE (a)-[:CONNECTED]-\u003e(b)\n          `)\n        })\n      )\n    )\n    \n    const result = await session.run(`\n      MATCH (:RaceNode {id: 'A'})-[r:CONNECTED]-\u003e(:RaceNode {id: 'B'})\n      RETURN count(r) as count\n    `)\n    expect(result.records[0].get('count').toInt()).toBe(1)\n    \n    await Promise.all(sessions.map(s =\u003e s.close()))\n  })\n})\n```\n\n### Transaction Retry Under Contention\n```typescript\ndescribe('Transaction Retry Under Contention E2E', () =\u003e {\n  it('should retry and eventually succeed', async () =\u003e {\n    await session.run('CREATE (n:Contested {value: 0})')\n    \n    const sessions = Array.from({ length: 5 }, () =\u003e driver.session())\n    let totalRetries = 0\n    \n    await Promise.all(\n      sessions.map(s =\u003e\n        s.executeWrite(async tx =\u003e {\n          // This might require retries due to contention\n          await tx.run(`\n            MATCH (n:Contested)\n            SET n.value = n.value + 1\n          `)\n        }, {\n          maxRetryTime: 30000 // Allow up to 30s of retries\n        })\n      )\n    )\n    \n    const result = await session.run('MATCH (n:Contested) RETURN n.value as value')\n    expect(result.records[0].get('value').toInt()).toBe(5)\n    \n    await Promise.all(sessions.map(s =\u003e s.close()))\n  })\n})\n```\n\n### Connection Pool Behavior\n```typescript\ndescribe('Connection Pool Behavior E2E', () =\u003e {\n  it('should reuse connections from pool', async () =\u003e {\n    // Create driver with limited pool\n    const pooledDriver = neo4j.driver('bolt://localhost', auth, {\n      maxConnectionPoolSize: 5\n    })\n    \n    // Execute more concurrent requests than pool size\n    const sessions = Array.from({ length: 10 }, () =\u003e pooledDriver.session())\n    \n    await Promise.all(\n      sessions.map(s =\u003e s.run('RETURN 1'))\n    )\n    \n    await Promise.all(sessions.map(s =\u003e s.close()))\n    await pooledDriver.close()\n  })\n\n  it('should queue requests when pool exhausted', async () =\u003e {\n    const pooledDriver = neo4j.driver('bolt://localhost', auth, {\n      maxConnectionPoolSize: 2,\n      connectionAcquisitionTimeout: 30000\n    })\n    \n    const sessions = Array.from({ length: 5 }, () =\u003e pooledDriver.session())\n    \n    // These should queue and eventually complete\n    const start = Date.now()\n    await Promise.all(\n      sessions.map(s =\u003e\n        s.run('CALL apoc.util.sleep(100) RETURN 1') // If APOC available\n          .catch(() =\u003e s.run('RETURN 1')) // Fallback\n      )\n    )\n    \n    await Promise.all(sessions.map(s =\u003e s.close()))\n    await pooledDriver.close()\n  })\n})\n```\n\n### Stress Test\n```typescript\ndescribe('Concurrent Stress Test E2E', () =\u003e {\n  it('should handle burst of operations', async () =\u003e {\n    const operations = 100\n    const sessions = Array.from({ length: operations }, () =\u003e driver.session())\n    \n    const start = Date.now()\n    \n    await Promise.all(\n      sessions.map((s, i) =\u003e\n        s.executeWrite(async tx =\u003e {\n          await tx.run('CREATE (n:StressTest {id: $id, timestamp: $ts})', {\n            id: i,\n            ts: Date.now()\n          })\n        })\n      )\n    )\n    \n    const duration = Date.now() - start\n    console.log(`Executed ${operations} operations in ${duration}ms`)\n    \n    const result = await session.run('MATCH (n:StressTest) RETURN count(n) as count')\n    expect(result.records[0].get('count').toInt()).toBe(operations)\n    \n    await Promise.all(sessions.map(s =\u003e s.close()))\n  })\n})\n```\n\n## Acceptance Criteria\n- [ ] Parallel session tests written\n- [ ] Concurrent write tests written\n- [ ] Race condition tests written\n- [ ] Transaction retry tests written\n- [ ] Connection pool tests written\n- [ ] Stress test written\n- [ ] Tests fail initially (RED phase)","status":"open","priority":2,"issue_type":"task","created_at":"2026-01-05T06:48:21.897081-06:00","updated_at":"2026-01-05T06:48:21.897081-06:00"}
{"id":"neo4j-pfaz","title":"RED: Write failing tests for rxResult.consume() method","description":"## Overview\nWrite failing tests for rxResult.consume() result summary method.\n\n## Test Cases to Write\n\n### Basic Consume Tests\n- consume() returns Observable of ResultSummary\n- Summary available after all records processed\n- Contains query statistics\n- Contains query plan info (if available)\n\n### ResultSummary Content Tests\n- counters (nodes created, relationships created, etc.)\n- query type (read/write)\n- database info\n- server info\n- notifications/warnings\n\n### Observable Behavior Tests\n- Single emission then complete\n- Available after records exhausted\n- Error if records() not consumed first\n- Error on query failure\n\n### Query Statistics Tests\n- nodesCreated count\n- nodesDeleted count\n- relationshipsCreated count\n- relationshipsDeleted count\n- propertiesSet count\n\n## Acceptance Criteria\n- All tests written and failing (RED phase)\n- Tests verify ResultSummary content\n- Tests cover Observable semantics\n- Tests verify statistics accuracy","status":"open","priority":2,"issue_type":"task","created_at":"2026-01-05T06:41:44.598287-06:00","updated_at":"2026-01-05T06:41:44.598287-06:00"}
{"id":"neo4j-pkrf","title":"REFACTOR: Graph Algorithms - Optimize for large graphs","description":"## Overview\nOptimize graph algorithms for large-scale graphs.\n\n## Goals\n\n### 1. Performance Optimizations\n- Index hints for relationship traversal\n- Batch processing for large result sets\n- Early termination for bounded searches\n- Parallel processing where possible\n\n### 2. Memory Efficiency\n- Streaming results instead of materializing\n- Incremental computation\n- Memory-bounded algorithms\n\n### 3. Additional Algorithms\n- A* search with heuristics\n- All-pairs shortest path\n- Triangle counting\n- K-core decomposition\n- Strongly connected components\n\n### 4. Configuration Options\n- Progress callbacks\n- Timeout limits\n- Memory limits\n- Sampling for large graphs\n\n### 5. Caching\n- Cache intermediate results\n- Reuse computation across queries\n- Invalidation on graph changes\n\n## Acceptance Criteria\n- [ ] All tests still passing\n- [ ] 10x performance improvement for large graphs\n- [ ] Memory-bounded execution\n- [ ] New algorithms working\n\n## Tags\nsuperset, graph-algorithms, tdd-refactor, performance","status":"open","priority":3,"issue_type":"task","created_at":"2026-01-05T06:50:57.095378-06:00","updated_at":"2026-01-05T06:50:57.095378-06:00"}
{"id":"neo4j-pm6","title":"RED: Pattern to JOIN Translation - Single Node Pattern","description":"## Overview\nWrite failing tests for single node pattern translation to SELECT statements.\n\n## Test Cases to Write\n\n### Test 1: Basic Node Pattern\n```typescript\ntest('translates (n) to SELECT * FROM nodes', () =\u003e {\n  const ast = parse('MATCH (n) RETURN n');\n  const sql = translate(ast);\n  expect(sql).toContain('SELECT');\n  expect(sql).toContain('FROM nodes');\n});\n```\n\n### Test 2: Node with Variable Binding\n```typescript\ntest('binds node variable for later reference', () =\u003e {\n  const ast = parse('MATCH (person) RETURN person.name');\n  const sql = translate(ast);\n  expect(sql).toContain('json_extract');\n  expect(sql).toContain('person');\n});\n```\n\n### Test 3: Node with Label Filter\n```typescript\ntest('translates (n:Person) to WHERE with label check', () =\u003e {\n  const ast = parse('MATCH (n:Person) RETURN n');\n  const sql = translate(ast);\n  expect(sql).toMatch(/WHERE.*label.*=.*'Person'/);\n});\n```\n\n### Test 4: Node with Multiple Labels\n```typescript\ntest('translates (n:Person:Employee) to AND conditions', () =\u003e {\n  const ast = parse('MATCH (n:Person:Employee) RETURN n');\n  const sql = translate(ast);\n  expect(sql).toContain('Person');\n  expect(sql).toContain('Employee');\n});\n```\n\n### Test 5: Node with Properties\n```typescript\ntest('translates (n {name: \"Alice\"}) to property WHERE', () =\u003e {\n  const ast = parse('MATCH (n {name: \"Alice\"}) RETURN n');\n  const sql = translate(ast);\n  expect(sql).toContain('json_extract');\n  expect(sql).toContain('name');\n  expect(sql).toContain('Alice');\n});\n```\n\n### Test 6: Anonymous Node\n```typescript\ntest('handles anonymous node pattern ()', () =\u003e {\n  const ast = parse('MATCH () RETURN count(*)');\n  const sql = translate(ast);\n  expect(sql).toContain('COUNT(*)');\n  expect(sql).toContain('FROM nodes');\n});\n```\n\n## Acceptance Criteria\n- [ ] All tests written and failing\n- [ ] Tests cover edge cases (empty labels, null properties)\n- [ ] Test file created at `src/cypher/translator/__tests__/pattern-to-join.test.ts`\n\n## TDD Phase\nRED - Write failing tests first","status":"closed","priority":1,"issue_type":"task","created_at":"2026-01-05T06:34:30.048383-06:00","updated_at":"2026-01-05T07:46:37.194182-06:00","closed_at":"2026-01-05T07:46:37.194182-06:00","close_reason":"Completed in Ralph Wiggum session - 987 tests pass"}
{"id":"neo4j-pni","title":"[GREEN] Lexer: Implement Comments and Parameters","description":"## Overview\nImplement comment and parameter tokenization.\n\n## Implementation Tasks\n\n### Single-Line Comment Scanner\n```typescript\nprivate scanSingleLineComment(): Token {\n  // Skip //\n  // Scan until newline or EOF\n  // Return COMMENT token\n}\n```\n\n### Multi-Line Comment Scanner\n```typescript\nprivate scanMultiLineComment(): Token {\n  // Skip /*\n  // Scan until */\n  // Track newlines for line counting\n  // Error if unclosed\n  // Return COMMENT token\n}\n```\n\n### Parameter Scanner\n```typescript\nprivate scanParameter(): Token {\n  // Skip $\n  // Scan identifier characters\n  // Return PARAMETER token with name\n}\n```\n\n## Acceptance Criteria\n- [ ] All comment tests pass\n- [ ] All parameter tests pass\n- [ ] Line counting accurate through comments\n- [ ] Proper errors for malformed input\n\n## TDD Phase: GREEN\n## Depends On: neo4j-rih","status":"closed","priority":1,"issue_type":"task","created_at":"2026-01-05T06:37:01.05857-06:00","updated_at":"2026-01-05T08:58:01.758844-06:00","closed_at":"2026-01-05T08:58:01.758844-06:00","close_reason":"AST, lexer and types tests passing"}
{"id":"neo4j-pt0","title":"RED: Full-Text Search - Write failing tests for FTS5 integration","description":"## Overview\nWrite failing tests for full-text search using SQLite FTS5 integration.\n\n## Test Cases\n\n```typescript\ndescribe('Full-Text Search', () =\u003e {\n  beforeAll(async () =\u003e {\n    await session.run('CALL db.index.fulltext.create(\"articles\", [\"Article\"], [\"title\", \"content\"])');\n    await session.run(`\n      CREATE (:Article {title: \"Introduction to Graph Databases\", content: \"Graph databases store data as nodes and relationships...\"})\n      CREATE (:Article {title: \"SQL Performance Tuning\", content: \"Optimizing SQL queries requires understanding indexes...\"})\n      CREATE (:Article {title: \"Neo4j Best Practices\", content: \"When working with Neo4j, consider these graph patterns...\"})\n    `);\n  });\n\n  describe('queryNodes Procedure', () =\u003e {\n    it('should search across configured fields', async () =\u003e {\n      const result = await session.run(\n        'CALL db.index.fulltext.queryNodes(\"articles\", \"graph databases\") YIELD node, score RETURN node.title, score'\n      );\n      \n      expect(result.records).toHaveLength(2);\n      expect(result.records[0].get('node.title')).toBe('Introduction to Graph Databases');\n    });\n\n    it('should support phrase search', async () =\u003e {\n      const result = await session.run(\n        'CALL db.index.fulltext.queryNodes(\"articles\", \"\\\"graph patterns\\\"\") YIELD node RETURN node.title'\n      );\n      \n      expect(result.records).toHaveLength(1);\n      expect(result.records[0].get('node.title')).toBe('Neo4j Best Practices');\n    });\n\n    it('should support boolean operators', async () =\u003e {\n      const result = await session.run(\n        'CALL db.index.fulltext.queryNodes(\"articles\", \"graph AND NOT sql\") YIELD node RETURN node.title'\n      );\n      \n      // Should exclude SQL article\n    });\n\n    it('should return relevance scores', async () =\u003e {\n      const result = await session.run(\n        'CALL db.index.fulltext.queryNodes(\"articles\", \"graph\") YIELD node, score RETURN node.title, score ORDER BY score DESC'\n      );\n      \n      // First result should have higher score\n      const score1 = result.records[0].get('score');\n      const score2 = result.records[1].get('score');\n      expect(score1).toBeGreaterThan(score2);\n    });\n\n    it('should limit results with LIMIT clause', async () =\u003e {\n      const result = await session.run(\n        'CALL db.index.fulltext.queryNodes(\"articles\", \"database\") YIELD node RETURN node LIMIT 1'\n      );\n      \n      expect(result.records).toHaveLength(1);\n    });\n  });\n\n  describe('queryRelationships Procedure', () =\u003e {\n    it('should search relationship properties', async () =\u003e {\n      await session.run('CALL db.index.fulltext.create(\"reviews\", [], [\"text\"], { entityType: \"relationship\", relTypes: [\"REVIEWED\"] })');\n      await session.run(`\n        CREATE (u:User)-[:REVIEWED {text: \"Excellent documentation and great performance\"}]-\u003e(p:Product)\n      `);\n      \n      const result = await session.run(\n        'CALL db.index.fulltext.queryRelationships(\"reviews\", \"excellent\") YIELD relationship RETURN relationship.text'\n      );\n      \n      expect(result.records[0].get('relationship.text')).toContain('Excellent');\n    });\n  });\n\n  describe('Fuzzy Matching', () =\u003e {\n    it('should find fuzzy matches', async () =\u003e {\n      const result = await session.run(\n        'CALL db.index.fulltext.queryNodes(\"articles\", \"databse~\") YIELD node RETURN node.title'\n      );\n      \n      // Should find \"database\" despite typo\n      expect(result.records.length).toBeGreaterThan(0);\n    });\n\n    it('should support configurable edit distance', async () =\u003e {\n      const result = await session.run(\n        'CALL db.index.fulltext.queryNodes(\"articles\", \"grph~2\") YIELD node RETURN node.title'\n      );\n      \n      // Should find \"graph\" with edit distance 2\n    });\n  });\n\n  describe('Prefix Search', () =\u003e {\n    it('should support prefix matching', async () =\u003e {\n      const result = await session.run(\n        'CALL db.index.fulltext.queryNodes(\"articles\", \"optim*\") YIELD node RETURN node.title'\n      );\n      \n      // Should find \"optimization\", \"optimizing\", etc.\n    });\n  });\n\n  describe('Index Management', () =\u003e {\n    it('should create index on multiple labels', async () =\u003e {\n      await session.run('CALL db.index.fulltext.create(\"content\", [\"Article\", \"Post\", \"Comment\"], [\"text\", \"body\"])');\n      // Index should cover all labels\n    });\n\n    it('should list all fulltext indexes', async () =\u003e {\n      const result = await session.run('CALL db.index.fulltext.list() YIELD name, labels, properties RETURN *');\n      expect(result.records.length).toBeGreaterThan(0);\n    });\n\n    it('should drop index', async () =\u003e {\n      await session.run('CALL db.index.fulltext.create(\"temp\", [\"Temp\"], [\"text\"])');\n      await session.run('CALL db.index.fulltext.drop(\"temp\")');\n      \n      await expect(session.run(\n        'CALL db.index.fulltext.queryNodes(\"temp\", \"test\") YIELD node RETURN node'\n      )).rejects.toThrow(/Index .* not found/);\n    });\n  });\n\n  describe('Auto-indexing', () =\u003e {\n    it('should automatically index new nodes', async () =\u003e {\n      await session.run('CREATE (:Article {title: \"New Article\", content: \"Fresh content about testing\"})');\n      \n      const result = await session.run(\n        'CALL db.index.fulltext.queryNodes(\"articles\", \"fresh testing\") YIELD node RETURN node.title'\n      );\n      \n      expect(result.records[0].get('node.title')).toBe('New Article');\n    });\n\n    it('should update index on property changes', async () =\u003e {\n      await session.run('MATCH (a:Article {title: \"New Article\"}) SET a.content = \"Updated content about changes\"');\n      \n      const result = await session.run(\n        'CALL db.index.fulltext.queryNodes(\"articles\", \"updated changes\") YIELD node RETURN node.title'\n      );\n      \n      expect(result.records[0].get('node.title')).toBe('New Article');\n    });\n  });\n});\n```\n\n## Acceptance Criteria\n- [ ] All test cases written and failing\n- [ ] FTS5 test infrastructure ready\n- [ ] Test fixtures with known relevance scores\n\n## Tags\nsuperset, fulltext-search, fts5, sqlite, tdd-red","status":"open","priority":2,"issue_type":"task","created_at":"2026-01-05T06:37:12.506609-06:00","updated_at":"2026-01-05T06:37:12.506609-06:00"}
{"id":"neo4j-pxyj","title":"GREEN: EagerResult structure - Implement buffered result class","description":"## Overview\nImplement the EagerResult class to make all RED phase tests pass.\n\n## Implementation\n\n```typescript\nexport class EagerResult\u003cR extends Record = Record\u003e {\n  readonly keys: string[];\n  readonly records: R[];\n  readonly summary: ResultSummary;\n\n  constructor(\n    keys: string[],\n    records: R[],\n    summary: ResultSummary\n  ) {\n    this.keys = Object.freeze([...keys]) as string[];\n    this.records = Object.freeze([...records]) as R[];\n    this.summary = summary;\n    \n    Object.freeze(this);\n  }\n}\n```\n\n## Acceptance Criteria\n- [ ] All RED phase tests now pass (GREEN phase)\n- [ ] Synchronous access to all properties\n- [ ] Properties are frozen/immutable\n- [ ] Implementation is minimal\n\n## TDD Phase\nGREEN - Minimal implementation to pass tests\n\n## Dependencies\n- neo4j-71wz (RED phase tests)","status":"closed","priority":1,"issue_type":"task","created_at":"2026-01-05T06:51:17.373047-06:00","updated_at":"2026-01-05T07:19:22.170744-06:00","closed_at":"2026-01-05T07:19:22.170744-06:00","close_reason":"Implemented in this Ralph Wiggum session - 662 tests pass"}
{"id":"neo4j-q3b4","title":"[RED] Backup and Recovery - Write failing tests for export/import operations","description":"## Overview\nWrite failing tests for backup and recovery operations before implementation.\n\n## Test Cases to Write\n\n### Export to Cypher Tests\n- `test_export_empty_database_returns_empty`\n- `test_export_single_node_to_cypher`\n- `test_export_node_with_labels_to_cypher`\n- `test_export_node_with_properties_to_cypher`\n- `test_export_relationship_to_cypher`\n- `test_export_full_graph_to_cypher`\n- `test_export_preserves_ids`\n- `test_export_escapes_special_characters`\n\n### Export to JSON Tests\n- `test_export_to_json_format`\n- `test_export_json_includes_nodes`\n- `test_export_json_includes_relationships`\n- `test_export_json_includes_metadata`\n- `test_export_json_streaming_large_graphs`\n\n### Import from Cypher Tests\n- `test_import_create_node_statement`\n- `test_import_create_relationship_statement`\n- `test_import_multiple_statements`\n- `test_import_with_parameters`\n- `test_import_handles_syntax_errors`\n- `test_import_transactional` - All or nothing\n\n### Import from JSON Tests\n- `test_import_json_creates_nodes`\n- `test_import_json_creates_relationships`\n- `test_import_json_validates_format`\n- `test_import_json_handles_missing_refs`\n- `test_import_json_transactional`\n\n### Incremental Backup Tests\n- `test_export_changes_since_timestamp`\n- `test_incremental_export_format`\n- `test_apply_incremental_backup`\n\n### Edge Cases\n- `test_export_large_property_values`\n- `test_import_circular_relationships`\n- `test_export_special_property_types`\n- `test_import_with_id_conflicts`\n\n## Acceptance Criteria\n- [ ] All tests written and failing\n- [ ] Cypher export/import tested\n- [ ] JSON export/import tested\n- [ ] Edge cases covered\n\n## TDD Phase\n**RED** - Write failing tests first","status":"open","priority":2,"issue_type":"task","created_at":"2026-01-05T06:42:47.771591-06:00","updated_at":"2026-01-05T06:42:47.771591-06:00"}
{"id":"neo4j-q4z5","title":"[RED] Parser: Relationship Pattern Tests","description":"## Overview\nWrite failing tests for relationship pattern parsing.\n\n## Test Cases to Write\n\n### Basic Relationship Patterns\n- Undirected: `(a)--(b)`\n- Outgoing: `(a)--\u003e(b)`\n- Incoming: `(a)\u003c--(b)`\n- Bidirectional: `(a)\u003c--\u003e(b)`\n\n### Relationship with Details\n- Variable: `(a)-[r]-(b)`\n- Type: `(a)-[:KNOWS]-(b)`\n- Variable and type: `(a)-[r:KNOWS]-(b)`\n- Multiple types: `(a)-[r:KNOWS|LIKES]-(b)`\n\n### Relationship with Properties\n- Properties: `(a)-[r:KNOWS {since: 2020}]-(b)`\n- Parameter: `(a)-[r:KNOWS $props]-(b)`\n\n### Variable-Length Paths\n- Any length: `(a)-[*]-(b)`\n- Exact length: `(a)-[*3]-(b)`\n- Min only: `(a)-[*2..]-(b)`\n- Max only: `(a)-[*..5]-(b)`\n- Range: `(a)-[*2..5]-(b)`\n- With type: `(a)-[:KNOWS*2..5]-(b)`\n- With variable: `(a)-[r:KNOWS*2..5]-(b)`\n\n### Direction Combinations\n- Outgoing with type: `(a)-[:KNOWS]-\u003e(b)`\n- Incoming with type: `(a)\u003c-[:KNOWS]-(b)`\n- All direction variations with details\n\n## Acceptance Criteria\n- [ ] All relationship tests written and failing\n- [ ] All direction combinations tested\n- [ ] Variable-length syntax tested\n- [ ] Error cases for invalid syntax\n\n## TDD Phase: RED","status":"closed","priority":1,"issue_type":"task","created_at":"2026-01-05T06:40:37.00301-06:00","updated_at":"2026-01-05T07:19:48.957782-06:00","closed_at":"2026-01-05T07:19:48.957782-06:00","close_reason":"Parser implemented with MATCH, RETURN, node/relationship patterns, expressions - 34 parser tests pass"}
{"id":"neo4j-q4zb","title":"[RED] Performance Benchmark: Cold Start","description":"# [RED] Performance Benchmark: Cold Start\n\n## Overview\nBenchmark cold start performance for Cloudflare Workers deployment - critical for serverless edge computing.\n\n## Cold Start Metrics\n\n### Worker Initialization\n```typescript\ndescribe('Cold Start Benchmarks', () =\u003e {\n  bench('worker initialization time', async () =\u003e {\n    // Measure time from worker start to first response\n    const worker = await unstable_dev('src/worker.ts', {\n      experimental: { disableExperimentalWarning: true }\n    })\n    \n    const start = performance.now()\n    const response = await worker.fetch('/health')\n    const duration = performance.now() - start\n    \n    console.log(`Cold start: ${duration}ms`)\n    await worker.stop()\n    \n    expect(duration).toBeLessThan(500) // Target: \u003c500ms cold start\n  })\n\n  bench('first query after cold start', async () =\u003e {\n    const worker = await unstable_dev('src/worker.ts')\n    \n    const start = performance.now()\n    const response = await worker.fetch('/query', {\n      method: 'POST',\n      body: JSON.stringify({ cypher: 'RETURN 1' })\n    })\n    const duration = performance.now() - start\n    \n    console.log(`First query: ${duration}ms`)\n    await worker.stop()\n    \n    expect(duration).toBeLessThan(1000) // Target: \u003c1s for first query\n  })\n})\n```\n\n### Module Loading\n```typescript\ndescribe('Module Loading Benchmarks', () =\u003e {\n  bench('import neo4j.do main', async () =\u003e {\n    const start = performance.now()\n    const neo4j = await import('neo4j.do')\n    const duration = performance.now() - start\n    \n    console.log(`Main import: ${duration}ms`)\n  })\n\n  bench('import neo4j.do/lite', async () =\u003e {\n    const start = performance.now()\n    const neo4jLite = await import('neo4j.do/lite')\n    const duration = performance.now() - start\n    \n    console.log(`Lite import: ${duration}ms`)\n    // Lite should be faster due to no RxJS\n  })\n\n  bench('import neo4j.do/client', async () =\u003e {\n    const start = performance.now()\n    const client = await import('neo4j.do/client')\n    const duration = performance.now() - start\n    \n    console.log(`Client import: ${duration}ms`)\n  })\n})\n```\n\n### Durable Object Initialization\n```typescript\ndescribe('Durable Object Cold Start', () =\u003e {\n  bench('first DO access', async () =\u003e {\n    // Measure time to access a new Durable Object\n    const start = performance.now()\n    \n    const id = env.GRAPH_STORE.newUniqueId()\n    const stub = env.GRAPH_STORE.get(id)\n    await stub.fetch('http://fake/init')\n    \n    const duration = performance.now() - start\n    console.log(`DO cold start: ${duration}ms`)\n  })\n\n  bench('subsequent DO access', async () =\u003e {\n    // Measure warm DO access\n    const id = env.GRAPH_STORE.idFromName('benchmark-do')\n    const stub = env.GRAPH_STORE.get(id)\n    \n    // Warm up\n    await stub.fetch('http://fake/ping')\n    \n    const start = performance.now()\n    await stub.fetch('http://fake/ping')\n    const duration = performance.now() - start\n    \n    console.log(`DO warm: ${duration}ms`)\n  })\n})\n```\n\n### D1 Database Initialization\n```typescript\ndescribe('D1 Cold Start', () =\u003e {\n  bench('first D1 query', async () =\u003e {\n    const start = performance.now()\n    await env.DB.prepare('SELECT 1').first()\n    const duration = performance.now() - start\n    \n    console.log(`D1 first query: ${duration}ms`)\n  })\n\n  bench('subsequent D1 queries', async () =\u003e {\n    // Warm up\n    await env.DB.prepare('SELECT 1').first()\n    \n    const start = performance.now()\n    await env.DB.prepare('SELECT 1').first()\n    const duration = performance.now() - start\n    \n    console.log(`D1 warm query: ${duration}ms`)\n  })\n})\n```\n\n## Bundle Size Analysis\n```typescript\ndescribe('Bundle Size', () =\u003e {\n  it('should have acceptable bundle size', async () =\u003e {\n    const fs = await import('fs/promises')\n    const path = await import('path')\n    \n    const mainBundle = await fs.stat(path.join(__dirname, '../dist/index.js'))\n    const liteBundle = await fs.stat(path.join(__dirname, '../dist/lite.js'))\n    \n    console.log(`Main bundle: ${(mainBundle.size / 1024).toFixed(2)}KB`)\n    console.log(`Lite bundle: ${(liteBundle.size / 1024).toFixed(2)}KB`)\n    \n    // Targets for edge deployment\n    expect(mainBundle.size).toBeLessThan(500 * 1024) // \u003c500KB\n    expect(liteBundle.size).toBeLessThan(200 * 1024) // \u003c200KB\n  })\n\n  it('should have no large dependencies', async () =\u003e {\n    // Analyze bundle composition\n    const { metafile } = await esbuild.build({\n      entryPoints: ['src/index.ts'],\n      bundle: true,\n      metafile: true,\n      write: false\n    })\n    \n    // Check for unexpectedly large imports\n    const inputs = Object.entries(metafile.inputs)\n      .map(([path, info]) =\u003e ({ path, size: info.bytes }))\n      .sort((a, b) =\u003e b.size - a.size)\n      .slice(0, 10)\n    \n    console.log('Largest dependencies:', inputs)\n  })\n})\n```\n\n## Regional Cold Start Comparison\n```typescript\ndescribe('Regional Performance', () =\u003e {\n  const regions = ['iad', 'lhr', 'sin', 'syd'] // Major CF regions\n  \n  for (const region of regions) {\n    bench(`cold start in ${region}`, async () =\u003e {\n      // Would need real deployment to test\n      // Placeholder for regional testing setup\n    })\n  }\n})\n```\n\n## Baseline Targets\n| Metric | Target | Notes |\n|--------|--------|-------|\n| Worker cold start | \u003c500ms | Time to first byte |\n| First Cypher query | \u003c1s | Including parse \u0026 execute |\n| Module import (main) | \u003c100ms | With tree shaking |\n| Module import (lite) | \u003c50ms | No RxJS |\n| Durable Object init | \u003c200ms | First access |\n| D1 first query | \u003c100ms | After connection |\n| Main bundle size | \u003c500KB | Gzipped |\n| Lite bundle size | \u003c200KB | Gzipped |\n\n## Acceptance Criteria\n- [ ] Worker cold start benchmark created\n- [ ] Module loading benchmarks created\n- [ ] DO initialization benchmarks created\n- [ ] D1 benchmarks created\n- [ ] Bundle size analysis added\n- [ ] Baseline targets documented\n- [ ] CI integration for tracking","status":"open","priority":3,"issue_type":"task","created_at":"2026-01-05T06:49:27.13447-06:00","updated_at":"2026-01-05T06:49:27.13447-06:00"}
{"id":"neo4j-q9p","title":"RED: Driver Lifecycle Methods Tests","description":"## Overview\nWrite comprehensive failing tests for Driver lifecycle methods: session creation, executeQuery, getServerInfo, close, and verifyConnectivity.\n\n## Test Cases\n\n### Session Creation Tests\n```typescript\ndescribe('driver.session()', () =\u003e {\n  it('should create session with default config')\n  it('should create session with database specified')\n  it('should create session with defaultAccessMode READ')\n  it('should create session with defaultAccessMode WRITE')\n  it('should create session with bookmarks')\n  it('should create session with fetchSize')\n  it('should create session with impersonatedUser')\n  it('should throw after driver is closed')\n  it('should track active sessions')\n})\n\ndescribe('driver.rxSession()', () =\u003e {\n  it('should create reactive session')\n  it('should return RxSession instance')\n  it('should accept same config as regular session')\n})\n```\n\n### Execute Query Tests\n```typescript\ndescribe('driver.executeQuery()', () =\u003e {\n  it('should execute simple query')\n  it('should execute query with parameters')\n  it('should return EagerResult with records')\n  it('should return summary information')\n  it('should return keys from result')\n  it('should use READ routing by default')\n  it('should respect routing configuration')\n  it('should respect database configuration')\n  it('should handle query errors')\n  it('should auto-retry transient errors')\n})\n```\n\n### Server Info Tests\n```typescript\ndescribe('driver.getServerInfo()', () =\u003e {\n  it('should return server address')\n  it('should return server agent')\n  it('should return protocol version')\n  it('should throw on connection failure')\n})\n\ndescribe('driver.verifyConnectivity()', () =\u003e {\n  it('should return ServerInfo on success')\n  it('should throw on failure')\n  it('should work as alias for getServerInfo')\n})\n```\n\n### Close Tests\n```typescript\ndescribe('driver.close()', () =\u003e {\n  it('should close all active sessions')\n  it('should release all resources')\n  it('should be idempotent')\n  it('should reject new session creation after close')\n  it('should wait for in-flight transactions')\n  it('should resolve when all cleanup complete')\n})\n```\n\n## TDD Phase\n**RED** - All tests should fail initially.\n\n## Acceptance Criteria\n- [ ] All test cases written\n- [ ] Tests cover success and error paths\n- [ ] Async behavior properly tested\n- [ ] Resource cleanup verified","status":"closed","priority":1,"issue_type":"task","created_at":"2026-01-05T06:35:27.354116-06:00","updated_at":"2026-01-05T08:46:57.51807-06:00","closed_at":"2026-01-05T08:46:57.51807-06:00","close_reason":"Tests passing - implementation complete"}
{"id":"neo4j-qd6i","title":"GREEN: Bookmark Manager \u0026 Causal Consistency Implementation","description":"## Overview\nImplement BookmarkManager and causal consistency mechanisms to pass all RED phase tests.\n\n## Implementation Requirements\n\n### BookmarkManager Class\n```typescript\nclass BookmarkManager {\n  private bookmarks: Map\u003cstring, string[]\u003e = new Map()\n  private listeners: BookmarkListener[] = []\n\n  constructor(config?: BookmarkManagerConfig) {\n    // Initialize with optional initial bookmarks\n  }\n\n  getBookmarks(database: string): string[] {\n    return this.bookmarks.get(database) ?? []\n  }\n\n  updateBookmarks(database: string, newBookmarks: string[]): void {\n    this.bookmarks.set(database, newBookmarks)\n    this.notifyListeners(database, newBookmarks)\n  }\n\n  addListener(listener: BookmarkListener): void {\n    this.listeners.push(listener)\n  }\n\n  private notifyListeners(database: string, bookmarks: string[]): void {\n    for (const listener of this.listeners) {\n      listener(database, bookmarks)\n    }\n  }\n}\n\ninterface BookmarkManagerConfig {\n  initialBookmarks?: Record\u003cstring, string[]\u003e\n  bookmarkSupplier?: (database: string) =\u003e Promise\u003cstring[]\u003e\n  bookmarkConsumer?: (database: string, bookmarks: string[]) =\u003e Promise\u003cvoid\u003e\n}\n\ntype BookmarkListener = (database: string, bookmarks: string[]) =\u003e void\n```\n\n### Bookmark Format\n```typescript\n// Format: FB:\u003cdatabase\u003e:\u003ctxId\u003e\n// Example: FB:neo4j:1234\n\nfunction generateBookmark(database: string, txId: number): string {\n  return `FB:${database}:${txId}`\n}\n\nfunction parseBookmark(bookmark: string): ParsedBookmark | null {\n  const match = bookmark.match(/^FB:([^:]+):(\\d+)$/)\n  if (\\!match) return null\n  return {\n    database: match[1],\n    txId: parseInt(match[2], 10)\n  }\n}\n```\n\n### Session Integration\n```typescript\nclass Session {\n  private bookmarkManager?: BookmarkManager\n\n  constructor(driver: Driver, config?: SessionConfig) {\n    // Use driver's bookmark manager if available\n    this.bookmarkManager = config?.bookmarkManager ?? driver._bookmarkManager\n    \n    // Load initial bookmarks\n    if (this.bookmarkManager) {\n      this.bookmarks = this.bookmarkManager.getBookmarks(this.config.database)\n    }\n  }\n\n  // After successful write transaction\n  private onWriteComplete(bookmark: string): void {\n    this._updateBookmarks(bookmark)\n    this.bookmarkManager?.updateBookmarks(this.config.database, [bookmark])\n  }\n}\n```\n\n### Driver Integration\n```typescript\nclass Driver {\n  private bookmarkManager?: BookmarkManager\n\n  constructor(config?: DriverConfig) {\n    if (config?.bookmarkManager \\!== false) {\n      this.bookmarkManager = config?.bookmarkManager ?? new BookmarkManager()\n    }\n  }\n}\n```\n\n## Files to Create/Modify\n- `src/session/bookmark-manager.ts`\n- `src/session/bookmarks.ts`\n- `src/session/session.ts`\n- `src/driver/driver.ts`\n\n## TDD Phase\n**GREEN** - Implement to pass tests.\n\n## Dependencies\n- Depends on: RED: Bookmark Manager \u0026 Causal Consistency Tests\n- Depends on: GREEN: Session Bookmarks \u0026 Lifecycle Implementation\n\n## Acceptance Criteria\n- [ ] All RED phase tests pass\n- [ ] BookmarkManager works standalone\n- [ ] Integration with sessions works\n- [ ] Causal consistency maintained","status":"closed","priority":1,"issue_type":"task","created_at":"2026-01-05T06:40:20.896238-06:00","updated_at":"2026-01-05T08:56:54.393288-06:00","closed_at":"2026-01-05T08:56:54.393288-06:00","close_reason":"Features implemented with tests"}
{"id":"neo4j-qsk","title":"[RED] SQLite Schema Design - Write failing tests for nodes table schema","description":"## Overview\nWrite failing tests for the nodes table schema design before implementation.\n\n## Test Cases to Write\n\n### Schema Structure Tests\n- `test_nodes_table_exists` - Verify nodes table is created\n- `test_nodes_table_has_id_column` - INTEGER PRIMARY KEY AUTOINCREMENT\n- `test_nodes_table_has_labels_column` - TEXT (JSON array)\n- `test_nodes_table_has_properties_column` - TEXT (JSON object)\n- `test_nodes_table_has_created_at_column` - DATETIME with default\n- `test_nodes_table_has_updated_at_column` - DATETIME with default\n\n### Relationships Table Tests\n- `test_relationships_table_exists`\n- `test_relationships_table_has_id_column` - INTEGER PRIMARY KEY\n- `test_relationships_table_has_type_column` - TEXT NOT NULL\n- `test_relationships_table_has_start_node_id_column` - INTEGER REFERENCES nodes(id)\n- `test_relationships_table_has_end_node_id_column` - INTEGER REFERENCES nodes(id)\n- `test_relationships_table_has_properties_column` - TEXT (JSON)\n- `test_relationships_table_has_created_at_column`\n\n### Index Tests\n- `test_labels_index_exists` - Index on labels column\n- `test_relationship_type_index_exists`\n- `test_start_node_index_exists`\n- `test_end_node_index_exists`\n\n### Schema Version Tests\n- `test_schema_version_table_exists`\n- `test_schema_version_has_version_column`\n- `test_schema_version_has_applied_at_column`\n\n## Acceptance Criteria\n- [ ] All tests written and failing (RED state)\n- [ ] Tests cover all table structures\n- [ ] Tests verify column types and constraints\n- [ ] Tests check index existence\n- [ ] Schema versioning tests included\n\n## TDD Phase\n**RED** - Write failing tests first","status":"closed","priority":1,"issue_type":"task","created_at":"2026-01-05T06:34:37.404124-06:00","updated_at":"2026-01-05T07:13:24.492181-06:00","closed_at":"2026-01-05T07:13:24.492181-06:00","close_reason":"SQLite schema implemented"}
{"id":"neo4j-qzj","title":"[GREEN] Node Operations - Implement CRUD operations to pass tests","description":"## Overview\nImplement node CRUD operations to make all tests pass.\n\n## Implementation Requirements\n\n### Node Interface\n```typescript\ninterface Node {\n  id: number;\n  elementId: string;\n  labels: string[];\n  properties: Record\u003cstring, unknown\u003e;\n}\n```\n\n### NodeOperations Class\n```typescript\nclass NodeOperations {\n  constructor(private sql: SqlStorage) {}\n\n  createNode(labels: string[], properties: Record\u003cstring, unknown\u003e): Node {\n    const result = this.sql.exec(\n      'INSERT INTO nodes (labels, properties) VALUES (?, ?) RETURNING *',\n      JSON.stringify(labels),\n      JSON.stringify(properties)\n    );\n    return this.rowToNode(result.one());\n  }\n\n  getNode(id: number): Node | null {\n    const result = this.sql.exec('SELECT * FROM nodes WHERE id = ?', id);\n    const row = result.one();\n    return row ? this.rowToNode(row) : null;\n  }\n\n  updateNode(id: number, properties: Record\u003cstring, unknown\u003e): Node {\n    // Merge with existing properties\n    const existing = this.getNode(id);\n    if (\\!existing) throw new Error('Node not found');\n    \n    const merged = { ...existing.properties, ...properties };\n    // Remove null values\n    Object.keys(merged).forEach(k =\u003e merged[k] === null \u0026\u0026 delete merged[k]);\n    \n    this.sql.exec(\n      'UPDATE nodes SET properties = ?, updated_at = CURRENT_TIMESTAMP WHERE id = ?',\n      JSON.stringify(merged), id\n    );\n    return this.getNode(id)\\!;\n  }\n\n  deleteNode(id: number): boolean {\n    // Check for relationships\n    const rels = this.sql.exec(\n      'SELECT COUNT(*) as count FROM relationships WHERE start_node_id = ? OR end_node_id = ?',\n      id, id\n    );\n    if (rels.one().count \u003e 0) {\n      throw new Error('Cannot delete node with relationships');\n    }\n    \n    const result = this.sql.exec('DELETE FROM nodes WHERE id = ?', id);\n    return result.rowsWritten \u003e 0;\n  }\n\n  getNodesByLabel(label: string): Node[] {\n    const result = this.sql.exec(\n      \"SELECT * FROM nodes WHERE json_each.value = ? FROM json_each(labels)\",\n      label\n    );\n    return result.toArray().map(this.rowToNode);\n  }\n\n  getAllNodes(limit?: number, offset?: number): Node[] {\n    let query = 'SELECT * FROM nodes';\n    if (limit) query += ' LIMIT ' + limit;\n    if (offset) query += ' OFFSET ' + offset;\n    return this.sql.exec(query).toArray().map(this.rowToNode);\n  }\n}\n```\n\n## Files to Create\n- `src/storage/operations/node-operations.ts`\n- `src/storage/types/node.ts`\n\n## Acceptance Criteria\n- [ ] All RED phase tests pass\n- [ ] CRUD operations work correctly\n- [ ] Error handling implemented\n- [ ] Timestamps managed properly\n\n## TDD Phase\n**GREEN** - Minimum code to pass tests","status":"closed","priority":1,"issue_type":"task","created_at":"2026-01-05T06:36:55.960347-06:00","updated_at":"2026-01-05T08:58:13.610308-06:00","closed_at":"2026-01-05T08:58:13.610308-06:00","close_reason":"Implementation complete with tests"}
{"id":"neo4j-r643","title":"RED: Write failing tests for rxTx.isOpen() method","description":"## Overview\nWrite failing tests for rxTx.isOpen() transaction state check method.\n\n## Test Cases to Write\n\n### Basic State Tests\n- isOpen() returns boolean\n- Returns true for new transaction\n- Returns false after commit\n- Returns false after rollback\n\n### State Transitions\n- True immediately after beginTransaction\n- False after successful commit\n- False after successful rollback\n- False after failed commit\n- False after failed rollback\n\n### Concurrent Access\n- Consistent across multiple calls\n- Thread-safe access\n- Real-time state reflection\n\n## Acceptance Criteria\n- All tests written and failing (RED phase)\n- Tests verify state transitions\n- Tests verify synchronous access\n- Tests cover all state scenarios","status":"open","priority":2,"issue_type":"task","created_at":"2026-01-05T06:40:12.225886-06:00","updated_at":"2026-01-05T06:40:12.225886-06:00"}
{"id":"neo4j-rih","title":"[RED] Lexer: Comments and Parameters Tests","description":"## Overview\nWrite failing tests for comment and parameter tokenization.\n\n## Test Cases to Write\n\n### Single-Line Comments\n- Simple: `// comment`\n- At end of line: `MATCH (n) // find nodes`\n- Empty: `//`\n- With special chars: `// TODO: fix this!`\n\n### Multi-Line Comments\n- Simple: `/* comment */`\n- Multi-line: `/* line1\\nline2 */`\n- Nested (if supported): `/* outer /* inner */ outer */`\n- Empty: `/**/`\n- Unclosed (error case)\n\n### Parameter Placeholders\n- Simple: `$param`\n- With numbers: `$param1`, `$1`\n- With underscores: `$my_param`\n- In query: `MATCH (n {id: $id}) RETURN n`\n\n### Edge Cases\n- Comment at start of input\n- Comment at end of input\n- Multiple consecutive comments\n- Parameter followed by operator\n\n## Acceptance Criteria\n- [ ] All tests written and failing\n- [ ] Both comment styles tested\n- [ ] Parameter syntax tested\n- [ ] Error cases for unclosed comments\n\n## TDD Phase: RED","status":"closed","priority":1,"issue_type":"task","created_at":"2026-01-05T06:36:46.911652-06:00","updated_at":"2026-01-05T08:54:14.036014-06:00","closed_at":"2026-01-05T08:54:14.036014-06:00","close_reason":"Tests passing - implementation complete"}
{"id":"neo4j-rkyl","title":"[GREEN] Parser: Implement Path Pattern and Multiple Patterns","description":"## Overview\nImplement path pattern and multiple pattern parsing.\n\n## Implementation Tasks\n\n### Pattern List Parser\n```typescript\nparsePatternList(): Pattern[] {\n  const patterns: Pattern[] = []\n  \n  do {\n    patterns.push(this.parsePattern())\n  } while (this.match(','))\n  \n  return patterns\n}\n```\n\n### Pattern Parser\n```typescript\nparsePattern(): Pattern | NamedPath {\n  const start = this.pos\n  \n  // Check for named path: p = (a)--\u003e(b)\n  if (this.isIdentifier() \u0026\u0026 this.lookAhead(1).value === '=') {\n    const variable = this.parseIdentifier()\n    this.expect('=')\n    const pattern = this.parsePatternChain()\n    return {\n      type: 'NamedPath',\n      variable,\n      pattern,\n      loc: this.getLoc(start)\n    }\n  }\n  \n  return this.parsePatternChain()\n}\n```\n\n### Pattern Chain Parser\n```typescript\nparsePatternChain(): PatternChain {\n  const elements: PatternElement[] = []\n  \n  // First element must be a node\n  elements.push(this.parseNodePattern())\n  \n  // Continue with relationship-node pairs\n  while (this.isRelationshipStart()) {\n    elements.push(this.parseRelationshipPattern())\n    elements.push(this.parseNodePattern())\n  }\n  \n  return {\n    type: 'PatternChain',\n    elements,\n    loc: this.getLoc(start)\n  }\n}\n\nprivate isRelationshipStart(): boolean {\n  const token = this.peek()\n  return token.value === '-' || token.value === '\u003c'\n}\n```\n\n## Acceptance Criteria\n- [ ] All path pattern tests pass\n- [ ] Named paths work correctly\n- [ ] Pattern chains parse completely\n- [ ] Multiple patterns separated correctly\n\n## TDD Phase: GREEN\n## Depends On: neo4j-jcd9","status":"closed","priority":1,"issue_type":"task","created_at":"2026-01-05T06:41:37.992669-06:00","updated_at":"2026-01-05T07:19:48.958143-06:00","closed_at":"2026-01-05T07:19:48.958143-06:00","close_reason":"Parser implemented with MATCH, RETURN, node/relationship patterns, expressions - 34 parser tests pass"}
{"id":"neo4j-rmri","title":"REFACTOR: Improve slow consumer handling","description":"## Overview\nRefactor slow consumer handling for better resilience.\n\n## Refactoring Tasks\n\n### Code Quality\n- Extract rate limiter\n- Clean up detection logic\n- Add proper types\n- Document behavior\n\n### Adaptive Behavior\n- Self-tuning thresholds\n- Learn consumer patterns\n- Optimize for common cases\n- Predictive backpressure\n\n### Observability\n- Better metrics\n- Clear warnings\n- Performance dashboard\n- Troubleshooting guide\n\n## Acceptance Criteria\n- All tests still pass\n- Robust slow consumer handling\n- Good observability\n- Well-documented behavior","status":"open","priority":2,"issue_type":"task","created_at":"2026-01-05T06:46:49.678199-06:00","updated_at":"2026-01-05T06:46:49.678199-06:00"}
{"id":"neo4j-rzqk","title":"[REFACTOR] Property Storage - Optimize serialization and add validation","description":"## Overview\nRefactor property storage for better performance and robustness.\n\n## Refactoring Tasks\n\n### Performance Optimization\n```typescript\nclass PropertySerializer {\n  // Cache for frequently used property schemas\n  private schemaCache = new Map\u003cstring, PropertySchema\u003e();\n  \n  // Fast path for simple types\n  serializeFast(properties: Record\u003cstring, unknown\u003e): string {\n    if (this.isSimpleObject(properties)) {\n      return JSON.stringify(properties);\n    }\n    return this.serialize(properties);\n  }\n  \n  private isSimpleObject(obj: object): boolean {\n    return Object.values(obj).every(v =\u003e \n      typeof v === 'string' || \n      typeof v === 'number' || \n      typeof v === 'boolean' || \n      v === null\n    );\n  }\n}\n```\n\n### Schema Validation\n```typescript\ninterface PropertySchema {\n  [key: string]: {\n    type: 'string' | 'number' | 'boolean' | 'array' | 'object';\n    required?: boolean;\n    items?: PropertySchema; // for arrays\n    properties?: PropertySchema; // for objects\n  };\n}\n\nfunction validateProperties(\n  properties: object, \n  schema: PropertySchema\n): ValidationResult {\n  const errors: string[] = [];\n  // Validate against schema\n  return { valid: errors.length === 0, errors };\n}\n```\n\n### Compression for Large Properties\n```typescript\n// For properties larger than threshold, use compression\nconst COMPRESSION_THRESHOLD = 1024;\n\nfunction serializeWithCompression(properties: object): string {\n  const json = JSON.stringify(properties);\n  if (json.length \u003e COMPRESSION_THRESHOLD) {\n    // Use compression prefix marker\n    return 'GZIP:' + gzip(json);\n  }\n  return json;\n}\n```\n\n### Type Extensions\n```typescript\n// Support additional Neo4j types\ninterface Point {\n  srid: number;\n  x: number;\n  y: number;\n  z?: number;\n}\n\ninterface Duration {\n  months: number;\n  days: number;\n  seconds: number;\n  nanoseconds: number;\n}\n\n// Add temporal types\ninterface LocalDate { year: number; month: number; day: number; }\ninterface LocalTime { hour: number; minute: number; second: number; nanosecond: number; }\n```\n\n### Code Quality\n- Add comprehensive type definitions\n- Create property diff utilities\n- Add property merge strategies\n- Implement property change tracking\n\n## Acceptance Criteria\n- [ ] All tests still pass\n- [ ] Serialization is faster\n- [ ] Validation available\n- [ ] All Neo4j types supported\n- [ ] Code well-documented\n\n## TDD Phase\n**REFACTOR** - Improve without changing behavior","status":"open","priority":2,"issue_type":"task","created_at":"2026-01-05T06:40:21.501491-06:00","updated_at":"2026-01-05T06:40:21.501491-06:00"}
{"id":"neo4j-s00","title":"RED: HttpSession class methods fail without implementation","description":"## Test-Driven Development: RED Phase\n\n### Component\nHTTP Client SDK - HttpSession Class\n\n### Test Cases to Write (Expected to FAIL)\n\n```typescript\nimport { describe, it, expect, vi, beforeEach } from 'vitest'\nimport { HttpSession } from '../src/client/http-session'\nimport { Neo4jHttpDriver } from '../src/client/http-driver'\n\ndescribe('HttpSession - RED', () =\u003e {\n  let driver: Neo4jHttpDriver\n  let session: HttpSession\n\n  beforeEach(() =\u003e {\n    driver = new Neo4jHttpDriver('https://neo4j.do/db/mydb')\n    session = driver.session()\n  })\n\n  describe('run()', () =\u003e {\n    it('should execute query via POST /query', async () =\u003e {\n      const mockFetch = vi.fn().mockResolvedValue({\n        ok: true,\n        json: () =\u003e Promise.resolve({ records: [{ n: 1 }] })\n      })\n      driver = new Neo4jHttpDriver('https://neo4j.do/db/mydb', { fetch: mockFetch })\n      session = driver.session()\n      \n      const result = await session.run('RETURN 1 as n')\n      \n      expect(mockFetch).toHaveBeenCalledWith(\n        'https://neo4j.do/db/mydb/query',\n        expect.objectContaining({ method: 'POST' })\n      )\n      expect(result.records[0].get('n')).toBe(1)\n    })\n\n    it('should include parameters in request body', async () =\u003e {\n      const mockFetch = vi.fn().mockResolvedValue({\n        ok: true,\n        json: () =\u003e Promise.resolve({ records: [] })\n      })\n      driver = new Neo4jHttpDriver('https://neo4j.do/db/mydb', { fetch: mockFetch })\n      session = driver.session()\n      \n      await session.run('MATCH (n) WHERE n.id = $id RETURN n', { id: 123 })\n      \n      const body = JSON.parse(mockFetch.mock.calls[0][1].body)\n      expect(body.query).toBe('MATCH (n) WHERE n.id = $id RETURN n')\n      expect(body.parameters).toEqual({ id: 123 })\n    })\n  })\n\n  describe('executeRead()', () =\u003e {\n    it('should execute with read access mode', async () =\u003e {\n      const result = await session.executeRead(async tx =\u003e {\n        return tx.run('MATCH (n) RETURN n')\n      })\n      expect(result).toBeDefined()\n    })\n\n    it('should send read routing hint to server', async () =\u003e {\n      const mockFetch = vi.fn().mockResolvedValue({\n        ok: true,\n        json: () =\u003e Promise.resolve({ records: [] })\n      })\n      driver = new Neo4jHttpDriver('https://neo4j.do/db/mydb', { fetch: mockFetch })\n      session = driver.session()\n      \n      await session.executeRead(tx =\u003e tx.run('MATCH (n) RETURN n'))\n      \n      const body = JSON.parse(mockFetch.mock.calls[0][1].body)\n      expect(body.accessMode).toBe('READ')\n    })\n  })\n\n  describe('executeWrite()', () =\u003e {\n    it('should execute with write access mode', async () =\u003e {\n      const result = await session.executeWrite(async tx =\u003e {\n        return tx.run('CREATE (n:Test) RETURN n')\n      })\n      expect(result).toBeDefined()\n    })\n\n    it('should send write routing hint to server', async () =\u003e {\n      const mockFetch = vi.fn().mockResolvedValue({\n        ok: true,\n        json: () =\u003e Promise.resolve({ records: [] })\n      })\n      driver = new Neo4jHttpDriver('https://neo4j.do/db/mydb', { fetch: mockFetch })\n      session = driver.session()\n      \n      await session.executeWrite(tx =\u003e tx.run('CREATE (n) RETURN n'))\n      \n      const body = JSON.parse(mockFetch.mock.calls[0][1].body)\n      expect(body.accessMode).toBe('WRITE')\n    })\n  })\n\n  describe('beginTransaction()', () =\u003e {\n    it('should start transaction via POST /tx/begin', async () =\u003e {\n      const tx = await session.beginTransaction()\n      expect(tx).toBeInstanceOf(HttpTransaction)\n      expect(tx.id).toBeDefined()\n    })\n  })\n\n  describe('close()', () =\u003e {\n    it('should close session and release resources', async () =\u003e {\n      await session.close()\n      expect(session.isClosed).toBe(true)\n    })\n\n    it('should reject operations after close', async () =\u003e {\n      await session.close()\n      await expect(session.run('RETURN 1')).rejects.toThrow('Session is closed')\n    })\n  })\n})\n```\n\n### Acceptance Criteria\n- [ ] Test file created at `tests/client/http-session.test.ts`\n- [ ] All tests fail with expected errors\n- [ ] Tests cover: run, executeRead, executeWrite, beginTransaction, close\n\n### TDD Cycle\nThis is the RED phase. Next: GREEN phase implementation.","status":"open","priority":2,"issue_type":"task","created_at":"2026-01-05T06:35:34.603033-06:00","updated_at":"2026-01-05T06:35:34.603033-06:00"}
{"id":"neo4j-s0s9","title":"[RED] Parser: Schema Commands Tests (CREATE CONSTRAINT/INDEX)","description":"## Overview\nWrite failing tests for schema command parsing.\n\n## Test Cases to Write\n\n### CREATE CONSTRAINT\n```cypher\nCREATE CONSTRAINT FOR (n:Person) REQUIRE n.id IS UNIQUE\n\nCREATE CONSTRAINT FOR (n:Person) REQUIRE n.name IS NOT NULL\n\nCREATE CONSTRAINT FOR (n:Person) REQUIRE (n.firstName, n.lastName) IS NODE KEY\n\nCREATE CONSTRAINT person_id IF NOT EXISTS FOR (n:Person) REQUIRE n.id IS UNIQUE\n```\n\n### DROP CONSTRAINT\n```cypher\nDROP CONSTRAINT person_id\n\nDROP CONSTRAINT IF EXISTS person_id\n```\n\n### CREATE INDEX\n```cypher\nCREATE INDEX FOR (n:Person) ON (n.name)\n\nCREATE INDEX FOR (n:Person) ON (n.firstName, n.lastName)\n\nCREATE INDEX person_name IF NOT EXISTS FOR (n:Person) ON (n.name)\n\nCREATE INDEX FOR ()-[r:KNOWS]-() ON (r.since)\n```\n\n### CREATE FULLTEXT INDEX\n```cypher\nCREATE FULLTEXT INDEX FOR (n:Person) ON EACH [n.name, n.bio]\n```\n\n### DROP INDEX\n```cypher\nDROP INDEX person_name\n\nDROP INDEX IF EXISTS person_name\n```\n\n### SHOW Commands\n```cypher\nSHOW CONSTRAINTS\nSHOW INDEXES\n```\n\n## Acceptance Criteria\n- [ ] All schema command tests written and failing\n- [ ] All constraint types tested\n- [ ] All index types tested\n- [ ] IF EXISTS/IF NOT EXISTS tested\n\n## TDD Phase: RED","status":"open","priority":2,"issue_type":"task","created_at":"2026-01-05T06:51:24.257507-06:00","updated_at":"2026-01-05T06:51:24.257507-06:00"}
{"id":"neo4j-s0y9","title":"GREEN: Subquery Translation","description":"## Overview\nImplement subquery translation to make RED tests pass.\n\n## Implementation Tasks\n\n### 1. ExistsTranslator\n- translateExists(): SQL EXISTS subquery\n- correlateVariables(): Reference outer variables\n- handleNegation(): NOT EXISTS\n\n### 2. ComprehensionTranslator\n- translatePatternComprehension(): Correlated pattern query\n- translateListComprehension(): Filter and map\n- buildResultArray(): Collect results\n\n### 3. CallSubqueryTranslator\n- translateCallSubquery(): CTE or inline\n- handleImport(): Variable import from outer\n- handleUnion(): UNION in CALL\n\n### 4. Subquery Scope Manager\n- Track variable visibility\n- Handle correlation\n- Prevent invalid references\n\n## Files to Create/Modify\n- src/cypher/translator/exists-translator.ts\n- src/cypher/translator/comprehension-translator.ts\n- src/cypher/translator/call-subquery-translator.ts\n- src/cypher/translator/subquery-scope.ts\n\n## Acceptance Criteria\n- All RED phase tests pass\n- EXISTS works correctly\n- Comprehensions translate properly\n\n## TDD Phase\nGREEN - Make tests pass with minimal code\n\n## Dependencies\n- Depends on: RED: Subquery Translation","status":"open","priority":2,"issue_type":"task","created_at":"2026-01-05T06:43:37.155477-06:00","updated_at":"2026-01-05T06:43:37.155477-06:00"}
{"id":"neo4j-s5rb","title":"[RED] Transaction Support - Write failing tests for transaction handling","description":"## Overview\nWrite failing tests for transaction support before implementation.\n\n## Test Cases to Write\n\n### BEGIN Transaction Tests\n- `test_begin_returns_transaction_id`\n- `test_begin_creates_new_transaction`\n- `test_multiple_begins_different_ids`\n- `test_begin_read_transaction`\n- `test_begin_write_transaction`\n\n### COMMIT Transaction Tests\n- `test_commit_persists_changes`\n- `test_commit_returns_success`\n- `test_commit_invalid_tx_throws`\n- `test_commit_already_committed_throws`\n- `test_commit_releases_resources`\n\n### ROLLBACK Transaction Tests\n- `test_rollback_reverts_changes`\n- `test_rollback_returns_success`\n- `test_rollback_invalid_tx_throws`\n- `test_rollback_already_rolled_back_throws`\n- `test_rollback_releases_resources`\n\n### Transaction Isolation Tests\n- `test_uncommitted_changes_not_visible_outside`\n- `test_committed_changes_visible_outside`\n- `test_rollback_changes_not_visible`\n- `test_concurrent_transactions_isolated`\n- `test_read_transaction_sees_committed_data`\n\n### Read vs Write Transaction Tests\n- `test_write_in_read_tx_throws`\n- `test_read_in_write_tx_allowed`\n- `test_read_tx_can_run_concurrently`\n- `test_write_tx_exclusive_access`\n\n### Transaction Timeout Tests\n- `test_transaction_timeout_configurable`\n- `test_timed_out_transaction_auto_rollback`\n- `test_operations_on_timed_out_tx_throw`\n\n## Acceptance Criteria\n- [ ] All tests written and failing\n- [ ] Transaction lifecycle tested\n- [ ] Isolation levels tested\n- [ ] Timeout handling tested\n\n## TDD Phase\n**RED** - Write failing tests first","status":"closed","priority":1,"issue_type":"task","created_at":"2026-01-05T06:40:57.410853-06:00","updated_at":"2026-01-05T08:56:35.537676-06:00","closed_at":"2026-01-05T08:56:35.537676-06:00","close_reason":"Tests passing - storage and transactions implemented"}
{"id":"neo4j-s8z1","title":"[RED] AST: Pretty-Print Tests","description":"## Overview\nWrite failing tests for AST pretty-printing functionality.\n\n## Test Cases to Write\n\n### Simple Pretty-Print\n```typescript\n// Input AST for: MATCH (n) RETURN n\nconst ast = { type: 'Query', clauses: [...] }\nexpect(prettyPrint(ast)).toBe('MATCH (n) RETURN n')\n```\n\n### Formatted Output\n- Test indentation for nested structures\n- Test line breaks for long queries\n- Test alignment options\n\n### Round-Trip Tests\n```typescript\n// Parse -\u003e Pretty-Print -\u003e Parse should yield equivalent AST\nconst query = 'MATCH (n:Person)-[:KNOWS]-\u003e(m) WHERE n.age \u003e 21 RETURN n.name'\nconst ast1 = parse(query)\nconst printed = prettyPrint(ast1)\nconst ast2 = parse(printed)\nexpect(ast1).toEqual(ast2)\n```\n\n### Options\n```typescript\ninterface PrettyPrintOptions {\n  indent?: string       // default '  '\n  lineWidth?: number    // default 80\n  uppercase?: boolean   // keywords uppercase\n  minify?: boolean      // single line, minimal spaces\n}\n```\n\n## Acceptance Criteria\n- [ ] All pretty-print tests written\n- [ ] Round-trip tests for all node types\n- [ ] Format options tested\n- [ ] Edge cases covered\n\n## TDD Phase: RED","status":"closed","priority":1,"issue_type":"task","created_at":"2026-01-05T06:39:24.244006-06:00","updated_at":"2026-01-05T08:56:54.394746-06:00","closed_at":"2026-01-05T08:56:54.394746-06:00","close_reason":"Features implemented with tests"}
{"id":"neo4j-scgi","title":"[GREEN] Parser: Implement CALL and UNION Clauses","description":"## Overview\nImplement CALL (procedures) and UNION clause parsing.\n\n## Implementation Tasks\n\n### CALL Clause\n```typescript\nparseCallClause(): CallClause {\n  const start = this.pos\n  this.expect('CALL')\n  \n  // Parse procedure name (can be dotted: db.labels)\n  const procedureName = this.parseDottedIdentifier()\n  \n  // Parse arguments\n  this.expect('(')\n  const args: Expression[] = []\n  if (\\!this.check(')')) {\n    do {\n      args.push(this.expressionParser.parseExpression())\n    } while (this.match(','))\n  }\n  this.expect(')')\n  \n  // Parse YIELD\n  let yields: YieldItem[] | undefined\n  let where: Expression | undefined\n  \n  if (this.match('YIELD')) {\n    if (this.match('*')) {\n      yields = [{ type: 'YieldAll' }]\n    } else {\n      yields = []\n      do {\n        const name = this.parseIdentifier()\n        let alias: Identifier | undefined\n        if (this.match('AS')) {\n          alias = this.parseIdentifier()\n        }\n        yields.push({ name, alias })\n      } while (this.match(','))\n    }\n    \n    if (this.match('WHERE')) {\n      where = this.expressionParser.parseExpression()\n    }\n  }\n  \n  return {\n    type: 'CallClause',\n    procedureName,\n    args,\n    yields,\n    where,\n    loc: this.getLoc(start)\n  }\n}\n```\n\n### UNION Parser\n```typescript\nparseQuery(): Query | Union {\n  const query = this.parseSingleQuery()\n  \n  if (this.match('UNION')) {\n    const all = this.match('ALL')\n    const right = this.parseQuery()\n    \n    return {\n      type: 'Union',\n      left: query,\n      right,\n      all,\n      loc: this.getLoc(start)\n    }\n  }\n  \n  return query\n}\n```\n\n## Acceptance Criteria\n- [ ] All CALL tests pass\n- [ ] All UNION tests pass\n- [ ] YIELD clause works correctly\n- [ ] UNION ALL flag correct\n\n## TDD Phase: GREEN\n## Depends On: neo4j-vkdj","status":"closed","priority":1,"issue_type":"task","created_at":"2026-01-05T06:45:26.681154-06:00","updated_at":"2026-01-05T08:51:56.57815-06:00","closed_at":"2026-01-05T08:51:56.57815-06:00","close_reason":"CALL and UNION clauses implemented with tests"}
{"id":"neo4j-sgw","title":"RED: Record.get(index) - Write failing tests for getting value by position","description":"## Overview\nWrite failing tests for the Record.get(index) method that retrieves values by numeric position.\n\n## Test Cases to Write\n\n```typescript\ndescribe('Record.get(index)', () =\u003e {\n  it('should return value at valid index', () =\u003e {\n    const record = new Record(['name', 'age'], ['Alice', 30]);\n    expect(record.get(0)).toBe('Alice');\n    expect(record.get(1)).toBe(30);\n  });\n\n  it('should return undefined for out-of-bounds index', () =\u003e {\n    const record = new Record(['name'], ['Alice']);\n    expect(record.get(5)).toBeUndefined();\n    expect(record.get(-1)).toBeUndefined();\n  });\n\n  it('should handle index 0 correctly', () =\u003e {\n    const record = new Record(['first'], ['value']);\n    expect(record.get(0)).toBe('value');\n  });\n\n  it('should distinguish between string key and numeric index', () =\u003e {\n    const record = new Record(['0', 'name'], ['zero-key', 'Alice']);\n    expect(record.get('0')).toBe('zero-key');\n    expect(record.get(0)).toBe('zero-key'); // Same because '0' is at index 0\n  });\n});\n```\n\n## Acceptance Criteria\n- [ ] All tests written and failing (RED phase)\n- [ ] Tests cover index access edge cases\n- [ ] Tests handle boundary conditions\n- [ ] Test file updated at `src/result/__tests__/record-get-index.test.ts`\n\n## TDD Phase\nRED - Tests should fail because index-based get doesn't exist yet","status":"closed","priority":1,"issue_type":"task","created_at":"2026-01-05T06:35:13.549083-06:00","updated_at":"2026-01-05T07:46:37.197342-06:00","closed_at":"2026-01-05T07:46:37.197342-06:00","close_reason":"Completed in Ralph Wiggum session - 987 tests pass"}
{"id":"neo4j-skwn","title":"[GREEN] Parser: Implement Subquery Parsing","description":"## Overview\nImplement subquery parsing.\n\n## Implementation Tasks\n\n### EXISTS Subquery Parser\n```typescript\nparseExistsSubquery(): ExistsSubquery {\n  const start = this.pos\n  this.expect('EXISTS')\n  this.expect('{')\n  \n  const query = this.parseQuery()\n  \n  this.expect('}')\n  \n  return {\n    type: 'ExistsSubquery',\n    query,\n    loc: this.getLoc(start)\n  }\n}\n```\n\n### COUNT Subquery Parser\n```typescript\nparseCountSubquery(): CountSubquery {\n  const start = this.pos\n  this.expect('COUNT')\n  this.expect('{')\n  \n  const query = this.parseQuery()\n  \n  this.expect('}')\n  \n  return {\n    type: 'CountSubquery',\n    query,\n    loc: this.getLoc(start)\n  }\n}\n```\n\n### CALL Subquery Parser\n```typescript\nparseCallSubquery(): CallSubquery {\n  const start = this.pos\n  this.expect('CALL')\n  this.expect('{')\n  \n  const query = this.parseQuery()\n  \n  this.expect('}')\n  \n  // Check for IN TRANSACTIONS\n  let inTransactions: TransactionConfig | undefined\n  if (this.match('IN')) {\n    this.expect('TRANSACTIONS')\n    inTransactions = this.parseTransactionConfig()\n  }\n  \n  return {\n    type: 'CallSubquery',\n    query,\n    inTransactions,\n    loc: this.getLoc(start)\n  }\n}\n\nparseTransactionConfig(): TransactionConfig {\n  let batchSize: number | undefined\n  \n  if (this.match('OF')) {\n    batchSize = this.parseInteger()\n    this.expect('ROWS')\n  }\n  \n  return { batchSize }\n}\n```\n\n## Acceptance Criteria\n- [ ] All subquery tests pass\n- [ ] EXISTS subquery works\n- [ ] CALL subquery works\n- [ ] IN TRANSACTIONS works\n\n## TDD Phase: GREEN\n## Depends On: neo4j-oep3","status":"open","priority":2,"issue_type":"task","created_at":"2026-01-05T06:51:05.174823-06:00","updated_at":"2026-01-05T06:51:05.174823-06:00"}
{"id":"neo4j-snk","title":"[RED] Graph Types (Node, Relationship, Path) - Write Failing Tests","description":"## Overview\nWrite comprehensive failing tests for Neo4j Graph types before implementation.\n\n## TDD Phase: RED (Write Failing Tests)\n\n### Types to Test\n\n#### 1. Node\n```typescript\n// Properties\nnode.identity       // Integer - unique node ID\nnode.labels         // string[] - node labels\nnode.properties     // Record\u003cstring, any\u003e - node properties\nnode.elementId      // string - element ID (Neo4j 5.x)\n\n// Type guard\nneo4j.isNode(node)\n```\n\n#### 2. Relationship\n```typescript\n// Properties\nrel.identity        // Integer - unique relationship ID\nrel.type            // string - relationship type\nrel.properties      // Record\u003cstring, any\u003e - relationship properties\nrel.start           // Integer - start node ID\nrel.end             // Integer - end node ID\nrel.startNodeElementId  // string - start node element ID\nrel.endNodeElementId    // string - end node element ID\nrel.elementId       // string - element ID\n\n// Type guard\nneo4j.isRelationship(rel)\n```\n\n#### 3. Path\n```typescript\n// Properties\npath.start          // Node - start node\npath.end            // Node - end node\npath.segments       // PathSegment[] - path segments\npath.length         // number - number of relationships\n\n// Type guard\nneo4j.isPath(path)\n```\n\n#### 4. PathSegment\n```typescript\n// Properties\nsegment.start       // Node - start node of segment\nsegment.relationship // Relationship - the relationship\nsegment.end         // Node - end node of segment\n\n// Type guard\nneo4j.isPathSegment(segment)\n```\n\n### Test Categories\n\n#### Construction Tests\n- Create Node with labels and properties\n- Create Relationship with type and properties\n- Create Path from nodes and relationships\n- Create PathSegment\n\n#### Property Access Tests\n- All properties readable\n- Properties are the correct types\n- Integer IDs work correctly\n- Element IDs are strings\n\n#### Immutability Tests\n- Properties cannot be modified\n- Labels array cannot be modified\n- Attempting to modify throws/fails\n\n#### Serialization Tests\n- JSON.stringify works\n- Can reconstruct from JSON\n- Properties serialize correctly\n- Integer IDs serialize as expected\n\n#### Type Guards\n- `neo4j.isNode()` returns true for Node\n- `neo4j.isNode()` returns false for plain objects with same shape\n- Same for isRelationship, isPath, isPathSegment\n- Type guards narrow types correctly\n\n#### Edge Cases\n- Empty labels array\n- Empty properties object\n- Self-referential relationships (start === end)\n- Very long paths\n- Unicode in labels/types/properties\n- Null/undefined property values\n\n### Test File Structure\n```\nsrc/types/graph/\n  node.test.ts\n  relationship.test.ts\n  path.test.ts\n  path-segment.test.ts\n```\n\n### Acceptance Criteria\n- [ ] All tests written and failing (RED state)\n- [ ] Tests match neo4j-driver API exactly\n- [ ] All graph types covered\n- [ ] Edge cases documented\n\n### References\n- [neo4j-driver Graph Types](https://neo4j.com/docs/api/javascript-driver/current/)","status":"closed","priority":1,"issue_type":"task","created_at":"2026-01-05T06:38:54.963103-06:00","updated_at":"2026-01-05T08:58:13.60802-06:00","closed_at":"2026-01-05T08:58:13.60802-06:00","close_reason":"Implementation complete with tests"}
{"id":"neo4j-snp7","title":"RED: Result.records - Write failing tests for records array access","description":"## Overview\nWrite failing tests for the Result.records property that provides access to all Record objects.\n\n## Test Cases to Write\n\n```typescript\ndescribe('Result.records', () =\u003e {\n  it('should return array of Record objects', async () =\u003e {\n    const result = createMockResult([\n      { name: 'Alice', age: 30 },\n      { name: 'Bob', age: 25 }\n    ]);\n    \n    const records = await result.records;\n    expect(records).toHaveLength(2);\n    expect(records[0]).toBeInstanceOf(Record);\n    expect(records[0].get('name')).toBe('Alice');\n  });\n\n  it('should return empty array for no results', async () =\u003e {\n    const result = createMockResult([]);\n    const records = await result.records;\n    expect(records).toEqual([]);\n  });\n\n  it('should preserve record order', async () =\u003e {\n    const result = createMockResult([\n      { id: 1 },\n      { id: 2 },\n      { id: 3 }\n    ]);\n    \n    const records = await result.records;\n    expect(records.map(r =\u003e r.get('id'))).toEqual([1, 2, 3]);\n  });\n\n  it('should be consumable only once', async () =\u003e {\n    const result = createMockResult([{ name: 'Alice' }]);\n    \n    const records1 = await result.records;\n    expect(records1).toHaveLength(1);\n    \n    // Second access should work (buffered)\n    const records2 = await result.records;\n    expect(records2).toHaveLength(1);\n  });\n});\n```\n\n## Acceptance Criteria\n- [ ] All tests written and failing (RED phase)\n- [ ] Tests cover record array access patterns\n- [ ] Tests verify Record object types\n- [ ] Test file created at src/result/__tests__/result-records.test.ts\n\n## TDD Phase\nRED - Tests should fail because Result class does not exist yet","status":"closed","priority":1,"issue_type":"task","created_at":"2026-01-05T06:41:47.660698-06:00","updated_at":"2026-01-05T08:52:47.257404-06:00","closed_at":"2026-01-05T08:52:47.257404-06:00","close_reason":"Already implemented with tests passing"}
{"id":"neo4j-snw","title":"GREEN: Implement rxTx.run() method","description":"## Overview\nImplement rxTx.run() to make all RED tests pass.\n\n## Implementation Requirements\n\n### Method Signature\n```typescript\ninterface RxTransaction {\n  run(cypher: string, params?: Record\u003cstring, any\u003e): RxResult\n}\n```\n\n### Implementation Details\n- Execute query within transaction context\n- Create RxResult for query results\n- Handle parameter serialization\n- Ensure transaction isolation\n- Support query cancellation\n\n### Observable Semantics\n- Cold observable for lazy execution\n- Proper error propagation\n- Unsubscription handling\n\n## Acceptance Criteria\n- All RED tests now pass (GREEN phase)\n- Query runs in transaction context\n- Returns proper RxResult\n- Parameters handled correctly","status":"open","priority":2,"issue_type":"task","created_at":"2026-01-05T06:38:44.820376-06:00","updated_at":"2026-01-05T06:38:44.820376-06:00"}
{"id":"neo4j-srl9","title":"GREEN: UPDATE Translation (SET/REMOVE)","description":"## Overview\nImplement SET and REMOVE clause translation to make RED tests pass.\n\n## Implementation Tasks\n\n### 1. SetClauseTranslator\n- translateSetProperty(): json_set for single property\n- translateSetMultiple(): Chain json_set calls\n- translateSetReplace(): Full property replacement\n- translateSetMerge(): json_patch for += operation\n\n### 2. RemoveClauseTranslator\n- translateRemoveProperty(): json_remove\n- translateRemoveLabel(): Array manipulation on labels\n\n### 3. Expression Evaluator for SET\n- Handle computed expressions (n.age + 1)\n- Resolve property references\n\n### 4. Label Array Manipulation\n- Add label: json_insert\n- Remove label: Array filter\n\n## Files to Create/Modify\n- src/cypher/translator/set-clause-translator.ts\n- src/cypher/translator/remove-clause-translator.ts\n- src/cypher/translator/json-operations.ts\n\n## Acceptance Criteria\n- All RED phase tests pass\n- JSON functions used correctly\n- Labels as arrays handled\n\n## TDD Phase\nGREEN - Make tests pass with minimal code\n\n## Dependencies\n- Depends on: RED: UPDATE Translation (SET/REMOVE)","status":"closed","priority":1,"issue_type":"task","created_at":"2026-01-05T06:39:28.106412-06:00","updated_at":"2026-01-05T08:55:39.254573-06:00","closed_at":"2026-01-05T08:55:39.254573-06:00","close_reason":"Translation already implemented with tests"}
{"id":"neo4j-ssc0","title":"GREEN: Implement Observable error propagation","description":"## Overview\nImplement proper error propagation to make all RED tests pass.\n\n## Implementation Requirements\n\n### Error Emission\n- Emit errors to subscriber\n- Terminate Observable on error\n- Include appropriate error info\n- Use correct error types\n\n### Error Types\n- Map database errors to Neo4jError\n- Preserve error classification\n- Include error codes\n- Maintain stack traces\n\n### Propagation\n- Errors flow through operators\n- Support catchError interception\n- Clean up on error path\n- Notify error handler\n\n## Acceptance Criteria\n- All RED tests now pass (GREEN phase)\n- Errors properly emitted\n- Error types correct\n- Propagation works through chains","status":"open","priority":2,"issue_type":"task","created_at":"2026-01-05T06:43:26.159733-06:00","updated_at":"2026-01-05T06:43:26.159733-06:00"}
{"id":"neo4j-t866","title":"[RED] Parser: Node Pattern Tests","description":"## Overview\nWrite failing tests for node pattern parsing.\n\n## Test Cases to Write\n\n### Basic Node Patterns\n- Empty node: `()`\n- Variable only: `(n)`\n- Label only: `(:Person)`\n- Variable and label: `(n:Person)`\n- Multiple labels: `(n:Person:Employee)`\n\n### Node Patterns with Properties\n- Map properties: `(n {name: 'John'})`\n- Multiple properties: `(n {name: 'John', age: 30})`\n- Variable + label + properties: `(n:Person {name: 'John'})`\n- Parameter properties: `(n:Person $props)`\n\n### Complex Property Values\n- String values: `(n {name: 'John'})`\n- Numeric values: `(n {age: 30})`\n- Boolean values: `(n {active: true})`\n- Null values: `(n {data: null})`\n- List values: `(n {tags: ['a', 'b']})`\n- Nested maps: `(n {address: {city: 'NYC'}})`\n\n### Edge Cases\n- Whitespace variations: `( n : Person )`\n- Backtick-quoted labels: `(n:\\`My Label\\`)`\n- Backtick-quoted variable: `(\\`my var\\`:Person)`\n\n## Acceptance Criteria\n- [ ] All node pattern tests written and failing\n- [ ] Tests cover all syntax variations\n- [ ] Error cases tested (malformed patterns)\n- [ ] File: `src/parser/__tests__/patterns.test.ts`\n\n## TDD Phase: RED","status":"closed","priority":1,"issue_type":"task","created_at":"2026-01-05T06:40:02.50345-06:00","updated_at":"2026-01-05T07:19:48.95702-06:00","closed_at":"2026-01-05T07:19:48.95702-06:00","close_reason":"Parser implemented with MATCH, RETURN, node/relationship patterns, expressions - 34 parser tests pass"}
{"id":"neo4j-thlw","title":"GREEN: Implement marble testing support","description":"## Overview\nImplement marble testing support to make all RED tests pass.\n\n## Implementation Requirements\n\n### Marble Compatibility\n- Observables work with expectObservable()\n- Support cold() helper\n- Support hot() helper\n- Match marble diagrams\n\n### Implementation Details\n- Use proper Observable creation\n- Support virtual time\n- Enable marble assertions\n- Handle timing correctly\n\n### Integration\n- Works with TestScheduler\n- Supports standard marble syntax\n- Proper subscription points\n- Accurate timing\n\n## Acceptance Criteria\n- All RED tests now pass (GREEN phase)\n- Marble testing works\n- Standard syntax supported\n- Timing accurate","status":"open","priority":2,"issue_type":"task","created_at":"2026-01-05T06:49:52.198377-06:00","updated_at":"2026-01-05T06:49:52.198377-06:00"}
{"id":"neo4j-tjkd","title":"RED: Write failing tests for Observable completion signaling","description":"## Overview\nWrite failing tests for proper Observable completion signaling.\n\n## Test Cases to Write\n\n### Basic Completion Tests\n- Observable completes after all emissions\n- Complete callback invoked\n- No emissions after complete\n- Completion propagates through chain\n\n### Different Observable Types\n- keys() completes after single emission\n- records() completes after last record\n- consume() completes after summary\n- close() completes after cleanup\n\n### Completion Timing\n- Completion after all records emitted\n- Completion before teardown\n- Completion order in chains\n- Completion with empty results\n\n### Completion with Operators\n- take() triggers early complete\n- takeUntil() triggers complete\n- first() triggers complete\n- Completion through flatMap()\n\n## Acceptance Criteria\n- All tests written and failing (RED phase)\n- Tests cover all Observable types\n- Tests verify completion timing\n- Tests verify operator interaction","status":"open","priority":2,"issue_type":"task","created_at":"2026-01-05T06:43:52.080901-06:00","updated_at":"2026-01-05T06:43:52.080901-06:00"}
{"id":"neo4j-tllx","title":"REFACTOR: Optimize RxJS integration patterns","description":"## Overview\nRefactor for optimal RxJS integration and patterns.\n\n## Refactoring Tasks\n\n### Code Quality\n- Document recommended patterns\n- Add TypeScript generics properly\n- Create utility operators if needed\n- Add examples for common patterns\n\n### Performance\n- Optimize Observable creation\n- Minimize operator overhead\n- Consider custom operators for common patterns\n\n### Developer Experience\n- Clear error messages in operator chains\n- Good type inference\n- IDE autocomplete support\n- Documentation for patterns\n\n## Acceptance Criteria\n- All tests still pass\n- Clear recommended patterns\n- Good TypeScript support\n- Well-documented integration","status":"open","priority":2,"issue_type":"task","created_at":"2026-01-05T06:42:29.746982-06:00","updated_at":"2026-01-05T06:42:29.746982-06:00"}
{"id":"neo4j-tqng","title":"[GREEN] Parser: Implement SET and REMOVE Clauses","description":"## Overview\nImplement SET and REMOVE clause parsing.\n\n## Implementation Tasks\n\n### SET Clause\n```typescript\nparseSetClause(): SetClause {\n  const start = this.pos\n  this.expect('SET')\n  \n  const items = this.parseSetItems()\n  \n  return {\n    type: 'SetClause',\n    items,\n    loc: this.getLoc(start)\n  }\n}\n\nparseSetItems(): SetItem[] {\n  const items: SetItem[] = []\n  do {\n    items.push(this.parseSetItem())\n  } while (this.match(','))\n  return items\n}\n\nparseSetItem(): SetItem {\n  const target = this.expressionParser.parseExpression()\n  \n  // Check for label set: n:Label\n  if (target.type === 'Identifier' \u0026\u0026 this.peek().value === ':') {\n    const labels = this.parseLabels()\n    return { type: 'SetLabels', variable: target, labels }\n  }\n  \n  // Property set\n  if (this.match('=')) {\n    const value = this.expressionParser.parseExpression()\n    return { type: 'SetProperty', target, value, operator: '=' }\n  }\n  \n  if (this.match('+=')) {\n    const value = this.expressionParser.parseExpression()\n    return { type: 'SetProperty', target, value, operator: '+=' }\n  }\n  \n  this.error('Expected = or += in SET clause')\n}\n```\n\n### REMOVE Clause\n```typescript\nparseRemoveClause(): RemoveClause {\n  const start = this.pos\n  this.expect('REMOVE')\n  \n  const items = this.parseRemoveItems()\n  \n  return {\n    type: 'RemoveClause',\n    items,\n    loc: this.getLoc(start)\n  }\n}\n\nparseRemoveItem(): RemoveItem {\n  const target = this.expressionParser.parseExpression()\n  \n  // Check for label removal: n:Label\n  if (target.type === 'Identifier' \u0026\u0026 this.peek().value === ':') {\n    const labels = this.parseLabels()\n    return { type: 'RemoveLabels', variable: target, labels }\n  }\n  \n  // Property removal\n  return { type: 'RemoveProperty', property: target }\n}\n```\n\n## Acceptance Criteria\n- [ ] All SET tests pass\n- [ ] All REMOVE tests pass\n- [ ] Label set/remove works\n- [ ] += operator works\n\n## TDD Phase: GREEN\n## Depends On: neo4j-afgx","status":"closed","priority":1,"issue_type":"task","created_at":"2026-01-05T06:44:13.697181-06:00","updated_at":"2026-01-05T08:46:40.403901-06:00","closed_at":"2026-01-05T08:46:40.403901-06:00","close_reason":"Tests passing - implementation complete"}
{"id":"neo4j-treu","title":"[RED] Parser: CASE Expression Tests","description":"## Overview\nWrite failing tests for CASE expression parsing.\n\n## Test Cases to Write\n\n### Simple CASE\n```cypher\nCASE n.type\n  WHEN 'A' THEN 1\n  WHEN 'B' THEN 2\n  ELSE 0\nEND\n```\n\n### Generic CASE\n```cypher\nCASE\n  WHEN n.age \u003c 18 THEN 'minor'\n  WHEN n.age \u003c 65 THEN 'adult'\n  ELSE 'senior'\nEND\n```\n\n### CASE without ELSE\n```cypher\nCASE n.status\n  WHEN 'active' THEN true\n  WHEN 'pending' THEN false\nEND\n```\n\n### Nested CASE\n```cypher\nCASE\n  WHEN n.type = 'A' THEN\n    CASE n.status\n      WHEN 'x' THEN 1\n      ELSE 2\n    END\n  ELSE 0\nEND\n```\n\n### CASE in Expressions\n- In RETURN: `RETURN CASE ... END AS result`\n- In WHERE: `WHERE CASE ... END = 'value'`\n- In properties: `{status: CASE ... END}`\n\n### Multiple WHEN Clauses\n- Many WHENs\n- Complex conditions\n\n## Acceptance Criteria\n- [ ] All CASE tests written and failing\n- [ ] Simple and generic forms tested\n- [ ] ELSE optional tested\n- [ ] Nested CASE tested\n\n## TDD Phase: RED","status":"open","priority":2,"issue_type":"task","created_at":"2026-01-05T06:48:11.205917-06:00","updated_at":"2026-01-05T06:48:11.205917-06:00"}
{"id":"neo4j-ttx","title":"GREEN: Record.get(index) - Implement get value by position","description":"## Overview\nImplement the Record.get(index) method to support numeric index access.\n\n## Implementation\n\n```typescript\nget(keyOrIndex: string | number): any {\n  if (typeof keyOrIndex === 'number') {\n    if (keyOrIndex \u003c 0 || keyOrIndex \u003e= this._values.length) {\n      return undefined;\n    }\n    return this._values[keyOrIndex];\n  }\n  \n  const index = this._fieldLookup.get(keyOrIndex);\n  if (index === undefined) {\n    return undefined;\n  }\n  return this._values[index];\n}\n```\n\n## Acceptance Criteria\n- [ ] All RED phase tests now pass (GREEN phase)\n- [ ] Both string key and numeric index work\n- [ ] Boundary conditions handled correctly\n- [ ] Previous tests still pass\n\n## TDD Phase\nGREEN - Minimal implementation to pass tests\n\n## Dependencies\n- neo4j-sgw (RED phase tests)","status":"closed","priority":1,"issue_type":"task","created_at":"2026-01-05T06:35:27.644722-06:00","updated_at":"2026-01-05T08:46:57.518926-06:00","closed_at":"2026-01-05T08:46:57.518926-06:00","close_reason":"Tests passing - implementation complete"}
{"id":"neo4j-u43","title":"[RED] AST: Define Core Node Type Interfaces","description":"## Overview\nWrite failing tests for AST node type definitions.\n\n## Test Cases to Write\n\n### Base Node Types\n```typescript\ninterface ASTNode {\n  type: string\n  loc: SourceLocation\n}\n\ninterface SourceLocation {\n  start: Position\n  end: Position\n}\n\ninterface Position {\n  line: number\n  column: number\n  offset: number\n}\n```\n\n### Query Nodes\n- Test Query node structure (clauses array)\n- Test Union node (left, right, all flag)\n\n### Clause Nodes\n- Test MatchClause (pattern, where, optional)\n- Test ReturnClause (items, distinct, orderBy, skip, limit)\n- Test WithClause (items, where, distinct, orderBy, skip, limit)\n- Test CreateClause (pattern)\n- Test MergeClause (pattern, onMatch, onCreate)\n- Test DeleteClause (expressions, detach)\n- Test SetClause (items)\n- Test RemoveClause (items)\n- Test UnwindClause (expression, alias)\n\n### Type Guards\n- Test isMatchClause(node)\n- Test isExpression(node)\n- Test isPattern(node)\n\n## Acceptance Criteria\n- [ ] All interface tests written\n- [ ] Tests verify required properties\n- [ ] Tests verify type discriminators\n- [ ] File: `src/parser/__tests__/ast-types.test.ts`\n\n## TDD Phase: RED","status":"closed","priority":1,"issue_type":"task","created_at":"2026-01-05T06:37:21.170007-06:00","updated_at":"2026-01-05T08:58:01.757043-06:00","closed_at":"2026-01-05T08:58:01.757043-06:00","close_reason":"AST, lexer and types tests passing"}
{"id":"neo4j-u538","title":"[GREEN] Parser: Implement Relationship Pattern Parsing","description":"## Overview\nImplement relationship pattern parsing to pass all tests.\n\n## Implementation Tasks\n\n### Relationship Parser\n```typescript\nparseRelationshipPattern(): RelationshipPattern {\n  const start = this.pos\n  \n  // Determine left direction\n  const leftArrow = this.match('\u003c')\n  this.expect('-')\n  \n  // Parse relationship details [r:TYPE*min..max {props}]\n  let variable: Identifier | undefined\n  const types: string[] = []\n  let length: RelationshipLength | undefined\n  let properties: MapLiteral | Parameter | undefined\n  \n  if (this.match('[')) {\n    // Variable\n    if (this.isIdentifier()) {\n      variable = this.parseIdentifier()\n    }\n    \n    // Types\n    if (this.match(':')) {\n      types.push(this.parseRelType())\n      while (this.match('|')) {\n        types.push(this.parseRelType())\n      }\n    }\n    \n    // Length\n    if (this.match('*')) {\n      length = this.parseRelationshipLength()\n    }\n    \n    // Properties\n    if (this.peek().value === '{') {\n      properties = this.parseMapLiteral()\n    }\n    \n    this.expect(']')\n  }\n  \n  this.expect('-')\n  const rightArrow = this.match('\u003e')\n  \n  return {\n    type: 'RelationshipPattern',\n    variable,\n    types,\n    length,\n    properties,\n    direction: this.determineDirection(leftArrow, rightArrow),\n    loc: this.getLoc(start)\n  }\n}\n```\n\n### Length Parser\n```typescript\nparseRelationshipLength(): RelationshipLength {\n  let min: number | undefined\n  let max: number | undefined\n  \n  if (this.isNumber()) {\n    min = this.parseNumber()\n    if (this.match('..')) {\n      max = this.isNumber() ? this.parseNumber() : undefined\n    } else {\n      max = min // exact length\n    }\n  } else if (this.match('..')) {\n    max = this.isNumber() ? this.parseNumber() : undefined\n  }\n  \n  return { min, max }\n}\n```\n\n## Acceptance Criteria\n- [ ] All relationship pattern tests pass\n- [ ] Directions correctly determined\n- [ ] Variable-length ranges correct\n- [ ] Edge cases handled\n\n## TDD Phase: GREEN\n## Depends On: neo4j-q4z5","status":"closed","priority":1,"issue_type":"task","created_at":"2026-01-05T06:40:56.620154-06:00","updated_at":"2026-01-05T07:19:48.957383-06:00","closed_at":"2026-01-05T07:19:48.957383-06:00","close_reason":"Parser implemented with MATCH, RETURN, node/relationship patterns, expressions - 34 parser tests pass"}
{"id":"neo4j-u5ql","title":"GREEN: Implement rxTx.rollback() method","description":"## Overview\nImplement rxTx.rollback() to make all RED tests pass.\n\n## Implementation Requirements\n\n### Method Signature\n```typescript\ninterface RxTransaction {\n  rollback(): Observable\u003cvoid\u003e\n}\n```\n\n### Implementation Details\n- Create Observable for rollback process\n- Send ROLLBACK to database\n- Do NOT update bookmarks\n- Mark transaction as closed\n- Handle rollback errors\n\n### Observable Semantics\n- Cold observable (lazy rollback)\n- Complete on success\n- Error on failure\n- Prevent double rollback\n\n## Acceptance Criteria\n- All RED tests now pass (GREEN phase)\n- Changes properly discarded\n- Bookmarks unchanged\n- Transaction state managed","status":"open","priority":2,"issue_type":"task","created_at":"2026-01-05T06:39:46.502391-06:00","updated_at":"2026-01-05T06:39:46.502391-06:00"}
{"id":"neo4j-u6jj","title":"[GREEN] Parser: Implement DELETE and UNWIND Clauses","description":"## Overview\nImplement DELETE and UNWIND clause parsing.\n\n## Implementation Tasks\n\n### DELETE Clause\n```typescript\nparseDeleteClause(): DeleteClause {\n  const start = this.pos\n  const detach = this.match('DETACH')\n  \n  this.expect('DELETE')\n  \n  const expressions: Expression[] = []\n  do {\n    expressions.push(this.expressionParser.parseExpression())\n  } while (this.match(','))\n  \n  return {\n    type: 'DeleteClause',\n    detach,\n    expressions,\n    loc: this.getLoc(start)\n  }\n}\n```\n\n### UNWIND Clause\n```typescript\nparseUnwindClause(): UnwindClause {\n  const start = this.pos\n  this.expect('UNWIND')\n  \n  const expression = this.expressionParser.parseExpression()\n  \n  this.expect('AS')\n  \n  const variable = this.parseIdentifier()\n  \n  return {\n    type: 'UnwindClause',\n    expression,\n    variable,\n    loc: this.getLoc(start)\n  }\n}\n```\n\n### AST Types\n```typescript\ninterface DeleteClause extends ASTNode {\n  type: 'DeleteClause'\n  detach: boolean\n  expressions: Expression[]\n}\n\ninterface UnwindClause extends ASTNode {\n  type: 'UnwindClause'\n  expression: Expression\n  variable: Identifier\n}\n```\n\n## Acceptance Criteria\n- [ ] All DELETE tests pass\n- [ ] All UNWIND tests pass\n- [ ] DETACH flag works correctly\n- [ ] AS alias required for UNWIND\n\n## TDD Phase: GREEN\n## Depends On: neo4j-l6fq","status":"closed","priority":1,"issue_type":"task","created_at":"2026-01-05T06:44:48.279559-06:00","updated_at":"2026-01-05T08:46:40.404651-06:00","closed_at":"2026-01-05T08:46:40.404651-06:00","close_reason":"Tests passing - implementation complete"}
{"id":"neo4j-uaaq","title":"GREEN: Implement proper RxJS operators integration","description":"## Overview\nEnsure RxJS operators work correctly with reactive API.\n\n## Implementation Requirements\n\n### Observable Compatibility\n- Return proper Observable instances\n- Support pipe() operator\n- Work with all standard operators\n- Proper type inference\n\n### Specific Operator Support\n- Transformation operators\n- Filtering operators\n- Combination operators\n- Error handling operators\n\n### Implementation Details\n- Use proper RxJS Observable creation\n- Support operator chaining\n- Ensure type safety through chain\n- Handle async operations correctly\n\n## Acceptance Criteria\n- All RED tests now pass (GREEN phase)\n- All listed operators work correctly\n- Type inference works\n- No unexpected behaviors","status":"open","priority":2,"issue_type":"task","created_at":"2026-01-05T06:42:23.315772-06:00","updated_at":"2026-01-05T06:42:23.315772-06:00"}
{"id":"neo4j-uamj","title":"RED: Result.keys - Write failing tests for column names Promise","description":"## Overview\nWrite failing tests for the Result.keys property that returns Promise of column names.\n\n## Test Cases to Write\n\n```typescript\ndescribe('Result.keys', () =\u003e {\n  it('should return Promise of column names', async () =\u003e {\n    const result = createMockResult([{ name: 'Alice', age: 30 }]);\n    \n    const keys = await result.keys;\n    expect(keys).toEqual(['name', 'age']);\n  });\n\n  it('should be available before consuming records', async () =\u003e {\n    const result = createMockResult([{ name: 'Alice' }]);\n    \n    // Keys should be available immediately\n    const keys = await result.keys;\n    expect(keys).toEqual(['name']);\n    \n    // Records still available\n    const records = await result.records;\n    expect(records).toHaveLength(1);\n  });\n\n  it('should return empty array for no results', async () =\u003e {\n    const result = createMockResultWithKeys([], ['name', 'age']);\n    \n    const keys = await result.keys;\n    expect(keys).toEqual(['name', 'age']);\n  });\n\n  it('should return consistent keys across records', async () =\u003e {\n    const result = createMockResult([\n      { name: 'Alice', age: 30 },\n      { name: 'Bob', age: 25 }\n    ]);\n    \n    const keys = await result.keys;\n    expect(keys).toEqual(['name', 'age']);\n  });\n});\n```\n\n## Acceptance Criteria\n- [ ] All tests written and failing (RED phase)\n- [ ] Tests verify early key availability\n- [ ] Tests verify key consistency\n- [ ] Test file created at src/result/__tests__/result-keys.test.ts\n\n## TDD Phase\nRED - Tests should fail because Result.keys does not exist yet","status":"closed","priority":1,"issue_type":"task","created_at":"2026-01-05T06:43:09.526033-06:00","updated_at":"2026-01-05T08:52:47.255043-06:00","closed_at":"2026-01-05T08:52:47.255043-06:00","close_reason":"Already implemented with tests passing"}
{"id":"neo4j-ucp","title":"[RED] AST: Expression Node Types Tests","description":"## Overview\nWrite failing tests for expression AST node types.\n\n## Test Cases to Write\n\n### Literal Expressions\n```typescript\ninterface StringLiteral { type: 'StringLiteral', value: string }\ninterface IntegerLiteral { type: 'IntegerLiteral', value: number }\ninterface FloatLiteral { type: 'FloatLiteral', value: number }\ninterface BooleanLiteral { type: 'BooleanLiteral', value: boolean }\ninterface NullLiteral { type: 'NullLiteral' }\ninterface ListLiteral { type: 'ListLiteral', elements: Expression[] }\ninterface MapLiteral { type: 'MapLiteral', entries: MapEntry[] }\n```\n\n### Identifier Expressions\n```typescript\ninterface Identifier { type: 'Identifier', name: string }\ninterface Parameter { type: 'Parameter', name: string }\n```\n\n### Property Access\n```typescript\ninterface PropertyAccess { type: 'PropertyAccess', object: Expression, property: string }\ninterface DynamicPropertyAccess { type: 'DynamicPropertyAccess', object: Expression, property: Expression }\n```\n\n### Operators\n```typescript\ninterface BinaryExpression { type: 'BinaryExpression', operator: BinaryOperator, left: Expression, right: Expression }\ninterface UnaryExpression { type: 'UnaryExpression', operator: UnaryOperator, argument: Expression }\n```\n\n### Function Calls\n```typescript\ninterface FunctionCall { type: 'FunctionCall', name: string, args: Expression[], distinct?: boolean }\n```\n\n## Acceptance Criteria\n- [ ] All expression type tests written\n- [ ] Tests verify required properties\n- [ ] Tests verify discriminator values\n- [ ] Complete expression type coverage\n\n## TDD Phase: RED","status":"closed","priority":1,"issue_type":"task","created_at":"2026-01-05T06:37:49.066724-06:00","updated_at":"2026-01-05T08:58:01.756078-06:00","closed_at":"2026-01-05T08:58:01.756078-06:00","close_reason":"AST, lexer and types tests passing"}
{"id":"neo4j-uqj1","title":"RED: Write failing tests for slow consumer handling","description":"## Overview\nWrite failing tests for graceful handling of slow consumers.\n\n## Test Cases to Write\n\n### Slow Consumer Detection\n- Detect when consumer falls behind\n- Measure consumer processing rate\n- Track backpressure metrics\n- Identify bottleneck\n\n### Graceful Degradation\n- Continue functioning with slow consumer\n- Don't crash or OOM\n- Apply backpressure to source\n- Configurable behavior\n\n### Consumer Rate Scenarios\n- Consumer slower than producer\n- Bursty consumer patterns\n- Consumer temporarily blocked\n- Consumer varies in speed\n\n### Warning/Metrics\n- Log slow consumer warnings\n- Expose backpressure metrics\n- Track buffer fill rate\n- Alert thresholds\n\n## Acceptance Criteria\n- All tests written and failing (RED phase)\n- Tests verify slow consumer handling\n- Tests verify graceful degradation\n- Tests verify metrics","status":"open","priority":2,"issue_type":"task","created_at":"2026-01-05T06:46:35.77873-06:00","updated_at":"2026-01-05T06:46:35.77873-06:00"}
{"id":"neo4j-uqtq","title":"REFACTOR: RETURN/WITH Clause Translation","description":"## Overview\nRefactor RETURN/WITH translation for clarity and optimization.\n\n## Refactoring Tasks\n\n### 1. Projection Builder\n- Clean column selection API\n- Alias management\n- Expression translation\n\n### 2. Order/Limit Handler\n- Unified ORDER BY handling\n- LIMIT/OFFSET optimization\n- NULL ordering control\n\n### 3. Pipeline Stage Pattern\n- WITH as pipeline stage\n- Clean data flow between stages\n- Variable scope management\n\n### 4. Aggregation Analyzer\n- Detect aggregate functions\n- Infer GROUP BY automatically\n- HAVING vs WHERE distinction\n\n## Quality Improvements\n- Clean projection API\n- Consistent alias handling\n- Optimized LIMIT queries\n- Type-safe column expressions\n\n## Acceptance Criteria\n- All tests still pass\n- Code is more readable\n- Performance maintained\n\n## TDD Phase\nREFACTOR - Improve code quality while keeping tests green\n\n## Dependencies\n- Depends on: GREEN: RETURN/WITH Clause Translation","status":"closed","priority":1,"issue_type":"task","created_at":"2026-01-05T06:41:16.805345-06:00","updated_at":"2026-01-05T08:55:39.252004-06:00","closed_at":"2026-01-05T08:55:39.252004-06:00","close_reason":"Translation already implemented with tests"}
{"id":"neo4j-urs5","title":"RED: Streaming support fails without implementation","description":"## Test-Driven Development: RED Phase\n\n### Component\nHTTP Client SDK - Streaming Support\n\n### Test Cases to Write (Expected to FAIL)\n\nTests for:\n- Server-Sent Events (SSE) for large results\n- Chunked response handling\n- Progress callbacks during streaming\n- Stream cancellation\n- Back-pressure handling\n\n### Test Examples\n- Should stream results via SSE\n- Should parse chunked responses\n- Should call progress callback with percentage\n- Should cancel stream on abort signal\n- Should handle slow consumers\n\n### Acceptance Criteria\n- Test file created at tests/client/streaming.test.ts\n- All tests fail with expected errors\n- Tests cover SSE, chunked responses, progress, cancellation\n\n### TDD Cycle\nThis is the RED phase. Next: GREEN phase implementation.","status":"open","priority":2,"issue_type":"task","created_at":"2026-01-05T06:47:57.908787-06:00","updated_at":"2026-01-05T06:47:57.908787-06:00"}
{"id":"neo4j-uv6b","title":"[REFACTOR] Types Module - Final Polish and Documentation","description":"## Overview\nFinal refactoring pass on the complete types module.\n\n## TDD Phase: REFACTOR (Final Polish)\n\n### Refactoring Goals\n\n#### API Consistency\n- [ ] Ensure all type guards have consistent behavior\n- [ ] Verify all factories have consistent signatures\n- [ ] Check all toString() methods have consistent format\n\n#### Documentation\n- [ ] Complete JSDoc for all exports\n- [ ] Type documentation with @example tags\n- [ ] Usage examples in comments\n\n#### Bundle Optimization\n- [ ] Tree-shaking verification\n- [ ] Ensure unused types can be excluded\n- [ ] Check bundle size per type\n\n#### Cross-Type Integration\n- [ ] Ensure Integer works with all numeric contexts\n- [ ] Test temporal types with properties\n- [ ] Test Point in properties\n- [ ] Test Vector in properties\n\n#### Error Handling\n- [ ] Consistent error types across module\n- [ ] Helpful error messages\n- [ ] Type validation errors\n\n#### Additional Tests\n- [ ] Full integration tests\n- [ ] Bundle size tests\n- [ ] Tree-shaking tests\n- [ ] ESM/CJS compatibility tests\n\n### Acceptance Criteria\n- [ ] All tests passing\n- [ ] 100% test coverage across types module\n- [ ] API fully documented\n- [ ] Bundle size documented\n- [ ] No any types in public API\n\n### Dependencies\n- Depends on: [GREEN] Types Module Export \u0026 API Surface - Implement Exports\n- Depends on: All REFACTOR issues","status":"closed","priority":1,"issue_type":"task","created_at":"2026-01-05T06:40:33.119768-06:00","updated_at":"2026-01-05T08:55:59.061422-06:00","closed_at":"2026-01-05T08:55:59.061422-06:00","close_reason":"Types implemented with tests","dependencies":[{"issue_id":"neo4j-uv6b","depends_on_id":"neo4j-63q3","type":"blocks","created_at":"2026-01-05T06:42:33.022262-06:00","created_by":"nathanclevenger"},{"issue_id":"neo4j-uv6b","depends_on_id":"neo4j-3x5","type":"blocks","created_at":"2026-01-05T06:42:52.426244-06:00","created_by":"nathanclevenger"},{"issue_id":"neo4j-uv6b","depends_on_id":"neo4j-ajg","type":"blocks","created_at":"2026-01-05T06:42:53.080204-06:00","created_by":"nathanclevenger"},{"issue_id":"neo4j-uv6b","depends_on_id":"neo4j-666","type":"blocks","created_at":"2026-01-05T06:42:53.443855-06:00","created_by":"nathanclevenger"},{"issue_id":"neo4j-uv6b","depends_on_id":"neo4j-e2j","type":"blocks","created_at":"2026-01-05T06:42:53.695935-06:00","created_by":"nathanclevenger"},{"issue_id":"neo4j-uv6b","depends_on_id":"neo4j-gahj","type":"blocks","created_at":"2026-01-05T06:42:59.366336-06:00","created_by":"nathanclevenger"}]}
{"id":"neo4j-v72g","title":"GREEN: Implement retry operators compatibility","description":"## Overview\nImplement retry compatibility to make all RED tests pass.\n\n## Implementation Requirements\n\n### Retry Support\n- Support RxJS retry()\n- Support retryWhen()\n- Fresh execution on retry\n- Proper cleanup between retries\n\n### Error Classification\n- Mark transient errors\n- Mark retriable errors\n- Expose error classification\n- Support custom classification\n\n### Implementation Details\n- Cold observables enable retry\n- Clean state on resubscribe\n- Connection pool integration\n- Transaction recreation\n\n## Acceptance Criteria\n- All RED tests now pass (GREEN phase)\n- Retry operators work correctly\n- Error classification correct\n- Clean retry behavior","status":"open","priority":2,"issue_type":"task","created_at":"2026-01-05T06:47:45.607533-06:00","updated_at":"2026-01-05T06:47:45.607533-06:00"}
{"id":"neo4j-vi3o","title":"[GREEN] Parser: Implement Node Pattern Parsing","description":"## Overview\nImplement node pattern parsing to pass all tests.\n\n## Implementation Tasks\n\n### Pattern Parser Class (src/parser/pattern-parser.ts)\n```typescript\nexport class PatternParser {\n  constructor(private tokens: Token[], private pos: number = 0) {}\n  \n  parseNodePattern(): NodePattern {\n    this.expect('(')\n    \n    let variable: Identifier | undefined\n    const labels: string[] = []\n    let properties: MapLiteral | Parameter | undefined\n    \n    // Parse variable\n    if (this.isIdentifier()) {\n      variable = this.parseIdentifier()\n    }\n    \n    // Parse labels\n    while (this.match(':')) {\n      labels.push(this.parseLabel())\n    }\n    \n    // Parse properties\n    if (this.peek().value === '{') {\n      properties = this.parseMapLiteral()\n    } else if (this.peek().type === 'PARAMETER') {\n      properties = this.parseParameter()\n    }\n    \n    this.expect(')')\n    \n    return {\n      type: 'NodePattern',\n      variable,\n      labels,\n      properties,\n      loc: this.getLoc(start)\n    }\n  }\n}\n```\n\n### Helper Methods\n- `parseLabel(): string` - parse label name\n- `parseMapLiteral(): MapLiteral` - parse property map\n- `parseIdentifier(): Identifier` - parse variable name\n\n## Acceptance Criteria\n- [ ] All node pattern tests pass\n- [ ] AST nodes correctly constructed\n- [ ] Source locations accurate\n- [ ] Error messages helpful\n\n## TDD Phase: GREEN\n## Depends On: neo4j-t866","status":"closed","priority":1,"issue_type":"task","created_at":"2026-01-05T06:40:18.135042-06:00","updated_at":"2026-01-05T07:19:48.956632-06:00","closed_at":"2026-01-05T07:19:48.956632-06:00","close_reason":"Parser implemented with MATCH, RETURN, node/relationship patterns, expressions - 34 parser tests pass"}
{"id":"neo4j-vjny","title":"GREEN: Implement test schedulers support","description":"## Overview\nImplement test scheduler support to make all RED tests pass.\n\n## Implementation Requirements\n\n### Scheduler Support\n- Accept scheduler parameter\n- Default to appropriate scheduler\n- Support TestScheduler\n- Propagate through Observable chain\n\n### Implementation Details\n- Add scheduler to config\n- Use scheduler for timing\n- Support virtual time\n- Enable deterministic tests\n\n### Integration\n- Works with marble testing\n- Supports time manipulation\n- Flush-able operations\n- Controllable async\n\n## Acceptance Criteria\n- All RED tests now pass (GREEN phase)\n- TestScheduler works\n- Virtual time works\n- Deterministic tests possible","status":"open","priority":2,"issue_type":"task","created_at":"2026-01-05T06:49:20.970332-06:00","updated_at":"2026-01-05T06:49:20.970332-06:00"}
{"id":"neo4j-vkdj","title":"[RED] Parser: CALL and UNION Clause Tests","description":"## Overview\nWrite failing tests for CALL (procedures) and UNION clause parsing.\n\n## Test Cases to Write\n\n### Basic CALL\n- No args: `CALL db.labels()`\n- With args: `CALL db.index.fulltext.queryNodes('index', 'query')`\n- With YIELD: `CALL db.labels() YIELD label`\n\n### CALL YIELD\n- Single: `CALL proc() YIELD x`\n- Multiple: `CALL proc() YIELD x, y, z`\n- With alias: `CALL proc() YIELD x AS a, y AS b`\n- All: `CALL proc() YIELD *`\n\n### CALL with WHERE\n- `CALL proc() YIELD x WHERE x \u003e 10`\n- `CALL proc() YIELD x, y WHERE x \u003e y`\n\n### CALL Context\n- Standalone: `CALL proc()`\n- After MATCH: `MATCH (n) CALL proc(n) YIELD x RETURN x`\n- With RETURN: `CALL db.labels() YIELD label RETURN label`\n\n### UNION\n- Simple: `MATCH (n:A) RETURN n UNION MATCH (n:B) RETURN n`\n- UNION ALL: `MATCH (n:A) RETURN n UNION ALL MATCH (n:B) RETURN n`\n- Multiple: `... UNION ... UNION ...`\n\n### UNION Rules\n- Same columns required (validation, not parsing)\n- Order of UNION vs UNION ALL\n\n## Acceptance Criteria\n- [ ] All CALL tests written and failing\n- [ ] All UNION tests written and failing\n- [ ] YIELD clause tested\n- [ ] Error cases covered\n\n## TDD Phase: RED","status":"closed","priority":1,"issue_type":"task","created_at":"2026-01-05T06:45:07.0669-06:00","updated_at":"2026-01-05T08:51:56.57905-06:00","closed_at":"2026-01-05T08:51:56.57905-06:00","close_reason":"CALL and UNION clauses implemented with tests"}
{"id":"neo4j-vsy","title":"REFACTOR: Record.toObject() - Optimize object conversion","description":"## Overview\nRefactor the Record.toObject() implementation for better type safety.\n\n## Refactoring Tasks\n\n1. **Type Safety**\n   - Add proper return type generics\n   - Consider typed record definitions\n\n2. **Performance**\n   - Consider Object.fromEntries alternative\n   - Benchmark different approaches\n\n## Acceptance Criteria\n- [ ] All tests still pass after refactoring\n- [ ] Code is clean and well-documented\n- [ ] TypeScript types properly defined\n\n## TDD Phase\nREFACTOR - Improve code without changing behavior\n\n## Dependencies\n- neo4j-na4 (GREEN phase implementation)","status":"closed","priority":1,"issue_type":"task","created_at":"2026-01-05T06:37:17.175661-06:00","updated_at":"2026-01-05T08:57:33.739946-06:00","closed_at":"2026-01-05T08:57:33.739946-06:00","close_reason":"Record methods already implemented with tests"}
{"id":"neo4j-vuyl","title":"[REFACTOR] Index Management - Optimize query planning and index selection","description":"## Overview\nRefactor index management for better query optimization.\n\n## Refactoring Tasks\n\n### Query Planner Integration\n```typescript\ninterface IndexHint {\n  indexName: string;\n  estimatedRows: number;\n  selectivity: number;\n}\n\nclass QueryPlanner {\n  private indexManager: IndexManager;\n  \n  suggestIndex(\n    entityType: 'node' | 'relationship',\n    labelOrType: string,\n    predicates: PropertyPredicate[]\n  ): IndexHint | null {\n    const indexes = this.indexManager.listIndexesFor(labelOrType);\n    \n    // Find best matching index\n    for (const index of indexes) {\n      const covered = predicates.filter(p =\u003e \n        index.properties.includes(p.property)\n      );\n      if (covered.length \u003e 0) {\n        return {\n          indexName: index.name,\n          estimatedRows: this.estimateRows(index, covered),\n          selectivity: covered.length / predicates.length\n        };\n      }\n    }\n    return null;\n  }\n}\n```\n\n### Index Statistics\n```typescript\ninterface IndexStatistics {\n  name: string;\n  size: number;\n  entries: number;\n  depth: number;\n  lastUpdated: Date;\n  avgQueryTime: number;\n}\n\nclass IndexManager {\n  gatherStatistics(indexName: string): IndexStatistics {\n    // Analyze index usage patterns\n  }\n\n  analyzeIndex(indexName: string): {\n    fragmentation: number;\n    recommendations: string[];\n  } {\n    // Provide optimization recommendations\n  }\n}\n```\n\n### Automatic Index Suggestions\n```typescript\nclass IndexAdvisor {\n  private queryLog: QueryLogEntry[] = [];\n\n  logQuery(query: string, executionTime: number, plan: QueryPlan): void {\n    this.queryLog.push({ query, executionTime, plan, timestamp: Date.now() });\n  }\n\n  suggestIndexes(): IndexSuggestion[] {\n    // Analyze query patterns\n    const suggestions: IndexSuggestion[] = [];\n    \n    // Find frequently filtered properties without indexes\n    const propertyUsage = this.analyzePropertyUsage();\n    for (const [property, count] of propertyUsage) {\n      if (count \u003e 100 \u0026\u0026 \\!this.hasIndex(property)) {\n        suggestions.push({\n          property,\n          benefit: this.estimateBenefit(property),\n          reason: `Property '${property}' used in ${count} queries without index`\n        });\n      }\n    }\n    \n    return suggestions;\n  }\n}\n```\n\n### Composite Index Optimization\n```typescript\n// Automatic composite index detection\nfunction suggestCompositeIndexes(\n  queryPatterns: QueryPattern[]\n): CompositeIndexSuggestion[] {\n  // Find property combinations frequently used together\n}\n```\n\n### Code Quality\n- Add index usage metrics\n- Implement index maintenance (VACUUM, REINDEX)\n- Add background index building\n- Create index health checks\n\n## Acceptance Criteria\n- [ ] All tests still pass\n- [ ] Query planning improved\n- [ ] Statistics available\n- [ ] Index advisor working\n- [ ] Code well-documented\n\n## TDD Phase\n**REFACTOR** - Improve without changing behavior","status":"open","priority":2,"issue_type":"task","created_at":"2026-01-05T06:42:06.352434-06:00","updated_at":"2026-01-05T06:42:06.352434-06:00"}
{"id":"neo4j-w45s","title":"RED: Import/Export Utilities - Write failing tests for APOC-compatible procedures","description":"## Overview\nWrite failing tests for import/export utilities compatible with APOC procedures.\n\n## Test Cases\n\n```typescript\ndescribe('Import/Export Utilities', () =\u003e {\n  describe('JSON Import', () =\u003e {\n    it('should import nodes from JSON URL', async () =\u003e {\n      // Setup mock URL with JSON data\n      mockServer.get('/data/people.json', [\n        { name: 'Alice', age: 30 },\n        { name: 'Bob', age: 25 }\n      ]);\n      \n      const result = await session.run(`\n        CALL apoc.import.json('http://localhost:9999/data/people.json', {\n          labels: ['Person'],\n          mapping: { name: 'name', age: 'age' }\n        }) YIELD nodes, relationships, time\n        RETURN nodes, relationships, time\n      `);\n      \n      expect(result.records[0].get('nodes')).toBe(2);\n      \n      const people = await session.run('MATCH (p:Person) RETURN p.name');\n      expect(people.records.map(r =\u003e r.get('p.name'))).toContain('Alice');\n    });\n\n    it('should import with nested relationships', async () =\u003e {\n      mockServer.get('/data/graph.json', {\n        nodes: [\n          { id: 1, labels: ['Person'], properties: { name: 'Alice' } },\n          { id: 2, labels: ['Company'], properties: { name: 'TechCo' } }\n        ],\n        relationships: [\n          { startNode: 1, endNode: 2, type: 'WORKS_AT', properties: { since: '2020' } }\n        ]\n      });\n      \n      const result = await session.run(`\n        CALL apoc.import.json('http://localhost:9999/data/graph.json')\n        YIELD nodes, relationships\n        RETURN nodes, relationships\n      `);\n      \n      expect(result.records[0].get('nodes')).toBe(2);\n      expect(result.records[0].get('relationships')).toBe(1);\n    });\n\n    it('should handle streaming large JSON files', async () =\u003e {\n      // 10000 records\n      const largeData = Array.from({ length: 10000 }, (_, i) =\u003e ({ id: i, value: 'test' }));\n      mockServer.get('/data/large.json', largeData);\n      \n      const result = await session.run(`\n        CALL apoc.import.json('http://localhost:9999/data/large.json', {\n          labels: ['Item'],\n          batchSize: 1000\n        }) YIELD nodes, batches\n        RETURN nodes, batches\n      `);\n      \n      expect(result.records[0].get('nodes')).toBe(10000);\n      expect(result.records[0].get('batches')).toBe(10);\n    });\n  });\n\n  describe('CSV Import', () =\u003e {\n    it('should import nodes from CSV', async () =\u003e {\n      mockServer.get('/data/people.csv', `\nname,age,email\nAlice,30,alice@example.com\nBob,25,bob@example.com\n`);\n      \n      const result = await session.run(`\n        CALL apoc.import.csv('http://localhost:9999/data/people.csv', {\n          labels: ['Person'],\n          mapping: {\n            name: { type: 'string' },\n            age: { type: 'integer' },\n            email: { type: 'string' }\n          }\n        }) YIELD nodes\n        RETURN nodes\n      `);\n      \n      expect(result.records[0].get('nodes')).toBe(2);\n    });\n\n    it('should handle CSV with relationships', async () =\u003e {\n      mockServer.get('/data/edges.csv', `\nfrom,to,type,weight\nAlice,Bob,KNOWS,1.0\nBob,Carol,KNOWS,0.8\n`);\n      \n      await session.run('CREATE (:Person {name: \"Alice\"}), (:Person {name: \"Bob\"}), (:Person {name: \"Carol\"})');\n      \n      const result = await session.run(`\n        CALL apoc.import.csv('http://localhost:9999/data/edges.csv', {\n          relationships: true,\n          fromField: 'from',\n          toField: 'to',\n          typeField: 'type',\n          fromLabel: 'Person',\n          toLabel: 'Person',\n          fromKey: 'name',\n          toKey: 'name'\n        }) YIELD relationships\n        RETURN relationships\n      `);\n      \n      expect(result.records[0].get('relationships')).toBe(2);\n    });\n  });\n\n  describe('JSON Export', () =\u003e {\n    it('should export query results to JSON', async () =\u003e {\n      await session.run('CREATE (:Person {name: \"Alice\", age: 30})');\n      \n      const result = await session.run(`\n        CALL apoc.export.json('MATCH (p:Person) RETURN p', {\n          format: 'array'\n        }) YIELD data\n        RETURN data\n      `);\n      \n      const data = JSON.parse(result.records[0].get('data'));\n      expect(data).toHaveLength(1);\n      expect(data[0].p.name).toBe('Alice');\n    });\n\n    it('should export full subgraph', async () =\u003e {\n      await session.run(`\n        CREATE (a:Person {name: \"Alice\"})-[:KNOWS]-\u003e(b:Person {name: \"Bob\"})\n      `);\n      \n      const result = await session.run(`\n        CALL apoc.export.json('MATCH path = (a)-[r]-\u003e(b) RETURN path', {\n          format: 'graph'\n        }) YIELD data\n        RETURN data\n      `);\n      \n      const data = JSON.parse(result.records[0].get('data'));\n      expect(data.nodes).toHaveLength(2);\n      expect(data.relationships).toHaveLength(1);\n    });\n\n    it('should export to R2 bucket', async () =\u003e {\n      const result = await session.run(`\n        CALL apoc.export.json('MATCH (p:Person) RETURN p', {\n          destination: 'r2://my-bucket/exports/people.json'\n        }) YIELD url\n        RETURN url\n      `);\n      \n      expect(result.records[0].get('url')).toMatch(/r2:\\/\\//);\n    });\n  });\n\n  describe('Cypher Export', () =\u003e {\n    it('should export as Cypher statements', async () =\u003e {\n      await session.run(`\n        CREATE (a:Person {name: \"Alice\"})-[:KNOWS {since: \"2020\"}]-\u003e(b:Person {name: \"Bob\"})\n      `);\n      \n      const result = await session.run(`\n        CALL apoc.export.cypher('MATCH path = (a)-[r]-\u003e(b) RETURN path')\n        YIELD cypher\n        RETURN cypher\n      `);\n      \n      const cypher = result.records[0].get('cypher');\n      expect(cypher).toContain('CREATE (:Person {name: \"Alice\"})');\n      expect(cypher).toContain('CREATE (:Person {name: \"Bob\"})');\n      expect(cypher).toContain('[:KNOWS {since: \"2020\"}]');\n    });\n  });\n\n  describe('R2 Integration', () =\u003e {\n    it('should import from R2 bucket', async () =\u003e {\n      await r2.put('imports/data.json', JSON.stringify([{ name: 'Test' }]));\n      \n      const result = await session.run(`\n        CALL apoc.import.json('r2://my-bucket/imports/data.json', {\n          labels: ['Item']\n        }) YIELD nodes\n        RETURN nodes\n      `);\n      \n      expect(result.records[0].get('nodes')).toBe(1);\n    });\n\n    it('should list available imports in R2', async () =\u003e {\n      const result = await session.run(`\n        CALL apoc.import.list('r2://my-bucket/imports/')\n        YIELD files\n        RETURN files\n      `);\n      \n      expect(result.records[0].get('files')).toContain('data.json');\n    });\n  });\n});\n```\n\n## Acceptance Criteria\n- [ ] All test cases written and failing\n- [ ] Mock HTTP server for URL tests\n- [ ] R2 mock for bucket tests\n- [ ] Large file streaming tests\n\n## Tags\nsuperset, import-export, apoc, r2, tdd-red","status":"open","priority":2,"issue_type":"task","created_at":"2026-01-05T06:51:41.534699-06:00","updated_at":"2026-01-05T06:51:41.534699-06:00"}
{"id":"neo4j-w5le","title":"GREEN: Result.peek() - Implement first record peek","description":"## Overview\nImplement the Result.peek() method to make all RED phase tests pass.\n\n## Implementation\n\n```typescript\nprivate _peekedRecord: R | null | undefined = undefined;\n\nasync peek(): Promise\u003cR | null\u003e {\n  if (this._peekedRecord !== undefined) {\n    return this._peekedRecord;\n  }\n  \n  const records = await this.records;\n  this._peekedRecord = records.length \u003e 0 ? records[0] : null;\n  return this._peekedRecord;\n}\n```\n\n## Acceptance Criteria\n- [ ] All RED phase tests now pass (GREEN phase)\n- [ ] Returns first record or null\n- [ ] Does not consume result\n- [ ] Implementation is minimal\n\n## TDD Phase\nGREEN - Minimal implementation to pass tests\n\n## Dependencies\n- neo4j-ee0o (RED phase tests)","status":"closed","priority":1,"issue_type":"task","created_at":"2026-01-05T06:48:51.444359-06:00","updated_at":"2026-01-05T07:19:22.168428-06:00","closed_at":"2026-01-05T07:19:22.168428-06:00","close_reason":"Implemented in this Ralph Wiggum session - 662 tests pass"}
{"id":"neo4j-w5n","title":"RED: Record.has(key) - Write failing tests for column existence check","description":"## Overview\nWrite failing tests for the Record.has(key) method that checks if a column exists.\n\n## Test Cases to Write\n\n```typescript\ndescribe('Record.has(key)', () =\u003e {\n  it('should return true for existing column', () =\u003e {\n    const record = new Record(['name', 'age'], ['Alice', 30]);\n    expect(record.has('name')).toBe(true);\n    expect(record.has('age')).toBe(true);\n  });\n\n  it('should return false for non-existent column', () =\u003e {\n    const record = new Record(['name'], ['Alice']);\n    expect(record.has('email')).toBe(false);\n    expect(record.has('missing')).toBe(false);\n  });\n\n  it('should be case-sensitive', () =\u003e {\n    const record = new Record(['Name'], ['Alice']);\n    expect(record.has('Name')).toBe(true);\n    expect(record.has('name')).toBe(false);\n  });\n\n  it('should return true even if value is null', () =\u003e {\n    const record = new Record(['email'], [null]);\n    expect(record.has('email')).toBe(true);\n  });\n\n  it('should return true even if value is undefined', () =\u003e {\n    const record = new Record(['value'], [undefined]);\n    expect(record.has('value')).toBe(true);\n  });\n\n  it('should handle empty string key', () =\u003e {\n    const record = new Record(['', 'name'], ['empty', 'Alice']);\n    expect(record.has('')).toBe(true);\n  });\n});\n```\n\n## Acceptance Criteria\n- [ ] All tests written and failing (RED phase)\n- [ ] Tests cover existence checks with various values\n- [ ] Tests verify case sensitivity\n- [ ] Test file created at src/result/__tests__/record-has.test.ts\n\n## TDD Phase\nRED - Tests should fail because has method does not exist yet","status":"closed","priority":1,"issue_type":"task","created_at":"2026-01-05T06:38:57.175041-06:00","updated_at":"2026-01-05T08:57:33.736291-06:00","closed_at":"2026-01-05T08:57:33.736291-06:00","close_reason":"Record methods already implemented with tests"}
{"id":"neo4j-wef","title":"GREEN: Variable-Length Path Translation - Recursive CTEs","description":"## Overview\nImplement variable-length path translation using recursive CTEs.\n\n## Implementation Tasks\n\n### 1. Recursive CTE Generator\n```typescript\nclass RecursiveCTEGenerator {\n  generate(pattern: VariableLengthPattern): string {\n    const { minHops, maxHops, relType, direction } = pattern;\n    \n    return `\n      WITH RECURSIVE path_cte AS (\n        -- Base case: starting nodes\n        SELECT id, id as current, 0 as depth, \n               JSON_ARRAY(id) as visited,\n               JSON_ARRAY(id) as path_nodes\n        FROM nodes\n        WHERE ${startCondition}\n        \n        UNION ALL\n        \n        -- Recursive case: follow relationships\n        SELECT p.id, r.end_node_id, p.depth + 1,\n               JSON_INSERT(p.visited, '$[#]', r.end_node_id),\n               JSON_INSERT(p.path_nodes, '$[#]', r.end_node_id)\n        FROM path_cte p\n        JOIN relationships r ON p.current = r.start_node_id\n        WHERE p.depth \u003c ${maxHops}\n          AND NOT JSON_CONTAINS(p.visited, r.end_node_id)\n          ${typeFilter}\n      )\n    `;\n  }\n}\n```\n\n### 2. Depth Bound Handler\n```typescript\nclass DepthBoundHandler {\n  getDepthCondition(min?: number, max?: number): string {\n    if (min \u0026\u0026 max) return `depth \u003e= ${min} AND depth \u003c= ${max}`;\n    if (min) return `depth \u003e= ${min}`;\n    if (max) return `depth \u003c= ${max}`;\n    return 'TRUE'; // Unlimited (with reasonable default limit)\n  }\n}\n```\n\n### 3. Cycle Detection\n```typescript\nclass CycleDetector {\n  getVisitedCheck(visitedColumn: string, newNodeId: string): string {\n    return `NOT EXISTS (\n      SELECT 1 FROM JSON_EACH(${visitedColumn}) \n      WHERE value = ${newNodeId}\n    )`;\n  }\n}\n```\n\n### 4. Exact Depth Optimizer\n```typescript\n// For exact depths, use chained JOINs instead of CTE\nclass ExactDepthTranslator {\n  translate(depth: number): string {\n    // Generate n-level JOINs for better performance\n  }\n}\n```\n\n## Files to Create/Modify\n- `src/cypher/translator/recursive-cte-generator.ts`\n- `src/cypher/translator/depth-bound-handler.ts`\n- `src/cypher/translator/cycle-detector.ts`\n\n## Acceptance Criteria\n- [ ] All RED phase tests pass\n- [ ] Cycle detection prevents infinite loops\n- [ ] Bounded paths optimized\n\n## TDD Phase\nGREEN - Make tests pass with minimal code\n\n## Dependencies\n- Depends on: RED: Variable-Length Path Translation - Recursive CTEs","status":"open","priority":2,"issue_type":"task","created_at":"2026-01-05T06:36:39.287449-06:00","updated_at":"2026-01-05T06:36:39.287449-06:00"}
{"id":"neo4j-wjo6","title":"[REFACTOR] Label Management - Optimize indexing strategies","description":"## Overview\nRefactor label management for better query performance.\n\n## Refactoring Tasks\n\n### Label Index Table\n```sql\n-- Dedicated index table for faster label queries\nCREATE TABLE IF NOT EXISTS label_index (\n  label TEXT NOT NULL,\n  node_id INTEGER NOT NULL REFERENCES nodes(id) ON DELETE CASCADE,\n  PRIMARY KEY (label, node_id)\n);\n\nCREATE INDEX idx_label_index_label ON label_index(label);\nCREATE INDEX idx_label_index_node ON label_index(node_id);\n```\n\n### Synchronized Updates\n```typescript\naddLabel(nodeId: number, label: string): void {\n  this.sql.transaction(() =\u003e {\n    // Update JSON array\n    this.updateLabelArray(nodeId, label, 'add');\n    // Update index table\n    this.sql.exec(\n      'INSERT OR IGNORE INTO label_index (label, node_id) VALUES (?, ?)',\n      label, nodeId\n    );\n  });\n}\n\nremoveLabel(nodeId: number, label: string): void {\n  this.sql.transaction(() =\u003e {\n    this.updateLabelArray(nodeId, label, 'remove');\n    this.sql.exec(\n      'DELETE FROM label_index WHERE label = ? AND node_id = ?',\n      label, nodeId\n    );\n  });\n}\n```\n\n### Optimized Queries\n```typescript\n// Fast label-based node lookup\ngetNodesByLabel(label: string): Node[] {\n  return this.sql.exec(`\n    SELECT n.* FROM nodes n\n    JOIN label_index li ON n.id = li.node_id\n    WHERE li.label = ?\n  `, label).toArray().map(this.rowToNode);\n}\n\n// Multi-label queries\ngetNodesByLabels(labels: string[], mode: 'all' | 'any'): Node[] {\n  if (mode === 'all') {\n    // Nodes with ALL specified labels\n    return this.sql.exec(`\n      SELECT n.* FROM nodes n\n      WHERE (SELECT COUNT(DISTINCT label) FROM label_index WHERE node_id = n.id AND label IN (${labels.map(() =\u003e '?').join(',')})) = ?\n    `, ...labels, labels.length).toArray().map(this.rowToNode);\n  }\n  // Nodes with ANY specified labels\n}\n```\n\n### Code Quality\n- Add index maintenance utilities\n- Create index consistency checker\n- Add label statistics gathering\n- Implement label cardinality estimation\n\n## Acceptance Criteria\n- [ ] All tests still pass\n- [ ] Label queries are fast\n- [ ] Index maintained consistently\n- [ ] Multi-label queries supported\n- [ ] Code well-documented\n\n## TDD Phase\n**REFACTOR** - Improve without changing behavior","status":"open","priority":2,"issue_type":"task","created_at":"2026-01-05T06:39:32.258025-06:00","updated_at":"2026-01-05T06:39:32.258025-06:00"}
{"id":"neo4j-wnk9","title":"GREEN: Implement Observable completion signaling","description":"## Overview\nImplement proper completion signaling to make all RED tests pass.\n\n## Implementation Requirements\n\n### Completion Emission\n- Call complete() after all emissions\n- Trigger subscriber complete callback\n- Ensure no emissions after complete\n- Propagate through operators\n\n### Implementation Details\n- Track emission state\n- Call complete at right time\n- Handle empty result sets\n- Support early completion\n\n### Observable-Specific Completion\n- keys(): after key array emission\n- records(): after last record\n- consume(): after summary\n- close(): after cleanup\n\n## Acceptance Criteria\n- All RED tests now pass (GREEN phase)\n- All Observables complete correctly\n- Completion timing correct\n- Operator interaction works","status":"open","priority":2,"issue_type":"task","created_at":"2026-01-05T06:43:58.796823-06:00","updated_at":"2026-01-05T06:43:58.796823-06:00"}
{"id":"neo4j-wpkt","title":"GREEN: Implement Request/Response serialization","description":"## Test-Driven Development: GREEN Phase\n\n### Component\nHTTP Client SDK - Request/Response Serialization\n\n### Implementation Requirements\n\nImplement `src/client/serialization.ts`:\n\n```typescript\nimport { \n  Node, Relationship, Path, Integer, DateTime, \n  Duration, Point, Record as Neo4jRecord \n} from './types'\n\n// Query serialization\nexport function serializeQuery(\n  query: string, \n  parameters?: Record\u003cstring, unknown\u003e\n): { query: string; parameters: Record\u003cstring, unknown\u003e } {\n  return {\n    query,\n    parameters: parameters ? serializeParameters(parameters) : {}\n  }\n}\n\n// Parameter serialization with Neo4j type encoding\nexport function serializeParameters(\n  params: Record\u003cstring, unknown\u003e\n): Record\u003cstring, unknown\u003e {\n  const result: Record\u003cstring, unknown\u003e = {}\n  \n  for (const [key, value] of Object.entries(params)) {\n    result[key] = serializeValue(value)\n  }\n  \n  return result\n}\n\nfunction serializeValue(value: unknown): unknown {\n  if (value === null || value === undefined) return null\n  \n  if (typeof value === 'bigint') {\n    return { __neo4j_type__: 'Integer', value: value.toString() }\n  }\n  \n  if (value instanceof Date) {\n    return { __neo4j_type__: 'DateTime', value: value.toISOString() }\n  }\n  \n  if (Array.isArray(value)) {\n    return value.map(serializeValue)\n  }\n  \n  if (typeof value === 'object') {\n    const obj = value as Record\u003cstring, unknown\u003e\n    \n    // Handle typed objects\n    if (obj.__type__ === 'Point') {\n      return {\n        __neo4j_type__: 'Point',\n        srid: obj.srid,\n        x: obj.longitude ?? obj.x,\n        y: obj.latitude ?? obj.y,\n        z: obj.z\n      }\n    }\n    \n    if (obj.__type__ === 'Duration') {\n      return {\n        __neo4j_type__: 'Duration',\n        months: obj.months ?? 0,\n        days: obj.days ?? 0,\n        seconds: obj.seconds ?? 0,\n        nanoseconds: obj.nanoseconds ?? 0\n      }\n    }\n    \n    // Plain object - recurse\n    return serializeParameters(obj as Record\u003cstring, unknown\u003e)\n  }\n  \n  return value\n}\n\n// Result deserialization\nexport interface QueryResult\u003cT = Neo4jRecord\u003e {\n  keys: string[]\n  records: T[]\n  summary: QuerySummary\n}\n\nexport function deserializeResult\u003cT = Neo4jRecord\u003e(\n  response: unknown\n): QueryResult\u003cT\u003e {\n  const data = response as {\n    keys: string[]\n    records: Array\u003cRecord\u003cstring, unknown\u003e\u003e\n    summary?: QuerySummary\n  }\n  \n  return {\n    keys: data.keys,\n    records: data.records.map(r =\u003e \n      createRecord(data.keys, r) as unknown as T\n    ),\n    summary: data.summary ?? createEmptySummary()\n  }\n}\n\nfunction createRecord(keys: string[], data: Record\u003cstring, unknown\u003e): Neo4jRecord {\n  const values = keys.map(k =\u003e deserializeNeo4jTypes(data[k]))\n  return new Neo4jRecord(keys, values)\n}\n\n// Neo4j type reconstruction\nexport function deserializeNeo4jTypes(value: unknown): unknown {\n  if (value === null || typeof value \\!== 'object') return value\n  \n  const obj = value as Record\u003cstring, unknown\u003e\n  \n  if (obj.__neo4j_type__) {\n    switch (obj.__neo4j_type__) {\n      case 'Node':\n        return new Node(\n          Integer.fromString(obj.identity as string),\n          obj.labels as string[],\n          deserializeProperties(obj.properties as Record\u003cstring, unknown\u003e)\n        )\n      \n      case 'Relationship':\n        return new Relationship(\n          Integer.fromString(obj.identity as string),\n          obj.type as string,\n          Integer.fromString(obj.startNodeIdentity as string),\n          Integer.fromString(obj.endNodeIdentity as string),\n          deserializeProperties(obj.properties as Record\u003cstring, unknown\u003e)\n        )\n      \n      case 'Path':\n        return new Path(\n          deserializeNeo4jTypes(obj.start) as Node,\n          deserializeNeo4jTypes(obj.end) as Node,\n          (obj.segments as unknown[]).map(s =\u003e deserializeNeo4jTypes(s))\n        )\n      \n      case 'DateTime':\n        return DateTime.fromString(obj.value as string)\n      \n      case 'Integer':\n        return Integer.fromString(obj.value as string)\n      \n      case 'Point':\n        return new Point(obj.srid as number, obj.x as number, obj.y as number, obj.z as number)\n      \n      case 'Duration':\n        return new Duration(\n          obj.months as number,\n          obj.days as number,\n          obj.seconds as number,\n          obj.nanoseconds as number\n        )\n    }\n  }\n  \n  // Array\n  if (Array.isArray(value)) {\n    return value.map(deserializeNeo4jTypes)\n  }\n  \n  // Plain object\n  return deserializeProperties(obj)\n}\n\n// Error parsing\nexport interface Neo4jError {\n  code: string\n  message: string\n  classification: string\n  isRetryable: boolean\n}\n\nexport function parseErrorResponse(response: unknown): Neo4jError {\n  const data = response as { error?: { code?: string; message?: string }; message?: string }\n  \n  const code = data.error?.code ?? 'Neo.ClientError.General.UnknownError'\n  const message = data.error?.message ?? data.message ?? 'Unknown error'\n  const parts = code.split('.')\n  const classification = parts[1] ?? 'ClientError'\n  \n  return {\n    code,\n    message,\n    classification,\n    isRetryable: classification === 'TransientError'\n  }\n}\n```\n\n### Acceptance Criteria\n- [ ] All RED phase tests pass\n- [ ] All Neo4j types serialize/deserialize correctly\n- [ ] Date, BigInt, Point, Duration handled\n- [ ] Error responses parsed correctly\n\n### Dependencies\n- RED: Request/Response serialization fails without implementation\n\n### TDD Cycle\nThis is the GREEN phase. Next: REFACTOR phase.","status":"open","priority":2,"issue_type":"task","created_at":"2026-01-05T06:39:56.293754-06:00","updated_at":"2026-01-05T06:39:56.293754-06:00"}
{"id":"neo4j-wumm","title":"GREEN: AgentFS - Implement virtual filesystem for graph data","description":"## Overview\nImplement AgentFS - a virtual filesystem interface to graph data.\n\n## Implementation Requirements\n\n### Core Components\n\n#### 1. Path Resolution\n```typescript\ninterface ResolvedPath {\n  type: 'root' | 'label' | 'node' | 'relationship_type' | 'relationship' | 'special';\n  label?: string;\n  nodeId?: string;\n  relType?: string;\n  direction?: 'outgoing' | 'incoming';\n  targetNodeId?: string;\n  specialPath?: string;\n}\n\nclass PathResolver {\n  resolve(path: string): ResolvedPath {\n    const segments = path.split('/').filter(Boolean);\n    \n    if (segments.length === 0) return { type: 'root' };\n    if (segments[0].startsWith('.')) return this.resolveSpecial(segments);\n    \n    // /Label\n    if (segments.length === 1) return { type: 'label', label: segments[0] };\n    \n    // /Label/node.json\n    if (segments.length === 2 \u0026\u0026 segments[1].endsWith('.json')) {\n      return { type: 'node', label: segments[0], nodeId: this.extractId(segments[1]) };\n    }\n    \n    // /Label/node/RELTYPE\n    // /Label/node/~RELTYPE (incoming)\n    // ... continue resolution\n  }\n}\n```\n\n#### 2. AgentFS Implementation\n```typescript\nclass AgentFS {\n  constructor(private graphService: GraphService) {}\n\n  async readdir(path: string): Promise\u003cstring[]\u003e {\n    const resolved = this.pathResolver.resolve(path);\n    \n    switch (resolved.type) {\n      case 'root':\n        return this.graphService.getLabels();\n      \n      case 'label':\n        const nodes = await this.graphService.findNodes(resolved.label\\!, {});\n        return nodes.map(n =\u003e this.nodeToFilename(n));\n      \n      case 'node':\n        // Return relationship types as subdirectories\n        const relTypes = await this.graphService.getRelationshipTypes(resolved.nodeId\\!);\n        return [...relTypes.outgoing, ...relTypes.incoming.map(t =\u003e '~' + t)];\n      \n      case 'relationship_type':\n        // Return connected nodes\n        const connected = await this.graphService.getConnectedNodes(\n          resolved.nodeId\\!,\n          resolved.relType\\!,\n          resolved.direction\\!\n        );\n        return connected.map(n =\u003e this.nodeToFilename(n));\n    }\n  }\n\n  async readFile(path: string): Promise\u003cstring\u003e {\n    const resolved = this.pathResolver.resolve(path);\n    \n    if (resolved.type === 'node') {\n      const node = await this.graphService.getNode(resolved.nodeId\\!);\n      return JSON.stringify({\n        _id: node.id,\n        _labels: node.labels,\n        ...node.properties\n      }, null, 2);\n    }\n    \n    if (path.endsWith('.rel.json')) {\n      // Return relationship properties\n    }\n    \n    throw new Error('ENOENT: ' + path);\n  }\n\n  async writeFile(path: string, content: string): Promise\u003cvoid\u003e {\n    const resolved = this.pathResolver.resolve(path);\n    const data = JSON.parse(content);\n    \n    if (resolved.type === 'node') {\n      if (resolved.nodeId) {\n        // Update existing node\n        await this.graphService.updateNode(resolved.nodeId, data);\n      } else {\n        // Create new node\n        await this.graphService.createNode(resolved.label\\!, data);\n      }\n    }\n  }\n\n  async unlink(path: string): Promise\u003cvoid\u003e {\n    const resolved = this.pathResolver.resolve(path);\n    \n    if (resolved.type === 'node') {\n      await this.graphService.deleteNode(resolved.nodeId\\!);\n    }\n  }\n\n  async stat(path: string): Promise\u003cStats\u003e {\n    const resolved = this.pathResolver.resolve(path);\n    \n    return {\n      isDirectory: () =\u003e ['root', 'label', 'relationship_type'].includes(resolved.type),\n      isFile: () =\u003e resolved.type === 'node' || resolved.type === 'relationship',\n      size: await this.getSize(resolved),\n      mtime: await this.getMtime(resolved)\n    };\n  }\n\n  async mkdir(path: string): Promise\u003cvoid\u003e {\n    // Create label or prepare for relationship\n  }\n\n  async symlink(target: string, path: string): Promise\u003cvoid\u003e {\n    // Create relationship\n    const resolved = this.pathResolver.resolve(path);\n    const targetResolved = this.pathResolver.resolve(target);\n    \n    await this.graphService.createRelationship(\n      resolved.nodeId\\!,\n      targetResolved.nodeId\\!,\n      resolved.relType\\!\n    );\n  }\n\n  watch(path: string, callback: WatchCallback): Watcher {\n    // Subscribe to CDC for path\n  }\n\n  async glob(pattern: string): Promise\u003cstring[]\u003e {\n    // Implement glob matching\n  }\n\n  async find(path: string, options: FindOptions): Promise\u003cstring[]\u003e {\n    // Implement find with filters\n  }\n}\n```\n\n#### 3. Special Paths\n```typescript\nclass SpecialPathHandler {\n  async handle(path: string, operation: string, data?: any): Promise\u003cany\u003e {\n    if (path.startsWith('/.schema')) {\n      return this.handleSchema(path, operation);\n    }\n    if (path.startsWith('/.indexes')) {\n      return this.handleIndexes(path, operation);\n    }\n    if (path.startsWith('/.query')) {\n      return this.handleQuery(path, operation, data);\n    }\n  }\n}\n```\n\n#### 4. Node Naming Strategy\n```typescript\ninterface NamingStrategy {\n  nodeToFilename(node: Node): string;\n  filenameToNodeId(filename: string, label: string): string;\n}\n\nclass DefaultNamingStrategy implements NamingStrategy {\n  nodeToFilename(node: Node): string {\n    // Use unique property if available (name, id, slug)\n    // Fall back to node ID\n    const name = node.properties.name || node.properties.id || node.id;\n    return slugify(name) + '.json';\n  }\n}\n```\n\n## Acceptance Criteria\n- [ ] All RED phase tests passing\n- [ ] POSIX-like operations working\n- [ ] Relationship traversal functional\n- [ ] Special paths implemented\n\n## Dependencies\n- RED: AgentFS tests\n- Graph service\n\n## Tags\nsuperset, agentfs, virtual-filesystem, ai-agents, tdd-green","status":"open","priority":2,"issue_type":"task","created_at":"2026-01-05T06:42:13.641527-06:00","updated_at":"2026-01-05T06:42:13.641527-06:00"}
{"id":"neo4j-xb7","title":"[RED] Temporal Types - Write Failing Tests","description":"## Overview\nWrite comprehensive failing tests for all Neo4j Temporal types before implementation.\n\n## TDD Phase: RED (Write Failing Tests)\n\n### Types to Test\n\n#### 1. Date (date without time)\n```typescript\n// Construction\nnew Date(year, month, day)\nDate.fromStandardDate(standardDate)\n\n// Properties\ndate.year, date.month, date.day\n\n// Methods\ndate.toString() // ISO format: 'YYYY-MM-DD'\ndate.toStandardDate()\n```\n\n#### 2. Time (time with timezone offset)\n```typescript\n// Construction\nnew Time(hour, minute, second, nanosecond, timeZoneOffsetSeconds)\nTime.fromStandardDate(standardDate)\n\n// Properties\ntime.hour, time.minute, time.second\ntime.nanosecond, time.timeZoneOffsetSeconds\n\n// Methods\ntime.toString() // ISO format: 'HH:MM:SS.nnnnnnnnn+HH:MM'\n```\n\n#### 3. LocalTime (time without timezone)\n```typescript\n// Construction\nnew LocalTime(hour, minute, second, nanosecond)\nLocalTime.fromStandardDate(standardDate)\n\n// Properties\nlocalTime.hour, localTime.minute, localTime.second, localTime.nanosecond\n\n// Methods\nlocalTime.toString() // ISO format: 'HH:MM:SS.nnnnnnnnn'\n```\n\n#### 4. DateTime (date + time + timezone)\n```typescript\n// Construction\nnew DateTime(year, month, day, hour, minute, second, nanosecond, timeZoneOffsetSeconds, timeZoneId?)\nDateTime.fromStandardDate(standardDate)\n\n// Properties\nAll date + time properties plus timeZoneId\n\n// Methods\ndateTime.toString() // ISO 8601 format\ndateTime.toStandardDate()\n```\n\n#### 5. LocalDateTime (date + time without timezone)\n```typescript\n// Construction\nnew LocalDateTime(year, month, day, hour, minute, second, nanosecond)\nLocalDateTime.fromStandardDate(standardDate)\n\n// Properties\nAll date + time properties (no timezone)\n\n// Methods\nlocalDateTime.toString()\nlocalDateTime.toStandardDate()\n```\n\n#### 6. Duration (time span)\n```typescript\n// Construction\nnew Duration(months, days, seconds, nanoseconds)\n\n// Properties\nduration.months, duration.days, duration.seconds, duration.nanoseconds\n\n// Methods\nduration.toString() // ISO 8601 duration format\n```\n\n### Test Categories for Each Type\n\n1. **Construction Tests**\n   - From components\n   - From ISO string\n   - From JavaScript Date\n   - Invalid input handling\n\n2. **Property Access Tests**\n   - All properties readable\n   - Properties are readonly\n   - Correct types\n\n3. **Serialization Tests**\n   - toString() format matches Neo4j\n   - JSON serialization\n   - Round-trip parsing\n\n4. **Edge Cases**\n   - Leap years\n   - Month boundaries\n   - Nanosecond precision\n   - Timezone edge cases (DST, etc.)\n\n5. **Type Guards**\n   - `neo4j.isDate()`\n   - `neo4j.isTime()`\n   - `neo4j.isLocalTime()`\n   - `neo4j.isDateTime()`\n   - `neo4j.isLocalDateTime()`\n   - `neo4j.isDuration()`\n\n### Acceptance Criteria\n- [ ] All tests written and failing (RED state)\n- [ ] Tests match neo4j-driver API exactly\n- [ ] Edge cases covered for each type\n- [ ] Test files at `src/types/temporal/*.test.ts`\n\n### References\n- [neo4j-driver Temporal Types](https://neo4j.com/docs/api/javascript-driver/current/)","status":"closed","priority":1,"issue_type":"task","created_at":"2026-01-05T06:35:39.293002-06:00","updated_at":"2026-01-05T08:48:00.95988-06:00","closed_at":"2026-01-05T08:48:00.95988-06:00","close_reason":"Tests passing - implementation complete"}
{"id":"neo4j-xg7i","title":"REFACTOR: Improve rxResult.keys() implementation","description":"## Overview\nRefactor rxResult.keys() for efficient key access.\n\n## Refactoring Tasks\n\n### Code Quality\n- Extract metadata handling\n- Improve caching strategy\n- Add proper types\n- Document behavior\n\n### Performance\n- Minimize observable overhead\n- Efficient caching (shareReplay)\n- Lazy metadata fetching\n\n### Integration\n- Align with sync result.keys()\n- Share metadata parsing code\n- Consistent behavior\n\n## Acceptance Criteria\n- All tests still pass\n- Efficient caching\n- Clean code\n- Consistent with sync API","status":"open","priority":2,"issue_type":"task","created_at":"2026-01-05T06:40:55.081824-06:00","updated_at":"2026-01-05T06:40:55.081824-06:00"}
{"id":"neo4j-xho7","title":"RED: Write failing tests for Mock RxSession testing utility","description":"## Overview\nWrite failing tests for Mock RxSession testing utility.\n\n## Test Cases to Write\n\n### Mock Creation Tests\n- createMockRxSession() creates mock\n- Mock has all RxSession methods\n- Mock methods return Observables\n- Mock is configurable\n\n### Mock Configuration Tests\n- Configure run() to return data\n- Configure run() to emit error\n- Configure executeRead() behavior\n- Configure executeWrite() behavior\n\n### Mock Verification Tests\n- Verify run() was called\n- Verify call arguments\n- Verify call count\n- Verify call order\n\n### Observable Behavior Tests\n- Mock returns cold observables\n- Mock respects timing configuration\n- Mock supports multiple subscriptions\n- Mock cleanup works\n\n## Acceptance Criteria\n- All tests written and failing (RED phase)\n- Tests verify mock creation\n- Tests verify configuration\n- Tests verify verification","status":"open","priority":2,"issue_type":"task","created_at":"2026-01-05T06:48:43.195466-06:00","updated_at":"2026-01-05T06:48:43.195466-06:00"}
{"id":"neo4j-xm9","title":"GREEN: Implement rxSession.executeRead() method","description":"## Overview\nImplement `rxSession.executeRead()` to make all RED tests pass.\n\n## Implementation Requirements\n\n### Method Signature\n```typescript\ninterface RxSession {\n  executeRead\u003cT\u003e(\n    work: (tx: RxManagedTransaction) =\u003e Observable\u003cT\u003e\n  ): Observable\u003cT\u003e\n}\n```\n\n### Implementation Details\n- Create managed transaction with READ mode\n- Execute work function with transaction\n- Auto-commit on successful completion\n- Auto-rollback on error\n- Handle retry logic for transient errors\n\n### Observable Chain\n- Wrap transaction lifecycle in Observable\n- Chain work function result\n- Proper error handling and propagation\n\n## Acceptance Criteria\n- [ ] All RED tests now pass (GREEN phase)\n- [ ] Transaction lifecycle correct\n- [ ] Retry logic works\n- [ ] Observable semantics proper","status":"open","priority":2,"issue_type":"task","created_at":"2026-01-05T06:35:45.824171-06:00","updated_at":"2026-01-05T06:35:45.824171-06:00"}
{"id":"neo4j-xpfx","title":"[RED] Parser: RETURN and WITH Clause Tests","description":"## Overview\nWrite failing tests for RETURN and WITH clause parsing.\n\n## Test Cases to Write\n\n### Basic RETURN\n- All: `RETURN *`\n- Single variable: `RETURN n`\n- Multiple: `RETURN a, b, c`\n- Expression: `RETURN n.name`\n\n### RETURN with Alias\n- Simple alias: `RETURN n.name AS name`\n- Multiple aliases: `RETURN a.x AS x, b.y AS y`\n\n### RETURN DISTINCT\n- `RETURN DISTINCT n`\n- `RETURN DISTINCT n.name`\n\n### ORDER BY\n- Single: `RETURN n ORDER BY n.name`\n- Multiple: `RETURN n ORDER BY n.name, n.age`\n- Direction: `RETURN n ORDER BY n.name ASC`\n- Descending: `RETURN n ORDER BY n.age DESC`\n- Mixed: `RETURN n ORDER BY n.name ASC, n.age DESC`\n\n### SKIP and LIMIT\n- Limit: `RETURN n LIMIT 10`\n- Skip: `RETURN n SKIP 5`\n- Both: `RETURN n SKIP 5 LIMIT 10`\n- With ORDER BY: `RETURN n ORDER BY n.name LIMIT 10`\n\n### WITH Clause\n- Simple: `MATCH (n) WITH n`\n- With WHERE: `MATCH (n) WITH n WHERE n.age \u003e 21`\n- Alias: `MATCH (n) WITH n.name AS name`\n- All modifiers: `WITH DISTINCT n ORDER BY n.x SKIP 1 LIMIT 10`\n\n## Acceptance Criteria\n- [ ] All RETURN tests written and failing\n- [ ] All WITH tests written and failing\n- [ ] All modifiers tested\n- [ ] Error cases covered\n\n## TDD Phase: RED","status":"closed","priority":1,"issue_type":"task","created_at":"2026-01-05T06:42:38.370674-06:00","updated_at":"2026-01-05T07:19:48.956267-06:00","closed_at":"2026-01-05T07:19:48.956267-06:00","close_reason":"Parser implemented with MATCH, RETURN, node/relationship patterns, expressions - 34 parser tests pass"}
{"id":"neo4j-xt0","title":"CI/CD pipeline (GitHub Actions)","description":"# CI/CD Pipeline with GitHub Actions\n\n## Overview\nSet up GitHub Actions workflows for continuous integration and deployment of the neo4j.do project.\n\n## Workflows to Create\n\n### 1. CI Workflow (.github/workflows/ci.yml)\nTriggers: push to main, pull requests\n\nJobs:\n- **lint**: Run ESLint and Prettier checks\n- **typecheck**: Run TypeScript type checking\n- **test**: Run test suite with coverage\n- **build**: Build the package\n\n```yaml\nname: CI\n\non:\n  push:\n    branches: [main]\n  pull_request:\n    branches: [main]\n\njobs:\n  lint:\n    runs-on: ubuntu-latest\n    steps:\n      - uses: actions/checkout@v4\n      - uses: actions/setup-node@v4\n        with:\n          node-version: '20'\n          cache: 'npm'\n      - run: npm ci\n      - run: npm run lint\n      - run: npm run format:check\n\n  typecheck:\n    runs-on: ubuntu-latest\n    steps:\n      - uses: actions/checkout@v4\n      - uses: actions/setup-node@v4\n        with:\n          node-version: '20'\n          cache: 'npm'\n      - run: npm ci\n      - run: npm run typecheck\n\n  test:\n    runs-on: ubuntu-latest\n    steps:\n      - uses: actions/checkout@v4\n      - uses: actions/setup-node@v4\n        with:\n          node-version: '20'\n          cache: 'npm'\n      - run: npm ci\n      - run: npm run test:coverage\n      - uses: codecov/codecov-action@v3\n\n  build:\n    runs-on: ubuntu-latest\n    needs: [lint, typecheck, test]\n    steps:\n      - uses: actions/checkout@v4\n      - uses: actions/setup-node@v4\n        with:\n          node-version: '20'\n          cache: 'npm'\n      - run: npm ci\n      - run: npm run build\n```\n\n### 2. Release Workflow (.github/workflows/release.yml)\nTriggers: version tags (v*)\n\n- Build package\n- Publish to npm\n- Deploy to Cloudflare Workers\n- Create GitHub release\n\n### 3. Compatibility Test Workflow\n- Run against real Neo4j instance\n- Run OpenCypher TCK tests\n\n## Acceptance Criteria\n- [ ] CI workflow runs on all PRs\n- [ ] Tests must pass before merge\n- [ ] Coverage reports uploaded\n- [ ] Build artifacts verified\n- [ ] Release workflow documented","status":"open","priority":1,"issue_type":"task","created_at":"2026-01-05T06:35:53.015174-06:00","updated_at":"2026-01-05T06:35:53.015174-06:00"}
{"id":"neo4j-xv2","title":"GREEN: AI Functions in Cypher - Implement Workers AI integration","description":"## Overview\nImplement AI-powered functions in Cypher using Workers AI.\n\n## Implementation Requirements\n\n### Core Components\n\n#### 1. AI Function Registry\n```typescript\ninterface AIFunction {\n  name: string;\n  handler: (args: any[], options: Record\u003cstring, any\u003e) =\u003e Promise\u003cany\u003e;\n  schema: {\n    args: JSONSchema[];\n    options?: JSONSchema;\n    returns: JSONSchema;\n  };\n}\n\nclass AIFunctionRegistry {\n  private functions = new Map\u003cstring, AIFunction\u003e();\n  \n  register(fn: AIFunction): void;\n  get(name: string): AIFunction | undefined;\n  execute(name: string, args: any[], options?: Record\u003cstring, any\u003e): Promise\u003cany\u003e;\n}\n```\n\n#### 2. Workers AI Service\n```typescript\nclass WorkersAIService {\n  constructor(private ai: Ai) {}\n\n  async embed(text: string, model?: string): Promise\u003cnumber[]\u003e {\n    const result = await this.ai.run(model ?? '@cf/baai/bge-m3', {\n      text: [text]\n    });\n    return result.data[0];\n  }\n\n  async embedBatch(texts: string[], model?: string): Promise\u003cnumber[][]\u003e {\n    const result = await this.ai.run(model ?? '@cf/baai/bge-m3', {\n      text: texts\n    });\n    return result.data;\n  }\n\n  async generate(prompt: string, options?: GenerateOptions): Promise\u003cstring\u003e {\n    const result = await this.ai.run(options?.model ?? '@cf/meta/llama-3.1-8b-instruct', {\n      prompt,\n      max_tokens: options?.maxTokens ?? 256,\n      temperature: options?.temperature ?? 0.7\n    });\n    return result.response;\n  }\n\n  async classify(text: string, categories: string[]): Promise\u003cClassifyResult\u003e {\n    // Use text generation with constrained output\n    // or dedicated classification model\n  }\n\n  async extract(text: string, schema: Record\u003cstring, string\u003e): Promise\u003cRecord\u003cstring, any\u003e\u003e {\n    // Use structured generation\n  }\n}\n```\n\n#### 3. Function Implementations\n```typescript\n// $ai.embed(text, options?)\nconst embedFunction: AIFunction = {\n  name: 'embed',\n  async handler([text], options) {\n    return aiService.embed(text, options?.model);\n  },\n  schema: {\n    args: [{ type: 'string' }],\n    options: { \n      type: 'object',\n      properties: { model: { type: 'string' } }\n    },\n    returns: { type: 'array', items: { type: 'number' } }\n  }\n};\n\n// $ai.generate(prompt, options?)\nconst generateFunction: AIFunction = {\n  name: 'generate',\n  async handler([prompt], options) {\n    return aiService.generate(prompt, options);\n  },\n  schema: {\n    args: [{ type: 'string' }],\n    options: {\n      type: 'object',\n      properties: {\n        model: { type: 'string' },\n        maxTokens: { type: 'number' },\n        temperature: { type: 'number' }\n      }\n    },\n    returns: { type: 'string' }\n  }\n};\n\n// $ai.classify(text, categories)\nconst classifyFunction: AIFunction = {\n  name: 'classify',\n  async handler([text, categories]) {\n    return aiService.classify(text, categories);\n  },\n  schema: {\n    args: [\n      { type: 'string' },\n      { type: 'array', items: { type: 'string' } }\n    ],\n    returns: {\n      type: 'object',\n      properties: {\n        label: { type: 'string' },\n        score: { type: 'number' }\n      }\n    }\n  }\n};\n\n// $ai.extract(text, schema)\nconst extractFunction: AIFunction = {\n  name: 'extract',\n  async handler([text, schema]) {\n    return aiService.extract(text, schema);\n  },\n  schema: {\n    args: [\n      { type: 'string' },\n      { type: 'object' }\n    ],\n    returns: { type: 'object' }\n  }\n};\n\n// $ai.similarity(vec1, vec2)\nconst similarityFunction: AIFunction = {\n  name: 'similarity',\n  async handler([vec1, vec2]) {\n    return cosineSimilarity(vec1, vec2);\n  },\n  schema: {\n    args: [\n      { type: 'array', items: { type: 'number' } },\n      { type: 'array', items: { type: 'number' } }\n    ],\n    returns: { type: 'number' }\n  }\n};\n```\n\n#### 4. Cypher Integration\n```typescript\n// In Cypher executor, detect $ai.xxx calls and execute\nclass CypherAIInterceptor {\n  async processExpression(expr: Expression): Promise\u003cany\u003e {\n    if (expr.type === 'FunctionCall' \u0026\u0026 expr.name.startsWith('$ai.')) {\n      const fnName = expr.name.slice(4); // Remove '$ai.'\n      const args = await Promise.all(expr.args.map(a =\u003e this.evaluate(a)));\n      const options = expr.options ? await this.evaluate(expr.options) : undefined;\n      return this.registry.execute(fnName, args, options);\n    }\n    // ... normal processing\n  }\n}\n```\n\n### Batching Optimization\n```typescript\nclass AIBatchProcessor {\n  private embedQueue: Map\u003cstring, Promise\u003cnumber[]\u003e\u003e = new Map();\n  \n  async embedWithDedup(text: string): Promise\u003cnumber[]\u003e {\n    if (this.embedQueue.has(text)) {\n      return this.embedQueue.get(text)\\!;\n    }\n    \n    const promise = this.processBatch(text);\n    this.embedQueue.set(text, promise);\n    return promise;\n  }\n}\n```\n\n## Acceptance Criteria\n- [ ] All RED phase tests passing\n- [ ] All AI functions implemented\n- [ ] Batching working for efficiency\n- [ ] Error handling comprehensive\n\n## Dependencies\n- RED: AI Functions tests\n- Workers AI binding\n\n## Tags\nsuperset, ai-functions, workers-ai, cypher, tdd-green","status":"open","priority":2,"issue_type":"task","created_at":"2026-01-05T06:39:00.997758-06:00","updated_at":"2026-01-05T06:39:00.997758-06:00"}
{"id":"neo4j-y30b","title":"RED: Write failing tests for request-based flow control","description":"## Overview\nWrite failing tests for request-based backpressure flow control.\n\n## Test Cases to Write\n\n### Basic Flow Control Tests\n- Consumer can request N records\n- Producer respects request count\n- No emissions beyond requested\n- Request more triggers more emissions\n\n### Backpressure Strategies\n- Buffer strategy works\n- Drop strategy works\n- Latest strategy works\n- Error strategy works\n\n### Rate Limiting Tests\n- Slow consumer handled gracefully\n- Fast producer doesn't overwhelm\n- Memory bounded during backpressure\n- Request-response coordination\n\n### RxJS Integration\n- Works with observeOn()\n- Works with buffer operators\n- Works with throttle operators\n- Works with sample operators\n\n## Acceptance Criteria\n- All tests written and failing (RED phase)\n- Tests verify flow control\n- Tests cover backpressure strategies\n- Tests verify memory bounds","status":"open","priority":2,"issue_type":"task","created_at":"2026-01-05T06:45:35.971291-06:00","updated_at":"2026-01-05T06:45:35.971291-06:00"}
{"id":"neo4j-y46d","title":"REFACTOR: Expression Translation","description":"## Overview\nRefactor expression translation for extensibility and type safety.\n\n## Refactoring Tasks\n\n### 1. Visitor Pattern for Expressions\n- ExpressionVisitor interface\n- Specific visitors for each expression type\n- Clean traversal of expression tree\n\n### 2. Function Registry\n- Register Cypher functions with SQL equivalents\n- Extensible for custom functions\n- Validation of function signatures\n\n### 3. Type System Integration\n- Track expression types through translation\n- Automatic type coercion where needed\n- Type checking for operators\n\n### 4. Operator Precedence\n- Correct parenthesization\n- Match SQL precedence rules\n- Minimize unnecessary parentheses\n\n## Quality Improvements\n- Extensible function registry\n- Type-safe expression building\n- Clean visitor implementation\n- Comprehensive operator handling\n\n## Acceptance Criteria\n- All tests still pass\n- Easy to add new functions\n- Type safety improved\n\n## TDD Phase\nREFACTOR - Improve code quality while keeping tests green\n\n## Dependencies\n- Depends on: GREEN: Expression Translation","status":"closed","priority":1,"issue_type":"task","created_at":"2026-01-05T06:42:09.336501-06:00","updated_at":"2026-01-05T08:53:30.81864-06:00","closed_at":"2026-01-05T08:53:30.81864-06:00","close_reason":"Aggregation/expression translation already implemented"}
{"id":"neo4j-ya4x","title":"[RED] E2E Node CRUD Tests","description":"# [RED] E2E Node CRUD Tests\n\n## Overview\nEnd-to-end tests for all node operations: Create, Read, Update, Delete.\n\n## Test Scenarios\n\n### Create Operations\n```typescript\ndescribe('Node Creation E2E', () =\u003e {\n  it('should create a node with no properties', async () =\u003e {\n    const result = await session.run('CREATE (n:Empty) RETURN n')\n    expect(result.records).toHaveLength(1)\n    expect(result.records[0].get('n').labels).toContain('Empty')\n  })\n\n  it('should create a node with properties', async () =\u003e {\n    const result = await session.run(`\n      CREATE (n:Person {name: 'Alice', age: 30, active: true})\n      RETURN n\n    `)\n    const node = result.records[0].get('n')\n    expect(node.properties.name).toBe('Alice')\n    expect(node.properties.age.toInt()).toBe(30)\n    expect(node.properties.active).toBe(true)\n  })\n\n  it('should create a node with multiple labels', async () =\u003e {\n    const result = await session.run('CREATE (n:Person:Employee:Manager) RETURN n')\n    const labels = result.records[0].get('n').labels\n    expect(labels).toContain('Person')\n    expect(labels).toContain('Employee')\n    expect(labels).toContain('Manager')\n  })\n\n  it('should create multiple nodes in one query', async () =\u003e {\n    const result = await session.run(`\n      CREATE (a:Person {name: 'A'}), (b:Person {name: 'B'}), (c:Person {name: 'C'})\n      RETURN a, b, c\n    `)\n    expect(result.records).toHaveLength(1)\n    expect(result.records[0].keys).toHaveLength(3)\n  })\n\n  it('should create nodes with parameters', async () =\u003e {\n    const result = await session.run(\n      'CREATE (n:Person {name: $name, age: $age}) RETURN n',\n      { name: 'Bob', age: 25 }\n    )\n    const node = result.records[0].get('n')\n    expect(node.properties.name).toBe('Bob')\n  })\n})\n```\n\n### Read Operations\n```typescript\ndescribe('Node Reading E2E', () =\u003e {\n  beforeEach(async () =\u003e {\n    await session.run(`\n      CREATE (:Person {name: 'Alice', age: 30}),\n             (:Person {name: 'Bob', age: 25}),\n             (:Person {name: 'Charlie', age: 35})\n    `)\n  })\n\n  it('should read all nodes of a label', async () =\u003e {\n    const result = await session.run('MATCH (n:Person) RETURN n')\n    expect(result.records).toHaveLength(3)\n  })\n\n  it('should filter nodes by property', async () =\u003e {\n    const result = await session.run('MATCH (n:Person {name: \"Alice\"}) RETURN n')\n    expect(result.records).toHaveLength(1)\n    expect(result.records[0].get('n').properties.name).toBe('Alice')\n  })\n\n  it('should filter nodes with WHERE clause', async () =\u003e {\n    const result = await session.run('MATCH (n:Person) WHERE n.age \u003e 26 RETURN n')\n    expect(result.records).toHaveLength(2)\n  })\n\n  it('should order results', async () =\u003e {\n    const result = await session.run('MATCH (n:Person) RETURN n ORDER BY n.age ASC')\n    const ages = result.records.map(r =\u003e r.get('n').properties.age.toInt())\n    expect(ages).toEqual([25, 30, 35])\n  })\n\n  it('should limit results', async () =\u003e {\n    const result = await session.run('MATCH (n:Person) RETURN n LIMIT 2')\n    expect(result.records).toHaveLength(2)\n  })\n\n  it('should skip results', async () =\u003e {\n    const result = await session.run('MATCH (n:Person) RETURN n ORDER BY n.age SKIP 1 LIMIT 1')\n    expect(result.records[0].get('n').properties.age.toInt()).toBe(30)\n  })\n})\n```\n\n### Update Operations\n```typescript\ndescribe('Node Update E2E', () =\u003e {\n  let nodeId: any\n\n  beforeEach(async () =\u003e {\n    const result = await session.run('CREATE (n:Person {name: \"Alice\", age: 30}) RETURN id(n) as id')\n    nodeId = result.records[0].get('id')\n  })\n\n  it('should update existing property', async () =\u003e {\n    await session.run('MATCH (n:Person {name: \"Alice\"}) SET n.age = 31')\n    const result = await session.run('MATCH (n:Person {name: \"Alice\"}) RETURN n.age as age')\n    expect(result.records[0].get('age').toInt()).toBe(31)\n  })\n\n  it('should add new property', async () =\u003e {\n    await session.run('MATCH (n:Person {name: \"Alice\"}) SET n.email = \"alice@example.com\"')\n    const result = await session.run('MATCH (n:Person {name: \"Alice\"}) RETURN n.email as email')\n    expect(result.records[0].get('email')).toBe('alice@example.com')\n  })\n\n  it('should remove property', async () =\u003e {\n    await session.run('MATCH (n:Person {name: \"Alice\"}) REMOVE n.age')\n    const result = await session.run('MATCH (n:Person {name: \"Alice\"}) RETURN n.age as age')\n    expect(result.records[0].get('age')).toBeNull()\n  })\n\n  it('should add label', async () =\u003e {\n    await session.run('MATCH (n:Person {name: \"Alice\"}) SET n:Employee')\n    const result = await session.run('MATCH (n:Person:Employee {name: \"Alice\"}) RETURN n')\n    expect(result.records).toHaveLength(1)\n  })\n\n  it('should remove label', async () =\u003e {\n    await session.run('MATCH (n:Person {name: \"Alice\"}) SET n:Employee')\n    await session.run('MATCH (n:Person {name: \"Alice\"}) REMOVE n:Employee')\n    const result = await session.run('MATCH (n:Employee {name: \"Alice\"}) RETURN n')\n    expect(result.records).toHaveLength(0)\n  })\n\n  it('should replace all properties', async () =\u003e {\n    await session.run('MATCH (n:Person {name: \"Alice\"}) SET n = {name: \"Alicia\", country: \"US\"}')\n    const result = await session.run('MATCH (n:Person {name: \"Alicia\"}) RETURN n')\n    const node = result.records[0].get('n')\n    expect(node.properties.name).toBe('Alicia')\n    expect(node.properties.country).toBe('US')\n    expect(node.properties.age).toBeUndefined()\n  })\n\n  it('should merge properties with +=', async () =\u003e {\n    await session.run('MATCH (n:Person {name: \"Alice\"}) SET n += {email: \"alice@test.com\"}')\n    const result = await session.run('MATCH (n:Person {name: \"Alice\"}) RETURN n')\n    const node = result.records[0].get('n')\n    expect(node.properties.age.toInt()).toBe(30) // Original preserved\n    expect(node.properties.email).toBe('alice@test.com') // New added\n  })\n})\n```\n\n### Delete Operations\n```typescript\ndescribe('Node Deletion E2E', () =\u003e {\n  beforeEach(async () =\u003e {\n    await session.run(`\n      CREATE (a:Person {name: 'Alice'})-[:KNOWS]-\u003e(b:Person {name: 'Bob'}),\n             (c:Person {name: 'Charlie'})\n    `)\n  })\n\n  it('should delete standalone node', async () =\u003e {\n    await session.run('MATCH (n:Person {name: \"Charlie\"}) DELETE n')\n    const result = await session.run('MATCH (n:Person {name: \"Charlie\"}) RETURN n')\n    expect(result.records).toHaveLength(0)\n  })\n\n  it('should fail deleting node with relationships', async () =\u003e {\n    await expect(\n      session.run('MATCH (n:Person {name: \"Alice\"}) DELETE n')\n    ).rejects.toThrow()\n  })\n\n  it('should detach delete node with relationships', async () =\u003e {\n    await session.run('MATCH (n:Person {name: \"Alice\"}) DETACH DELETE n')\n    const result = await session.run('MATCH (n:Person {name: \"Alice\"}) RETURN n')\n    expect(result.records).toHaveLength(0)\n  })\n\n  it('should delete all nodes', async () =\u003e {\n    await session.run('MATCH (n) DETACH DELETE n')\n    const result = await session.run('MATCH (n) RETURN count(n) as count')\n    expect(result.records[0].get('count').toInt()).toBe(0)\n  })\n})\n```\n\n## Acceptance Criteria\n- [ ] All CREATE tests written and failing\n- [ ] All READ tests written and failing\n- [ ] All UPDATE tests written and failing\n- [ ] All DELETE tests written and failing\n- [ ] Edge cases covered\n- [ ] Parameter handling tested","status":"open","priority":2,"issue_type":"task","created_at":"2026-01-05T06:40:08.421903-06:00","updated_at":"2026-01-05T06:40:08.421903-06:00"}
{"id":"neo4j-ygaw","title":"[GREEN] Property Storage - Implement property serialization to pass tests","description":"## Overview\nImplement property storage with type preservation to make all tests pass.\n\n## Implementation Requirements\n\n### Type Markers for Preservation\n```typescript\n// Neo4j types that need special handling\ninterface TypedValue {\n  __neo4j_type__: string;\n  value: unknown;\n}\n\nconst TypeMarkers = {\n  INTEGER: 'integer',\n  FLOAT: 'float', \n  DATE: 'date',\n  DATETIME: 'datetime',\n  DURATION: 'duration',\n  POINT: 'point',\n  BIGINT: 'bigint'\n};\n```\n\n### PropertySerializer Class\n```typescript\nclass PropertySerializer {\n  serialize(properties: Record\u003cstring, unknown\u003e): string {\n    const serializable = this.convertForStorage(properties);\n    return JSON.stringify(serializable);\n  }\n\n  deserialize(json: string): Record\u003cstring, unknown\u003e {\n    const parsed = JSON.parse(json);\n    return this.restoreTypes(parsed);\n  }\n\n  private convertForStorage(obj: unknown): unknown {\n    if (obj === null || obj === undefined) return null;\n    \n    if (typeof obj === 'bigint') {\n      return { __neo4j_type__: 'bigint', value: obj.toString() };\n    }\n    \n    if (obj instanceof Date) {\n      return { __neo4j_type__: 'datetime', value: obj.toISOString() };\n    }\n    \n    if (Number.isInteger(obj)) {\n      return { __neo4j_type__: 'integer', value: obj };\n    }\n    \n    if (Array.isArray(obj)) {\n      return obj.map(item =\u003e this.convertForStorage(item));\n    }\n    \n    if (typeof obj === 'object') {\n      const result: Record\u003cstring, unknown\u003e = {};\n      for (const [key, value] of Object.entries(obj)) {\n        result[key] = this.convertForStorage(value);\n      }\n      return result;\n    }\n    \n    return obj;\n  }\n\n  private restoreTypes(obj: unknown): unknown {\n    if (obj === null || obj === undefined) return null;\n    \n    if (this.isTypedValue(obj)) {\n      return this.restoreTypedValue(obj);\n    }\n    \n    if (Array.isArray(obj)) {\n      return obj.map(item =\u003e this.restoreTypes(item));\n    }\n    \n    if (typeof obj === 'object') {\n      const result: Record\u003cstring, unknown\u003e = {};\n      for (const [key, value] of Object.entries(obj)) {\n        result[key] = this.restoreTypes(value);\n      }\n      return result;\n    }\n    \n    return obj;\n  }\n}\n```\n\n### Nested Property Access\n```typescript\nfunction getNestedProperty(obj: object, path: string): unknown {\n  const parts = path.split('.');\n  let current: unknown = obj;\n  for (const part of parts) {\n    if (current == null) return undefined;\n    current = (current as Record\u003cstring, unknown\u003e)[part];\n  }\n  return current;\n}\n\nfunction setNestedProperty(obj: object, path: string, value: unknown): void {\n  const parts = path.split('.');\n  let current: Record\u003cstring, unknown\u003e = obj as Record\u003cstring, unknown\u003e;\n  for (let i = 0; i \u003c parts.length - 1; i++) {\n    if (!(parts[i] in current)) {\n      current[parts[i]] = {};\n    }\n    current = current[parts[i]] as Record\u003cstring, unknown\u003e;\n  }\n  current[parts[parts.length - 1]] = value;\n}\n\nfunction hasProperty(obj: object, path: string): boolean {\n  return getNestedProperty(obj, path) !== undefined;\n}\n```\n\n## Files to Create\n- `src/storage/property-serializer.ts`\n- `src/storage/property-utils.ts`\n\n## Acceptance Criteria\n- [ ] All RED phase tests pass\n- [ ] Types preserved through round-trip\n- [ ] Nested access works\n- [ ] Null vs missing distinguished\n\n## TDD Phase\n**GREEN** - Minimum code to pass tests","status":"closed","priority":1,"issue_type":"task","created_at":"2026-01-05T06:40:14.828187-06:00","updated_at":"2026-01-05T08:56:35.534475-06:00","closed_at":"2026-01-05T08:56:35.534475-06:00","close_reason":"Tests passing - storage and transactions implemented"}
{"id":"neo4j-ygry","title":"RED: Change Data Capture - Write failing tests for CDC streaming","description":"## Overview\nWrite failing tests for Change Data Capture (CDC) streaming functionality.\n\n## Test Cases\n\n```typescript\ndescribe('Change Data Capture', () =\u003e {\n  describe('Event Emission', () =\u003e {\n    it('should emit event on node creation', async () =\u003e {\n      const events: CDCEvent[] = [];\n      const subscription = await cdc.subscribe('*', (event) =\u003e events.push(event));\n      \n      await session.run('CREATE (p:Person {name: \"Alice\"}) RETURN p');\n      \n      await waitFor(() =\u003e events.length \u003e 0);\n      \n      expect(events[0]).toMatchObject({\n        operation: 'CREATE',\n        entityType: 'node',\n        labels: ['Person'],\n        properties: { name: 'Alice' },\n        timestamp: expect.any(Number)\n      });\n      \n      subscription.unsubscribe();\n    });\n\n    it('should emit event on node update', async () =\u003e {\n      const events: CDCEvent[] = [];\n      await session.run('CREATE (p:Person {name: \"Bob\"})');\n      \n      const subscription = await cdc.subscribe('*', (event) =\u003e events.push(event));\n      await session.run('MATCH (p:Person {name: \"Bob\"}) SET p.age = 30');\n      \n      await waitFor(() =\u003e events.length \u003e 0);\n      \n      expect(events[0]).toMatchObject({\n        operation: 'UPDATE',\n        entityType: 'node',\n        before: { name: 'Bob' },\n        after: { name: 'Bob', age: 30 },\n        changes: { age: { from: null, to: 30 } }\n      });\n      \n      subscription.unsubscribe();\n    });\n\n    it('should emit event on node deletion', async () =\u003e {\n      const events: CDCEvent[] = [];\n      await session.run('CREATE (p:Person {name: \"ToDelete\"})');\n      \n      const subscription = await cdc.subscribe('*', (event) =\u003e events.push(event));\n      await session.run('MATCH (p:Person {name: \"ToDelete\"}) DELETE p');\n      \n      await waitFor(() =\u003e events.length \u003e 0);\n      \n      expect(events[0]).toMatchObject({\n        operation: 'DELETE',\n        entityType: 'node',\n        labels: ['Person'],\n        properties: { name: 'ToDelete' }\n      });\n      \n      subscription.unsubscribe();\n    });\n\n    it('should emit events for relationship changes', async () =\u003e {\n      const events: CDCEvent[] = [];\n      const subscription = await cdc.subscribe('*', (event) =\u003e events.push(event));\n      \n      await session.run(`\n        MATCH (a:Person {name: \"Alice\"}), (b:Person {name: \"Bob\"})\n        CREATE (a)-[r:KNOWS {since: \"2024\"}]-\u003e(b)\n        RETURN r\n      `);\n      \n      await waitFor(() =\u003e events.length \u003e 0);\n      \n      const relEvent = events.find(e =\u003e e.entityType === 'relationship');\n      expect(relEvent).toMatchObject({\n        operation: 'CREATE',\n        entityType: 'relationship',\n        type: 'KNOWS',\n        properties: { since: '2024' }\n      });\n      \n      subscription.unsubscribe();\n    });\n  });\n\n  describe('Filtered Subscriptions', () =\u003e {\n    it('should filter by label', async () =\u003e {\n      const events: CDCEvent[] = [];\n      const subscription = await cdc.subscribe({ labels: ['Person'] }, (event) =\u003e events.push(event));\n      \n      await session.run('CREATE (:Person {name: \"P1\"})');\n      await session.run('CREATE (:Company {name: \"C1\"})');\n      \n      await waitFor(() =\u003e events.length \u003e 0);\n      \n      expect(events).toHaveLength(1);\n      expect(events[0].labels).toContain('Person');\n      \n      subscription.unsubscribe();\n    });\n\n    it('should filter by operation type', async () =\u003e {\n      const events: CDCEvent[] = [];\n      const subscription = await cdc.subscribe({ operations: ['CREATE'] }, (event) =\u003e events.push(event));\n      \n      await session.run('CREATE (p:Person {name: \"New\"})');\n      await session.run('MATCH (p:Person {name: \"New\"}) SET p.age = 25');\n      \n      await waitFor(() =\u003e events.length \u003e 0);\n      \n      expect(events.every(e =\u003e e.operation === 'CREATE')).toBe(true);\n      \n      subscription.unsubscribe();\n    });\n\n    it('should filter by property changes', async () =\u003e {\n      const events: CDCEvent[] = [];\n      const subscription = await cdc.subscribe({ \n        properties: ['email']\n      }, (event) =\u003e events.push(event));\n      \n      await session.run('CREATE (p:Person {name: \"Test\", email: \"test@example.com\"})');\n      \n      expect(events).toHaveLength(1);\n      \n      subscription.unsubscribe();\n    });\n  });\n\n  describe('Webhook Integration', () =\u003e {\n    it('should send webhook on matching events', async () =\u003e {\n      const webhookCalls: any[] = [];\n      mockWebhookServer.onRequest((req) =\u003e webhookCalls.push(req));\n      \n      await cdc.registerWebhook({\n        url: 'http://localhost:9999/webhook',\n        filter: { labels: ['Order'] },\n        secret: 'test-secret'\n      });\n      \n      await session.run('CREATE (:Order {id: \"ORD-123\", total: 99.99})');\n      \n      await waitFor(() =\u003e webhookCalls.length \u003e 0);\n      \n      expect(webhookCalls[0].headers['x-webhook-signature']).toBeDefined();\n      expect(webhookCalls[0].body.event.labels).toContain('Order');\n    });\n\n    it('should retry failed webhooks', async () =\u003e {\n      let attempts = 0;\n      mockWebhookServer.onRequest(() =\u003e {\n        attempts++;\n        if (attempts \u003c 3) throw new Error('Temporary failure');\n      });\n      \n      await cdc.registerWebhook({\n        url: 'http://localhost:9999/webhook',\n        filter: { labels: ['Order'] },\n        retryPolicy: { maxRetries: 3, backoff: 'exponential' }\n      });\n      \n      await session.run('CREATE (:Order {id: \"ORD-456\"})');\n      \n      await waitFor(() =\u003e attempts \u003e= 3);\n      expect(attempts).toBe(3);\n    });\n  });\n\n  describe('Kafka.do Integration', () =\u003e {\n    it('should publish events to Kafka topic', async () =\u003e {\n      const messages: any[] = [];\n      mockKafka.onMessage('graph-changes', (msg) =\u003e messages.push(msg));\n      \n      await cdc.configureKafka({\n        topic: 'graph-changes',\n        filter: { labels: ['Event'] }\n      });\n      \n      await session.run('CREATE (:Event {type: \"UserSignup\", userId: \"123\"})');\n      \n      await waitFor(() =\u003e messages.length \u003e 0);\n      \n      expect(messages[0].value).toMatchObject({\n        operation: 'CREATE',\n        labels: ['Event']\n      });\n    });\n  });\n\n  describe('Event Replay', () =\u003e {\n    it('should replay events from timestamp', async () =\u003e {\n      const timestamp = Date.now();\n      \n      await session.run('CREATE (:Log {msg: \"Event 1\"})');\n      await session.run('CREATE (:Log {msg: \"Event 2\"})');\n      \n      const events = await cdc.replay({ since: timestamp, labels: ['Log'] });\n      \n      expect(events).toHaveLength(2);\n    });\n\n    it('should support cursor-based pagination', async () =\u003e {\n      const page1 = await cdc.replay({ limit: 10 });\n      const page2 = await cdc.replay({ cursor: page1.cursor, limit: 10 });\n      \n      expect(page2.events[0].id).not.toBe(page1.events[0].id);\n    });\n  });\n});\n```\n\n## Acceptance Criteria\n- [ ] All test cases written and failing\n- [ ] Mock webhook server setup\n- [ ] Mock Kafka setup\n- [ ] Event schema defined\n\n## Tags\nsuperset, cdc, change-data-capture, webhooks, kafka, tdd-red","status":"open","priority":2,"issue_type":"task","created_at":"2026-01-05T06:43:25.881157-06:00","updated_at":"2026-01-05T06:43:25.881157-06:00"}
{"id":"neo4j-yi6","title":"GREEN: Transaction Class Core Operations Implementation","description":"## Overview\nImplement Transaction class core operations to pass all RED phase tests.\n\n## Implementation Requirements\n\n### Transaction Class\n```typescript\nclass Transaction {\n  private session: Session\n  private state: TransactionState = 'OPEN'\n  private txId: number\n  private queries: QueryHandle[] = []\n\n  constructor(session: Session, config?: TransactionConfig) {\n    this.session = session\n    this.txId = generateTransactionId()\n  }\n\n  isOpen(): boolean {\n    return this.state === 'OPEN'\n  }\n}\n\ntype TransactionState = 'OPEN' | 'COMMITTED' | 'ROLLED_BACK' | 'FAILED'\n```\n\n### run() Method\n```typescript\nasync run(cypher: string, params?: Record\u003cstring, any\u003e): Promise\u003cResult\u003e {\n  this.ensureOpen()\n  \n  const result = await this.session._executeInTransaction(\n    this.txId,\n    cypher,\n    params\n  )\n  \n  return result\n}\n\nprivate ensureOpen(): void {\n  if (this.state \\!== 'OPEN') {\n    throw new TransactionClosed(`Transaction is ${this.state.toLowerCase()}`)\n  }\n}\n```\n\n### commit() Method\n```typescript\nasync commit(): Promise\u003cvoid\u003e {\n  if (this.state === 'COMMITTED') return\n  \n  if (this.state \\!== 'OPEN') {\n    throw new TransactionClosed('Cannot commit: transaction is not open')\n  }\n\n  try {\n    await this.session._commitTransaction(this.txId)\n    this.state = 'COMMITTED'\n    // Generate and update bookmark\n    const bookmark = generateBookmark(this.session.database, this.txId)\n    this.session._updateBookmarks(bookmark)\n  } catch (error) {\n    this.state = 'FAILED'\n    throw error\n  }\n}\n```\n\n### rollback() Method\n```typescript\nasync rollback(): Promise\u003cvoid\u003e {\n  if (this.state === 'ROLLED_BACK' || this.state === 'COMMITTED') return\n  \n  try {\n    await this.session._rollbackTransaction(this.txId)\n  } finally {\n    this.state = 'ROLLED_BACK'\n  }\n}\n```\n\n## Files to Create/Modify\n- `src/transaction/transaction.ts`\n- `src/transaction/types.ts`\n- `src/errors/transaction-closed.ts`\n\n## TDD Phase\n**GREEN** - Implement to pass tests.\n\n## Dependencies\n- Depends on: RED: Transaction Class Core Operations Tests\n- Depends on: GREEN: Session Bookmarks \u0026 Lifecycle Implementation\n\n## Acceptance Criteria\n- [ ] All RED phase tests pass\n- [ ] ACID properties maintained\n- [ ] State transitions are correct\n- [ ] Proper error handling","status":"closed","priority":1,"issue_type":"task","created_at":"2026-01-05T06:38:28.895111-06:00","updated_at":"2026-01-05T08:57:46.159214-06:00","closed_at":"2026-01-05T08:57:46.159214-06:00","close_reason":"Translation and session tests passing"}
{"id":"neo4j-ysah","title":"REFACTOR: DELETE Translation","description":"## Overview\nRefactor DELETE translation for safety and efficiency.\n\n## Refactoring Tasks\n\n### 1. Delete Strategy Pattern\n- SimpleDeleteStrategy for relationships\n- ConstrainedDeleteStrategy for nodes\n- CascadeDeleteStrategy for DETACH DELETE\n\n### 2. Integrity Guard\n- Centralized relationship existence check\n- Clear error messages for constraint violations\n\n### 3. Batch Optimization\n- Collect deletions and execute in batches\n- Single transaction for DETACH DELETE\n\n### 4. Delete Execution Order\n- Sort deletions to handle dependencies\n- Relationships before nodes\n\n## Quality Improvements\n- Clean strategy selection\n- Consistent error handling\n- Transaction safety\n- Performance for large deletes\n\n## Acceptance Criteria\n- All tests still pass\n- Delete operations are safe\n- Code is maintainable\n\n## TDD Phase\nREFACTOR - Improve code quality while keeping tests green\n\n## Dependencies\n- Depends on: GREEN: DELETE Translation","status":"closed","priority":1,"issue_type":"task","created_at":"2026-01-05T06:40:29.952956-06:00","updated_at":"2026-01-05T08:55:39.253157-06:00","closed_at":"2026-01-05T08:55:39.253157-06:00","close_reason":"Translation already implemented with tests"}
{"id":"neo4j-yxe","title":"[RED] Spatial Types (Point) - Write Failing Tests","description":"## Overview\nWrite comprehensive failing tests for the Neo4j Point spatial type before implementation.\n\n## TDD Phase: RED (Write Failing Tests)\n\n### Test Cases to Write\n\n#### Point Construction\n```typescript\n// 2D Cartesian point\nnew Point(7203, x, y)\n\n// 3D Cartesian point\nnew Point(9157, x, y, z)\n\n// 2D Geographic point (WGS 84)\nnew Point(4326, longitude, latitude)\n\n// 3D Geographic point (WGS 84 + height)\nnew Point(4979, longitude, latitude, height)\n```\n\n#### SRID Constants\n- `SRID.CARTESIAN_2D = 7203`\n- `SRID.CARTESIAN_3D = 9157`\n- `SRID.WGS84_2D = 4326`\n- `SRID.WGS84_3D = 4979`\n\n#### Property Access\n```typescript\npoint.srid        // Spatial Reference ID\npoint.x           // X coordinate / Longitude\npoint.y           // Y coordinate / Latitude\npoint.z           // Z coordinate / Height (undefined for 2D)\n```\n\n#### Type Guard\n```typescript\nneo4j.isPoint(point)  // true for Point instances\nneo4j.isPoint({})     // false for plain objects\nneo4j.isPoint(null)   // false for null\n```\n\n#### Serialization\n```typescript\npoint.toString()      // String representation\nJSON.stringify(point) // JSON serialization\n```\n\n#### Factory Function\n```typescript\nneo4j.types.Point     // Point class export\n```\n\n### Edge Cases to Test\n- [ ] Invalid SRID values\n- [ ] Missing required coordinates\n- [ ] Z coordinate for 2D points (should be undefined)\n- [ ] Coordinate boundary values\n- [ ] NaN and Infinity coordinates\n- [ ] Geographic coordinate ranges (-180 to 180, -90 to 90)\n\n### Test File Structure\n```\nsrc/types/spatial/\n  point.test.ts\n  srid.test.ts\n```\n\n### Acceptance Criteria\n- [ ] All tests written and failing (RED state)\n- [ ] Tests match neo4j-driver Point API\n- [ ] All SRID types covered\n- [ ] Both 2D and 3D variants tested\n- [ ] Edge cases documented\n\n### References\n- [Neo4j Spatial Types](https://neo4j.com/docs/cypher-manual/current/syntax/spatial/)","status":"closed","priority":1,"issue_type":"task","created_at":"2026-01-05T06:36:53.218634-06:00","updated_at":"2026-01-05T08:58:01.758346-06:00","closed_at":"2026-01-05T08:58:01.758346-06:00","close_reason":"AST, lexer and types tests passing"}
{"id":"neo4j-yzyz","title":"REFACTOR: Change Data Capture - Add durability and batching","description":"## Overview\nRefactor CDC for production reliability and advanced streaming.\n\n## Goals\n\n### 1. Durability\n- Durable Object for subscription state\n- At-least-once delivery guarantee\n- Dead letter queue for failed deliveries\n\n### 2. Batching\n- Batch event processing\n- Configurable batch size and wait time\n- Deduplication within batches\n\n### 3. Advanced Filtering\n- Property-based filtering\n- Custom filter functions\n- Windowed aggregations\n\n### 4. Stream Processing DSL\n- Fluent API for stream processing\n- Window functions\n- Aggregations\n\n### 5. Observability\n- Event processing metrics\n- Delivery latency tracking\n- Health checks\n\n## Acceptance Criteria\n- [ ] All tests still passing\n- [ ] Zero event loss under failures\n- [ ] Less than 100ms p99 delivery latency\n- [ ] Efficient log compaction\n\n## Tags\nsuperset, cdc, tdd-refactor, reliability","status":"open","priority":3,"issue_type":"task","created_at":"2026-01-05T06:49:02.745998-06:00","updated_at":"2026-01-05T06:49:02.745998-06:00"}
{"id":"neo4j-zgu","title":"REFACTOR: Vector Search - Optimize search performance and add advanced features","description":"## Overview\nRefactor vector search implementation for optimal performance and enhanced features.\n\n## Refactoring Goals\n\n### 1. Performance Optimization\n- Implement approximate nearest neighbor (ANN) tuning\n- Add query result caching with TTL\n- Optimize metadata filtering in Vectorize\n- Batch vector upserts for bulk operations\n\n### 2. Advanced Query Features\n```typescript\ninterface AdvancedSearchOptions {\n  // Re-ranking with cross-encoder\n  rerank?: {\n    enabled: boolean;\n    model?: string;\n    topK?: number; // Re-rank top K from initial results\n  };\n  \n  // Diversity sampling\n  diversity?: {\n    enabled: boolean;\n    lambda?: number; // MMR lambda parameter\n  };\n  \n  // Fusion with keyword search\n  fusion?: {\n    enabled: boolean;\n    keywordWeight?: number;\n    vectorWeight?: number;\n  };\n}\n```\n\n### 3. Index Management\n- Background index rebuilding\n- Index statistics and health checks\n- Automatic dimension inference\n- Index migration utilities\n\n### 4. Monitoring \u0026 Observability\n- Search latency metrics\n- Index size tracking\n- Query analytics (popular queries, zero-result queries)\n- Vectorize quota monitoring\n\n### 5. Code Quality\n- Extract search strategy pattern\n- Add comprehensive error types\n- Implement retry logic for Vectorize calls\n- Add structured logging\n\n## Tasks\n- [ ] Implement query result caching\n- [ ] Add re-ranking support\n- [ ] Create MMR diversity sampling\n- [ ] Build hybrid fusion search\n- [ ] Add index health monitoring\n- [ ] Create migration utilities\n- [ ] Performance benchmark suite\n\n## Acceptance Criteria\n- [ ] All tests still passing\n- [ ] \u003c 50ms p99 latency for cached queries\n- [ ] Re-ranking improving relevance metrics\n- [ ] Comprehensive monitoring dashboard\n\n## Tags\nsuperset, vector-search, vectorize, tdd-refactor, performance","status":"open","priority":3,"issue_type":"task","created_at":"2026-01-05T06:36:42.054881-06:00","updated_at":"2026-01-05T06:36:42.054881-06:00"}
{"id":"neo4j-zjax","title":"[GREEN] Backup and Recovery - Implement export/import to pass tests","description":"## Overview\nImplement backup and recovery operations to make all tests pass.\n\n## Implementation Requirements\n\n### Cypher Exporter\n```typescript\nclass CypherExporter {\n  constructor(private nodeOps: NodeOperations, private relOps: RelationshipOperations) {}\n\n  exportToCypher(): string {\n    const statements: string[] = [];\n    \n    // Export nodes\n    for (const node of this.nodeOps.getAllNodes()) {\n      const labels = node.labels.map(l =\u003e `:${l}`).join('');\n      const props = this.formatProperties(node.properties);\n      statements.push(`CREATE (n${node.id}${labels} ${props});`);\n    }\n    \n    // Export relationships\n    for (const rel of this.relOps.getAllRelationships()) {\n      const props = this.formatProperties(rel.properties);\n      statements.push(\n        `MATCH (a), (b) WHERE id(a) = ${rel.startNodeId} AND id(b) = ${rel.endNodeId} ` +\n        `CREATE (a)-[:${rel.type} ${props}]-\u003e(b);`\n      );\n    }\n    \n    return statements.join('\\n');\n  }\n\n  private formatProperties(props: Record\u003cstring, unknown\u003e): string {\n    if (Object.keys(props).length === 0) return '';\n    const pairs = Object.entries(props).map(([k, v]) =\u003e \n      `${k}: ${this.formatValue(v)}`\n    );\n    return `{${pairs.join(', ')}}`;\n  }\n\n  private formatValue(value: unknown): string {\n    if (typeof value === 'string') return `'${this.escapeString(value)}'`;\n    if (typeof value === 'number') return String(value);\n    if (typeof value === 'boolean') return String(value);\n    if (value === null) return 'null';\n    if (Array.isArray(value)) return `[${value.map(v =\u003e this.formatValue(v)).join(', ')}]`;\n    return JSON.stringify(value);\n  }\n\n  private escapeString(s: string): string {\n    return s.replace(/\\\\/g, '\\\\\\\\').replace(/'/g, \"\\\\'\"}).replace(/\\n/g, '\\\\n');\n  }\n}\n```\n\n### JSON Exporter\n```typescript\ninterface GraphJson {\n  version: string;\n  metadata: {\n    exportedAt: string;\n    nodeCount: number;\n    relationshipCount: number;\n  };\n  nodes: Array\u003c{\n    id: number;\n    labels: string[];\n    properties: Record\u003cstring, unknown\u003e;\n  }\u003e;\n  relationships: Array\u003c{\n    id: number;\n    type: string;\n    startNodeId: number;\n    endNodeId: number;\n    properties: Record\u003cstring, unknown\u003e;\n  }\u003e;\n}\n\nclass JsonExporter {\n  export(): GraphJson {\n    return {\n      version: '1.0',\n      metadata: {\n        exportedAt: new Date().toISOString(),\n        nodeCount: this.nodeOps.count(),\n        relationshipCount: this.relOps.count()\n      },\n      nodes: this.nodeOps.getAllNodes(),\n      relationships: this.relOps.getAllRelationships()\n    };\n  }\n  \n  exportStream(): ReadableStream\u003cstring\u003e {\n    // For large graphs, stream JSON\n  }\n}\n```\n\n### Importer\n```typescript\nclass GraphImporter {\n  importFromJson(json: GraphJson): ImportResult {\n    return this.sql.transaction(() =\u003e {\n      const idMapping = new Map\u003cnumber, number\u003e();\n      \n      // Import nodes\n      for (const node of json.nodes) {\n        const created = this.nodeOps.createNode(node.labels, node.properties);\n        idMapping.set(node.id, created.id);\n      }\n      \n      // Import relationships with mapped IDs\n      for (const rel of json.relationships) {\n        const startId = idMapping.get(rel.startNodeId);\n        const endId = idMapping.get(rel.endNodeId);\n        if (\\!startId || \\!endId) {\n          throw new Error(`Invalid node reference in relationship`);\n        }\n        this.relOps.createRelationship(rel.type, startId, endId, rel.properties);\n      }\n      \n      return {\n        nodesImported: json.nodes.length,\n        relationshipsImported: json.relationships.length\n      };\n    });\n  }\n}\n```\n\n## Files to Create\n- `src/storage/backup/cypher-exporter.ts`\n- `src/storage/backup/json-exporter.ts`\n- `src/storage/backup/importer.ts`\n\n## Acceptance Criteria\n- [ ] All RED phase tests pass\n- [ ] Cypher export works\n- [ ] JSON export works\n- [ ] Import is transactional\n- [ ] IDs remapped correctly\n\n## TDD Phase\n**GREEN** - Minimum code to pass tests","status":"open","priority":2,"issue_type":"task","created_at":"2026-01-05T06:42:53.295565-06:00","updated_at":"2026-01-05T06:42:53.295565-06:00"}
{"id":"neo4j-zm0u","title":"[GREEN] Parser: Implement MATCH Clause Parsing","description":"## Overview\nImplement MATCH clause parsing to pass all tests.\n\n## Implementation Tasks\n\n### Clause Parser (src/parser/clause-parser.ts)\n```typescript\nexport class ClauseParser {\n  parseMatchClause(): MatchClause {\n    const start = this.pos\n    const optional = this.match('OPTIONAL')\n    \n    this.expect('MATCH')\n    \n    const patterns = this.patternParser.parsePatternList()\n    \n    let where: Expression | undefined\n    if (this.match('WHERE')) {\n      where = this.expressionParser.parseExpression()\n    }\n    \n    return {\n      type: 'MatchClause',\n      optional,\n      patterns,\n      where,\n      loc: this.getLoc(start)\n    }\n  }\n}\n```\n\n### Integration with Main Parser\n```typescript\nparseClause(): Clause {\n  const token = this.peek()\n  \n  if (token.value === 'MATCH' || token.value === 'OPTIONAL') {\n    return this.parseMatchClause()\n  }\n  // ... other clauses\n}\n```\n\n## Acceptance Criteria\n- [ ] All MATCH clause tests pass\n- [ ] OPTIONAL flag correctly set\n- [ ] WHERE clause correctly attached\n- [ ] Patterns correctly parsed\n\n## TDD Phase: GREEN\n## Depends On: neo4j-3gi0","status":"closed","priority":1,"issue_type":"task","created_at":"2026-01-05T06:42:13.646482-06:00","updated_at":"2026-01-05T07:19:48.954746-06:00","closed_at":"2026-01-05T07:19:48.954746-06:00","close_reason":"Parser implemented with MATCH, RETURN, node/relationship patterns, expressions - 34 parser tests pass"}
{"id":"neo4j-zofo","title":"[RED] Cypher Query Result Validation Tests","description":"# [RED] Cypher Query Result Validation Tests\n\n## Overview\nCreate comprehensive tests for validating that Cypher query results are correctly structured and contain accurate data.\n\n## Result Structure Tests\n\n### Record Structure\n```typescript\ndescribe('Record Structure Validation', () =\u003e {\n  it('should return records with correct field access', async () =\u003e {\n    const result = await session.run('RETURN 1 AS num, \"hello\" AS str')\n    const record = result.records[0]\n    \n    // Named access\n    expect(record.get('num')).toBeDefined()\n    expect(record.get('str')).toBeDefined()\n    \n    // Index access\n    expect(record.get(0)).toBeDefined()\n    expect(record.get(1)).toBeDefined()\n    \n    // Keys\n    expect(record.keys).toEqual(['num', 'str'])\n    \n    // Values\n    expect(record.values()).toHaveLength(2)\n    \n    // toObject\n    expect(record.toObject()).toEqual({ num: expect.any(Object), str: 'hello' })\n  })\n\n  it('should handle missing field access', async () =\u003e {\n    const result = await session.run('RETURN 1 AS num')\n    const record = result.records[0]\n    \n    expect(() =\u003e record.get('nonexistent')).toThrow()\n    expect(record.has('num')).toBe(true)\n    expect(record.has('nonexistent')).toBe(false)\n  })\n})\n```\n\n### Node Result Validation\n```typescript\ndescribe('Node Result Validation', () =\u003e {\n  it('should return node with all properties', async () =\u003e {\n    await session.run('CREATE (n:Person {name: \"Alice\", age: 30})')\n    const result = await session.run('MATCH (n:Person {name: \"Alice\"}) RETURN n')\n    const node = result.records[0].get('n')\n    \n    expect(node.labels).toContain('Person')\n    expect(node.properties.name).toBe('Alice')\n    expect(node.properties.age.toInt()).toBe(30)\n    expect(node.identity).toBeDefined()\n    expect(node.elementId).toBeDefined()\n  })\n\n  it('should handle multi-label nodes', async () =\u003e {\n    await session.run('CREATE (n:Person:Employee {name: \"Bob\"})')\n    const result = await session.run('MATCH (n:Person:Employee) RETURN n')\n    const node = result.records[0].get('n')\n    \n    expect(node.labels).toContain('Person')\n    expect(node.labels).toContain('Employee')\n  })\n})\n```\n\n### Relationship Result Validation\n```typescript\ndescribe('Relationship Result Validation', () =\u003e {\n  it('should return relationship with all properties', async () =\u003e {\n    await session.run(`\n      CREATE (a:Person {name: \"Alice\"})-[r:KNOWS {since: 2020}]-\u003e(b:Person {name: \"Bob\"})\n    `)\n    const result = await session.run('MATCH ()-[r:KNOWS]-\u003e() RETURN r')\n    const rel = result.records[0].get('r')\n    \n    expect(rel.type).toBe('KNOWS')\n    expect(rel.properties.since.toInt()).toBe(2020)\n    expect(rel.start).toBeDefined()\n    expect(rel.end).toBeDefined()\n    expect(rel.identity).toBeDefined()\n    expect(rel.elementId).toBeDefined()\n  })\n})\n```\n\n### Path Result Validation\n```typescript\ndescribe('Path Result Validation', () =\u003e {\n  it('should return path with segments', async () =\u003e {\n    await session.run(`\n      CREATE (a:Person {name: \"A\"})-[:KNOWS]-\u003e(b:Person {name: \"B\"})-[:KNOWS]-\u003e(c:Person {name: \"C\"})\n    `)\n    const result = await session.run('MATCH p=(a)-[*]-\u003e(c) WHERE a.name = \"A\" RETURN p')\n    const path = result.records[0].get('p')\n    \n    expect(path.start).toBeDefined()\n    expect(path.end).toBeDefined()\n    expect(path.segments).toHaveLength(2)\n    expect(path.length).toBe(2)\n  })\n})\n```\n\n### Aggregation Result Validation\n```typescript\ndescribe('Aggregation Result Validation', () =\u003e {\n  beforeEach(async () =\u003e {\n    await session.run(`\n      CREATE (:Product {price: 10}),\n             (:Product {price: 20}),\n             (:Product {price: 30})\n    `)\n  })\n\n  it('should validate count results', async () =\u003e {\n    const result = await session.run('MATCH (p:Product) RETURN count(p) AS count')\n    expect(result.records[0].get('count').toInt()).toBe(3)\n  })\n\n  it('should validate sum results', async () =\u003e {\n    const result = await session.run('MATCH (p:Product) RETURN sum(p.price) AS total')\n    expect(result.records[0].get('total').toInt()).toBe(60)\n  })\n\n  it('should validate collect results', async () =\u003e {\n    const result = await session.run('MATCH (p:Product) RETURN collect(p.price) AS prices')\n    const prices = result.records[0].get('prices').map((p: any) =\u003e p.toInt())\n    expect(prices).toHaveLength(3)\n    expect(prices).toContain(10)\n    expect(prices).toContain(20)\n    expect(prices).toContain(30)\n  })\n})\n```\n\n## Summary Validation\n```typescript\ndescribe('Result Summary Validation', () =\u003e {\n  it('should include query statistics', async () =\u003e {\n    const result = await session.run('CREATE (n:Test) RETURN n')\n    \n    expect(result.summary.counters.nodesCreated()).toBe(1)\n    expect(result.summary.counters.labelsAdded()).toBe(1)\n    expect(result.summary.query.text).toBe('CREATE (n:Test) RETURN n')\n  })\n\n  it('should include timing information', async () =\u003e {\n    const result = await session.run('MATCH (n) RETURN n LIMIT 10')\n    \n    expect(result.summary.resultAvailableAfter).toBeDefined()\n    expect(result.summary.resultConsumedAfter).toBeDefined()\n  })\n\n  it('should include plan when profiled', async () =\u003e {\n    const result = await session.run('PROFILE MATCH (n) RETURN n')\n    \n    expect(result.summary.plan).toBeDefined()\n    expect(result.summary.profile).toBeDefined()\n  })\n})\n```\n\n## Acceptance Criteria\n- [ ] Record structure tests written\n- [ ] Node validation tests written\n- [ ] Relationship validation tests written\n- [ ] Path validation tests written\n- [ ] Aggregation validation tests written\n- [ ] Summary validation tests written\n- [ ] Tests fail initially (RED phase)","status":"open","priority":2,"issue_type":"task","created_at":"2026-01-05T06:39:27.493941-06:00","updated_at":"2026-01-05T06:39:27.493941-06:00"}
