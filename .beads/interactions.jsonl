{"id":"neo4j-00x","title":"REFACTOR: MATCH Clause Translation","description":"## Overview\nRefactor MATCH clause translation for cleanliness and extensibility.\n\n## Refactoring Tasks\n\n### 1. Query Builder Pattern\n- Fluent API for building SELECT queries\n- Chainable methods for FROM, JOIN, WHERE\n\n### 2. Join Type Abstraction\n- INNER JOIN, LEFT JOIN, CROSS JOIN strategies\n- Clean interface for join generation\n\n### 3. Variable Scope Manager\n- Track variable visibility across clauses\n- Handle shadowing and rebinding\n\n### 4. Pattern Combination Logic\n- Extract pattern connection detection\n- Optimize join order\n\n## Quality Improvements\n- No code duplication\n- Single responsibility per function\n- Comprehensive type definitions\n- Performance profiling\n\n## Acceptance Criteria\n- All tests still pass after refactoring\n- Code is more readable and maintainable\n- No new technical debt\n\n## TDD Phase\nREFACTOR - Improve code quality while keeping tests green\n\n## Dependencies\n- Depends on: GREEN: MATCH Clause Translation","status":"open","priority":1,"issue_type":"task","created_at":"2026-01-05T06:38:07.355028-06:00","updated_at":"2026-01-05T06:38:07.355028-06:00"}
{"id":"neo4j-04d","title":"RED: Write failing tests for rxSession.executeRead() method","description":"## Overview\nWrite failing tests for rxSession.executeRead() transaction function for read operations.\n\n## Test Cases to Write\n\n### Basic Transaction Function Tests\n- executeRead(work) returns Observable\n- Work function receives RxManagedTransaction\n- Work function can run queries\n- Returns result of work function\n\n### Transaction Behavior Tests\n- Transaction auto-commits on success\n- Transaction auto-rollbacks on error\n- Read access mode is enforced\n- Bookmarks are respected\n\n### Observable Semantics Tests\n- Cold observable (lazy execution)\n- Proper completion on success\n- Error emission on failure\n- Supports async work functions\n\n### Retry Behavior Tests\n- Retries on transient errors\n- Respects retry configuration\n- Non-retriable errors propagate immediately\n\n## Acceptance Criteria\n- All tests written and failing (RED phase)\n- Tests cover transaction lifecycle\n- Tests verify Observable behavior\n- Tests cover retry scenarios","status":"open","priority":2,"issue_type":"task","created_at":"2026-01-05T06:36:04.311815-06:00","updated_at":"2026-01-05T06:36:04.311815-06:00"}
{"id":"neo4j-070","title":"[RED] AST: Visitor Pattern Tests","description":"## Overview\nWrite failing tests for AST visitor pattern implementation.\n\n## Test Cases to Write\n\n### Visitor Interface\n```typescript\ninterface ASTVisitor\u003cT\u003e {\n  visitQuery(node: Query): T\n  visitMatchClause(node: MatchClause): T\n  visitReturnClause(node: ReturnClause): T\n  visitNodePattern(node: NodePattern): T\n  visitBinaryExpression(node: BinaryExpression): T\n  // ... all node types\n}\n```\n\n### Base Visitor\n- Test default visit behavior (visit children)\n- Test visit method dispatching\n- Test pre/post visit hooks\n\n### Walk Function\n```typescript\nfunction walk(node: ASTNode, visitor: ASTVisitor): void\nfunction walkExpression(node: Expression, visitor: ASTVisitor): void\n```\n\n### Test Scenarios\n- Count all nodes of a specific type\n- Collect all identifiers\n- Transform expressions\n- Validate patterns\n\n### Enter/Exit Pattern\n```typescript\ninterface ASTVisitor {\n  enter?(node: ASTNode): void\n  exit?(node: ASTNode): void\n  enterMatchClause?(node: MatchClause): void\n  exitMatchClause?(node: MatchClause): void\n}\n```\n\n## Acceptance Criteria\n- [ ] All visitor tests written\n- [ ] Tests cover visitor dispatch\n- [ ] Tests verify traversal order\n- [ ] Transform use case tested\n\n## TDD Phase: RED","status":"open","priority":1,"issue_type":"task","created_at":"2026-01-05T06:38:51.020059-06:00","updated_at":"2026-01-05T06:38:51.020059-06:00"}
{"id":"neo4j-0be","title":"REFACTOR: Driver Lifecycle Methods Optimization","description":"## Overview\nRefactor Driver lifecycle methods for robustness and edge case handling.\n\n## Refactoring Goals\n\n### Concurrency Safety\n- Thread-safe session tracking\n- Atomic close operation\n- Race condition prevention\n\n### Resource Management\n- WeakRef for session tracking (memory efficiency)\n- Proper cleanup on unexpected errors\n- Timeout handling for stuck sessions\n\n### Edge Cases\n```typescript\ndescribe('Driver Lifecycle Edge Cases', () =\u003e {\n  it('should handle concurrent session creation')\n  it('should handle session close during driver close')\n  it('should handle executeQuery during driver close')\n  it('should timeout waiting for sessions on close')\n  it('should handle rapid open/close cycles')\n  it('should recover from partial initialization')\n  it('should handle getServerInfo with network partition')\n})\n```\n\n### Observability\n- Add telemetry hooks\n- Session lifecycle logging\n- Connection pool metrics\n\n## TDD Phase\n**REFACTOR** - Improve without breaking tests.\n\n## Dependencies\n- Depends on: GREEN: Driver Lifecycle Methods Implementation\n\n## Acceptance Criteria\n- [ ] All tests pass\n- [ ] Concurrent operations are safe\n- [ ] Memory leaks eliminated\n- [ ] Graceful degradation on errors","status":"open","priority":2,"issue_type":"task","created_at":"2026-01-05T06:35:57.587463-06:00","updated_at":"2026-01-05T06:35:57.587463-06:00"}
{"id":"neo4j-0bw","title":"GREEN: CREATE/MERGE Translation","description":"## Overview\nImplement CREATE and MERGE clause translation to make RED tests pass.\n\n## Implementation Tasks\n\n### 1. CreateClauseTranslator\n- translateCreateNode(): Generate INSERT INTO nodes\n- translateCreateRelationship(): Generate INSERT INTO relationships\n- generateId(): UUID generation for new entities\n\n### 2. MergeClauseTranslator\n- translateMergeNode(): INSERT OR IGNORE pattern\n- translateMergeRelationship(): Upsert with conflict handling\n- handleOnCreate(): Conditional SET for new entities\n- handleOnMatch(): Conditional SET for existing entities\n\n### 3. Property Serialization\n- Serialize property maps to JSON\n- Handle nested objects and arrays\n\n### 4. Variable Binding for Created Entities\n- Return created IDs for later use\n- Bind variables to new entities\n\n## Files to Create/Modify\n- src/cypher/translator/create-clause-translator.ts\n- src/cypher/translator/merge-clause-translator.ts\n- src/cypher/translator/id-generator.ts\n\n## Acceptance Criteria\n- All RED phase tests pass\n- MERGE correctly uses INSERT OR IGNORE\n- ON CREATE/ON MATCH conditions work\n\n## TDD Phase\nGREEN - Make tests pass with minimal code\n\n## Dependencies\n- Depends on: RED: CREATE/MERGE Translation","status":"open","priority":1,"issue_type":"task","created_at":"2026-01-05T06:38:42.427213-06:00","updated_at":"2026-01-05T06:38:42.427213-06:00"}
{"id":"neo4j-0d9","title":"[RED] Lexer: Numeric Literal Tests","description":"## Overview\nWrite failing tests for numeric literal tokenization.\n\n## Test Cases to Write\n\n### Integer Literals\n- Simple: `0`, `1`, `123`, `999999`\n- Negative: `-1`, `-123` (may be operator + integer)\n- Leading zeros: `007` (should be valid integer)\n\n### Floating Point Literals\n- Simple: `1.0`, `3.14`, `0.5`\n- No leading digit: `.5` (if supported)\n- No trailing digit: `5.` (if supported)\n- Negative: `-1.5`\n\n### Scientific Notation\n- Lowercase: `1e10`, `1e-10`, `1e+10`\n- Uppercase: `1E10`, `1E-10`\n- With decimal: `1.5e10`, `3.14e-5`\n\n### Hexadecimal Literals\n- Lowercase: `0x1a`, `0xff`\n- Uppercase: `0X1A`, `0xFF`\n- Mixed: `0xDeAdBeEf`\n\n### Octal Literals (if supported)\n- `0o777`, `0O123`\n\n### Edge Cases\n- Number at end of input\n- Number followed by identifier (should be two tokens)\n- Invalid number formats (error cases)\n\n## Acceptance Criteria\n- [ ] All tests written and failing\n- [ ] Tests cover integers, floats, scientific, hex\n- [ ] Edge cases documented\n- [ ] Error cases have proper messages\n\n## TDD Phase: RED","status":"open","priority":1,"issue_type":"task","created_at":"2026-01-05T06:35:42.892714-06:00","updated_at":"2026-01-05T06:35:42.892714-06:00"}
{"id":"neo4j-0h4","title":"GREEN: Record.length - Implement column count property","description":"## Overview\nImplement the Record.length property to make all RED phase tests pass.\n\n## Implementation\n\n```typescript\nget length(): number {\n  return this._keys.length;\n}\n```\n\n## Acceptance Criteria\n- [ ] All RED phase tests now pass (GREEN phase)\n- [ ] Returns correct column count\n- [ ] Property is read-only\n- [ ] Implementation is minimal\n\n## TDD Phase\nGREEN - Minimal implementation to pass tests\n\n## Dependencies\n- neo4j-gjj (RED phase tests)","status":"open","priority":1,"issue_type":"task","created_at":"2026-01-05T06:38:29.570807-06:00","updated_at":"2026-01-05T06:38:29.570807-06:00"}
{"id":"neo4j-0jw","title":"REFACTOR: Improve rxSession.close() implementation","description":"## Overview\nRefactor rxSession.close() for robust resource management.\n\n## Refactoring Tasks\n\n### Code Quality\n- Extract cleanup logic\n- Improve error handling during cleanup\n- Add proper state management\n- Document cleanup order\n\n### Resource Safety\n- Ensure cleanup happens even on errors\n- Handle partial cleanup failures\n- Add cleanup timeout handling\n- Consider finalize operator usage\n\n### Integration\n- Align with sync session.close()\n- Share cleanup logic where possible\n- Consistent logging of cleanup\n\n## Acceptance Criteria\n- All tests still pass\n- Robust cleanup handling\n- Clear error reporting\n- Well-documented cleanup process","status":"open","priority":2,"issue_type":"task","created_at":"2026-01-05T06:38:10.38188-06:00","updated_at":"2026-01-05T06:38:10.38188-06:00"}
{"id":"neo4j-0wy","title":"[GREEN] Lexer: Implement Numeric Literal Parsing","description":"## Overview\nImplement numeric literal tokenization to pass all numeric tests.\n\n## Implementation Tasks\n\n### Integer Scanner\n```typescript\nprivate scanInteger(): Token {\n  // Scan consecutive digits\n  // Check for hex prefix 0x/0X\n  // Check for octal prefix 0o/0O\n  // Return INTEGER token with value\n}\n```\n\n### Float Scanner\n```typescript\nprivate scanFloat(integerPart: string): Token {\n  // Scan decimal point\n  // Scan fractional part\n  // Check for exponent e/E\n  // Scan exponent sign and digits\n  // Return FLOAT token\n}\n```\n\n### Number Type Detection\n- Determine if integer or float\n- Handle scientific notation\n- Parse hex/octal values\n\n## Acceptance Criteria\n- [ ] All numeric literal tests pass\n- [ ] Correct token type (INTEGER vs FLOAT)\n- [ ] Values correctly parsed\n- [ ] Hex and scientific notation work\n\n## TDD Phase: GREEN\n## Depends On: neo4j-0d9","status":"open","priority":1,"issue_type":"task","created_at":"2026-01-05T06:35:57.701712-06:00","updated_at":"2026-01-05T06:35:57.701712-06:00"}
{"id":"neo4j-0yo","title":"GREEN: Record.has(key) - Implement column existence check","description":"## Overview\nImplement the Record.has(key) method to make all RED phase tests pass.\n\n## Implementation\n\n```typescript\nhas(key: string): boolean {\n  return this._fieldLookup.has(key);\n}\n```\n\n## Acceptance Criteria\n- [ ] All RED phase tests now pass (GREEN phase)\n- [ ] Uses existing field lookup Map\n- [ ] O(1) lookup performance\n- [ ] Implementation is minimal\n\n## TDD Phase\nGREEN - Minimal implementation to pass tests\n\n## Dependencies\n- neo4j-w5n (RED phase tests)","status":"open","priority":1,"issue_type":"task","created_at":"2026-01-05T06:39:10.026625-06:00","updated_at":"2026-01-05T06:39:10.026625-06:00"}
{"id":"neo4j-11c","title":"RED: Write failing tests for rxTx.run() method","description":"## Overview\nWrite failing tests for rxTx.run() query execution within reactive transaction.\n\n## Test Cases to Write\n\n### Basic Query Tests\n- rxTx.run(cypher) returns RxResult\n- rxTx.run(cypher, params) accepts parameters\n- Query executes within transaction context\n- Multiple queries share transaction\n\n### Parameter Tests\n- All Neo4j types supported as parameters\n- Handles null and undefined correctly\n- Complex nested objects work\n\n### Transaction Context Tests\n- Query sees uncommitted changes from same tx\n- Query isolated from other transactions\n- Transaction state affects query behavior\n\n### Observable Behavior Tests\n- Cold observable (lazy execution)\n- Proper error propagation\n- Query cancelled on unsubscription\n\n## Acceptance Criteria\n- All tests written and failing (RED phase)\n- Tests verify transaction context\n- Tests cover parameter handling\n- Tests verify Observable semantics","status":"open","priority":2,"issue_type":"task","created_at":"2026-01-05T06:38:38.301249-06:00","updated_at":"2026-01-05T06:38:38.301249-06:00"}
{"id":"neo4j-147","title":"[RED] Neo4j Driver Error Message Compatibility Tests","description":"# [RED] Neo4j Driver Error Message Compatibility Tests\n\n## Overview\nCreate tests that verify neo4j.do produces compatible error messages and error types with neo4j-driver.\n\n## Error Categories to Test\n\n### Syntax Errors\n```typescript\ndescribe('Syntax Error Compatibility', () =\u003e {\n  it('should produce similar error for invalid Cypher', async () =\u003e {\n    await expect(session.run('INVALID CYPHER')).rejects.toMatchObject({\n      code: expect.stringMatching(/SyntaxError/),\n      message: expect.stringContaining('Invalid')\n    })\n  })\n\n  it('should indicate error position', async () =\u003e {\n    try {\n      await session.run('MATCH (n) RETRUN n')\n    } catch (error) {\n      expect(error.message).toContain('RETRUN')\n      // Error should indicate position of syntax error\n    }\n  })\n})\n```\n\n### Constraint Errors\n```typescript\ndescribe('Constraint Error Compatibility', () =\u003e {\n  it('should produce unique constraint violation error', async () =\u003e {\n    await session.run('CREATE CONSTRAINT IF NOT EXISTS FOR (p:Person) REQUIRE p.id IS UNIQUE')\n    await session.run('CREATE (p:Person {id: 1})')\n    \n    await expect(session.run('CREATE (p:Person {id: 1})')).rejects.toMatchObject({\n      code: expect.stringMatching(/ConstraintValidation/),\n      message: expect.stringContaining('unique')\n    })\n  })\n})\n```\n\n### Authentication Errors\n```typescript\ndescribe('Authentication Error Compatibility', () =\u003e {\n  it('should produce auth failure error', async () =\u003e {\n    const d = driver('bolt://localhost', auth.basic('wrong', 'credentials'))\n    \n    await expect(d.verifyConnectivity()).rejects.toMatchObject({\n      code: expect.stringMatching(/AuthenticationError|Unauthorized/),\n    })\n  })\n})\n```\n\n### Transaction Errors\n```typescript\ndescribe('Transaction Error Compatibility', () =\u003e {\n  it('should produce transaction terminated error', async () =\u003e {\n    const tx = session.beginTransaction()\n    await tx.run('CREATE (n:Test)')\n    await tx.rollback()\n    \n    await expect(tx.run('CREATE (n:AfterRollback)')).rejects.toMatchObject({\n      code: expect.stringMatching(/TransactionTerminated/),\n    })\n  })\n\n  it('should produce deadlock error format', async () =\u003e {\n    // Setup deadlock scenario\n    // Verify error format matches neo4j-driver\n  })\n})\n```\n\n### Connection Errors\n```typescript\ndescribe('Connection Error Compatibility', () =\u003e {\n  it('should produce service unavailable error', async () =\u003e {\n    const d = driver('bolt://non-existent:7687', auth.basic('u', 'p'))\n    \n    await expect(d.verifyConnectivity()).rejects.toMatchObject({\n      code: expect.stringMatching(/ServiceUnavailable/),\n    })\n  })\n\n  it('should produce session expired error', async () =\u003e {\n    // Simulate session expiration\n    // Verify error format\n  })\n})\n```\n\n## Error Type Mapping\n| neo4j-driver Error Code | neo4j.do Error Code |\n|-------------------------|---------------------|\n| Neo.ClientError.Statement.SyntaxError | Same |\n| Neo.ClientError.Schema.ConstraintValidationFailed | Same |\n| Neo.ClientError.Security.Unauthorized | Same |\n| ServiceUnavailable | Same |\n| SessionExpired | Same |\n\n## Acceptance Criteria\n- [ ] All error type tests written\n- [ ] Error code format matches\n- [ ] Error message structure compatible\n- [ ] Tests fail initially (RED phase)","status":"open","priority":2,"issue_type":"task","created_at":"2026-01-05T06:38:02.742573-06:00","updated_at":"2026-01-05T06:38:02.742573-06:00"}
{"id":"neo4j-14s","title":"GREEN: Vector Search - Implement vector query procedures with Vectorize","description":"## Overview\nImplement vector search procedures to make all RED tests pass.\n\n## Implementation Requirements\n\n### Core Components\n\n#### 1. Vector Index Manager\n```typescript\ninterface VectorIndex {\n  name: string;\n  entityType: 'node' | 'relationship';\n  labelOrType: string;\n  embeddingField: string;\n  dimensions: number;\n  metric: 'cosine' | 'euclidean' | 'dot_product';\n  vectorizeIndex?: VectorizeIndex;\n}\n\nclass VectorIndexManager {\n  async createIndex(config: VectorIndex): Promise\u003cvoid\u003e;\n  async dropIndex(name: string): Promise\u003cvoid\u003e;\n  async listIndexes(): Promise\u003cVectorIndex[]\u003e;\n  async getIndex(name: string): Promise\u003cVectorIndex | null\u003e;\n  \n  // Sync with Vectorize\n  async syncToVectorize(name: string): Promise\u003cvoid\u003e;\n  async rebuildIndex(name: string): Promise\u003cvoid\u003e;\n}\n```\n\n#### 2. Vector Search Service\n```typescript\ninterface VectorSearchOptions {\n  metric?: 'cosine' | 'euclidean' | 'dot_product';\n  minScore?: number;\n  filter?: Record\u003cstring, any\u003e;\n}\n\ninterface VectorSearchResult {\n  entityId: string;\n  score: number;\n  vector?: number[];\n}\n\nclass VectorSearchService {\n  constructor(\n    private vectorize: VectorizeIndex,\n    private db: D1Database\n  ) {}\n\n  async queryNodes(\n    indexName: string,\n    k: number,\n    queryVector: number[],\n    options?: VectorSearchOptions\n  ): Promise\u003cVectorSearchResult[]\u003e;\n\n  async queryRelationships(\n    indexName: string,\n    k: number,\n    queryVector: number[],\n    options?: VectorSearchOptions\n  ): Promise\u003cVectorSearchResult[]\u003e;\n\n  async searchText(\n    indexName: string,\n    text: string,\n    k: number,\n    options?: VectorSearchOptions\n  ): Promise\u003cVectorSearchResult[]\u003e;\n}\n```\n\n#### 3. Procedure Implementations\n```typescript\n// db.index.vector.create\nasync function createVectorIndex(\n  indexName: string,\n  labelOrType: string,\n  embeddingField: string,\n  dimensions: number,\n  metric: string\n): Promise\u003cvoid\u003e;\n\n// db.index.vector.queryNodes\nasync function* queryNodes(\n  indexName: string,\n  k: number,\n  queryVector: number[],\n  options?: VectorSearchOptions\n): AsyncGenerator\u003c{ node: Node; score: number }\u003e;\n\n// db.index.vector.queryRelationships\nasync function* queryRelationships(\n  indexName: string,\n  k: number,\n  queryVector: number[],\n  options?: VectorSearchOptions\n): AsyncGenerator\u003c{ relationship: Relationship; score: number }\u003e;\n\n// db.index.vector.searchText\nasync function* searchText(\n  indexName: string,\n  text: string,\n  k: number,\n  options?: VectorSearchOptions\n): AsyncGenerator\u003c{ node: Node; score: number }\u003e;\n```\n\n### SQL Schema\n```sql\nCREATE TABLE vector_indexes (\n  id TEXT PRIMARY KEY,\n  name TEXT NOT NULL UNIQUE,\n  entity_type TEXT NOT NULL CHECK (entity_type IN ('node', 'relationship')),\n  label_or_type TEXT NOT NULL,\n  embedding_field TEXT NOT NULL,\n  dimensions INTEGER NOT NULL,\n  metric TEXT NOT NULL DEFAULT 'cosine',\n  vectorize_index_id TEXT,\n  created_at TEXT DEFAULT (datetime('now')),\n  updated_at TEXT DEFAULT (datetime('now'))\n);\n\n-- Node embeddings stored in properties, but indexed in Vectorize\n-- Relationship embeddings similarly\n```\n\n### Vectorize Integration\n```typescript\ninterface VectorizeSync {\n  // Called when nodes/relationships are created/updated\n  async upsertVector(indexName: string, id: string, vector: number[], metadata?: Record\u003cstring, any\u003e): Promise\u003cvoid\u003e;\n  \n  // Called when nodes/relationships are deleted\n  async deleteVector(indexName: string, id: string): Promise\u003cvoid\u003e;\n  \n  // Bulk sync for existing data\n  async syncAll(indexName: string): Promise\u003c{ synced: number; failed: number }\u003e;\n}\n```\n\n## Acceptance Criteria\n- [ ] All RED phase tests passing\n- [ ] Vectorize index creation working\n- [ ] Vector queries returning correct results\n- [ ] Hybrid search with filters working\n- [ ] Text-to-vector search working\n\n## Dependencies\n- RED: Vector Search tests\n- Vectorize binding configuration\n- Auto Vector Embeddings (optional)\n\n## Tags\nsuperset, vector-search, vectorize, tdd-green","status":"open","priority":2,"issue_type":"task","created_at":"2026-01-05T06:36:23.5907-06:00","updated_at":"2026-01-05T06:36:23.5907-06:00"}
{"id":"neo4j-19p","title":"REFACTOR: Auto Vector Embeddings - Optimize embedding pipeline","description":"## Overview\nRefactor auto vector embedding implementation for production quality.\n\n## Refactoring Goals\n\n### 1. Performance Optimization\n- Implement embedding queue with batching\n- Add request deduplication for identical texts\n- Cache embeddings for unchanged content (hash-based)\n- Parallel embedding generation for independent nodes\n\n### 2. Reliability Improvements\n- Circuit breaker for Workers AI failures\n- Exponential backoff retry strategy\n- Dead letter queue for failed embeddings\n- Async embedding with eventual consistency option\n\n### 3. Code Quality\n- Extract embedding strategies (different models)\n- Add comprehensive logging and metrics\n- Implement proper TypeScript interfaces\n- Add JSDoc documentation\n\n### 4. Configuration Enhancements\n```typescript\ninterface AdvancedEmbeddingConfig {\n  // ... base config\n  preprocessing?: {\n    lowercase?: boolean;\n    stripHtml?: boolean;\n    maxLength?: number;\n    template?: string; // e.g., \"title: {title}\\ncontent: {content}\"\n  };\n  caching?: {\n    enabled: boolean;\n    ttl: number;\n  };\n  async?: {\n    enabled: boolean;\n    webhook?: string;\n  };\n}\n```\n\n### 5. Monitoring\n- Add embedding latency metrics\n- Track embedding cache hit rate\n- Monitor Workers AI quota usage\n- Alert on embedding backlogs\n\n## Tasks\n- [ ] Implement embedding request batching\n- [ ] Add content hash caching\n- [ ] Create circuit breaker\n- [ ] Add retry with backoff\n- [ ] Extract strategy pattern\n- [ ] Add metrics collection\n- [ ] Write integration tests\n- [ ] Performance benchmark suite\n\n## Acceptance Criteria\n- [ ] All tests still passing\n- [ ] 50%+ reduction in Workers AI calls via caching\n- [ ] \u003c 100ms p99 latency for cached embeddings\n- [ ] Graceful degradation on AI failures\n\n## Tags\nsuperset, embeddings, workers-ai, tdd-refactor, performance","status":"open","priority":3,"issue_type":"task","created_at":"2026-01-05T06:35:25.265623-06:00","updated_at":"2026-01-05T06:35:25.265623-06:00"}
{"id":"neo4j-1cg","title":"[RED] ID Generation - Write failing tests for internal and element IDs","description":"## Overview\nWrite failing tests for ID generation and encoding before implementation.\n\n## Test Cases to Write\n\n### Internal ID Tests\n- `test_internal_id_is_integer`\n- `test_internal_id_is_positive`\n- `test_internal_id_auto_increments`\n- `test_internal_id_unique_across_creations`\n- `test_internal_id_persists_after_restart`\n\n### Element ID Format Tests\n- `test_element_id_matches_neo4j_format` - '4:xxx:123'\n- `test_element_id_contains_database_uuid`\n- `test_element_id_contains_internal_id`\n- `test_node_element_id_prefix_is_4`\n- `test_relationship_element_id_prefix_is_5`\n\n### ID Encoding Tests\n- `test_encode_node_id`\n- `test_encode_relationship_id`\n- `test_decode_element_id_extracts_internal_id`\n- `test_decode_element_id_validates_format`\n- `test_decode_invalid_element_id_throws`\n\n### ID Mapping Tests\n- `test_internal_to_element_id_bijection`\n- `test_element_to_internal_id_bijection`\n- `test_id_mapping_consistent_across_queries`\n\n### Edge Cases\n- `test_very_large_internal_id`\n- `test_element_id_special_characters_handled`\n- `test_concurrent_id_generation_safe`\n\n## Acceptance Criteria\n- [ ] All tests written and failing\n- [ ] Neo4j element ID format tested\n- [ ] Encoding/decoding tested\n- [ ] Edge cases covered\n\n## TDD Phase\n**RED** - Write failing tests first","status":"open","priority":1,"issue_type":"task","created_at":"2026-01-05T06:38:33.766018-06:00","updated_at":"2026-01-05T06:38:33.766018-06:00"}
{"id":"neo4j-1du","title":"[RED] Durable Object Implementation - Write failing tests for Neo4jDatabase class","description":"## Overview\nWrite failing tests for the Neo4jDatabase Durable Object before implementation.\n\n## Test Cases to Write\n\n### Initialization Tests\n- `test_durable_object_can_be_instantiated`\n- `test_sqlite_initialized_on_first_request`\n- `test_schema_applied_on_initialization`\n- `test_schema_version_recorded`\n\n### Request Routing Tests\n- `test_fetch_handles_query_requests`\n- `test_fetch_handles_transaction_requests`\n- `test_fetch_rejects_invalid_methods`\n- `test_fetch_returns_proper_json_responses`\n- `test_fetch_handles_errors_gracefully`\n\n### Query Handling Tests\n- `test_execute_cypher_query`\n- `test_execute_parameterized_query`\n- `test_query_returns_results_array`\n- `test_query_handles_syntax_errors`\n\n### Transaction Handling Tests\n- `test_begin_transaction_returns_tx_id`\n- `test_commit_transaction`\n- `test_rollback_transaction`\n- `test_transaction_isolation`\n\n### Connection Management Tests\n- `test_websocket_upgrade_supported`\n- `test_concurrent_requests_handled`\n- `test_request_timeout_handling`\n- `test_alarm_for_cleanup`\n\n## Acceptance Criteria\n- [ ] All tests written and failing\n- [ ] Tests cover DO lifecycle\n- [ ] Tests cover all request types\n- [ ] Error handling tests included\n- [ ] Concurrency tests included\n\n## TDD Phase\n**RED** - Write failing tests first","status":"open","priority":1,"issue_type":"task","created_at":"2026-01-05T06:36:02.082377-06:00","updated_at":"2026-01-05T06:36:02.082377-06:00"}
{"id":"neo4j-1ly","title":"GREEN: Driver Lifecycle Methods Implementation","description":"## Overview\nImplement Driver lifecycle methods to pass all RED phase tests.\n\n## Implementation Requirements\n\n### Session Creation\n```typescript\nclass Driver {\n  private sessions: Set\u003cSession\u003e = new Set()\n  private closed: boolean = false\n\n  session(config?: SessionConfig): Session {\n    if (this.closed) {\n      throw new ServiceUnavailable('Driver has been closed')\n    }\n    const session = new Session(this, config)\n    this.sessions.add(session)\n    return session\n  }\n\n  rxSession(config?: SessionConfig): RxSession {\n    return new RxSession(this.session(config))\n  }\n}\n\ninterface SessionConfig {\n  database?: string\n  defaultAccessMode?: 'READ' | 'WRITE'\n  bookmarks?: string | string[]\n  fetchSize?: number\n  impersonatedUser?: string\n}\n```\n\n### Execute Query\n```typescript\ninterface QueryConfig {\n  routing?: 'READ' | 'WRITE'\n  database?: string\n  impersonatedUser?: string\n  bookmarkManager?: BookmarkManager\n}\n\ninterface EagerResult\u003cT = Record\u003cstring, any\u003e\u003e {\n  keys: string[]\n  records: Record\u003cT\u003e[]\n  summary: ResultSummary\n}\n\nasync executeQuery\u003cT\u003e(\n  cypher: string,\n  params?: Record\u003cstring, any\u003e,\n  config?: QueryConfig\n): Promise\u003cEagerResult\u003cT\u003e\u003e\n```\n\n### Server Info \u0026 Connectivity\n```typescript\ninterface ServerInfo {\n  address: string\n  agent: string\n  protocolVersion: number\n}\n\nasync getServerInfo(): Promise\u003cServerInfo\u003e\nasync verifyConnectivity(): Promise\u003cServerInfo\u003e\n```\n\n### Close \u0026 Cleanup\n```typescript\nasync close(): Promise\u003cvoid\u003e {\n  if (this.closed) return\n  this.closed = true\n  \n  const closePromises = Array.from(this.sessions).map(s =\u003e s.close())\n  await Promise.all(closePromises)\n  this.sessions.clear()\n}\n```\n\n## Files to Create/Modify\n- `src/driver/driver.ts`\n- `src/driver/types.ts`\n- `src/session/session.ts` (stub)\n\n## TDD Phase\n**GREEN** - Implement to pass tests.\n\n## Dependencies\n- Depends on: RED: Driver Lifecycle Methods Tests\n- Depends on: GREEN: Driver Class Factory \u0026 URI Parsing Implementation\n\n## Acceptance Criteria\n- [ ] All RED phase tests pass\n- [ ] Session tracking works correctly\n- [ ] Resource cleanup is complete\n- [ ] API matches neo4j-driver","status":"open","priority":1,"issue_type":"task","created_at":"2026-01-05T06:35:43.787537-06:00","updated_at":"2026-01-05T06:35:43.787537-06:00"}
{"id":"neo4j-1rt","title":"GREEN: Implement driver.rxSession() factory method","description":"## Overview\nImplement the `driver.rxSession()` factory method to make all RED tests pass.\n\n## Implementation Requirements\n\n### Factory Method\n```typescript\ninterface Driver {\n  rxSession(config?: RxSessionConfig): RxSession\n}\n\ninterface RxSessionConfig {\n  database?: string\n  defaultAccessMode?: 'READ' | 'WRITE'\n  bookmarks?: string[]\n  fetchSize?: number\n}\n```\n\n### Implementation Details\n- Create RxSession instance with provided config\n- Share underlying connection pool with sync sessions\n- Initialize reactive session state\n- Wire up to existing driver infrastructure\n\n## Acceptance Criteria\n- [ ] All RED tests now pass (GREEN phase)\n- [ ] No existing tests broken\n- [ ] Implementation is minimal (just enough to pass)\n- [ ] Factory properly creates RxSession instances","status":"open","priority":2,"issue_type":"task","created_at":"2026-01-05T06:34:39.486559-06:00","updated_at":"2026-01-05T06:34:39.486559-06:00"}
{"id":"neo4j-1uc","title":"[RED] Lexer: Identifier and Keyword Tests","description":"## Overview\nWrite failing tests for identifier and keyword tokenization.\n\n## Test Cases to Write\n\n### Regular Identifiers\n- Simple: `n`, `node`, `myVar`\n- With numbers: `node1`, `n2`, `var123`\n- With underscores: `my_var`, `_private`, `__dunder__`\n- Unicode identifiers (if supported)\n\n### Backtick-Quoted Identifiers\n- Simple: \\`my identifier\\`\n- With spaces: \\`has spaces\\`\n- With special chars: \\`has-dashes\\`, \\`has.dots\\`\n- Reserved word escape: \\`match\\`, \\`return\\`\n- With backtick inside: \\`has\\\\\\`tick\\`\n\n### Keywords (Case-Insensitive)\n- Uppercase: `MATCH`, `RETURN`, `WHERE`\n- Lowercase: `match`, `return`, `where`\n- Mixed: `Match`, `ReTuRn`, `WhErE`\n- All keywords tested\n\n### Keyword List\n```\nMATCH, OPTIONAL, WHERE, RETURN, WITH, UNWIND, CREATE, MERGE,\nDELETE, DETACH, SET, REMOVE, ORDER, BY, ASC, DESC, ASCENDING,\nDESCENDING, SKIP, LIMIT, UNION, ALL, CALL, YIELD, IN, STARTS,\nENDS, CONTAINS, NOT, AND, OR, XOR, IS, NULL, TRUE, FALSE, AS,\nDISTINCT, CASE, WHEN, THEN, ELSE, END, EXISTS, COUNT, COLLECT,\nFOREACH, LOAD, CSV, FROM, HEADERS, EXPLAIN, PROFILE, USING,\nINDEX, CONSTRAINT, ON, ASSERT, UNIQUE, NODE, KEY, DROP, CREATE\n```\n\n## Acceptance Criteria\n- [ ] All tests written and failing\n- [ ] Keyword vs identifier distinction clear\n- [ ] Backtick escaping works\n- [ ] Case insensitivity verified\n\n## TDD Phase: RED","status":"open","priority":1,"issue_type":"task","created_at":"2026-01-05T06:36:16.056533-06:00","updated_at":"2026-01-05T06:36:16.056533-06:00"}
{"id":"neo4j-1un","title":"Vitest configuration","description":"# Vitest Configuration\n\n## Overview\nSet up Vitest for testing the neo4j.do project with support for unit tests, integration tests, and E2E tests.\n\n## Configuration Requirements\n- TypeScript support\n- Cloudflare Workers environment simulation\n- Coverage reporting\n- Watch mode\n- Test file patterns\n\n## Configuration File\n```typescript\n// vitest.config.ts\nimport { defineConfig } from 'vitest/config'\n\nexport default defineConfig({\n  test: {\n    globals: true,\n    environment: 'miniflare', // Cloudflare Workers simulation\n    include: [\n      'src/**/*.test.ts',\n      'tests/**/*.test.ts'\n    ],\n    exclude: ['node_modules', 'dist'],\n    coverage: {\n      provider: 'v8',\n      reporter: ['text', 'json', 'html'],\n      include: ['src/**/*.ts'],\n      exclude: ['src/**/*.test.ts', 'src/**/*.d.ts']\n    },\n    testTimeout: 10000,\n    hookTimeout: 10000,\n    setupFiles: ['./tests/setup.ts'],\n    pool: 'forks',\n    poolOptions: {\n      forks: {\n        singleFork: true\n      }\n    }\n  }\n})\n```\n\n## Test Directory Structure\n```\ntests/\n├── setup.ts           # Global test setup\n├── unit/              # Unit tests\n├── integration/       # Integration tests\n├── e2e/               # End-to-end tests\n└── fixtures/          # Test fixtures\n```\n\n## Acceptance Criteria\n- [ ] vitest.config.ts created\n- [ ] Test discovery works\n- [ ] Coverage reporting works\n- [ ] Miniflare environment configured\n- [ ] Watch mode functional","status":"open","priority":1,"issue_type":"task","created_at":"2026-01-05T06:35:17.766204-06:00","updated_at":"2026-01-05T06:35:17.766204-06:00"}
{"id":"neo4j-2im","title":"[REFACTOR] Durable Object Implementation - Improve architecture and error handling","description":"## Overview\nRefactor the Durable Object implementation for production readiness.\n\n## Refactoring Tasks\n\n### Architecture Improvements\n- Extract request routing to separate module\n- Implement middleware pattern for common logic\n- Add request validation layer\n- Create typed request/response interfaces\n\n### Error Handling\n```typescript\nclass Neo4jError extends Error {\n  constructor(\n    public code: string,\n    message: string,\n    public details?: unknown\n  ) {\n    super(message);\n  }\n}\n\n// Error codes matching Neo4j\nconst ErrorCodes = {\n  SYNTAX_ERROR: 'Neo.ClientError.Statement.SyntaxError',\n  CONSTRAINT_VIOLATION: 'Neo.ClientError.Schema.ConstraintValidationFailed',\n  ENTITY_NOT_FOUND: 'Neo.ClientError.Statement.EntityNotFound',\n};\n```\n\n### Performance Optimizations\n- Connection pooling for WebSocket\n- Query plan caching\n- Prepared statement reuse\n- Batch request support\n\n### Monitoring \u0026 Observability\n- Add request logging\n- Add metrics collection\n- Add trace context propagation\n- Add health check endpoint\n\n### Code Quality\n- Comprehensive JSDoc\n- Integration test suite\n- Load testing setup\n- Documentation\n\n## Acceptance Criteria\n- [ ] All tests still pass\n- [ ] Error handling is comprehensive\n- [ ] Performance is optimized\n- [ ] Code is well-documented\n- [ ] Production-ready state\n\n## TDD Phase\n**REFACTOR** - Improve without changing behavior","status":"open","priority":2,"issue_type":"task","created_at":"2026-01-05T06:36:15.64421-06:00","updated_at":"2026-01-05T06:36:15.64421-06:00"}
{"id":"neo4j-2ps","title":"[GREEN] AST: Implement Expression Node Types","description":"## Overview\nImplement all expression AST node types.\n\n## Implementation Tasks\n\n### Literal Types (src/parser/ast/expressions.ts)\n```typescript\nexport interface StringLiteral extends ASTNode {\n  type: 'StringLiteral'\n  value: string\n  quote: '\"' | \"'\"\n}\n\nexport interface IntegerLiteral extends ASTNode {\n  type: 'IntegerLiteral'\n  value: number\n  raw: string\n}\n\nexport interface FloatLiteral extends ASTNode {\n  type: 'FloatLiteral'\n  value: number\n  raw: string\n}\n\nexport interface BooleanLiteral extends ASTNode {\n  type: 'BooleanLiteral'\n  value: boolean\n}\n\nexport interface NullLiteral extends ASTNode {\n  type: 'NullLiteral'\n}\n\nexport interface ListLiteral extends ASTNode {\n  type: 'ListLiteral'\n  elements: Expression[]\n}\n\nexport interface MapLiteral extends ASTNode {\n  type: 'MapLiteral'\n  entries: MapEntry[]\n}\n\nexport interface MapEntry {\n  key: string | Expression\n  value: Expression\n}\n```\n\n### Operator Types\n```typescript\nexport type BinaryOperator =\n  | '+' | '-' | '*' | '/' | '%' | '^'  // arithmetic\n  | '=' | '\u003c\u003e' | '\u003c' | '\u003e' | '\u003c=' | '\u003e='  // comparison\n  | 'AND' | 'OR' | 'XOR'  // logical\n  | 'IN' | 'STARTS WITH' | 'ENDS WITH' | 'CONTAINS' | '=~'  // string/list\n```\n\n## Acceptance Criteria\n- [ ] All expression type tests pass\n- [ ] All operators defined\n- [ ] Types are composable\n- [ ] Proper type narrowing works\n\n## TDD Phase: GREEN\n## Depends On: neo4j-ucp","status":"open","priority":1,"issue_type":"task","created_at":"2026-01-05T06:38:05.152566-06:00","updated_at":"2026-01-05T06:38:05.152566-06:00"}
{"id":"neo4j-2sr","title":"GREEN: Implement rxSession.executeWrite() method","description":"## Overview\nImplement rxSession.executeWrite() to make all RED tests pass.\n\n## Implementation Requirements\n\n### Method Signature\n```typescript\ninterface RxSession {\n  executeWrite\u003cT\u003e(\n    work: (tx: RxManagedTransaction) =\u003e Observable\u003cT\u003e\n  ): Observable\u003cT\u003e\n}\n```\n\n### Implementation Details\n- Create managed transaction with WRITE mode\n- Execute work function with transaction\n- Auto-commit on successful completion\n- Auto-rollback on error\n- Update bookmarks on commit\n- Handle retry logic for transient errors\n\n### Observable Chain\n- Wrap transaction lifecycle in Observable\n- Chain work function result\n- Proper error handling\n\n## Acceptance Criteria\n- All RED tests now pass (GREEN phase)\n- Write mode enforced\n- Bookmarks updated on commit\n- Retry logic works correctly","status":"open","priority":2,"issue_type":"task","created_at":"2026-01-05T06:36:29.992301-06:00","updated_at":"2026-01-05T06:36:29.992301-06:00"}
{"id":"neo4j-2vg","title":"[RED] Relationship Operations - Write failing tests for relationship CRUD","description":"## Overview\nWrite failing tests for all relationship CRUD operations before implementation.\n\n## Test Cases to Write\n\n### createRelationship Tests\n- `test_create_relationship_returns_relationship_with_id`\n- `test_create_relationship_with_type`\n- `test_create_relationship_connects_nodes`\n- `test_create_relationship_with_properties`\n- `test_create_relationship_invalid_start_node_throws`\n- `test_create_relationship_invalid_end_node_throws`\n- `test_create_self_referencing_relationship`\n\n### getRelationship Tests\n- `test_get_relationship_returns_existing`\n- `test_get_relationship_returns_null_for_missing`\n- `test_get_relationship_includes_start_end_ids`\n- `test_get_relationship_includes_properties`\n\n### updateRelationship Tests\n- `test_update_relationship_changes_properties`\n- `test_update_relationship_merges_properties`\n- `test_update_relationship_removes_null_properties`\n- `test_update_nonexistent_relationship_throws`\n- `test_cannot_update_relationship_type`\n- `test_cannot_update_start_end_nodes`\n\n### deleteRelationship Tests\n- `test_delete_relationship_removes_from_storage`\n- `test_delete_nonexistent_returns_false`\n- `test_delete_updates_adjacency_lists`\n\n### getRelationshipsByType Tests\n- `test_get_by_type_returns_matching`\n- `test_get_by_type_empty_for_unknown`\n- `test_get_by_type_multiple_results`\n\n### getRelationshipsForNode Tests\n- `test_get_outgoing_relationships`\n- `test_get_incoming_relationships`\n- `test_get_both_direction_relationships`\n- `test_get_relationships_empty_for_isolated_node`\n- `test_get_relationships_with_type_filter`\n\n## Acceptance Criteria\n- [ ] All tests written and failing\n- [ ] Direction handling tested\n- [ ] Type filtering tested\n- [ ] Error cases covered\n\n## TDD Phase\n**RED** - Write failing tests first","status":"open","priority":1,"issue_type":"task","created_at":"2026-01-05T06:37:36.902338-06:00","updated_at":"2026-01-05T06:37:36.902338-06:00"}
{"id":"neo4j-2wa","title":"GREEN: Implement Neo4jHttpDriver class","description":"## Test-Driven Development: GREEN Phase\n\n### Component\nHTTP Client SDK - Neo4jHttpDriver Class\n\n### Implementation Requirements\n\nImplement `src/client/http-driver.ts`:\n\n```typescript\nexport interface HttpDriverConfig {\n  auth?: { username: string; password: string } | { token: string }\n  maxConnectionPoolSize?: number\n  connectionTimeout?: number\n  fetch?: typeof fetch\n  headers?: Record\u003cstring, string\u003e\n}\n\nexport class Neo4jHttpDriver {\n  readonly baseUrl: string\n  readonly config: HttpDriverConfig\n  private _closed = false\n\n  constructor(baseUrl: string, config?: HttpDriverConfig) {\n    this.baseUrl = baseUrl.replace(/\\/$/, '')\n    this.config = config ?? {}\n  }\n\n  get isAuthenticated(): boolean {\n    return \\!\\!this.config.auth\n  }\n\n  get isClosed(): boolean {\n    return this._closed\n  }\n\n  session(config?: SessionConfig): HttpSession {\n    if (this._closed) throw new Error('Driver is closed')\n    return new HttpSession(this, config)\n  }\n\n  async executeQuery\u003cT = Record\u003cstring, unknown\u003e\u003e(\n    query: string,\n    params?: Record\u003cstring, unknown\u003e,\n    config?: QueryConfig\n  ): Promise\u003cQueryResult\u003cT\u003e\u003e {\n    const session = this.session()\n    try {\n      return await session.run\u003cT\u003e(query, params)\n    } finally {\n      await session.close()\n    }\n  }\n\n  async getServerInfo(): Promise\u003cServerInfo\u003e {\n    const response = await this.fetch('/server-info')\n    return response.json()\n  }\n\n  async close(): Promise\u003cvoid\u003e {\n    this._closed = true\n  }\n\n  protected async fetch(path: string, init?: RequestInit): Promise\u003cResponse\u003e {\n    const fetchFn = this.config.fetch ?? globalThis.fetch\n    const headers = this.buildHeaders()\n    return fetchFn(`${this.baseUrl}${path}`, { ...init, headers })\n  }\n\n  private buildHeaders(): Record\u003cstring, string\u003e {\n    const headers: Record\u003cstring, string\u003e = {\n      'Content-Type': 'application/json',\n      ...this.config.headers\n    }\n    if (this.config.auth) {\n      if ('token' in this.config.auth) {\n        headers['Authorization'] = `Bearer ${this.config.auth.token}`\n      } else {\n        const { username, password } = this.config.auth\n        headers['Authorization'] = `Basic ${btoa(`${username}:${password}`)}`\n      }\n    }\n    return headers\n  }\n}\n```\n\n### Acceptance Criteria\n- [ ] All RED phase tests pass\n- [ ] Driver creates sessions correctly\n- [ ] executeQuery() works via HTTP POST\n- [ ] getServerInfo() fetches from /server-info\n- [ ] Authentication headers are properly set\n- [ ] close() marks driver as closed\n\n### Dependencies\n- RED: Neo4jHttpDriver class instantiation fails without implementation\n\n### TDD Cycle\nThis is the GREEN phase. Next: REFACTOR phase.","status":"open","priority":2,"issue_type":"task","created_at":"2026-01-05T06:34:47.70754-06:00","updated_at":"2026-01-05T06:34:47.70754-06:00"}
{"id":"neo4j-32f","title":"REFACTOR: HttpTransaction class optimization","description":"## Test-Driven Development: REFACTOR Phase\n\n### Component\nHTTP Client SDK - HttpTransaction Class\n\n### Refactoring Goals\n\n1. **State machine pattern**\n   - Implement proper transaction state machine\n   - Add state transition validation\n\n2. **Auto-rollback on error**\n   - Implement automatic rollback on unhandled errors\n   - Add cleanup on garbage collection (where supported)\n\n3. **Query batching**\n   - Support running multiple queries in single request\n   - Optimize network round trips\n\n4. **Metadata tracking**\n   - Track queries executed in transaction\n   - Support transaction metadata for debugging\n\n### Code Improvements\n\n```typescript\n// Transaction state machine\nenum TransactionState {\n  OPEN = 'OPEN',\n  COMMITTED = 'COMMITTED',\n  ROLLED_BACK = 'ROLLED_BACK',\n  FAILED = 'FAILED'\n}\n\nexport class HttpTransaction {\n  private state: TransactionState = TransactionState.OPEN\n  private queryHistory: string[] = []\n\n  async run\u003cT = Record\u003e(\n    query: string,\n    parameters?: Record\u003cstring, unknown\u003e\n  ): Promise\u003cQueryResult\u003cT\u003e\u003e {\n    this.assertState(TransactionState.OPEN)\n    this.queryHistory.push(query)\n    \n    try {\n      return await this.executeQuery(query, parameters)\n    } catch (error) {\n      this.state = TransactionState.FAILED\n      throw error\n    }\n  }\n\n  // Batch multiple queries\n  async runBatch(\n    queries: Array\u003c{ query: string; parameters?: Record\u003cstring, unknown\u003e }\u003e\n  ): Promise\u003cQueryResult[]\u003e {\n    this.assertState(TransactionState.OPEN)\n    \n    const response = await this.driver.fetch(`/tx/${this.id}/run-batch`, {\n      method: 'POST',\n      body: JSON.stringify({ queries })\n    })\n    \n    return response.json()\n  }\n\n  private assertState(...allowedStates: TransactionState[]): void {\n    if (!allowedStates.includes(this.state)) {\n      throw new Error(\n        `Invalid transaction state: ${this.state}. Expected: ${allowedStates.join(' or ')}`\n      )\n    }\n  }\n}\n```\n\n### Acceptance Criteria\n- [ ] All existing tests still pass\n- [ ] State machine properly enforced\n- [ ] Batch query support added\n- [ ] Better error messages\n- [ ] Query history tracking for debugging\n\n### Dependencies\n- GREEN: Implement HttpTransaction class\n\n### TDD Cycle\nThis completes the RED-\u003eGREEN-\u003eREFACTOR cycle for HttpTransaction.","status":"open","priority":2,"issue_type":"task","created_at":"2026-01-05T06:37:20.923696-06:00","updated_at":"2026-01-05T06:37:20.923696-06:00"}
{"id":"neo4j-3f4","title":"[RED] In-Memory Graph - Write failing tests for node storage with Map","description":"## Overview\nWrite failing tests for in-memory graph implementation before coding.\n\n## Test Cases to Write\n\n### Node Storage Tests\n- `test_create_node_stores_in_map` - Node accessible after creation\n- `test_get_node_returns_node_or_null`\n- `test_update_node_modifies_properties`\n- `test_delete_node_removes_from_map`\n- `test_node_has_correct_structure` - id, labels, properties\n\n### Adjacency List Tests\n- `test_relationship_creates_adjacency_entry`\n- `test_outgoing_adjacency_list_correct`\n- `test_incoming_adjacency_list_correct`\n- `test_delete_relationship_updates_adjacency`\n- `test_bidirectional_traversal_works`\n\n### Label Index Tests\n- `test_label_index_empty_initially`\n- `test_adding_label_updates_index`\n- `test_removing_label_updates_index`\n- `test_get_nodes_by_label_returns_correct_nodes`\n- `test_node_with_multiple_labels_indexed_correctly`\n\n### Relationship Type Index Tests\n- `test_type_index_empty_initially`\n- `test_creating_relationship_updates_type_index`\n- `test_get_relationships_by_type_works`\n- `test_deleting_relationship_updates_type_index`\n\n### Property Index Tests (Optional)\n- `test_property_index_creation`\n- `test_property_index_updates_on_node_change`\n- `test_query_by_indexed_property`\n\n## Acceptance Criteria\n- [ ] All tests written and failing\n- [ ] Tests cover Map-based storage\n- [ ] Tests cover adjacency list operations\n- [ ] Tests cover all index types\n- [ ] Edge cases covered (empty graph, missing nodes)\n\n## TDD Phase\n**RED** - Write failing tests first","status":"open","priority":1,"issue_type":"task","created_at":"2026-01-05T06:35:20.008352-06:00","updated_at":"2026-01-05T06:35:20.008352-06:00"}
{"id":"neo4j-3hoi","title":"REFACTOR: Clean up rxTx.commit() implementation","description":"## Overview\nRefactor rxTx.commit() for robust commit handling.\n\n## Refactoring Tasks\n\n### Code Quality\n- Extract commit protocol logic\n- Improve error categorization\n- Add state machine for transaction\n- Document commit semantics\n\n### Error Handling\n- Categorize commit errors properly\n- Add retry logic for transient failures\n- Clear error messages\n\n### Integration\n- Align with sync tx.commit()\n- Share commit logic where possible\n- Consistent bookmark handling\n\n## Acceptance Criteria\n- All tests still pass\n- Robust commit handling\n- Clear error messages\n- Well-documented behavior","status":"open","priority":2,"issue_type":"task","created_at":"2026-01-05T06:39:22.150487-06:00","updated_at":"2026-01-05T06:39:22.150487-06:00"}
{"id":"neo4j-3j8","title":"REFACTOR: Full-Text Search - Optimize FTS5 performance and add advanced features","description":"## Overview\nRefactor full-text search for production quality and advanced features.\n\n## Refactoring Goals\n\n### 1. Performance Optimization\n- Incremental index updates vs full rebuild\n- Query result caching\n- Index size monitoring and optimization\n- Async index rebuilding\n\n### 2. Advanced Search Features\n```typescript\ninterface AdvancedFTSOptions {\n  // Highlighting\n  highlight?: {\n    preTag: string;\n    postTag: string;\n    maxFragments: number;\n    fragmentSize: number;\n  };\n  \n  // Boosting\n  boost?: Record\u003cstring, number\u003e; // field -\u003e boost factor\n  \n  // Spell correction\n  didYouMean?: boolean;\n  \n  // Faceting\n  facets?: string[]; // Return facet counts\n}\n```\n\n### 3. Query Enhancements\n- Spell correction suggestions\n- Query expansion (synonyms)\n- Stopword configuration\n- Custom tokenizers\n\n### 4. Index Management\n- Index health checks\n- Automatic optimization scheduling\n- Index backup/restore\n- Migration between tokenizers\n\n### 5. Observability\n- Search query analytics\n- Zero-result query tracking\n- Index size metrics\n- Query latency percentiles\n\n## Tasks\n- [ ] Implement incremental index updates\n- [ ] Add highlighting support\n- [ ] Create spell correction\n- [ ] Build faceting feature\n- [ ] Add query analytics\n- [ ] Optimize trigger performance\n- [ ] Create index backup utilities\n\n## Acceptance Criteria\n- [ ] All tests still passing\n- [ ] \u003c 10ms p99 for simple queries\n- [ ] Highlighting working correctly\n- [ ] Spell correction suggestions accurate\n\n## Tags\nsuperset, fulltext-search, fts5, tdd-refactor, performance","status":"open","priority":3,"issue_type":"task","created_at":"2026-01-05T06:37:56.468292-06:00","updated_at":"2026-01-05T06:37:56.468292-06:00"}
{"id":"neo4j-3vz","title":"REFACTOR: Record.keys - Optimize frozen keys array","description":"## Overview\nRefactor the Record.keys implementation for better memory efficiency.\n\n## Refactoring Tasks\n\n1. **Lazy Initialization**\n   - Ensure keys are only frozen once\n   - Consider freezing in constructor\n\n2. **Type Safety**\n   - Ensure readonly type is properly exposed\n\n## Acceptance Criteria\n- [ ] All tests still pass after refactoring\n- [ ] Memory efficient implementation\n- [ ] TypeScript types properly defined\n\n## TDD Phase\nREFACTOR - Improve code without changing behavior\n\n## Dependencies\n- neo4j-8q6 (GREEN phase implementation)","status":"open","priority":1,"issue_type":"task","created_at":"2026-01-05T06:37:57.857754-06:00","updated_at":"2026-01-05T06:37:57.857754-06:00"}
{"id":"neo4j-3x5","title":"[REFACTOR] Integer Type - Optimize and Harden","description":"## Overview\nRefactor the Integer type implementation for performance, edge cases, and code quality.\n\n## TDD Phase: REFACTOR (Improve While Green)\n\n### Refactoring Goals\n\n#### Performance Optimizations\n- [ ] Cache common Integer values (0, 1, -1, small integers)\n- [ ] Optimize hot paths (equality, comparison)\n- [ ] Minimize object allocations in arithmetic\n- [ ] Consider using BigInt internally for simplicity (benchmark)\n\n#### Edge Case Hardening\n- [ ] Add tests for overflow scenarios\n- [ ] Handle NaN, Infinity inputs\n- [ ] Validate string parsing edge cases\n- [ ] Test with MAX_VALUE and MIN_VALUE boundaries\n- [ ] Division by zero behavior\n\n#### Code Quality\n- [ ] Extract helper functions for 64-bit operations\n- [ ] Add JSDoc comments for all public methods\n- [ ] Ensure consistent error messages\n- [ ] Add type narrowing helpers\n\n#### Additional Tests\n- [ ] Property-based tests for arithmetic laws\n- [ ] Fuzz testing for parsing\n- [ ] Serialization round-trip tests\n- [ ] Integration with Result type\n\n### Acceptance Criteria\n- [ ] All existing tests still pass\n- [ ] Performance benchmarks show improvement\n- [ ] 100% test coverage on Integer module\n- [ ] No any types in implementation\n- [ ] Documentation complete\n\n### Dependencies\n- Depends on: [GREEN] Integer Type - Implement to Pass Tests","status":"open","priority":1,"issue_type":"task","created_at":"2026-01-05T06:35:15.443225-06:00","updated_at":"2026-01-05T06:35:15.443225-06:00"}
{"id":"neo4j-3ym","title":"REFACTOR: Transaction Class Core Operations Optimization","description":"## Overview\nRefactor Transaction class for robustness, performance, and edge case handling.\n\n## Refactoring Goals\n\n### State Machine Improvements\n- Formal state machine implementation\n- State transition validation\n- State history tracking for debugging\n\n### Performance Optimizations\n- Query batching within transaction\n- Lazy result materialization\n- Lock acquisition optimization\n\n### Edge Cases\n```typescript\ndescribe('Transaction Edge Cases', () =\u003e {\n  it('should handle run after commit')\n  it('should handle concurrent commits')\n  it('should handle commit during network failure')\n  it('should handle rollback during network failure')\n  it('should handle very long transactions')\n  it('should handle transaction timeout')\n  it('should handle partial query execution failure')\n  it('should handle out-of-memory during transaction')\n})\n```\n\n### Consistency Improvements\n- Write-ahead logging integration\n- Checkpoint handling\n- Recovery from partial commits\n\n### Code Quality\n- Extract state machine\n- Create transaction context\n- Improve error messages with transaction context\n- Add transaction ID to all logs\n\n## TDD Phase\n**REFACTOR** - Improve without breaking tests.\n\n## Dependencies\n- Depends on: GREEN: Transaction Class Core Operations Implementation\n\n## Acceptance Criteria\n- [ ] All tests pass\n- [ ] State machine is well-defined\n- [ ] Edge cases handled\n- [ ] Performance improved","status":"open","priority":2,"issue_type":"task","created_at":"2026-01-05T06:38:43.288644-06:00","updated_at":"2026-01-05T06:38:43.288644-06:00"}
{"id":"neo4j-3zo","title":"[REFACTOR] SQLite Schema Design - Optimize and clean up schema implementation","description":"## Overview\nRefactor the schema implementation for better performance and maintainability.\n\n## Refactoring Tasks\n\n### Schema Organization\n- Extract schema definitions to constants\n- Create type-safe schema builder\n- Add schema documentation comments\n\n### Migration System\n- Implement versioned migrations\n- Add rollback support\n- Create migration CLI tool\n- Add migration status checking\n\n### Index Optimization\n- Analyze query patterns\n- Add composite indexes where beneficial\n- Consider partial indexes for common filters\n\n### Trigger Optimization\n```sql\n-- Auto-update updated_at\nCREATE TRIGGER IF NOT EXISTS update_node_timestamp \nAFTER UPDATE ON nodes\nBEGIN\n  UPDATE nodes SET updated_at = CURRENT_TIMESTAMP WHERE id = NEW.id;\nEND;\n```\n\n### Code Quality\n- Add JSDoc comments\n- Create TypeScript interfaces for schema\n- Add schema validation utility\n- Write schema documentation\n\n## Performance Considerations\n- PRAGMA settings for Durable Objects\n- WAL mode configuration\n- Foreign key enforcement settings\n\n## Acceptance Criteria\n- [ ] All tests still pass\n- [ ] Code is well-documented\n- [ ] Migration system is production-ready\n- [ ] Schema is optimized for common queries\n- [ ] No code duplication\n\n## TDD Phase\n**REFACTOR** - Improve without changing behavior","status":"open","priority":2,"issue_type":"task","created_at":"2026-01-05T06:34:49.852338-06:00","updated_at":"2026-01-05T06:34:49.852338-06:00"}
{"id":"neo4j-41o","title":"REFACTOR: REST API endpoint optimization","description":"## Test-Driven Development: REFACTOR Phase\n\n### Component\nHTTP Client SDK - REST API Endpoints\n\n### Refactoring Goals\n\n1. **Middleware extraction**\n   - Authentication middleware\n   - Error handling middleware\n   - Request validation middleware\n\n2. **OpenAPI specification**\n   - Generate OpenAPI/Swagger docs\n   - Validate requests against schema\n\n3. **Response formatting**\n   - Standardize response envelope\n   - HATEOAS links for discoverability\n\n4. **Performance optimizations**\n   - Response compression\n   - ETag support for caching\n\n### Code Improvements\n\n```typescript\n// Middleware for error handling\nconst errorHandler: ErrorHandler = (err, c) =\u003e {\n  console.error('API Error:', err)\n  \n  if (err instanceof Neo4jError) {\n    return c.json({\n      error: {\n        code: err.code,\n        message: err.message,\n        details: err.details\n      }\n    }, mapNeo4jErrorToStatus(err))\n  }\n  \n  return c.json({\n    error: {\n      code: 'INTERNAL_ERROR',\n      message: 'An unexpected error occurred'\n    }\n  }, 500)\n}\n\n// Request validation middleware\nconst validateQuery = validator('json', (value, c) =\u003e {\n  const parsed = querySchema.safeParse(value)\n  if (!parsed.success) {\n    return c.json({ error: parsed.error.format() }, 400)\n  }\n  return parsed.data\n})\n\n// Standardized response envelope\ninterface ApiResponse\u003cT\u003e {\n  data: T\n  meta: {\n    requestId: string\n    timestamp: string\n    duration: number\n  }\n  links?: Record\u003cstring, string\u003e\n}\n\n// Route with HATEOAS\napp.post('/tx/begin', validateTransaction, async (c) =\u003e {\n  const tx = await txManager.begin(c.req.valid('json'))\n  return c.json({\n    data: { id: tx.id, accessMode: tx.accessMode },\n    meta: { requestId: c.get('requestId'), timestamp: new Date().toISOString() },\n    links: {\n      run: `/tx/${tx.id}/run`,\n      commit: `/tx/${tx.id}/commit`,\n      rollback: `/tx/${tx.id}/rollback`\n    }\n  }, 201)\n})\n```\n\n### Acceptance Criteria\n- [ ] All existing tests still pass\n- [ ] Middleware properly separated\n- [ ] Error responses are consistent\n- [ ] OpenAPI spec generated\n- [ ] Response envelope standardized\n\n### Dependencies\n- GREEN: Implement REST API endpoint handlers\n\n### TDD Cycle\nThis completes the RED-\u003eGREEN-\u003eREFACTOR cycle for REST API Endpoints.","status":"open","priority":2,"issue_type":"task","created_at":"2026-01-05T06:38:43.957952-06:00","updated_at":"2026-01-05T06:38:43.957952-06:00"}
{"id":"neo4j-44n","title":"RED: HttpTransaction class methods fail without implementation","description":"## Test-Driven Development: RED Phase\n\n### Component\nHTTP Client SDK - HttpTransaction Class\n\n### Test Cases to Write (Expected to FAIL)\n\n```typescript\nimport { describe, it, expect, vi, beforeEach } from 'vitest'\nimport { HttpTransaction } from '../src/client/http-transaction'\nimport { Neo4jHttpDriver } from '../src/client/http-driver'\n\ndescribe('HttpTransaction - RED', () =\u003e {\n  let driver: Neo4jHttpDriver\n  let mockFetch: ReturnType\u003ctypeof vi.fn\u003e\n\n  beforeEach(() =\u003e {\n    mockFetch = vi.fn()\n    driver = new Neo4jHttpDriver('https://neo4j.do/db/mydb', { fetch: mockFetch })\n  })\n\n  describe('transaction ID management', () =\u003e {\n    it('should have a unique transaction ID', () =\u003e {\n      const tx = new HttpTransaction(driver, 'tx-123')\n      expect(tx.id).toBe('tx-123')\n    })\n\n    it('should track transaction state', () =\u003e {\n      const tx = new HttpTransaction(driver, 'tx-123')\n      expect(tx.isOpen).toBe(true)\n      expect(tx.isCommitted).toBe(false)\n      expect(tx.isRolledBack).toBe(false)\n    })\n  })\n\n  describe('run()', () =\u003e {\n    it('should execute query via POST /tx/{id}/run', async () =\u003e {\n      mockFetch.mockResolvedValue({\n        ok: true,\n        json: () =\u003e Promise.resolve({ records: [{ n: 1 }] })\n      })\n      \n      const tx = new HttpTransaction(driver, 'tx-123')\n      const result = await tx.run('RETURN 1 as n')\n      \n      expect(mockFetch).toHaveBeenCalledWith(\n        'https://neo4j.do/db/mydb/tx/tx-123/run',\n        expect.objectContaining({ method: 'POST' })\n      )\n      expect(result.records[0].get('n')).toBe(1)\n    })\n\n    it('should include parameters in request', async () =\u003e {\n      mockFetch.mockResolvedValue({\n        ok: true,\n        json: () =\u003e Promise.resolve({ records: [] })\n      })\n      \n      const tx = new HttpTransaction(driver, 'tx-123')\n      await tx.run('MATCH (n) WHERE n.id = $id RETURN n', { id: 456 })\n      \n      const body = JSON.parse(mockFetch.mock.calls[0][1].body)\n      expect(body.query).toBe('MATCH (n) WHERE n.id = $id RETURN n')\n      expect(body.parameters).toEqual({ id: 456 })\n    })\n\n    it('should reject run after commit', async () =\u003e {\n      mockFetch.mockResolvedValue({ ok: true, json: () =\u003e Promise.resolve({}) })\n      \n      const tx = new HttpTransaction(driver, 'tx-123')\n      await tx.commit()\n      \n      await expect(tx.run('RETURN 1')).rejects.toThrow('Transaction is not open')\n    })\n  })\n\n  describe('commit()', () =\u003e {\n    it('should commit via POST /tx/{id}/commit', async () =\u003e {\n      mockFetch.mockResolvedValue({\n        ok: true,\n        json: () =\u003e Promise.resolve({ bookmarks: ['bm:1'] })\n      })\n      \n      const tx = new HttpTransaction(driver, 'tx-123')\n      await tx.commit()\n      \n      expect(mockFetch).toHaveBeenCalledWith(\n        'https://neo4j.do/db/mydb/tx/tx-123/commit',\n        expect.objectContaining({ method: 'POST' })\n      )\n      expect(tx.isCommitted).toBe(true)\n      expect(tx.isOpen).toBe(false)\n    })\n\n    it('should return bookmarks after commit', async () =\u003e {\n      mockFetch.mockResolvedValue({\n        ok: true,\n        json: () =\u003e Promise.resolve({ bookmarks: ['bm:1', 'bm:2'] })\n      })\n      \n      const tx = new HttpTransaction(driver, 'tx-123')\n      const result = await tx.commit()\n      \n      expect(result.bookmarks).toEqual(['bm:1', 'bm:2'])\n    })\n  })\n\n  describe('rollback()', () =\u003e {\n    it('should rollback via POST /tx/{id}/rollback', async () =\u003e {\n      mockFetch.mockResolvedValue({ ok: true, json: () =\u003e Promise.resolve({}) })\n      \n      const tx = new HttpTransaction(driver, 'tx-123')\n      await tx.rollback()\n      \n      expect(mockFetch).toHaveBeenCalledWith(\n        'https://neo4j.do/db/mydb/tx/tx-123/rollback',\n        expect.objectContaining({ method: 'POST' })\n      )\n      expect(tx.isRolledBack).toBe(true)\n      expect(tx.isOpen).toBe(false)\n    })\n  })\n\n  describe('timeout handling', () =\u003e {\n    it('should support transaction timeout', async () =\u003e {\n      const tx = new HttpTransaction(driver, 'tx-123', { timeout: 30000 })\n      expect(tx.timeout).toBe(30000)\n    })\n\n    it('should abort on timeout', async () =\u003e {\n      vi.useFakeTimers()\n      mockFetch.mockImplementation(() =\u003e new Promise(() =\u003e {})) // Never resolves\n      \n      const tx = new HttpTransaction(driver, 'tx-123', { timeout: 1000 })\n      const promise = tx.run('RETURN 1')\n      \n      vi.advanceTimersByTime(1001)\n      \n      await expect(promise).rejects.toThrow('Transaction timed out')\n      vi.useRealTimers()\n    })\n  })\n})\n```\n\n### Acceptance Criteria\n- [ ] Test file created at `tests/client/http-transaction.test.ts`\n- [ ] All tests fail with expected errors\n- [ ] Tests cover: ID management, run, commit, rollback, timeout\n\n### TDD Cycle\nThis is the RED phase. Next: GREEN phase implementation.","status":"open","priority":2,"issue_type":"task","created_at":"2026-01-05T06:36:42.923906-06:00","updated_at":"2026-01-05T06:36:42.923906-06:00"}
{"id":"neo4j-4c5","title":"[GREEN] Durable Object Implementation - Implement Neo4jDatabase class to pass tests","description":"## Overview\nImplement the Neo4jDatabase Durable Object to make all tests pass.\n\n## Implementation Requirements\n\n### Durable Object Class\n```typescript\nexport class Neo4jDatabase implements DurableObject {\n  private sql: SqlStorage;\n  private initialized = false;\n\n  constructor(state: DurableObjectState, env: Env) {\n    this.sql = state.storage.sql;\n  }\n\n  async fetch(request: Request): Promise\u003cResponse\u003e {\n    await this.ensureInitialized();\n    \n    const url = new URL(request.url);\n    switch (url.pathname) {\n      case '/query':\n        return this.handleQuery(request);\n      case '/transaction/begin':\n        return this.handleBeginTransaction(request);\n      case '/transaction/commit':\n        return this.handleCommitTransaction(request);\n      case '/transaction/rollback':\n        return this.handleRollbackTransaction(request);\n      default:\n        return new Response('Not Found', { status: 404 });\n    }\n  }\n\n  private async ensureInitialized(): Promise\u003cvoid\u003e {\n    if (this.initialized) return;\n    await this.initializeSchema();\n    this.initialized = true;\n  }\n}\n```\n\n### Request Handlers\n```typescript\ninterface QueryRequest {\n  query: string;\n  parameters?: Record\u003cstring, unknown\u003e;\n}\n\ninterface QueryResponse {\n  results: any[];\n  summary: {\n    counters: UpdateCounters;\n    time: number;\n  };\n}\n```\n\n### Schema Initialization\n- Apply migrations on first request\n- Check and update schema version\n- Create indexes and constraints\n\n## Files to Create\n- `src/durable-objects/neo4j-database.ts`\n- `src/durable-objects/handlers/query.ts`\n- `src/durable-objects/handlers/transaction.ts`\n\n## Acceptance Criteria\n- [ ] All RED phase tests pass\n- [ ] DO initializes correctly\n- [ ] Queries execute properly\n- [ ] Transactions work correctly\n- [ ] Errors handled gracefully\n\n## TDD Phase\n**GREEN** - Minimum code to pass tests","status":"open","priority":1,"issue_type":"task","created_at":"2026-01-05T06:36:09.025399-06:00","updated_at":"2026-01-05T06:36:09.025399-06:00"}
{"id":"neo4j-4eq","title":"RED: Driver Class Factory \u0026 URI Parsing Tests","description":"## Overview\nWrite comprehensive failing tests for the Driver class factory function and URI parsing.\n\n## Test Cases\n\n### Factory Function Tests\n```typescript\ndescribe('neo4j.driver()', () =\u003e {\n  it('should create driver with URI only')\n  it('should create driver with URI and auth token')\n  it('should create driver with URI, auth, and config')\n  it('should throw on invalid URI format')\n  it('should throw on unsupported scheme')\n})\n```\n\n### URI Parsing Tests\n```typescript\ndescribe('URI Parsing', () =\u003e {\n  it('should parse neo4j:// scheme')\n  it('should parse neo4j+s:// scheme (encrypted)')\n  it('should parse bolt:// scheme')\n  it('should parse bolt+s:// scheme (encrypted)')\n  it('should extract host from URI')\n  it('should extract port from URI (default 7687)')\n  it('should handle custom ports')\n  it('should handle IPv6 addresses')\n  it('should parse query parameters')\n})\n```\n\n### Auth Token Tests\n```typescript\ndescribe('neo4j.auth', () =\u003e {\n  describe('basic()', () =\u003e {\n    it('should create basic auth token with username/password')\n    it('should create basic auth with realm')\n  })\n  describe('bearer()', () =\u003e {\n    it('should create bearer token')\n  })\n  describe('custom()', () =\u003e {\n    it('should create custom auth with principal/credentials/realm/scheme')\n    it('should include custom parameters')\n  })\n})\n```\n\n### Configuration Tests\n```typescript\ndescribe('Driver Configuration', () =\u003e {\n  it('should accept maxTransactionRetryTime')\n  it('should accept connectionTimeout')\n  it('should accept maxConnectionPoolSize')\n  it('should accept connectionAcquisitionTimeout')\n  it('should accept logging configuration')\n  it('should use defaults when not specified')\n  it('should validate configuration values')\n})\n```\n\n## TDD Phase\n**RED** - All tests should fail initially as no implementation exists.\n\n## Acceptance Criteria\n- [ ] All test cases written with clear descriptions\n- [ ] Tests use proper mocking for Cloudflare environment\n- [ ] Tests cover edge cases and error conditions\n- [ ] Tests are isolated and independent\n- [ ] Test file created at `src/driver/__tests__/driver.test.ts`","status":"open","priority":1,"issue_type":"task","created_at":"2026-01-05T06:34:30.854121-06:00","updated_at":"2026-01-05T06:34:30.854121-06:00"}
{"id":"neo4j-4hz","title":"GREEN: Pattern to JOIN Translation - Relationship Patterns","description":"## Overview\nImplement relationship pattern translation to make RED tests pass.\n\n## Implementation Tasks\n\n### 1. Extend PatternTranslator for Relationships\n```typescript\nclass PatternTranslator {\n  translateRelationshipPattern(pattern: RelationshipPattern): SQLFragment {\n    const { startNode, relationship, endNode, direction } = pattern;\n    // Generate JOINs based on direction\n  }\n}\n```\n\n### 2. Direction Handler\n```typescript\nenum Direction { OUTGOING, INCOMING, BOTH }\n\nclass DirectionHandler {\n  getJoinConditions(direction: Direction, relAlias: string, \n                    startAlias: string, endAlias: string): string[] {\n    switch (direction) {\n      case Direction.OUTGOING:\n        return [`${startAlias}.id = ${relAlias}.start_node_id`,\n                `${endAlias}.id = ${relAlias}.end_node_id`];\n      case Direction.INCOMING:\n        return [`${startAlias}.id = ${relAlias}.end_node_id`,\n                `${endAlias}.id = ${relAlias}.start_node_id`];\n      case Direction.BOTH:\n        // OR condition for either direction\n    }\n  }\n}\n```\n\n### 3. Multi-Hop Pattern Handler\n```typescript\nclass PathPatternTranslator {\n  translatePath(segments: PathSegment[]): SQLFragment {\n    // Chain JOINs for each segment\n    // Share node references between adjacent segments\n  }\n}\n```\n\n### 4. Relationship Type Filter\n```typescript\nprivate translateTypeFilter(types: string[]): string {\n  if (types.length === 1) return `type = '${types[0]}'`;\n  return `type IN (${types.map(t =\u003e \"'\"+t+\"'\").join(', ')})`;\n}\n```\n\n## Files to Create/Modify\n- `src/cypher/translator/pattern-translator.ts`\n- `src/cypher/translator/direction-handler.ts`\n- `src/cypher/translator/path-pattern-translator.ts`\n\n## Acceptance Criteria\n- [ ] All RED phase tests pass\n- [ ] JOINs generated correctly for all directions\n- [ ] Multi-hop patterns work\n\n## TDD Phase\nGREEN - Make tests pass with minimal code\n\n## Dependencies\n- Depends on: RED: Pattern to JOIN Translation - Relationship Patterns","status":"open","priority":1,"issue_type":"task","created_at":"2026-01-05T06:35:41.772273-06:00","updated_at":"2026-01-05T06:35:41.772273-06:00"}
{"id":"neo4j-4kp","title":"[GREEN] Temporal Types - Implement to Pass Tests","description":"## Overview\nImplement all Neo4j Temporal types to pass the failing tests.\n\n## TDD Phase: GREEN (Make Tests Pass)\n\n### Implementation Requirements\n\n#### Base Temporal Class (optional internal)\n```typescript\nabstract class Temporal {\n  abstract toString(): string;\n}\n```\n\n#### Date Implementation\n```typescript\nclass Date {\n  readonly year: number;\n  readonly month: number;\n  readonly day: number;\n  \n  constructor(year: number, month: number, day: number);\n  static fromStandardDate(date: globalThis.Date): Date;\n  \n  toString(): string;\n  toStandardDate(): globalThis.Date;\n}\n```\n\n#### Time Implementation\n```typescript\nclass Time {\n  readonly hour: number;\n  readonly minute: number;\n  readonly second: number;\n  readonly nanosecond: number;\n  readonly timeZoneOffsetSeconds: number;\n  \n  constructor(\n    hour: number,\n    minute: number,\n    second: number,\n    nanosecond: number,\n    timeZoneOffsetSeconds: number\n  );\n  \n  toString(): string;\n}\n```\n\n#### LocalTime Implementation\n```typescript\nclass LocalTime {\n  readonly hour: number;\n  readonly minute: number;\n  readonly second: number;\n  readonly nanosecond: number;\n  \n  constructor(\n    hour: number,\n    minute: number,\n    second: number,\n    nanosecond: number\n  );\n  static fromStandardDate(date: globalThis.Date): LocalTime;\n  \n  toString(): string;\n}\n```\n\n#### DateTime Implementation\n```typescript\nclass DateTime {\n  readonly year: number;\n  readonly month: number;\n  readonly day: number;\n  readonly hour: number;\n  readonly minute: number;\n  readonly second: number;\n  readonly nanosecond: number;\n  readonly timeZoneOffsetSeconds: number;\n  readonly timeZoneId?: string;\n  \n  constructor(\n    year: number,\n    month: number,\n    day: number,\n    hour: number,\n    minute: number,\n    second: number,\n    nanosecond: number,\n    timeZoneOffsetSeconds: number,\n    timeZoneId?: string\n  );\n  static fromStandardDate(date: globalThis.Date): DateTime;\n  \n  toString(): string;\n  toStandardDate(): globalThis.Date;\n}\n```\n\n#### LocalDateTime Implementation\n```typescript\nclass LocalDateTime {\n  readonly year: number;\n  readonly month: number;\n  readonly day: number;\n  readonly hour: number;\n  readonly minute: number;\n  readonly second: number;\n  readonly nanosecond: number;\n  \n  constructor(\n    year: number,\n    month: number,\n    day: number,\n    hour: number,\n    minute: number,\n    second: number,\n    nanosecond: number\n  );\n  static fromStandardDate(date: globalThis.Date): LocalDateTime;\n  \n  toString(): string;\n  toStandardDate(): globalThis.Date;\n}\n```\n\n#### Duration Implementation\n```typescript\nclass Duration {\n  readonly months: number;\n  readonly days: number;\n  readonly seconds: number;\n  readonly nanoseconds: number;\n  \n  constructor(\n    months: number,\n    days: number,\n    seconds: number,\n    nanoseconds: number\n  );\n  \n  toString(): string;\n}\n```\n\n### Implementation Notes\n- Use ISO 8601 format for all string representations\n- Handle nanosecond precision (Neo4j supports nanoseconds)\n- Timezone offset in seconds (not minutes)\n- Month/day values are 1-indexed (not 0-indexed)\n\n### Acceptance Criteria\n- [ ] All RED phase tests passing\n- [ ] All 6 temporal types implemented\n- [ ] Matches neo4j-driver API\n- [ ] Implementation files at `src/types/temporal/`\n- [ ] Exported from `src/types/index.ts`\n\n### Dependencies\n- Depends on: [RED] Temporal Types - Write Failing Tests","status":"open","priority":1,"issue_type":"task","created_at":"2026-01-05T06:35:59.272454-06:00","updated_at":"2026-01-05T06:35:59.272454-06:00"}
{"id":"neo4j-4m1","title":"[GREEN] Graph Types (Node, Relationship, Path) - Implement to Pass Tests","description":"## Overview\nImplement Neo4j Graph types to pass all failing tests.\n\n## TDD Phase: GREEN (Make Tests Pass)\n\n### Implementation Requirements\n\n#### Node Class\n```typescript\nexport class Node\u003cT extends Record\u003cstring, any\u003e = Record\u003cstring, any\u003e\u003e {\n  readonly identity: Integer;\n  readonly labels: readonly string[];\n  readonly properties: Readonly\u003cT\u003e;\n  readonly elementId: string;\n  \n  constructor(\n    identity: Integer,\n    labels: string[],\n    properties: T,\n    elementId?: string\n  );\n  \n  toString(): string;\n}\n```\n\n#### Relationship Class\n```typescript\nexport class Relationship\u003cT extends Record\u003cstring, any\u003e = Record\u003cstring, any\u003e\u003e {\n  readonly identity: Integer;\n  readonly start: Integer;\n  readonly end: Integer;\n  readonly type: string;\n  readonly properties: Readonly\u003cT\u003e;\n  readonly elementId: string;\n  readonly startNodeElementId: string;\n  readonly endNodeElementId: string;\n  \n  constructor(\n    identity: Integer,\n    start: Integer,\n    end: Integer,\n    type: string,\n    properties: T,\n    elementId?: string,\n    startNodeElementId?: string,\n    endNodeElementId?: string\n  );\n  \n  toString(): string;\n}\n```\n\n#### PathSegment Class\n```typescript\nexport class PathSegment {\n  readonly start: Node;\n  readonly relationship: Relationship;\n  readonly end: Node;\n  \n  constructor(\n    start: Node,\n    relationship: Relationship,\n    end: Node\n  );\n}\n```\n\n#### Path Class\n```typescript\nexport class Path {\n  readonly start: Node;\n  readonly end: Node;\n  readonly segments: readonly PathSegment[];\n  readonly length: number;\n  \n  constructor(\n    start: Node,\n    end: Node,\n    segments: PathSegment[]\n  );\n  \n  // Iterator support\n  [Symbol.iterator](): Iterator\u003cPathSegment\u003e;\n}\n```\n\n#### Type Guards\n```typescript\nexport function isNode(value: unknown): value is Node;\nexport function isRelationship(value: unknown): value is Relationship;\nexport function isPath(value: unknown): value is Path;\nexport function isPathSegment(value: unknown): value is PathSegment;\n```\n\n### Implementation Notes\n- Use readonly arrays and Readonly\u003cT\u003e for immutability\n- Generate elementId if not provided (for local creation)\n- Labels and type should be frozen after construction\n- Properties object should be deeply frozen\n\n### File Structure\n```\nsrc/types/graph/\n  index.ts\n  node.ts\n  relationship.ts\n  path.ts\n  path-segment.ts\n```\n\n### Acceptance Criteria\n- [ ] All RED phase tests passing\n- [ ] All graph types implemented\n- [ ] Type guards working correctly\n- [ ] Proper TypeScript generics for properties\n- [ ] Exported from `src/types/index.ts`\n\n### Dependencies\n- Depends on: [RED] Graph Types (Node, Relationship, Path) - Write Failing Tests\n- Depends on: [GREEN] Integer Type - Implement to Pass Tests","status":"open","priority":1,"issue_type":"task","created_at":"2026-01-05T06:39:17.578027-06:00","updated_at":"2026-01-05T06:39:17.578027-06:00"}
{"id":"neo4j-4q9","title":"[RED] Lexer: String Literal Tests","description":"## Overview\nWrite failing tests for string literal tokenization in Cypher.\n\n## Test Cases to Write\n\n### Single-Quoted Strings\n- Simple: `'hello'`\n- With spaces: `'hello world'`\n- Empty: `''`\n- With escaped single quote: `'it\\'s'`\n- With escaped backslash: `'path\\\\to'`\n\n### Double-Quoted Strings\n- Simple: `\"hello\"`\n- With spaces: `\"hello world\"`\n- Empty: `\"\"`\n- With escaped double quote: `\"say \\\"hi\\\"\"`\n- With escaped backslash: `\"path\\\\to\"`\n\n### Escape Sequences\n- Newline: `\\n`\n- Tab: `\\t`\n- Carriage return: `\\r`\n- Unicode: `\\uXXXX`\n\n### Edge Cases\n- Unclosed string (should error with position)\n- String at end of input\n- String with newlines inside\n- Very long strings\n\n## Acceptance Criteria\n- [ ] All tests written and failing\n- [ ] Tests cover both quote styles\n- [ ] Tests cover all escape sequences\n- [ ] Error cases have proper error messages\n\n## TDD Phase: RED","status":"open","priority":1,"issue_type":"task","created_at":"2026-01-05T06:35:11.301775-06:00","updated_at":"2026-01-05T06:35:11.301775-06:00"}
{"id":"neo4j-4sy","title":"[RED] Label Management - Write failing tests for label operations","description":"## Overview\nWrite failing tests for label management operations before implementation.\n\n## Test Cases to Write\n\n### Add Label Tests\n- `test_add_label_to_node`\n- `test_add_label_already_exists_no_duplicate`\n- `test_add_label_updates_index`\n- `test_add_label_to_nonexistent_node_throws`\n- `test_add_multiple_labels_at_once`\n\n### Remove Label Tests\n- `test_remove_label_from_node`\n- `test_remove_label_updates_index`\n- `test_remove_nonexistent_label_no_error`\n- `test_remove_label_from_nonexistent_node_throws`\n- `test_remove_last_label_leaves_empty_array`\n\n### Get Labels Tests\n- `test_get_labels_for_node`\n- `test_get_labels_empty_for_unlabeled_node`\n- `test_get_all_labels_in_database`\n- `test_get_all_labels_unique`\n- `test_get_labels_after_add_remove_cycle`\n\n### Label Index Tests\n- `test_label_index_updated_on_add`\n- `test_label_index_updated_on_remove`\n- `test_label_index_query_returns_correct_nodes`\n- `test_label_index_empty_after_all_removed`\n- `test_label_index_handles_special_characters`\n\n### Label Validation Tests\n- `test_valid_label_names`\n- `test_invalid_label_names_rejected` - (empty, spaces, special chars)\n- `test_label_case_sensitivity`\n\n## Acceptance Criteria\n- [ ] All tests written and failing\n- [ ] Add/remove operations tested\n- [ ] Index maintenance tested\n- [ ] Validation tested\n\n## TDD Phase\n**RED** - Write failing tests first","status":"open","priority":1,"issue_type":"task","created_at":"2026-01-05T06:39:19.222134-06:00","updated_at":"2026-01-05T06:39:19.222134-06:00"}
{"id":"neo4j-51e","title":"REFACTOR: Driver Class Factory \u0026 URI Parsing Optimization","description":"## Overview\nRefactor the Driver class factory and URI parsing for optimal performance and edge case handling.\n\n## Refactoring Goals\n\n### Performance Optimizations\n- URI parsing caching for repeated connections\n- Lazy initialization of driver internals\n- Efficient config merging with defaults\n\n### Code Quality\n- Extract URI validation into separate validator\n- Create builder pattern for complex configurations\n- Improve error messages with context\n\n### Edge Cases to Handle\n```typescript\ndescribe('Edge Cases', () =\u003e {\n  it('should handle URIs with special characters in credentials')\n  it('should handle very long URIs')\n  it('should handle concurrent driver creation')\n  it('should handle driver creation after close')\n  it('should properly clean up on creation failure')\n  it('should handle malformed IPv6 addresses')\n  it('should handle empty configuration objects')\n  it('should handle null vs undefined parameters')\n})\n```\n\n### Additional Tests\n- Stress tests for rapid driver creation/destruction\n- Memory leak detection tests\n- Configuration immutability tests\n\n## Files to Modify\n- `src/driver/driver.ts`\n- `src/driver/uri-parser.ts`\n- `src/driver/auth.ts`\n- `src/driver/config.ts`\n\n## TDD Phase\n**REFACTOR** - Improve code quality while maintaining passing tests.\n\n## Dependencies\n- Depends on: GREEN: Driver Class Factory \u0026 URI Parsing Implementation\n\n## Acceptance Criteria\n- [ ] All existing tests still pass\n- [ ] New edge case tests added and passing\n- [ ] Code follows DRY principles\n- [ ] Performance benchmarks documented\n- [ ] No memory leaks detected","status":"open","priority":2,"issue_type":"task","created_at":"2026-01-05T06:35:05.569604-06:00","updated_at":"2026-01-05T06:35:05.569604-06:00"}
{"id":"neo4j-538","title":"RED: Write failing tests for rxSession.lastBookmarks() method","description":"## Overview\nWrite failing tests for rxSession.lastBookmarks() bookmark retrieval method.\n\n## Test Cases to Write\n\n### Basic Bookmark Tests\n- lastBookmarks() returns string array\n- Returns empty array for new session\n- Returns bookmarks from session config\n- Returns updated bookmarks after transaction commit\n\n### Bookmark Update Tests\n- Bookmarks update after executeRead completes\n- Bookmarks update after executeWrite completes\n- Bookmarks update after explicit transaction commit\n- Bookmarks not updated after rollback\n\n### Multiple Transaction Tests\n- Bookmarks accumulate across transactions\n- Most recent bookmark takes precedence\n- Bookmarks from multiple databases tracked separately\n\n## Acceptance Criteria\n- All tests written and failing (RED phase)\n- Tests cover bookmark retrieval\n- Tests cover bookmark updates\n- Tests verify synchronous access","status":"open","priority":2,"issue_type":"task","created_at":"2026-01-05T06:37:28.037397-06:00","updated_at":"2026-01-05T06:37:28.037397-06:00"}
{"id":"neo4j-55g","title":"REFACTOR: Record.get(index) - Optimize unified get method","description":"## Overview\nRefactor the unified get(keyOrIndex) method for type safety and clarity.\n\n## Refactoring Tasks\n\n1. **Type Overloads**\n   - Add proper function overloads for string and number\n   - Ensure type inference works correctly\n\n2. **Code Organization**\n   - Clean up conditional logic\n   - Consider helper methods for clarity\n\n## Acceptance Criteria\n- [ ] All tests still pass after refactoring\n- [ ] TypeScript overloads properly defined\n- [ ] Code is readable and maintainable\n\n## TDD Phase\nREFACTOR - Improve code without changing behavior\n\n## Dependencies\n- neo4j-ttx (GREEN phase implementation)","status":"open","priority":1,"issue_type":"task","created_at":"2026-01-05T06:35:41.736166-06:00","updated_at":"2026-01-05T06:35:41.736166-06:00"}
{"id":"neo4j-57y","title":"RED: Write failing tests for rxSession.executeWrite() method","description":"## Overview\nWrite failing tests for rxSession.executeWrite() transaction function for write operations.\n\n## Test Cases to Write\n\n### Basic Transaction Function Tests\n- executeWrite(work) returns Observable\n- Work function receives RxManagedTransaction\n- Work function can run write queries\n- Returns result of work function\n\n### Transaction Behavior Tests\n- Transaction auto-commits on success\n- Transaction auto-rollbacks on error\n- Write access mode is set\n- Bookmarks are updated after commit\n\n### Observable Semantics Tests\n- Cold observable (lazy execution)\n- Proper completion on success\n- Error emission on failure\n- Single execution per subscription\n\n### Retry Behavior Tests\n- Retries on transient errors\n- Does NOT retry on constraint violations\n- Respects retry configuration\n\n## Acceptance Criteria\n- All tests written and failing (RED phase)\n- Tests cover write-specific behavior\n- Tests verify Observable behavior\n- Tests cover retry scenarios","status":"open","priority":2,"issue_type":"task","created_at":"2026-01-05T06:36:23.741398-06:00","updated_at":"2026-01-05T06:36:23.741398-06:00"}
{"id":"neo4j-5i2","title":"[RED] AST: Pattern Node Types Tests","description":"## Overview\nWrite failing tests for pattern AST node types.\n\n## Test Cases to Write\n\n### Pattern Container\n```typescript\ninterface Pattern {\n  type: 'Pattern'\n  elements: PatternElement[]\n}\n```\n\n### Node Pattern\n```typescript\ninterface NodePattern {\n  type: 'NodePattern'\n  variable?: Identifier\n  labels: string[]\n  properties?: MapLiteral | Parameter\n}\n```\n\n### Relationship Pattern\n```typescript\ninterface RelationshipPattern {\n  type: 'RelationshipPattern'\n  variable?: Identifier\n  types: string[]\n  properties?: MapLiteral | Parameter\n  direction: 'outgoing' | 'incoming' | 'both' | 'none'\n  length?: RelationshipLength\n}\n\ninterface RelationshipLength {\n  min?: number\n  max?: number\n}\n```\n\n### Path Pattern\n```typescript\ninterface PathPattern {\n  type: 'PathPattern'\n  variable?: Identifier\n  pattern: PatternElement[]\n}\n```\n\n### Pattern Element\n```typescript\ntype PatternElement = NodePattern | RelationshipPattern | PathPattern\n```\n\n## Acceptance Criteria\n- [ ] All pattern type tests written\n- [ ] Tests cover all pattern variants\n- [ ] Relationship direction tested\n- [ ] Variable-length patterns tested\n\n## TDD Phase: RED","status":"open","priority":1,"issue_type":"task","created_at":"2026-01-05T06:38:23.083289-06:00","updated_at":"2026-01-05T06:38:23.083289-06:00"}
{"id":"neo4j-5ii","title":"[GREEN] Relationship Operations - Implement CRUD operations to pass tests","description":"## Overview\nImplement relationship CRUD operations to make all tests pass.\n\n## Implementation Requirements\n\n### Relationship Interface\n```typescript\ninterface Relationship {\n  id: number;\n  elementId: string;\n  type: string;\n  startNodeId: number;\n  startNodeElementId: string;\n  endNodeId: number;\n  endNodeElementId: string;\n  properties: Record\u003cstring, unknown\u003e;\n}\n\ntype Direction = 'OUTGOING' | 'INCOMING' | 'BOTH';\n```\n\n### RelationshipOperations Class\n```typescript\nclass RelationshipOperations {\n  constructor(private sql: SqlStorage) {}\n\n  createRelationship(\n    type: string,\n    startNodeId: number,\n    endNodeId: number,\n    properties: Record\u003cstring, unknown\u003e = {}\n  ): Relationship {\n    // Verify both nodes exist\n    const startExists = this.sql.exec('SELECT 1 FROM nodes WHERE id = ?', startNodeId).one();\n    const endExists = this.sql.exec('SELECT 1 FROM nodes WHERE id = ?', endNodeId).one();\n    \n    if (\\!startExists) throw new Error('Start node not found');\n    if (\\!endExists) throw new Error('End node not found');\n    \n    const result = this.sql.exec(\n      'INSERT INTO relationships (type, start_node_id, end_node_id, properties) VALUES (?, ?, ?, ?) RETURNING *',\n      type, startNodeId, endNodeId, JSON.stringify(properties)\n    );\n    return this.rowToRelationship(result.one());\n  }\n\n  getRelationship(id: number): Relationship | null {\n    const result = this.sql.exec('SELECT * FROM relationships WHERE id = ?', id);\n    const row = result.one();\n    return row ? this.rowToRelationship(row) : null;\n  }\n\n  updateRelationship(id: number, properties: Record\u003cstring, unknown\u003e): Relationship {\n    const existing = this.getRelationship(id);\n    if (\\!existing) throw new Error('Relationship not found');\n    \n    const merged = { ...existing.properties, ...properties };\n    Object.keys(merged).forEach(k =\u003e merged[k] === null \u0026\u0026 delete merged[k]);\n    \n    this.sql.exec(\n      'UPDATE relationships SET properties = ? WHERE id = ?',\n      JSON.stringify(merged), id\n    );\n    return this.getRelationship(id)\\!;\n  }\n\n  deleteRelationship(id: number): boolean {\n    const result = this.sql.exec('DELETE FROM relationships WHERE id = ?', id);\n    return result.rowsWritten \u003e 0;\n  }\n\n  getRelationshipsByType(type: string): Relationship[] {\n    return this.sql.exec('SELECT * FROM relationships WHERE type = ?', type)\n      .toArray().map(this.rowToRelationship);\n  }\n\n  getRelationshipsForNode(\n    nodeId: number,\n    direction: Direction = 'BOTH',\n    type?: string\n  ): Relationship[] {\n    let query = 'SELECT * FROM relationships WHERE ';\n    const conditions: string[] = [];\n    const params: (string | number)[] = [];\n\n    if (direction === 'OUTGOING' || direction === 'BOTH') {\n      conditions.push('start_node_id = ?');\n      params.push(nodeId);\n    }\n    if (direction === 'INCOMING' || direction === 'BOTH') {\n      conditions.push('end_node_id = ?');\n      params.push(nodeId);\n    }\n\n    query += '(' + conditions.join(' OR ') + ')';\n    \n    if (type) {\n      query += ' AND type = ?';\n      params.push(type);\n    }\n\n    return this.sql.exec(query, ...params).toArray().map(this.rowToRelationship);\n  }\n}\n```\n\n## Files to Create\n- `src/storage/operations/relationship-operations.ts`\n- `src/storage/types/relationship.ts`\n\n## Acceptance Criteria\n- [ ] All RED phase tests pass\n- [ ] Foreign key validation works\n- [ ] Direction filtering works\n- [ ] Type filtering works\n\n## TDD Phase\n**GREEN** - Minimum code to pass tests","status":"open","priority":1,"issue_type":"task","created_at":"2026-01-05T06:37:43.851724-06:00","updated_at":"2026-01-05T06:37:43.851724-06:00"}
{"id":"neo4j-5ip","title":"Build configuration (tsup.config.ts)","description":"# Build Configuration with tsup\n\n## Overview\nConfigure tsup for building the neo4j.do library with multiple entry points and formats.\n\n## Entry Points\n- `src/index.ts` -\u003e Main export\n- `src/client.ts` -\u003e Client export\n- `src/types.ts` -\u003e Types export\n- `src/lite.ts` -\u003e Lite version (no RxJS dependencies)\n\n## Build Configuration\n```typescript\nimport { defineConfig } from 'tsup'\n\nexport default defineConfig({\n  entry: {\n    index: 'src/index.ts',\n    client: 'src/client.ts',\n    types: 'src/types.ts',\n    lite: 'src/lite.ts'\n  },\n  format: ['esm', 'cjs'],\n  dts: true,\n  clean: true,\n  splitting: true,\n  treeshake: true,\n  minify: false, // For debugging; enable for production\n  sourcemap: true,\n  external: ['rxjs'], // External for lite version\n  target: 'es2022'\n})\n```\n\n## Output Structure\n```\ndist/\n├── index.js\n├── index.d.ts\n├── client.js\n├── client.d.ts\n├── types.js\n├── types.d.ts\n├── lite.js\n└── lite.d.ts\n```\n\n## Acceptance Criteria\n- [ ] tsup.config.ts created\n- [ ] All entry points build successfully\n- [ ] ESM and CJS formats generated\n- [ ] Type declarations generated\n- [ ] Source maps generated\n- [ ] Build output is tree-shakeable","status":"open","priority":1,"issue_type":"task","created_at":"2026-01-05T06:34:59.248449-06:00","updated_at":"2026-01-05T06:34:59.248449-06:00"}
{"id":"neo4j-5kj","title":"[REFACTOR] ID Generation - Add caching and optimize lookups","description":"## Overview\nRefactor ID generation for better performance and compatibility.\n\n## Refactoring Tasks\n\n### Performance Optimization\n```typescript\nclass IdGenerator {\n  private elementIdCache = new Map\u003cnumber, string\u003e();\n  private internalIdCache = new Map\u003cstring, number\u003e();\n  private cacheMaxSize = 10000;\n\n  encodeNodeId(internalId: number): string {\n    const cached = this.elementIdCache.get(internalId);\n    if (cached) return cached;\n    \n    const elementId = `4:${this.databaseUuid}:${internalId}`;\n    this.addToCache(internalId, elementId);\n    return elementId;\n  }\n\n  private addToCache(internalId: number, elementId: string): void {\n    if (this.elementIdCache.size \u003e= this.cacheMaxSize) {\n      // LRU eviction\n      const firstKey = this.elementIdCache.keys().next().value;\n      this.elementIdCache.delete(firstKey);\n    }\n    this.elementIdCache.set(internalId, elementId);\n    this.internalIdCache.set(elementId, internalId);\n  }\n}\n```\n\n### Batch Operations\n```typescript\nencodeNodeIds(internalIds: number[]): string[] {\n  return internalIds.map(id =\u003e this.encodeNodeId(id));\n}\n\ndecodeElementIds(elementIds: string[]): number[] {\n  return elementIds.map(id =\u003e this.extractInternalId(id));\n}\n```\n\n### Compatibility Layer\n```typescript\n// Support legacy ID formats\nparseLegacyId(id: string | number): number {\n  if (typeof id === 'number') return id;\n  if (id.includes(':')) return this.extractInternalId(id);\n  return parseInt(id, 10);\n}\n\n// Support Neo4j driver ID objects\nfromNeo4jId(neo4jId: { low: number; high: number }): number {\n  // Handle Neo4j Integer type\n  return neo4jId.low;\n}\n```\n\n### Code Quality\n- Add comprehensive type definitions\n- Add JSDoc documentation\n- Add ID format validation utilities\n- Create ID conversion helpers\n\n## Acceptance Criteria\n- [ ] All tests still pass\n- [ ] Caching improves performance\n- [ ] Batch operations available\n- [ ] Legacy compatibility added\n- [ ] Code well-documented\n\n## TDD Phase\n**REFACTOR** - Improve without changing behavior","status":"open","priority":2,"issue_type":"task","created_at":"2026-01-05T06:38:47.008023-06:00","updated_at":"2026-01-05T06:38:47.008023-06:00"}
{"id":"neo4j-666","title":"[REFACTOR] Spatial Types (Point) - Optimize and Harden","description":"## Overview\nRefactor Point type for performance, edge cases, and enhanced functionality.\n\n## TDD Phase: REFACTOR (Improve While Green)\n\n### Refactoring Goals\n\n#### Distance Calculations (Optional Enhancement)\n- [ ] Add `point.distance(other)` for same SRID\n- [ ] Haversine distance for geographic points\n- [ ] Euclidean distance for cartesian points\n\n#### Bounding Box Support\n- [ ] `Point.boundingBox(points[])` utility\n- [ ] Within-bounds checking\n\n#### Edge Case Hardening\n- [ ] Antimeridian crossing (longitude +-180)\n- [ ] Pole proximity handling\n- [ ] Coordinate precision limits\n- [ ] Very large/small coordinate values\n\n#### Performance Optimizations\n- [ ] Cache toString() results\n- [ ] Efficient equality checking\n- [ ] Minimize property access overhead\n\n#### Code Quality\n- [ ] Add comprehensive JSDoc\n- [ ] Type narrowing for 2D vs 3D points\n- [ ] Better error messages for invalid coordinates\n\n#### Additional Tests\n- [ ] Distance calculation accuracy tests\n- [ ] Serialization round-trip tests\n- [ ] Property-based tests for coordinates\n- [ ] Integration with Cypher POINT() function\n\n### Acceptance Criteria\n- [ ] All existing tests still pass\n- [ ] Optional distance methods documented\n- [ ] 100% test coverage\n- [ ] JSDoc complete for all public API\n\n### Dependencies\n- Depends on: [GREEN] Spatial Types (Point) - Implement to Pass Tests","status":"open","priority":1,"issue_type":"task","created_at":"2026-01-05T06:37:29.079602-06:00","updated_at":"2026-01-05T06:37:29.079602-06:00"}
{"id":"neo4j-67q","title":"[GREEN] Lexer: Implement Identifier and Keyword Parsing","description":"## Overview\nImplement identifier and keyword tokenization.\n\n## Implementation Tasks\n\n### Identifier Scanner\n```typescript\nprivate scanIdentifier(): Token {\n  // Start with letter or underscore\n  // Continue with letter, digit, or underscore\n  // Check if result is a keyword\n  // Return KEYWORD or IDENTIFIER token\n}\n```\n\n### Backtick Identifier Scanner\n```typescript\nprivate scanBacktickIdentifier(): Token {\n  // Scan until closing backtick\n  // Handle escaped backticks\n  // Return IDENTIFIER token (never keyword)\n}\n```\n\n### Keyword Lookup\n```typescript\nconst KEYWORDS = new Set([\n  'MATCH', 'OPTIONAL', 'WHERE', 'RETURN', 'WITH', ...\n])\n\nprivate isKeyword(value: string): boolean {\n  return KEYWORDS.has(value.toUpperCase())\n}\n```\n\n## Acceptance Criteria\n- [ ] All identifier tests pass\n- [ ] All keyword tests pass\n- [ ] Case insensitivity for keywords\n- [ ] Backtick escaping works correctly\n\n## TDD Phase: GREEN\n## Depends On: neo4j-1uc","status":"open","priority":1,"issue_type":"task","created_at":"2026-01-05T06:36:30.899863-06:00","updated_at":"2026-01-05T06:36:30.899863-06:00"}
{"id":"neo4j-6fn","title":"[RED] Cypher Version Compatibility Tests (Cypher 9, 10)","description":"# [RED] Cypher Version Compatibility Tests\n\n## Overview\nCreate tests to verify compatibility with different Cypher versions, specifically Cypher 9 and Cypher 10.\n\n## Cypher Version Differences\n\n### Cypher 9 Features\n- Standard pattern matching\n- Classic aggregations\n- Original function set\n- Traditional path expressions\n\n### Cypher 10 New Features\n- Graph Pattern Matching (GPM)\n- Improved subqueries (CALL in transactions)\n- Enhanced type system\n- New functions and operators\n- Pattern comprehension improvements\n\n## Test Structure\n\n### Version Detection\n```typescript\ndescribe('Cypher Version Detection', () =\u003e {\n  it('should report supported Cypher version', async () =\u003e {\n    const result = await session.run('CALL dbms.components() YIELD versions')\n    // Verify version info is available\n  })\n\n  it('should accept version hint in query', async () =\u003e {\n    const result = await session.run('CYPHER 9 MATCH (n) RETURN n')\n    expect(result).toBeDefined()\n  })\n})\n```\n\n### Cypher 9 Compatibility\n```typescript\ndescribe('Cypher 9 Compatibility', () =\u003e {\n  it('should support variable-length paths', async () =\u003e {\n    await session.run('MATCH (a)-[*1..3]-\u003e(b) RETURN a, b')\n  })\n\n  it('should support classic aggregations', async () =\u003e {\n    await session.run('MATCH (n) RETURN count(n), sum(n.value), avg(n.value)')\n  })\n\n  it('should support UNWIND', async () =\u003e {\n    await session.run('UNWIND [1, 2, 3] AS x RETURN x')\n  })\n\n  it('should support FOREACH', async () =\u003e {\n    await session.run('FOREACH (x IN [1,2,3] | CREATE (:Node {value: x}))')\n  })\n})\n```\n\n### Cypher 10 Features\n```typescript\ndescribe('Cypher 10 Features', () =\u003e {\n  it('should support graph pattern quantifiers', async () =\u003e {\n    // New quantified path patterns\n    await session.run('MATCH (a)--\u003e+(b) RETURN a, b')\n  })\n\n  it('should support CALL in transactions', async () =\u003e {\n    await session.run(`\n      CALL {\n        CREATE (n:Node)\n        RETURN n\n      } IN TRANSACTIONS OF 100 ROWS\n    `)\n  })\n\n  it('should support enhanced type predicates', async () =\u003e {\n    await session.run('MATCH (n) WHERE n IS Node RETURN n')\n  })\n\n  it('should support new string functions', async () =\u003e {\n    await session.run(\"RETURN normalize('café') AS normalized\")\n  })\n})\n```\n\n### Version-Specific Error Handling\n```typescript\ndescribe('Version-Specific Errors', () =\u003e {\n  it('should reject Cypher 10 syntax when requesting Cypher 9', async () =\u003e {\n    await expect(\n      session.run('CYPHER 9 MATCH (a)--\u003e+(b) RETURN a, b')\n    ).rejects.toThrow()\n  })\n\n  it('should provide helpful upgrade hints', async () =\u003e {\n    // When Cypher 10 feature used without version hint\n    // Suggest updating Cypher version\n  })\n})\n```\n\n## Compatibility Matrix\n| Feature | Cypher 9 | Cypher 10 | neo4j.do |\n|---------|----------|-----------|----------|\n| Variable-length paths | Yes | Yes | TBD |\n| Pattern quantifiers | No | Yes | TBD |\n| CALL IN TRANSACTIONS | No | Yes | TBD |\n\n## Acceptance Criteria\n- [ ] Tests written for Cypher 9 features\n- [ ] Tests written for Cypher 10 features\n- [ ] Version detection tests written\n- [ ] Compatibility matrix documented\n- [ ] Tests fail initially (RED phase)","status":"open","priority":2,"issue_type":"task","created_at":"2026-01-05T06:38:57.72616-06:00","updated_at":"2026-01-05T06:38:57.72616-06:00"}
{"id":"neo4j-6md","title":"RED: Pattern to JOIN Translation - Relationship Patterns","description":"## Overview\nWrite failing tests for relationship pattern translation to JOINs.\n\n## Test Cases to Write\n\n### Test 1: Two-Node Outgoing Relationship\n```typescript\ntest('translates (a)-[r]-\u003e(b) to JOIN', () =\u003e {\n  const ast = parse('MATCH (a)-[r]-\u003e(b) RETURN a, b');\n  const sql = translate(ast);\n  expect(sql).toContain('JOIN relationships');\n  expect(sql).toContain('JOIN nodes');\n  expect(sql).toContain('start_node_id');\n  expect(sql).toContain('end_node_id');\n});\n```\n\n### Test 2: Incoming Relationship\n```typescript\ntest('translates (a)\u003c-[r]-(b) with reversed direction', () =\u003e {\n  const ast = parse('MATCH (a)\u003c-[r]-(b) RETURN a, b');\n  const sql = translate(ast);\n  // a is end_node, b is start_node\n  expect(sql).toMatch(/a\\.id.*=.*end_node_id/);\n});\n```\n\n### Test 3: Undirected Relationship\n```typescript\ntest('translates (a)-[r]-(b) to bidirectional match', () =\u003e {\n  const ast = parse('MATCH (a)-[r]-(b) RETURN a, b');\n  const sql = translate(ast);\n  // Should match either direction\n  expect(sql).toMatch(/OR/);\n});\n```\n\n### Test 4: Relationship with Type\n```typescript\ntest('translates (a)-[r:KNOWS]-\u003e(b) with type filter', () =\u003e {\n  const ast = parse('MATCH (a)-[r:KNOWS]-\u003e(b) RETURN a, b');\n  const sql = translate(ast);\n  expect(sql).toContain(\"type = 'KNOWS'\");\n});\n```\n\n### Test 5: Relationship with Properties\n```typescript\ntest('translates relationship properties to WHERE', () =\u003e {\n  const ast = parse('MATCH (a)-[r {since: 2020}]-\u003e(b) RETURN r');\n  const sql = translate(ast);\n  expect(sql).toContain('json_extract');\n  expect(sql).toContain('since');\n});\n```\n\n### Test 6: Multiple Relationship Hops\n```typescript\ntest('translates (a)-[]-\u003e(b)-[]-\u003e(c) to multiple JOINs', () =\u003e {\n  const ast = parse('MATCH (a)-[r1]-\u003e(b)-[r2]-\u003e(c) RETURN a, c');\n  const sql = translate(ast);\n  // Should have 3 node aliases and 2 relationship JOINs\n  expect(sql.match(/JOIN/g)?.length).toBeGreaterThanOrEqual(4);\n});\n```\n\n### Test 7: Anonymous Relationship\n```typescript\ntest('handles anonymous relationship (a)--\u003e(b)', () =\u003e {\n  const ast = parse('MATCH (a)--\u003e(b) RETURN a');\n  const sql = translate(ast);\n  expect(sql).toContain('relationships');\n});\n```\n\n## Acceptance Criteria\n- [ ] All tests written and failing\n- [ ] Direction handling tested (in, out, both)\n- [ ] Multiple hops tested\n\n## TDD Phase\nRED - Write failing tests first","status":"open","priority":1,"issue_type":"task","created_at":"2026-01-05T06:35:24.509766-06:00","updated_at":"2026-01-05T06:35:24.509766-06:00"}
{"id":"neo4j-6nt","title":"REFACTOR: Neo4jHttpDriver class optimization","description":"## Test-Driven Development: REFACTOR Phase\n\n### Component\nHTTP Client SDK - Neo4jHttpDriver Class\n\n### Refactoring Goals\n\n1. **Extract HTTP client concerns**\n   - Create `HttpClient` utility class for fetch wrapper\n   - Centralize header building and error handling\n\n2. **Improve type safety**\n   - Add branded types for URL validation\n   - Strict typing for auth configurations\n\n3. **Connection pooling abstraction**\n   - Implement `ConnectionPool` interface\n   - Support keep-alive connections\n\n4. **Error handling**\n   - Create `HttpDriverError` class hierarchy\n   - Map HTTP status codes to Neo4j error types\n\n### Code Improvements\n\n```typescript\n// Extract to http-client.ts\nexport class HttpClient {\n  constructor(\n    private baseUrl: string,\n    private config: HttpClientConfig\n  ) {}\n\n  async request\u003cT\u003e(path: string, init?: RequestInit): Promise\u003cT\u003e {\n    const response = await this.fetch(path, init)\n    if (!response.ok) {\n      throw await this.createError(response)\n    }\n    return response.json()\n  }\n\n  private async createError(response: Response): Promise\u003cHttpDriverError\u003e {\n    const body = await response.json().catch(() =\u003e ({}))\n    return new HttpDriverError(response.status, body.message, body.code)\n  }\n}\n```\n\n### Acceptance Criteria\n- [ ] All existing tests still pass\n- [ ] HttpClient extracted and reusable\n- [ ] Error classes properly structured\n- [ ] Code coverage maintained or improved\n- [ ] No external dependencies added\n\n### Dependencies\n- GREEN: Implement Neo4jHttpDriver class\n\n### TDD Cycle\nThis completes the RED-\u003eGREEN-\u003eREFACTOR cycle for Neo4jHttpDriver.","status":"open","priority":2,"issue_type":"task","created_at":"2026-01-05T06:35:06.19288-06:00","updated_at":"2026-01-05T06:35:06.19288-06:00"}
{"id":"neo4j-6sj","title":"[GREEN] Integer Type - Implement to Pass Tests","description":"## Overview\nImplement the Neo4j Integer type to pass all failing tests.\n\n## TDD Phase: GREEN (Make Tests Pass)\n\n### Implementation Requirements\n\n#### Class Structure\n```typescript\nclass Integer {\n  readonly low: number;   // Low 32 bits\n  readonly high: number;  // High 32 bits\n  \n  constructor(low: number, high: number);\n  \n  // Conversion\n  toNumber(): number;\n  toString(radix?: number): string;\n  toInt(): number;\n  toBigInt(): bigint;\n  \n  // Checks\n  inSafeRange(): boolean;\n  isZero(): boolean;\n  isNegative(): boolean;\n  isPositive(): boolean;\n  isOdd(): boolean;\n  isEven(): boolean;\n  \n  // Arithmetic\n  add(other: Integer | number | string): Integer;\n  subtract(other: Integer | number | string): Integer;\n  multiply(other: Integer | number | string): Integer;\n  divide(other: Integer | number | string): Integer;\n  modulo(other: Integer | number | string): Integer;\n  negate(): Integer;\n  \n  // Comparison\n  equals(other: Integer | number | string): boolean;\n  lessThan(other: Integer | number | string): boolean;\n  lessThanOrEqual(other: Integer | number | string): boolean;\n  greaterThan(other: Integer | number | string): boolean;\n  greaterThanOrEqual(other: Integer | number | string): boolean;\n  compare(other: Integer | number | string): number;\n  \n  // Bitwise\n  and(other: Integer | number | string): Integer;\n  or(other: Integer | number | string): Integer;\n  xor(other: Integer | number | string): Integer;\n  not(): Integer;\n  shiftLeft(bits: number): Integer;\n  shiftRight(bits: number): Integer;\n}\n```\n\n#### Factory Functions\n```typescript\nfunction int(value: number | string | Integer): Integer;\nconst integer = int; // Alias\n\ninteger.inSafeRange = (val: Integer): boolean =\u003e { ... };\ninteger.toNumber = (val: Integer): number =\u003e { ... };\ninteger.toString = (val: Integer, radix?: number): string =\u003e { ... };\n```\n\n#### Constants\n```typescript\nInteger.ZERO: Integer;\nInteger.ONE: Integer;\nInteger.NEG_ONE: Integer;\nInteger.MAX_VALUE: Integer;\nInteger.MIN_VALUE: Integer;\nInteger.MAX_SAFE_VALUE: Integer;\nInteger.MIN_SAFE_VALUE: Integer;\n```\n\n### Implementation Notes\n- Use two 32-bit numbers (low/high) for 64-bit representation\n- Match neo4j-driver behavior exactly\n- Handle string parsing for large integers\n- Implement efficient arithmetic using 32-bit operations\n\n### Acceptance Criteria\n- [ ] All RED phase tests passing\n- [ ] Implementation matches neo4j-driver API\n- [ ] No TypeScript errors\n- [ ] Implementation file at `src/types/integer.ts`\n- [ ] Exported from `src/types/index.ts`\n\n### Dependencies\n- Depends on: [RED] Integer Type - Write Failing Tests","status":"open","priority":1,"issue_type":"task","created_at":"2026-01-05T06:34:56.435371-06:00","updated_at":"2026-01-05T06:34:56.435371-06:00"}
{"id":"neo4j-73h","title":"REFACTOR: Pattern to JOIN Translation - Single Node Pattern","description":"## Overview\nRefactor single node pattern translation for cleanliness and extensibility.\n\n## Refactoring Tasks\n\n### 1. Extract SQL Builder\n```typescript\nclass SQLBuilder {\n  select(columns: string[]): this;\n  from(table: string, alias?: string): this;\n  where(condition: string): this;\n  build(): string;\n}\n```\n\n### 2. Create Label Strategy Pattern\n```typescript\ninterface LabelMatcher {\n  match(labels: string[]): SQLCondition;\n}\n\nclass SingleLabelMatcher implements LabelMatcher { }\nclass MultiLabelMatcher implements LabelMatcher { }\n```\n\n### 3. Improve Property Access\n```typescript\nclass PropertyAccessor {\n  static jsonExtract(column: string, path: string): string;\n  static jsonSet(column: string, path: string, value: any): string;\n}\n```\n\n### 4. Add Documentation\n- JSDoc comments for public APIs\n- Inline comments for complex logic\n- Usage examples\n\n## Quality Improvements\n- [ ] No code duplication\n- [ ] Single responsibility per function\n- [ ] Consistent naming conventions\n- [ ] Type safety throughout\n\n## Acceptance Criteria\n- [ ] All tests still pass after refactoring\n- [ ] Code coverage maintained or improved\n- [ ] No new technical debt\n\n## TDD Phase\nREFACTOR - Improve code quality while keeping tests green\n\n## Dependencies\n- Depends on: GREEN: Pattern to JOIN Translation - Single Node Pattern","status":"open","priority":1,"issue_type":"task","created_at":"2026-01-05T06:35:02.073918-06:00","updated_at":"2026-01-05T06:35:02.073918-06:00"}
{"id":"neo4j-76b","title":"[GREEN] SQLite Schema Design - Implement schema to pass tests","description":"## Overview\nImplement the SQLite schema to make all failing tests pass.\n\n## Implementation Requirements\n\n### Nodes Table\n```sql\nCREATE TABLE IF NOT EXISTS nodes (\n  id INTEGER PRIMARY KEY AUTOINCREMENT,\n  labels TEXT NOT NULL DEFAULT '[]',\n  properties TEXT NOT NULL DEFAULT '{}',\n  created_at DATETIME DEFAULT CURRENT_TIMESTAMP,\n  updated_at DATETIME DEFAULT CURRENT_TIMESTAMP\n);\n```\n\n### Relationships Table\n```sql\nCREATE TABLE IF NOT EXISTS relationships (\n  id INTEGER PRIMARY KEY AUTOINCREMENT,\n  type TEXT NOT NULL,\n  start_node_id INTEGER NOT NULL REFERENCES nodes(id),\n  end_node_id INTEGER NOT NULL REFERENCES nodes(id),\n  properties TEXT NOT NULL DEFAULT '{}',\n  created_at DATETIME DEFAULT CURRENT_TIMESTAMP\n);\n```\n\n### Indexes\n```sql\nCREATE INDEX IF NOT EXISTS idx_nodes_labels ON nodes(labels);\nCREATE INDEX IF NOT EXISTS idx_relationships_type ON relationships(type);\nCREATE INDEX IF NOT EXISTS idx_relationships_start ON relationships(start_node_id);\nCREATE INDEX IF NOT EXISTS idx_relationships_end ON relationships(end_node_id);\n```\n\n### Schema Versioning\n```sql\nCREATE TABLE IF NOT EXISTS schema_version (\n  version INTEGER PRIMARY KEY,\n  applied_at DATETIME DEFAULT CURRENT_TIMESTAMP\n);\n```\n\n## Files to Create/Modify\n- `src/storage/schema.ts` - Schema definitions\n- `src/storage/migrations.ts` - Migration runner\n\n## Acceptance Criteria\n- [ ] All RED phase tests now pass\n- [ ] Schema is created on Durable Object initialization\n- [ ] Foreign key constraints work correctly\n- [ ] Indexes are created properly\n\n## TDD Phase\n**GREEN** - Minimum code to pass tests","status":"open","priority":1,"issue_type":"task","created_at":"2026-01-05T06:34:43.563302-06:00","updated_at":"2026-01-05T06:34:43.563302-06:00"}
{"id":"neo4j-78n","title":"GREEN: Implement HttpSession class","description":"## Test-Driven Development: GREEN Phase\n\n### Component\nHTTP Client SDK - HttpSession Class\n\n### Implementation Requirements\n\nImplement `src/client/http-session.ts`:\n\n```typescript\nimport { Neo4jHttpDriver } from './http-driver'\nimport { HttpTransaction } from './http-transaction'\nimport { QueryResult, Record } from './types'\n\nexport interface SessionConfig {\n  database?: string\n  defaultAccessMode?: 'READ' | 'WRITE'\n  bookmarks?: string[]\n}\n\nexport class HttpSession {\n  private _closed = false\n  private lastBookmarks: string[] = []\n\n  constructor(\n    private driver: Neo4jHttpDriver,\n    private config: SessionConfig = {}\n  ) {}\n\n  get isClosed(): boolean {\n    return this._closed\n  }\n\n  async run\u003cT = Record\u003e(\n    query: string,\n    parameters?: Record\u003cstring, unknown\u003e\n  ): Promise\u003cQueryResult\u003cT\u003e\u003e {\n    this.assertOpen()\n    \n    const response = await this.driver.fetch('/query', {\n      method: 'POST',\n      body: JSON.stringify({\n        query,\n        parameters: parameters ?? {},\n        database: this.config.database,\n        bookmarks: this.lastBookmarks\n      })\n    })\n\n    const data = await response.json()\n    this.lastBookmarks = data.bookmarks ?? []\n    return this.mapResult\u003cT\u003e(data)\n  }\n\n  async executeRead\u003cT\u003e(\n    work: (tx: HttpTransaction) =\u003e Promise\u003cT\u003e\n  ): Promise\u003cT\u003e {\n    return this.executeInTransaction(work, 'READ')\n  }\n\n  async executeWrite\u003cT\u003e(\n    work: (tx: HttpTransaction) =\u003e Promise\u003cT\u003e\n  ): Promise\u003cT\u003e {\n    return this.executeInTransaction(work, 'WRITE')\n  }\n\n  private async executeInTransaction\u003cT\u003e(\n    work: (tx: HttpTransaction) =\u003e Promise\u003cT\u003e,\n    accessMode: 'READ' | 'WRITE'\n  ): Promise\u003cT\u003e {\n    this.assertOpen()\n    const tx = await this.beginTransaction({ accessMode })\n    try {\n      const result = await work(tx)\n      await tx.commit()\n      return result\n    } catch (error) {\n      await tx.rollback()\n      throw error\n    }\n  }\n\n  async beginTransaction(config?: { accessMode?: 'READ' | 'WRITE' }): Promise\u003cHttpTransaction\u003e {\n    this.assertOpen()\n    \n    const response = await this.driver.fetch('/tx/begin', {\n      method: 'POST',\n      body: JSON.stringify({\n        database: this.config.database,\n        accessMode: config?.accessMode ?? this.config.defaultAccessMode ?? 'WRITE',\n        bookmarks: this.lastBookmarks\n      })\n    })\n\n    const data = await response.json()\n    return new HttpTransaction(this.driver, data.id)\n  }\n\n  async close(): Promise\u003cvoid\u003e {\n    this._closed = true\n  }\n\n  private assertOpen(): void {\n    if (this._closed) {\n      throw new Error('Session is closed')\n    }\n  }\n\n  private mapResult\u003cT\u003e(data: any): QueryResult\u003cT\u003e {\n    return {\n      records: data.records.map((r: any) =\u003e new Record(r)),\n      summary: data.summary,\n      keys: data.keys\n    }\n  }\n}\n```\n\n### Acceptance Criteria\n- [ ] All RED phase tests pass\n- [ ] run() POSTs to /query endpoint\n- [ ] executeRead/Write use correct access modes\n- [ ] beginTransaction returns HttpTransaction\n- [ ] Session tracks bookmarks\n- [ ] close() prevents further operations\n\n### Dependencies\n- RED: HttpSession class methods fail without implementation\n- GREEN: Implement Neo4jHttpDriver class\n\n### TDD Cycle\nThis is the GREEN phase. Next: REFACTOR phase.","status":"open","priority":2,"issue_type":"task","created_at":"2026-01-05T06:35:55.784768-06:00","updated_at":"2026-01-05T06:35:55.784768-06:00"}
{"id":"neo4j-7ec","title":"REFACTOR: Session Bookmarks \u0026 Lifecycle Optimization","description":"## Overview\nRefactor Session bookmarks and lifecycle for robustness and advanced scenarios.\n\n## Refactoring Goals\n\n### Bookmark Enhancements\n- Bookmark manager for cross-session coordination\n- Bookmark compression for storage efficiency\n- Bookmark expiration handling\n- Multi-database bookmark merging\n\n### Lifecycle Improvements\n- Graceful degradation on partial failures\n- Session pooling support\n- Idle session timeout\n- Session health monitoring\n\n### Edge Cases\n```typescript\ndescribe('Session Lifecycle Edge Cases', () =\u003e {\n  it('should handle close during query execution')\n  it('should handle close during transaction work function')\n  it('should handle rapid open/close cycles')\n  it('should handle close with uncommitted changes')\n  it('should handle concurrent close calls')\n  it('should handle driver close during session operation')\n})\n\ndescribe('Bookmark Edge Cases', () =\u003e {\n  it('should handle malformed bookmarks gracefully')\n  it('should handle bookmarks from future transactions')\n  it('should handle bookmarks from deleted databases')\n  it('should handle very old bookmarks')\n  it('should merge bookmarks from multiple databases')\n})\n```\n\n### Observability\n- Session lifecycle events\n- Bookmark tracking metrics\n- Query timing telemetry\n\n## TDD Phase\n**REFACTOR** - Improve without breaking tests.\n\n## Dependencies\n- Depends on: GREEN: Session Bookmarks \u0026 Lifecycle Implementation\n\n## Acceptance Criteria\n- [ ] All tests pass\n- [ ] Advanced bookmark scenarios work\n- [ ] Session lifecycle is bulletproof\n- [ ] Metrics and logging added","status":"open","priority":2,"issue_type":"task","created_at":"2026-01-05T06:37:49.313366-06:00","updated_at":"2026-01-05T06:37:49.313366-06:00"}
{"id":"neo4j-7t2","title":"[RED] Vector Type - Write Failing Tests","description":"## Overview\nWrite comprehensive failing tests for the Vector type (superset feature for AI/ML workloads).\n\n## TDD Phase: RED (Write Failing Tests)\n\n### Note: Superset Feature\nThis is a **superset feature** not in standard neo4j-driver. It provides first-class vector support for embeddings and AI/ML use cases.\n\n### Test Cases to Write\n\n#### Vector Factory\n```typescript\n// From Float32Array (most common for embeddings)\nneo4j.vector(new Float32Array([0.1, 0.2, 0.3]))\n\n// From regular array (auto-converts to Float32)\nneo4j.vector([0.1, 0.2, 0.3])\n\n// With explicit type\nneo4j.vector(data, 'float32')\nneo4j.vector(data, 'float64')\nneo4j.vector(data, 'int8')\nneo4j.vector(data, 'int16')\nneo4j.vector(data, 'int32')\nneo4j.vector(data, 'int64')\n```\n\n#### Vector Properties\n```typescript\nvector.dimensions    // number of elements\nvector.dtype         // 'float32' | 'float64' | 'int8' | etc.\nvector.byteLength    // size in bytes\n```\n\n#### Vector Methods\n```typescript\nvector.asTypedArray()      // returns underlying TypedArray\nvector.toArray()           // returns regular number[]\nvector.at(index)           // element access\nvector.slice(start, end)   // returns new Vector\nvector.toString()          // string representation\n```\n\n#### Type Guard\n```typescript\nneo4j.isVector(value)  // true for Vector instances\n```\n\n#### Serialization\n```typescript\nvector.toJSON()        // { type: 'Vector', dtype, dimensions, data }\nVector.fromJSON(obj)   // reconstruct from JSON\n```\n\n### Test Categories\n\n#### 1. Construction Tests\n- From each TypedArray type\n- From regular arrays\n- With explicit dtype specification\n- Invalid input handling\n\n#### 2. Property Tests\n- dimensions accuracy\n- dtype correctness\n- byteLength calculation\n\n#### 3. Method Tests\n- asTypedArray returns correct type\n- toArray conversion\n- at() bounds checking\n- slice() behavior\n\n#### 4. Edge Cases\n- Empty vectors\n- Very large vectors (10K+ dimensions)\n- Single-element vectors\n- NaN/Infinity values\n- Type coercion edge cases\n\n### Acceptance Criteria\n- [ ] All tests written and failing (RED state)\n- [ ] All supported dtypes tested\n- [ ] Edge cases covered\n- [ ] Test file at `src/types/vector.test.ts`\n\n### References\n- [Neo4j Vector Index](https://neo4j.com/docs/cypher-manual/current/indexes/semantic-indexes/vector-indexes/)\n- Common embedding sizes: 384, 768, 1536, 3072","status":"open","priority":2,"issue_type":"task","created_at":"2026-01-05T06:37:51.588788-06:00","updated_at":"2026-01-05T06:37:51.588788-06:00"}
{"id":"neo4j-80r","title":"RED: Session Bookmarks \u0026 Lifecycle Tests","description":"## Overview\nWrite comprehensive failing tests for Session bookmarks, causal consistency, and lifecycle management.\n\n## Test Cases\n\n### Bookmark Tests\n```typescript\ndescribe('session.lastBookmark()', () =\u003e {\n  it('should return null before any transaction')\n  it('should return bookmark after write transaction')\n  it('should return latest bookmark after multiple writes')\n  it('should not change after read transaction')\n})\n\ndescribe('session.lastBookmarks()', () =\u003e {\n  it('should return empty array before any transaction')\n  it('should return array with single bookmark')\n  it('should return array with multiple bookmarks')\n  it('should include initial bookmarks from config')\n})\n```\n\n### Causal Consistency Tests\n```typescript\ndescribe('Causal Consistency', () =\u003e {\n  it('should wait for bookmarks when session created with bookmarks')\n  it('should chain bookmarks across sessions')\n  it('should handle bookmark from different database')\n  it('should handle invalid bookmark format')\n  it('should handle expired bookmark')\n})\n```\n\n### Session Lifecycle Tests\n```typescript\ndescribe('session.close()', () =\u003e {\n  it('should close session successfully')\n  it('should rollback open transaction on close')\n  it('should release all resources')\n  it('should be idempotent')\n  it('should reject new operations after close')\n  it('should wait for in-flight queries')\n})\n\ndescribe('Session State', () =\u003e {\n  it('should track session open/closed state')\n  it('should throw SessionExpired on operation after close')\n  it('should remove from driver tracking on close')\n})\n```\n\n### Configuration Tests\n```typescript\ndescribe('Session Configuration', () =\u003e {\n  it('should use specified database')\n  it('should default to neo4j database')\n  it('should respect defaultAccessMode for transactions')\n  it('should apply fetchSize to results')\n  it('should impersonate user when specified')\n})\n```\n\n## TDD Phase\n**RED** - All tests should fail initially.\n\n## Acceptance Criteria\n- [ ] All test cases written\n- [ ] Causal consistency scenarios covered\n- [ ] Lifecycle edge cases tested\n- [ ] Configuration validation tested","status":"open","priority":1,"issue_type":"task","created_at":"2026-01-05T06:37:13.274195-06:00","updated_at":"2026-01-05T06:37:13.274195-06:00"}
{"id":"neo4j-82o","title":"[RED] Neo4j Driver Behavior Parity Tests","description":"# [RED] Neo4j Driver Behavior Parity Tests\n\n## Overview\nCreate tests that verify neo4j.do behaves identically to neo4j-driver in all scenarios.\n\n## Behavioral Tests\n\n### Connection Behavior\n```typescript\ndescribe('Connection Behavior Parity', () =\u003e {\n  it('should handle connection failure gracefully', async () =\u003e {\n    const d = driver('bolt://invalid-host:7687', auth.basic('u', 'p'))\n    await expect(d.verifyConnectivity()).rejects.toThrow()\n  })\n\n  it('should timeout on slow connections', async () =\u003e {\n    const d = driver('bolt://slow-host:7687', auth.basic('u', 'p'), {\n      connectionTimeout: 1000\n    })\n    await expect(d.verifyConnectivity()).rejects.toThrow(/timeout/i)\n  })\n\n  it('should reconnect after connection loss', async () =\u003e {\n    // Test connection recovery behavior\n  })\n})\n```\n\n### Query Result Behavior\n```typescript\ndescribe('Query Result Behavior Parity', () =\u003e {\n  it('should return same result structure', async () =\u003e {\n    const result = await session.run('CREATE (n:Test {name: $name}) RETURN n', { name: 'test' })\n    \n    expect(result.records).toBeInstanceOf(Array)\n    expect(result.records[0].get('n')).toBeDefined()\n    expect(result.records[0].get(0)).toBeDefined() // Index access\n    expect(result.summary.counters.nodesCreated()).toBe(1)\n  })\n\n  it('should handle null values identically', async () =\u003e {\n    const result = await session.run('RETURN null AS value')\n    expect(result.records[0].get('value')).toBeNull()\n  })\n\n  it('should handle empty results', async () =\u003e {\n    const result = await session.run('MATCH (n:NonExistent) RETURN n')\n    expect(result.records).toEqual([])\n  })\n})\n```\n\n### Transaction Behavior\n```typescript\ndescribe('Transaction Behavior Parity', () =\u003e {\n  it('should rollback on error in transaction function', async () =\u003e {\n    await expect(\n      session.executeWrite(async tx =\u003e {\n        await tx.run('CREATE (n:WillBeRolledBack)')\n        throw new Error('Intentional error')\n      })\n    ).rejects.toThrow('Intentional error')\n\n    const result = await session.run('MATCH (n:WillBeRolledBack) RETURN count(n) AS count')\n    expect(result.records[0].get('count').toInt()).toBe(0)\n  })\n\n  it('should commit on successful transaction', async () =\u003e {\n    await session.executeWrite(async tx =\u003e {\n      await tx.run('CREATE (n:WillBeCommitted)')\n    })\n\n    const result = await session.run('MATCH (n:WillBeCommitted) RETURN count(n) AS count')\n    expect(result.records[0].get('count').toInt()).toBe(1)\n  })\n\n  it('should handle nested queries in transaction', async () =\u003e {\n    await session.executeWrite(async tx =\u003e {\n      await tx.run('CREATE (a:Person {name: \"Alice\"})')\n      await tx.run('CREATE (b:Person {name: \"Bob\"})')\n      await tx.run('MATCH (a:Person {name: \"Alice\"}), (b:Person {name: \"Bob\"}) CREATE (a)-[:KNOWS]-\u003e(b)')\n    })\n  })\n})\n```\n\n### Type Coercion Behavior\n```typescript\ndescribe('Type Coercion Behavior Parity', () =\u003e {\n  it('should handle Integer type', async () =\u003e {\n    const result = await session.run('RETURN 42 AS num')\n    const num = result.records[0].get('num')\n    expect(neo4j.isInt(num)).toBe(true)\n    expect(num.toInt()).toBe(42)\n  })\n\n  it('should handle large integers', async () =\u003e {\n    const result = await session.run('RETURN 9007199254740993 AS bigNum')\n    const bigNum = result.records[0].get('bigNum')\n    expect(bigNum.toString()).toBe('9007199254740993')\n  })\n\n  it('should handle temporal types', async () =\u003e {\n    const result = await session.run('RETURN datetime() AS now')\n    const now = result.records[0].get('now')\n    expect(now.year).toBeDefined()\n    expect(now.month).toBeDefined()\n  })\n})\n```\n\n## Acceptance Criteria\n- [ ] All behavior tests written\n- [ ] Tests fail initially (RED phase)\n- [ ] Edge cases covered\n- [ ] Error scenarios documented","status":"open","priority":2,"issue_type":"task","created_at":"2026-01-05T06:37:31.334913-06:00","updated_at":"2026-01-05T06:37:31.334913-06:00"}
{"id":"neo4j-83q","title":"REFACTOR: CREATE/MERGE Translation","description":"## Overview\nRefactor CREATE/MERGE translation for maintainability and performance.\n\n## Refactoring Tasks\n\n### 1. Mutation Builder Pattern\n- Unified interface for INSERT/UPDATE/DELETE\n- Batch operation support\n\n### 2. MERGE Strategy Pattern\n- InsertStrategy for new entities\n- UpdateStrategy for existing entities\n- Clean conditional logic\n\n### 3. ID Generation Strategy\n- UUID strategy (default)\n- Sequential strategy (optional)\n- Custom ID strategy\n\n### 4. Transaction Wrapper\n- Ensure atomicity of multi-statement mutations\n- Rollback support for failures\n\n## Quality Improvements\n- Clean separation of CREATE vs MERGE logic\n- Reusable property serialization\n- Consistent error handling\n- Performance optimization for batch creates\n\n## Acceptance Criteria\n- All tests still pass\n- Code is extensible for new mutation types\n- Batch operations optimized\n\n## TDD Phase\nREFACTOR - Improve code quality while keeping tests green\n\n## Dependencies\n- Depends on: GREEN: CREATE/MERGE Translation","status":"open","priority":1,"issue_type":"task","created_at":"2026-01-05T06:38:55.290576-06:00","updated_at":"2026-01-05T06:38:55.290576-06:00"}
{"id":"neo4j-85v","title":"REFACTOR: Variable-Length Path Translation - Recursive CTEs","description":"## Overview\nRefactor variable-length path translation for performance and maintainability.\n\n## Refactoring Tasks\n\n### 1. Strategy Pattern for Depth Handling\n```typescript\ninterface DepthStrategy {\n  translate(pattern: VariableLengthPattern): SQLFragment;\n  isApplicable(min?: number, max?: number): boolean;\n}\n\nclass ExactDepthStrategy implements DepthStrategy {\n  // Use JOINs for exact depth (more efficient)\n}\n\nclass BoundedDepthStrategy implements DepthStrategy {\n  // Use recursive CTE with bounds\n}\n\nclass UnboundedDepthStrategy implements DepthStrategy {\n  // Use recursive CTE with safety limit\n}\n```\n\n### 2. CTE Builder\n```typescript\nclass CTEBuilder {\n  withRecursive(name: string): this;\n  baseCase(query: string): this;\n  recursiveCase(query: string): this;\n  terminationCondition(condition: string): this;\n  build(): string;\n}\n```\n\n### 3. Performance Optimizations\n- Use LIMIT in recursive CTE for safety\n- Optimize visited array for SQLite\n- Consider using bloom filter for cycle detection\n- Add query hints for index usage\n\n### 4. Path Result Builder\n```typescript\nclass PathBuilder {\n  buildNodeArray(): string;\n  buildRelationshipArray(): string;\n  buildFullPath(): string;\n}\n```\n\n## Quality Improvements\n- [ ] Clean strategy selection\n- [ ] Reusable CTE builder\n- [ ] Performance profiling added\n- [ ] Memory-efficient cycle detection\n\n## Acceptance Criteria\n- [ ] All tests still pass\n- [ ] Performance improved for common cases\n- [ ] Code is extensible for new depth patterns\n\n## TDD Phase\nREFACTOR - Improve code quality while keeping tests green\n\n## Dependencies\n- Depends on: GREEN: Variable-Length Path Translation - Recursive CTEs","status":"open","priority":2,"issue_type":"task","created_at":"2026-01-05T06:36:57.744501-06:00","updated_at":"2026-01-05T06:36:57.744501-06:00"}
{"id":"neo4j-87a","title":"REFACTOR: Record.length - Ensure immutability","description":"## Overview\nRefactor the Record.length property for immutability guarantees.\n\n## Refactoring Tasks\n\n1. **Immutability**\n   - Ensure property cannot be overwritten\n   - Consider Object.defineProperty if needed\n\n## Acceptance Criteria\n- [ ] All tests still pass after refactoring\n- [ ] Property is truly immutable\n- [ ] TypeScript types properly defined\n\n## TDD Phase\nREFACTOR - Improve code without changing behavior\n\n## Dependencies\n- neo4j-0h4 (GREEN phase implementation)","status":"open","priority":1,"issue_type":"task","created_at":"2026-01-05T06:38:42.615375-06:00","updated_at":"2026-01-05T06:38:42.615375-06:00"}
{"id":"neo4j-8fm","title":"Initialize package.json with correct metadata","description":"# Initialize package.json with correct metadata\n\n## Overview\nSet up the foundational package.json file for the neo4j.do project with all required metadata, dependencies, and scripts.\n\n## Requirements\n- Package name: `neo4j.do`\n- Description: Neo4j-compatible graph database on Cloudflare Workers\n- Main entry point configuration\n- Module type: ESM\n- Engine requirements: Node.js 18+\n- Author and license information\n- Repository URLs\n\n## Dependencies to Include\n- Production: None initially (pure implementation)\n- Dev Dependencies:\n  - typescript\n  - tsup (bundler)\n  - vitest (testing)\n  - @cloudflare/workers-types\n  - wrangler\n  - eslint\n  - prettier\n\n## Scripts\n- `build`: Build with tsup\n- `dev`: Development mode\n- `test`: Run vitest\n- `test:watch`: Run vitest in watch mode\n- `lint`: Run eslint\n- `format`: Run prettier\n- `typecheck`: Run tsc --noEmit\n- `deploy`: Deploy to Cloudflare Workers\n\n## Acceptance Criteria\n- [ ] package.json created with all metadata\n- [ ] All scripts are defined and functional\n- [ ] Dependencies are correctly categorized\n- [ ] Package can be installed without errors","status":"open","priority":1,"issue_type":"task","created_at":"2026-01-05T06:34:24.217211-06:00","updated_at":"2026-01-05T06:34:24.217211-06:00"}
{"id":"neo4j-8hb","title":"REFACTOR: Record.get(key) - Optimize and clean up implementation","description":"## Overview\nRefactor the Record.get(key) implementation for better performance and code quality.\n\n## Refactoring Tasks\n\n1. **Type Safety**\n   - Add proper TypeScript generics\n   - Ensure return type matches column type\n\n2. **Performance**\n   - Verify Map lookup is O(1)\n   - Consider frozen object for immutability\n\n3. **Code Quality**\n   - Add JSDoc documentation\n   - Ensure Neo4j driver API compatibility\n\n## Acceptance Criteria\n- [ ] All tests still pass after refactoring\n- [ ] Code is clean and well-documented\n- [ ] TypeScript types are properly defined\n- [ ] Performance is optimal\n\n## TDD Phase\nREFACTOR - Improve code without changing behavior\n\n## Dependencies\n- neo4j-b16 (GREEN phase implementation)","status":"open","priority":1,"issue_type":"task","created_at":"2026-01-05T06:34:57.079477-06:00","updated_at":"2026-01-05T06:34:57.079477-06:00"}
{"id":"neo4j-8q6","title":"GREEN: Record.keys - Implement column names array property","description":"## Overview\nImplement the Record.keys property to make all RED phase tests pass.\n\n## Implementation\n\n```typescript\nprivate _frozenKeys: readonly string[] | null = null;\n\nget keys(): readonly string[] {\n  if (this._frozenKeys === null) {\n    this._frozenKeys = Object.freeze([...this._keys]);\n  }\n  return this._frozenKeys;\n}\n```\n\n## Acceptance Criteria\n- [ ] All RED phase tests now pass (GREEN phase)\n- [ ] Returns frozen array\n- [ ] Returns same instance on multiple access\n- [ ] Implementation is minimal\n\n## TDD Phase\nGREEN - Minimal implementation to pass tests\n\n## Dependencies\n- neo4j-95e (RED phase tests)","status":"open","priority":1,"issue_type":"task","created_at":"2026-01-05T06:37:46.236683-06:00","updated_at":"2026-01-05T06:37:46.236683-06:00"}
{"id":"neo4j-8ugu","title":"RED: Request/Response serialization fails without implementation","description":"## Test-Driven Development: RED Phase\n\n### Component\nHTTP Client SDK - Request/Response Serialization\n\n### Test Cases to Write (Expected to FAIL)\n\n```typescript\nimport { describe, it, expect } from 'vitest'\nimport { \n  serializeQuery,\n  serializeParameters,\n  deserializeResult,\n  deserializeNeo4jTypes,\n  parseErrorResponse\n} from '../src/client/serialization'\n\ndescribe('Serialization - RED', () =\u003e {\n  describe('serializeQuery()', () =\u003e {\n    it('should serialize Cypher query to JSON', () =\u003e {\n      const result = serializeQuery('MATCH (n) RETURN n', { limit: 10 })\n      expect(result).toEqual({\n        query: 'MATCH (n) RETURN n',\n        parameters: { limit: 10 }\n      })\n    })\n  })\n\n  describe('serializeParameters()', () =\u003e {\n    it('should handle primitive types', () =\u003e {\n      const result = serializeParameters({\n        string: 'hello',\n        number: 42,\n        float: 3.14,\n        boolean: true,\n        null: null\n      })\n      expect(result).toEqual({\n        string: 'hello',\n        number: 42,\n        float: 3.14,\n        boolean: true,\n        null: null\n      })\n    })\n\n    it('should serialize Date to Neo4j DateTime', () =\u003e {\n      const date = new Date('2024-01-15T10:30:00Z')\n      const result = serializeParameters({ date })\n      expect(result.date).toEqual({\n        __neo4j_type__: 'DateTime',\n        value: '2024-01-15T10:30:00.000Z'\n      })\n    })\n\n    it('should serialize Neo4j Integer for large numbers', () =\u003e {\n      const bigNum = 9007199254740993n // Beyond safe integer\n      const result = serializeParameters({ id: bigNum })\n      expect(result.id).toEqual({\n        __neo4j_type__: 'Integer',\n        value: '9007199254740993'\n      })\n    })\n\n    it('should serialize arrays', () =\u003e {\n      const result = serializeParameters({ tags: ['a', 'b', 'c'] })\n      expect(result.tags).toEqual(['a', 'b', 'c'])\n    })\n\n    it('should serialize nested objects as maps', () =\u003e {\n      const result = serializeParameters({\n        person: { name: 'Alice', age: 30 }\n      })\n      expect(result.person).toEqual({ name: 'Alice', age: 30 })\n    })\n\n    it('should serialize Point spatial type', () =\u003e {\n      const point = { latitude: 40.7128, longitude: -74.0060 }\n      const result = serializeParameters({ \n        location: { __type__: 'Point', ...point, srid: 4326 }\n      })\n      expect(result.location).toEqual({\n        __neo4j_type__: 'Point',\n        srid: 4326,\n        x: -74.0060,\n        y: 40.7128\n      })\n    })\n\n    it('should serialize Duration type', () =\u003e {\n      const result = serializeParameters({\n        interval: { __type__: 'Duration', months: 1, days: 5, seconds: 3600 }\n      })\n      expect(result.interval).toEqual({\n        __neo4j_type__: 'Duration',\n        months: 1,\n        days: 5,\n        seconds: 3600,\n        nanoseconds: 0\n      })\n    })\n  })\n\n  describe('deserializeResult()', () =\u003e {\n    it('should deserialize query result to records', () =\u003e {\n      const response = {\n        keys: ['n', 'count'],\n        records: [\n          { n: { name: 'Alice' }, count: 5 },\n          { n: { name: 'Bob' }, count: 3 }\n        ]\n      }\n      \n      const result = deserializeResult(response)\n      expect(result.keys).toEqual(['n', 'count'])\n      expect(result.records).toHaveLength(2)\n      expect(result.records[0].get('n')).toEqual({ name: 'Alice' })\n      expect(result.records[0].get('count')).toBe(5)\n    })\n\n    it('should include query summary', () =\u003e {\n      const response = {\n        keys: [],\n        records: [],\n        summary: {\n          counters: { nodesCreated: 1 },\n          queryType: 'w',\n          plan: null\n        }\n      }\n      \n      const result = deserializeResult(response)\n      expect(result.summary.counters.nodesCreated).toBe(1)\n      expect(result.summary.queryType).toBe('w')\n    })\n  })\n\n  describe('deserializeNeo4jTypes()', () =\u003e {\n    it('should reconstruct Node from JSON', () =\u003e {\n      const json = {\n        __neo4j_type__: 'Node',\n        identity: '123',\n        labels: ['Person'],\n        properties: { name: 'Alice' }\n      }\n      \n      const node = deserializeNeo4jTypes(json)\n      expect(node.identity.toString()).toBe('123')\n      expect(node.labels).toContain('Person')\n      expect(node.properties.name).toBe('Alice')\n    })\n\n    it('should reconstruct Relationship from JSON', () =\u003e {\n      const json = {\n        __neo4j_type__: 'Relationship',\n        identity: '456',\n        type: 'KNOWS',\n        startNodeIdentity: '123',\n        endNodeIdentity: '789',\n        properties: { since: 2020 }\n      }\n      \n      const rel = deserializeNeo4jTypes(json)\n      expect(rel.type).toBe('KNOWS')\n      expect(rel.startNodeElementId).toBe('123')\n    })\n\n    it('should reconstruct Path from JSON', () =\u003e {\n      const json = {\n        __neo4j_type__: 'Path',\n        start: { __neo4j_type__: 'Node', identity: '1', labels: ['A'], properties: {} },\n        end: { __neo4j_type__: 'Node', identity: '2', labels: ['B'], properties: {} },\n        segments: []\n      }\n      \n      const path = deserializeNeo4jTypes(json)\n      expect(path.start.identity.toString()).toBe('1')\n      expect(path.end.identity.toString()).toBe('2')\n    })\n\n    it('should reconstruct DateTime from JSON', () =\u003e {\n      const json = {\n        __neo4j_type__: 'DateTime',\n        value: '2024-01-15T10:30:00.000Z'\n      }\n      \n      const dt = deserializeNeo4jTypes(json)\n      expect(dt.toStandardDate().toISOString()).toBe('2024-01-15T10:30:00.000Z')\n    })\n\n    it('should reconstruct Integer from string', () =\u003e {\n      const json = {\n        __neo4j_type__: 'Integer',\n        value: '9007199254740993'\n      }\n      \n      const int = deserializeNeo4jTypes(json)\n      expect(int.toBigInt()).toBe(9007199254740993n)\n    })\n  })\n\n  describe('parseErrorResponse()', () =\u003e {\n    it('should parse Neo4j error response', () =\u003e {\n      const response = {\n        error: {\n          code: 'Neo.ClientError.Statement.SyntaxError',\n          message: 'Invalid syntax at position 5'\n        }\n      }\n      \n      const error = parseErrorResponse(response)\n      expect(error.code).toBe('Neo.ClientError.Statement.SyntaxError')\n      expect(error.message).toBe('Invalid syntax at position 5')\n      expect(error.classification).toBe('ClientError')\n    })\n\n    it('should handle transient errors', () =\u003e {\n      const response = {\n        error: {\n          code: 'Neo.TransientError.Transaction.LockClient',\n          message: 'Lock wait timeout'\n        }\n      }\n      \n      const error = parseErrorResponse(response)\n      expect(error.isRetryable).toBe(true)\n    })\n\n    it('should handle unknown error format', () =\u003e {\n      const response = { message: 'Something went wrong' }\n      \n      const error = parseErrorResponse(response)\n      expect(error.code).toBe('Neo.ClientError.General.UnknownError')\n    })\n  })\n})\n```\n\n### Acceptance Criteria\n- [ ] Test file created at `tests/client/serialization.test.ts`\n- [ ] All tests fail with expected errors\n- [ ] Tests cover all Neo4j types and edge cases\n\n### TDD Cycle\nThis is the RED phase. Next: GREEN phase implementation.","status":"open","priority":2,"issue_type":"task","created_at":"2026-01-05T06:39:27.860597-06:00","updated_at":"2026-01-05T06:39:27.860597-06:00"}
{"id":"neo4j-8uq","title":"RED: Write failing tests for rxSession.beginTransaction() method","description":"## Overview\nWrite failing tests for rxSession.beginTransaction() explicit transaction method.\n\n## Test Cases to Write\n\n### Basic Transaction Creation Tests\n- beginTransaction() returns Observable of RxTransaction\n- Transaction is created on subscription\n- Transaction is not created until subscribed (cold)\n- Multiple subscriptions create multiple transactions\n\n### Transaction Configuration Tests\n- Accepts transaction metadata\n- Accepts timeout configuration\n- Respects session access mode\n\n### Observable Behavior Tests\n- Emits single RxTransaction then completes\n- Error on connection failure\n- Proper cleanup on unsubscription\n\n### State Tests\n- Transaction is open after emission\n- Session tracks active transaction\n- Cannot begin while transaction active\n\n## Acceptance Criteria\n- All tests written and failing (RED phase)\n- Tests cover explicit transaction creation\n- Tests verify Observable semantics\n- Tests cover configuration options","status":"open","priority":2,"issue_type":"task","created_at":"2026-01-05T06:36:56.141891-06:00","updated_at":"2026-01-05T06:36:56.141891-06:00"}
{"id":"neo4j-93w","title":"RED: Write failing tests for rxSession.close() method","description":"## Overview\nWrite failing tests for rxSession.close() cleanup method.\n\n## Test Cases to Write\n\n### Basic Close Tests\n- close() returns Observable of void\n- Session resources released on subscription\n- Connection returned to pool\n- Multiple close calls are safe (idempotent)\n\n### Active Transaction Tests\n- Close rolls back active transaction\n- Close waits for pending operations\n- Close emits error if rollback fails\n\n### Observable Behavior Tests\n- Cold observable (lazy execution)\n- Completes after cleanup\n- Error emission on failure\n- Subscription triggers cleanup\n\n### Post-Close Tests\n- Operations after close emit error\n- Session state reflects closed status\n- Bookmarks still accessible after close\n\n## Acceptance Criteria\n- All tests written and failing (RED phase)\n- Tests cover cleanup behavior\n- Tests verify Observable semantics\n- Tests cover error scenarios","status":"open","priority":2,"issue_type":"task","created_at":"2026-01-05T06:37:56.8499-06:00","updated_at":"2026-01-05T06:37:56.8499-06:00"}
{"id":"neo4j-95e","title":"RED: Record.keys - Write failing tests for column names array","description":"## Overview\nWrite failing tests for the Record.keys property that returns array of column names.\n\n## Test Cases to Write\n\n```typescript\ndescribe('Record.keys', () =\u003e {\n  it('should return array of column names', () =\u003e {\n    const record = new Record(['name', 'age', 'city'], ['Alice', 30, 'NYC']);\n    expect(record.keys).toEqual(['name', 'age', 'city']);\n  });\n\n  it('should return empty array for empty record', () =\u003e {\n    const record = new Record([], []);\n    expect(record.keys).toEqual([]);\n  });\n\n  it('should preserve order of columns', () =\u003e {\n    const record = new Record(['z', 'a', 'm'], [1, 2, 3]);\n    expect(record.keys).toEqual(['z', 'a', 'm']);\n  });\n\n  it('should be read-only (frozen array)', () =\u003e {\n    const record = new Record(['name'], ['Alice']);\n    expect(() =\u003e {\n      (record.keys as string[]).push('illegal');\n    }).toThrow();\n  });\n\n  it('should return same array instance on multiple access', () =\u003e {\n    const record = new Record(['name'], ['Alice']);\n    expect(record.keys).toBe(record.keys);\n  });\n});\n```\n\n## Acceptance Criteria\n- [ ] All tests written and failing (RED phase)\n- [ ] Tests verify immutability of keys array\n- [ ] Tests verify order preservation\n- [ ] Test file created at src/result/__tests__/record-keys.test.ts\n\n## TDD Phase\nRED - Tests should fail because keys property does not exist yet","status":"open","priority":1,"issue_type":"task","created_at":"2026-01-05T06:37:33.129287-06:00","updated_at":"2026-01-05T06:37:33.129287-06:00"}
{"id":"neo4j-98j","title":"GREEN: Implement HttpTransaction class","description":"## Test-Driven Development: GREEN Phase\n\n### Component\nHTTP Client SDK - HttpTransaction Class\n\n### Implementation Requirements\n\nImplement `src/client/http-transaction.ts`:\n\n```typescript\nimport { Neo4jHttpDriver } from './http-driver'\nimport { QueryResult, Record } from './types'\n\nexport interface TransactionConfig {\n  timeout?: number\n  metadata?: Record\u003cstring, unknown\u003e\n}\n\nexport interface CommitResult {\n  bookmarks: string[]\n}\n\nexport class HttpTransaction {\n  readonly id: string\n  readonly timeout?: number\n  \n  private _isOpen = true\n  private _isCommitted = false\n  private _isRolledBack = false\n  private abortController?: AbortController\n\n  constructor(\n    private driver: Neo4jHttpDriver,\n    id: string,\n    config?: TransactionConfig\n  ) {\n    this.id = id\n    this.timeout = config?.timeout\n  }\n\n  get isOpen(): boolean {\n    return this._isOpen\n  }\n\n  get isCommitted(): boolean {\n    return this._isCommitted\n  }\n\n  get isRolledBack(): boolean {\n    return this._isRolledBack\n  }\n\n  async run\u003cT = Record\u003e(\n    query: string,\n    parameters?: Record\u003cstring, unknown\u003e\n  ): Promise\u003cQueryResult\u003cT\u003e\u003e {\n    this.assertOpen()\n\n    const response = await this.fetchWithTimeout(`/tx/${this.id}/run`, {\n      method: 'POST',\n      body: JSON.stringify({ query, parameters: parameters ?? {} })\n    })\n\n    const data = await response.json()\n    return this.mapResult\u003cT\u003e(data)\n  }\n\n  async commit(): Promise\u003cCommitResult\u003e {\n    this.assertOpen()\n\n    const response = await this.driver.fetch(`/tx/${this.id}/commit`, {\n      method: 'POST'\n    })\n\n    const data = await response.json()\n    this._isOpen = false\n    this._isCommitted = true\n    \n    return { bookmarks: data.bookmarks ?? [] }\n  }\n\n  async rollback(): Promise\u003cvoid\u003e {\n    this.assertOpen()\n\n    await this.driver.fetch(`/tx/${this.id}/rollback`, {\n      method: 'POST'\n    })\n\n    this._isOpen = false\n    this._isRolledBack = true\n  }\n\n  private async fetchWithTimeout(path: string, init: RequestInit): Promise\u003cResponse\u003e {\n    if (!this.timeout) {\n      return this.driver.fetch(path, init)\n    }\n\n    this.abortController = new AbortController()\n    const timeoutId = setTimeout(() =\u003e {\n      this.abortController?.abort()\n    }, this.timeout)\n\n    try {\n      return await this.driver.fetch(path, {\n        ...init,\n        signal: this.abortController.signal\n      })\n    } catch (error) {\n      if (error instanceof Error \u0026\u0026 error.name === 'AbortError') {\n        throw new Error('Transaction timed out')\n      }\n      throw error\n    } finally {\n      clearTimeout(timeoutId)\n    }\n  }\n\n  private assertOpen(): void {\n    if (!this._isOpen) {\n      throw new Error('Transaction is not open')\n    }\n  }\n\n  private mapResult\u003cT\u003e(data: any): QueryResult\u003cT\u003e {\n    return {\n      records: data.records.map((r: any) =\u003e new Record(r)),\n      summary: data.summary,\n      keys: data.keys\n    }\n  }\n}\n```\n\n### Acceptance Criteria\n- [ ] All RED phase tests pass\n- [ ] Transaction ID properly managed\n- [ ] run() POSTs to /tx/{id}/run\n- [ ] commit() POSTs to /tx/{id}/commit\n- [ ] rollback() POSTs to /tx/{id}/rollback\n- [ ] Timeout handling works with AbortController\n\n### Dependencies\n- RED: HttpTransaction class methods fail without implementation\n- GREEN: Implement Neo4jHttpDriver class\n\n### TDD Cycle\nThis is the GREEN phase. Next: REFACTOR phase.","status":"open","priority":2,"issue_type":"task","created_at":"2026-01-05T06:37:01.939322-06:00","updated_at":"2026-01-05T06:37:01.939322-06:00"}
{"id":"neo4j-990","title":"RED: MATCH Clause Translation","description":"## Overview\nWrite failing tests for MATCH clause translation to SQL SELECT with JOINs.\n\n## Test Cases to Write\n\n### Test 1: Simple MATCH\n- translates simple MATCH to SELECT\n- FROM nodes table\n\n### Test 2: OPTIONAL MATCH\n- translates OPTIONAL MATCH to LEFT JOIN\n\n### Test 3: Multiple MATCH Clauses\n- handles multiple MATCH clauses with cartesian product\n\n### Test 4: MATCH with WHERE\n- integrates WHERE clause with json_extract\n\n### Test 5: Connected MATCHes Share Variables\n- connects MATCH clauses by shared variables\n\n### Test 6: MATCH with Multiple Patterns\n- handles comma-separated patterns in MATCH\n\n### Test 7: OPTIONAL MATCH with No Results\n- OPTIONAL MATCH returns NULL when no match via LEFT JOIN\n\n## Acceptance Criteria\n- All tests written and failing\n- OPTIONAL MATCH correctly uses LEFT JOIN\n- Variable binding across clauses tested\n\n## TDD Phase\nRED - Write failing tests first","status":"open","priority":1,"issue_type":"task","created_at":"2026-01-05T06:37:33.415134-06:00","updated_at":"2026-01-05T06:37:33.415134-06:00"}
{"id":"neo4j-9ex","title":"REFACTOR: Clean up rxSession.executeWrite() implementation","description":"## Overview\nRefactor rxSession.executeWrite() for maintainability.\n\n## Refactoring Tasks\n\n### Code Quality\n- Share common logic with executeRead\n- Extract transaction function executor\n- Improve type inference\n- Better error categorization\n\n### Bookmark Management\n- Extract bookmark handling logic\n- Ensure thread-safe bookmark updates\n- Optimize bookmark serialization\n\n### Performance\n- Review Observable chain efficiency\n- Minimize allocations\n- Optimize retry path\n\n## Acceptance Criteria\n- All tests still pass\n- Shared code with executeRead\n- Clean bookmark management\n- Efficient implementation","status":"open","priority":2,"issue_type":"task","created_at":"2026-01-05T06:36:36.523054-06:00","updated_at":"2026-01-05T06:36:36.523054-06:00"}
{"id":"neo4j-9v84","title":"[GREEN] Label Management - Implement label operations to pass tests","description":"## Overview\nImplement label management operations to make all tests pass.\n\n## Implementation Requirements\n\n### LabelManager Class\n```typescript\nclass LabelManager {\n  constructor(private sql: SqlStorage) {}\n\n  addLabel(nodeId: number, label: string): void {\n    this.validateLabel(label);\n    \n    const node = this.sql.exec('SELECT labels FROM nodes WHERE id = ?', nodeId).one();\n    if (\\!node) throw new Error('Node not found');\n    \n    const labels: string[] = JSON.parse(node.labels);\n    if (\\!labels.includes(label)) {\n      labels.push(label);\n      this.sql.exec(\n        'UPDATE nodes SET labels = ?, updated_at = CURRENT_TIMESTAMP WHERE id = ?',\n        JSON.stringify(labels), nodeId\n      );\n    }\n  }\n\n  addLabels(nodeId: number, newLabels: string[]): void {\n    newLabels.forEach(label =\u003e this.validateLabel(label));\n    \n    const node = this.sql.exec('SELECT labels FROM nodes WHERE id = ?', nodeId).one();\n    if (\\!node) throw new Error('Node not found');\n    \n    const labels: string[] = JSON.parse(node.labels);\n    const toAdd = newLabels.filter(l =\u003e \\!labels.includes(l));\n    \n    if (toAdd.length \u003e 0) {\n      labels.push(...toAdd);\n      this.sql.exec(\n        'UPDATE nodes SET labels = ?, updated_at = CURRENT_TIMESTAMP WHERE id = ?',\n        JSON.stringify(labels), nodeId\n      );\n    }\n  }\n\n  removeLabel(nodeId: number, label: string): void {\n    const node = this.sql.exec('SELECT labels FROM nodes WHERE id = ?', nodeId).one();\n    if (\\!node) throw new Error('Node not found');\n    \n    const labels: string[] = JSON.parse(node.labels);\n    const index = labels.indexOf(label);\n    \n    if (index \\!== -1) {\n      labels.splice(index, 1);\n      this.sql.exec(\n        'UPDATE nodes SET labels = ?, updated_at = CURRENT_TIMESTAMP WHERE id = ?',\n        JSON.stringify(labels), nodeId\n      );\n    }\n  }\n\n  getLabels(nodeId: number): string[] {\n    const node = this.sql.exec('SELECT labels FROM nodes WHERE id = ?', nodeId).one();\n    if (\\!node) throw new Error('Node not found');\n    return JSON.parse(node.labels);\n  }\n\n  getAllLabels(): string[] {\n    const result = this.sql.exec(\n      'SELECT DISTINCT value FROM nodes, json_each(nodes.labels)'\n    );\n    return result.toArray().map(row =\u003e row.value as string);\n  }\n\n  private validateLabel(label: string): void {\n    if (\\!label || typeof label \\!== 'string') {\n      throw new Error('Label must be a non-empty string');\n    }\n    if (\\!/^[A-Za-z_][A-Za-z0-9_]*$/.test(label)) {\n      throw new Error('Invalid label format');\n    }\n  }\n}\n```\n\n## Files to Create\n- `src/storage/operations/label-manager.ts`\n\n## Acceptance Criteria\n- [ ] All RED phase tests pass\n- [ ] Labels stored as JSON array\n- [ ] Duplicates prevented\n- [ ] Validation enforced\n\n## TDD Phase\n**GREEN** - Minimum code to pass tests","status":"open","priority":1,"issue_type":"task","created_at":"2026-01-05T06:39:25.355822-06:00","updated_at":"2026-01-05T06:39:25.355822-06:00"}
{"id":"neo4j-9va","title":"[GREEN] Spatial Types (Point) - Implement to Pass Tests","description":"## Overview\nImplement the Neo4j Point spatial type to pass all failing tests.\n\n## TDD Phase: GREEN (Make Tests Pass)\n\n### Implementation Requirements\n\n#### SRID Enum/Constants\n```typescript\nexport const SRID = {\n  CARTESIAN_2D: 7203,\n  CARTESIAN_3D: 9157,\n  WGS84_2D: 4326,\n  WGS84_3D: 4979,\n} as const;\n\nexport type SRIDValue = typeof SRID[keyof typeof SRID];\n```\n\n#### Point Class\n```typescript\nexport class Point {\n  readonly srid: SRIDValue;\n  readonly x: number;\n  readonly y: number;\n  readonly z?: number;\n  \n  constructor(srid: SRIDValue, x: number, y: number, z?: number);\n  \n  toString(): string;\n  \n  // For geographic points, provide aliases\n  get longitude(): number;  // alias for x\n  get latitude(): number;   // alias for y\n  get height(): number | undefined;  // alias for z\n}\n```\n\n#### Type Guard\n```typescript\nexport function isPoint(value: unknown): value is Point {\n  return value instanceof Point;\n}\n```\n\n#### Validation\n- 2D SRIDs (7203, 4326) should not have z coordinate\n- 3D SRIDs (9157, 4979) may have z coordinate\n- Geographic coordinates should be validated:\n  - Longitude: -180 to 180\n  - Latitude: -90 to 90\n\n### File Structure\n```\nsrc/types/spatial/\n  index.ts\n  point.ts\n  srid.ts\n```\n\n### Export from Main Types\n```typescript\n// src/types/index.ts\nexport { Point, isPoint, SRID } from './spatial';\n```\n\n### Acceptance Criteria\n- [ ] All RED phase tests passing\n- [ ] Point class implemented with all properties\n- [ ] SRID constants exported\n- [ ] Type guard working\n- [ ] Proper TypeScript types\n- [ ] Exported from `src/types/index.ts`\n\n### Dependencies\n- Depends on: [RED] Spatial Types (Point) - Write Failing Tests","status":"open","priority":1,"issue_type":"task","created_at":"2026-01-05T06:37:12.734363-06:00","updated_at":"2026-01-05T06:37:12.734363-06:00"}
{"id":"neo4j-9ys","title":"[GREEN] Lexer: Implement String Literal Parsing","description":"## Overview\nImplement string literal tokenization to pass all string tests.\n\n## Implementation Tasks\n\n### String Scanner\n```typescript\nprivate scanString(quote: '\"' | \"'\"): Token {\n  // Track start position\n  // Scan until matching quote\n  // Handle escape sequences\n  // Return STRING token\n}\n```\n\n### Escape Sequence Handler\n```typescript\nprivate parseEscapeSequence(): string {\n  // \\' -\u003e '\n  // \\\" -\u003e \"\n  // \\\\ -\u003e \\\n  // \\n -\u003e newline\n  // \\t -\u003e tab\n  // \\r -\u003e carriage return\n  // \\uXXXX -\u003e unicode char\n}\n```\n\n### Error Handling\n- UnterminatedStringError with line/column\n- InvalidEscapeSequenceError with position\n\n## Acceptance Criteria\n- [ ] All string literal tests pass\n- [ ] Both quote styles work correctly\n- [ ] All escape sequences handled\n- [ ] Clear error messages for invalid strings\n\n## TDD Phase: GREEN\n## Depends On: neo4j-4q9","status":"open","priority":1,"issue_type":"task","created_at":"2026-01-05T06:35:27.6309-06:00","updated_at":"2026-01-05T06:35:27.6309-06:00"}
{"id":"neo4j-9zx","title":"GREEN: MATCH Clause Translation","description":"## Overview\nImplement MATCH clause translation to make RED tests pass.\n\n## Implementation Tasks\n\n### 1. MatchClauseTranslator Class\n- translateMatch(clause): Generate SELECT with JOINs\n- translateOptionalMatch(clause): Generate LEFT JOINs\n- handleMultipleMatches(clauses): Combine multiple MATCH clauses\n\n### 2. WHERE Integration\n- Combine pattern WHERE with explicit WHERE\n- Translate Cypher expressions to SQL\n\n### 3. Variable Sharing\n- Track variables across MATCH clauses\n- Ensure same variable refers to same table alias\n\n### 4. Cartesian Product Handling\n- Detect disconnected patterns\n- Generate CROSS JOIN or comma-separated FROM\n\n## Files to Create/Modify\n- src/cypher/translator/match-clause-translator.ts\n- src/cypher/translator/where-integrator.ts\n\n## Acceptance Criteria\n- All RED phase tests pass\n- LEFT JOIN used for OPTIONAL MATCH\n- Variables properly shared\n\n## TDD Phase\nGREEN - Make tests pass with minimal code\n\n## Dependencies\n- Depends on: RED: MATCH Clause Translation","status":"open","priority":1,"issue_type":"task","created_at":"2026-01-05T06:37:51.742353-06:00","updated_at":"2026-01-05T06:37:51.742353-06:00"}
{"id":"neo4j-a4g","title":"GREEN: Implement REST API endpoint handlers","description":"## Test-Driven Development: GREEN Phase\n\n### Component\nHTTP Client SDK - REST API Endpoints (Server-Side)\n\n### Implementation Requirements\n\nImplement `src/api/rest-routes.ts`:\n\n```typescript\nimport { Hono } from 'hono'\nimport { GraphDatabase } from '../graph/database'\nimport { TransactionManager } from '../transaction/manager'\n\nexport function createRestRoutes(db: GraphDatabase) {\n  const app = new Hono()\n  const txManager = new TransactionManager(db)\n\n  // POST /query - Execute single query\n  app.post('/query', async (c) =\u003e {\n    const { query, parameters, database, bookmarks } = await c.req.json()\n    const result = await db.query(query, parameters, { database, bookmarks })\n    return c.json({\n      records: result.records,\n      keys: result.keys,\n      summary: result.summary,\n      bookmarks: result.bookmarks\n    })\n  })\n\n  // POST /tx/begin - Start transaction\n  app.post('/tx/begin', async (c) =\u003e {\n    const { database, accessMode, bookmarks } = await c.req.json()\n    const tx = await txManager.begin({ database, accessMode, bookmarks })\n    return c.json({ id: tx.id, accessMode: tx.accessMode }, 201)\n  })\n\n  // POST /tx/:id/run - Run in transaction\n  app.post('/tx/:id/run', async (c) =\u003e {\n    const id = c.req.param('id')\n    const tx = txManager.get(id)\n    if (!tx) return c.json({ error: 'Transaction not found' }, 404)\n    \n    const { query, parameters } = await c.req.json()\n    const result = await tx.run(query, parameters)\n    return c.json({\n      records: result.records,\n      keys: result.keys,\n      summary: result.summary\n    })\n  })\n\n  // POST /tx/:id/commit - Commit transaction\n  app.post('/tx/:id/commit', async (c) =\u003e {\n    const id = c.req.param('id')\n    const tx = txManager.get(id)\n    if (!tx) return c.json({ error: 'Transaction not found' }, 404)\n    \n    const result = await tx.commit()\n    txManager.remove(id)\n    return c.json({ bookmarks: result.bookmarks })\n  })\n\n  // POST /tx/:id/rollback - Rollback transaction\n  app.post('/tx/:id/rollback', async (c) =\u003e {\n    const id = c.req.param('id')\n    const tx = txManager.get(id)\n    if (!tx) return c.json({ error: 'Transaction not found' }, 404)\n    \n    await tx.rollback()\n    txManager.remove(id)\n    return c.json({ success: true })\n  })\n\n  // GET /server-info - Server metadata\n  app.get('/server-info', (c) =\u003e {\n    return c.json({\n      address: 'neo4j.do',\n      protocolVersion: '5.0',\n      agent: 'neo4j.do/1.0.0',\n      connectionId: crypto.randomUUID()\n    })\n  })\n\n  // GET /databases - List databases\n  app.get('/databases', async (c) =\u003e {\n    const databases = await db.listDatabases()\n    return c.json({ databases })\n  })\n\n  // POST /databases - Create database\n  app.post('/databases', async (c) =\u003e {\n    const { name } = await c.req.json()\n    if (!/^[a-z][a-z0-9_]*$/i.test(name)) {\n      return c.json({ error: 'Invalid database name' }, 400)\n    }\n    const database = await db.createDatabase(name)\n    return c.json({ name: database.name }, 201)\n  })\n\n  return app\n}\n```\n\n### Acceptance Criteria\n- [ ] All RED phase tests pass\n- [ ] POST /query executes Cypher\n- [ ] Transaction endpoints manage lifecycle\n- [ ] GET /server-info returns metadata\n- [ ] Database management endpoints work\n\n### Dependencies\n- RED: REST API endpoint handlers fail without implementation\n\n### TDD Cycle\nThis is the GREEN phase. Next: REFACTOR phase.","status":"open","priority":2,"issue_type":"task","created_at":"2026-01-05T06:38:25.91329-06:00","updated_at":"2026-01-05T06:38:25.91329-06:00"}
{"id":"neo4j-a52","title":"EPIC: neo4j.do - Neo4j-compatible graph database on Cloudflare Workers","description":"## Vision\n\nBuild neo4j.do - a Neo4j-compatible graph database running on Cloudflare Workers with 100% API compatibility with the official neo4j-driver npm package, plus intelligent superset features.\n\n## Goals\n\n1. Drop-in Replacement: Any code using neo4j-driver should work with neo4j.do\n2. Edge-Native: Run entirely on Cloudflare Workers with Durable Objects + SQLite\n3. Cypher Support: Full Cypher query language parsing and execution\n4. Superset Features: Auto-embeddings, vector search, AI integration\n\n## Architecture: Dual-Mode (following mongo.do)\n\n- URI Mode: In-memory graph for testing\n- Durable Objects Mode: Production with SQLite persistence\n\n## Key Innovation: Cypher to SQL Compiler\n\nTranslates Cypher pattern matching to SQL JOINs with recursive CTEs for variable-length paths.","status":"open","priority":0,"issue_type":"epic","created_at":"2026-01-05T06:31:38.572913-06:00","updated_at":"2026-01-05T06:31:56.316187-06:00"}
{"id":"neo4j-adf","title":"RED: Variable-Length Path Translation - Recursive CTEs","description":"## Overview\nWrite failing tests for variable-length path translation using recursive CTEs.\n\n## Test Cases to Write\n\n### Test 1: Unlimited Depth (*)\n```typescript\ntest('translates [*] to recursive CTE', () =\u003e {\n  const ast = parse('MATCH (a)-[*]-\u003e(b) RETURN a, b');\n  const sql = translate(ast);\n  expect(sql).toContain('WITH RECURSIVE');\n  expect(sql).toContain('UNION');\n});\n```\n\n### Test 2: Exact Depth (*n)\n```typescript\ntest('translates [*3] to 3-level JOIN', () =\u003e {\n  const ast = parse('MATCH (a)-[*3]-\u003e(b) RETURN a, b');\n  const sql = translate(ast);\n  // Should have exactly 3 relationship JOINs\n  expect(sql.match(/JOIN relationships/g)?.length).toBe(3);\n});\n```\n\n### Test 3: Range Depth (*n..m)\n```typescript\ntest('translates [*1..3] to bounded recursive CTE', () =\u003e {\n  const ast = parse('MATCH (a)-[*1..3]-\u003e(b) RETURN a, b');\n  const sql = translate(ast);\n  expect(sql).toContain('WITH RECURSIVE');\n  expect(sql).toContain('depth');\n  expect(sql).toMatch(/depth.*\u003c=.*3/);\n});\n```\n\n### Test 4: Minimum Only (*n..)\n```typescript\ntest('translates [*2..] to min-bounded CTE', () =\u003e {\n  const ast = parse('MATCH (a)-[*2..]-\u003e(b) RETURN a, b');\n  const sql = translate(ast);\n  expect(sql).toMatch(/depth.*\u003e=.*2/);\n});\n```\n\n### Test 5: Cycle Detection\n```typescript\ntest('includes cycle detection in recursive CTE', () =\u003e {\n  const ast = parse('MATCH (a)-[*]-\u003e(b) RETURN a, b');\n  const sql = translate(ast);\n  // Should track visited nodes to prevent cycles\n  expect(sql).toContain('visited');\n});\n```\n\n### Test 6: Path Construction\n```typescript\ntest('constructs path with nodes and relationships', () =\u003e {\n  const ast = parse('MATCH path = (a)-[*]-\u003e(b) RETURN path');\n  const sql = translate(ast);\n  // Should collect nodes and relationships in path\n  expect(sql).toContain('JSON_GROUP_ARRAY');\n});\n```\n\n### Test 7: With Relationship Type Filter\n```typescript\ntest('translates [*:KNOWS] with type filter', () =\u003e {\n  const ast = parse('MATCH (a)-[:KNOWS*]-\u003e(b) RETURN b');\n  const sql = translate(ast);\n  expect(sql).toContain(\"type = 'KNOWS'\");\n});\n```\n\n## Acceptance Criteria\n- [ ] All tests written and failing\n- [ ] Cycle detection tested\n- [ ] Performance bounds tested\n\n## TDD Phase\nRED - Write failing tests first","status":"open","priority":2,"issue_type":"task","created_at":"2026-01-05T06:36:14.562393-06:00","updated_at":"2026-01-05T06:36:14.562393-06:00"}
{"id":"neo4j-ajg","title":"[REFACTOR] Temporal Types - Optimize and Harden","description":"## Overview\nRefactor temporal types for performance, edge cases, and code quality.\n\n## TDD Phase: REFACTOR (Improve While Green)\n\n### Refactoring Goals\n\n#### Performance Optimizations\n- [ ] Lazy string formatting (cache toString results)\n- [ ] Efficient comparison methods\n- [ ] Minimize allocations in conversions\n\n#### Edge Case Hardening\n- [ ] Leap year handling (Feb 29)\n- [ ] Leap seconds\n- [ ] DST transitions\n- [ ] Timezone offset boundaries (-12:00 to +14:00)\n- [ ] Year boundaries (negative years, year 0)\n- [ ] Month/day validation\n- [ ] Nanosecond overflow handling\n\n#### Additional Features\n- [ ] Add arithmetic: date.add(duration)\n- [ ] Add comparison: date.equals(other), date.compareTo(other)\n- [ ] Add factories: Date.now(), DateTime.now()\n\n#### Code Quality\n- [ ] Extract shared temporal utilities\n- [ ] Add comprehensive JSDoc\n- [ ] Consistent error messages\n- [ ] Shared validation logic\n\n#### Additional Tests\n- [ ] Timezone database edge cases\n- [ ] Historical dates (Julian calendar issues)\n- [ ] Far future dates\n- [ ] Round-trip serialization tests\n- [ ] Cross-type comparisons\n\n### Acceptance Criteria\n- [ ] All existing tests still pass\n- [ ] Edge cases covered with new tests\n- [ ] 100% test coverage on temporal modules\n- [ ] Performance benchmarks documented\n- [ ] JSDoc complete\n\n### Dependencies\n- Depends on: [GREEN] Temporal Types - Implement to Pass Tests","status":"open","priority":1,"issue_type":"task","created_at":"2026-01-05T06:36:18.729309-06:00","updated_at":"2026-01-05T06:36:18.729309-06:00"}
{"id":"neo4j-au2","title":"REFACTOR: Clean up rxSession.lastBookmarks() implementation","description":"## Overview\nRefactor rxSession.lastBookmarks() for better bookmark management.\n\n## Refactoring Tasks\n\n### Code Quality\n- Extract bookmark manager class\n- Share with sync session implementation\n- Improve type safety\n- Add bookmark validation\n\n### Performance\n- Optimize bookmark storage\n- Consider immutable bookmark arrays\n- Efficient bookmark merging\n\n### Documentation\n- Document bookmark semantics\n- Add examples for causal consistency\n- Explain multi-database bookmarks\n\n## Acceptance Criteria\n- All tests still pass\n- Shared bookmark management code\n- Efficient implementation\n- Well-documented behavior","status":"open","priority":2,"issue_type":"task","created_at":"2026-01-05T06:37:40.452107-06:00","updated_at":"2026-01-05T06:37:40.452107-06:00"}
{"id":"neo4j-b16","title":"GREEN: Record.get(key) - Implement get value by column name","description":"## Overview\nImplement the Record.get(key) method to make all RED phase tests pass.\n\n## Implementation\n\n```typescript\nexport class Record\u003cR extends Dict = Dict\u003e {\n  private _keys: string[];\n  private _values: any[];\n  private _fieldLookup: Map\u003cstring, number\u003e;\n\n  constructor(keys: string[], values: any[]) {\n    this._keys = keys;\n    this._values = values;\n    this._fieldLookup = new Map(keys.map((k, i) =\u003e [k, i]));\n  }\n\n  get(key: string): any {\n    const index = this._fieldLookup.get(key);\n    if (index === undefined) {\n      return undefined;\n    }\n    return this._values[index];\n  }\n}\n```\n\n## Acceptance Criteria\n- [ ] All RED phase tests now pass (GREEN phase)\n- [ ] Implementation is minimal - just enough to pass tests\n- [ ] No premature optimization\n- [ ] Record class created at `src/result/record.ts`\n\n## TDD Phase\nGREEN - Minimal implementation to pass tests\n\n## Dependencies\n- neo4j-i2k (RED phase tests)","status":"open","priority":1,"issue_type":"task","created_at":"2026-01-05T06:34:41.918471-06:00","updated_at":"2026-01-05T06:34:41.918471-06:00"}
{"id":"neo4j-bec","title":"Configure package exports (main, client, types, lite)","description":"# Configure Package Exports\n\n## Overview\nSet up proper package.json exports field for the neo4j.do package with multiple entry points.\n\n## Export Configuration\n```json\n{\n  \"name\": \"neo4j.do\",\n  \"exports\": {\n    \".\": {\n      \"types\": \"./dist/index.d.ts\",\n      \"import\": \"./dist/index.js\",\n      \"require\": \"./dist/index.cjs\"\n    },\n    \"./client\": {\n      \"types\": \"./dist/client.d.ts\",\n      \"import\": \"./dist/client.js\",\n      \"require\": \"./dist/client.cjs\"\n    },\n    \"./types\": {\n      \"types\": \"./dist/types.d.ts\",\n      \"import\": \"./dist/types.js\",\n      \"require\": \"./dist/types.cjs\"\n    },\n    \"./lite\": {\n      \"types\": \"./dist/lite.d.ts\",\n      \"import\": \"./dist/lite.js\",\n      \"require\": \"./dist/lite.cjs\"\n    }\n  },\n  \"main\": \"./dist/index.cjs\",\n  \"module\": \"./dist/index.js\",\n  \"types\": \"./dist/index.d.ts\",\n  \"files\": [\"dist\"],\n  \"sideEffects\": false\n}\n```\n\n## Entry Point Descriptions\n\n### Main (`neo4j.do`)\n- Full-featured driver with RxJS support\n- Complete API surface matching neo4j-driver\n- All transaction types\n\n### Client (`neo4j.do/client`)\n- Standalone client for direct usage\n- Connection management\n- Session handling\n\n### Types (`neo4j.do/types`)\n- All TypeScript type definitions\n- Cypher types (Integer, Point, Duration, etc.)\n- Result types\n- Configuration types\n\n### Lite (`neo4j.do/lite`)\n- No RxJS dependency\n- Smaller bundle size\n- Promise-only API\n- Suitable for edge environments\n\n## Acceptance Criteria\n- [ ] All exports resolve correctly\n- [ ] TypeScript types work for all entry points\n- [ ] ESM imports work: `import { driver } from 'neo4j.do'`\n- [ ] CJS requires work: `const { driver } = require('neo4j.do')`\n- [ ] Subpath imports work: `import { Session } from 'neo4j.do/client'`\n- [ ] Lite version excludes RxJS","status":"open","priority":1,"issue_type":"task","created_at":"2026-01-05T06:36:33.828489-06:00","updated_at":"2026-01-05T06:36:33.828489-06:00"}
{"id":"neo4j-bk7","title":"RED: UPDATE Translation (SET/REMOVE)","description":"## Overview\nWrite failing tests for SET and REMOVE clause translation to UPDATE statements.\n\n## Test Cases to Write\n\n### Test 1: SET Single Property\n- SET n.name = 'Bob' -\u003e UPDATE with json_set\n\n### Test 2: SET Multiple Properties\n- SET n.name = 'Bob', n.age = 30 -\u003e Multiple json_set calls\n\n### Test 3: SET Node = Map (Replace All)\n- SET n = {name: 'Bob'} -\u003e Full property replacement\n\n### Test 4: SET Node += Map (Merge)\n- SET n += {age: 30} -\u003e Property merge with json_patch\n\n### Test 5: REMOVE Property\n- REMOVE n.age -\u003e UPDATE with json_remove\n\n### Test 6: REMOVE Label\n- REMOVE n:Employee -\u003e Update labels array\n\n### Test 7: SET with Expression\n- SET n.age = n.age + 1 -\u003e Computed property update\n\n### Test 8: SET Relationship Property\n- SET r.since = 2020 -\u003e UPDATE relationships table\n\n### Test 9: SET from Another Property\n- SET n.nickname = n.name -\u003e Copy property value\n\n## Acceptance Criteria\n- All tests written and failing\n- json_set/json_remove used correctly\n- Label manipulation handled\n\n## TDD Phase\nRED - Write failing tests first","status":"open","priority":1,"issue_type":"task","created_at":"2026-01-05T06:39:13.033336-06:00","updated_at":"2026-01-05T06:39:13.033336-06:00"}
{"id":"neo4j-cgs","title":"wrangler.jsonc for Cloudflare Workers","description":"# Wrangler Configuration\n\n## Overview\nConfigure wrangler.jsonc for deploying neo4j.do to Cloudflare Workers.\n\n## Configuration File\n```jsonc\n{\n  \"name\": \"neo4j-do\",\n  \"main\": \"dist/index.js\",\n  \"compatibility_date\": \"2024-01-01\",\n  \"compatibility_flags\": [\"nodejs_compat\"],\n  \n  // Durable Objects for graph storage\n  \"durable_objects\": {\n    \"bindings\": [\n      {\n        \"name\": \"GRAPH_STORE\",\n        \"class_name\": \"GraphStore\"\n      },\n      {\n        \"name\": \"TRANSACTION_COORDINATOR\",\n        \"class_name\": \"TransactionCoordinator\"\n      }\n    ]\n  },\n  \n  // D1 database for metadata and indexes\n  \"d1_databases\": [\n    {\n      \"binding\": \"DB\",\n      \"database_name\": \"neo4j-do\",\n      \"database_id\": \"\u003cto-be-created\u003e\"\n    }\n  ],\n  \n  // KV for caching\n  \"kv_namespaces\": [\n    {\n      \"binding\": \"CACHE\",\n      \"id\": \"\u003cto-be-created\u003e\"\n    }\n  ],\n  \n  // Vectorize for vector search (optional)\n  \"vectorize\": [\n    {\n      \"binding\": \"VECTORS\",\n      \"index_name\": \"neo4j-do-vectors\"\n    }\n  ],\n  \n  // Environment variables\n  \"vars\": {\n    \"ENVIRONMENT\": \"production\"\n  },\n  \n  // Development settings\n  \"dev\": {\n    \"port\": 8787,\n    \"local_protocol\": \"http\"\n  }\n}\n```\n\n## Bindings Required\n1. **Durable Objects**: Graph storage and transaction coordination\n2. **D1 Database**: Metadata, indexes, and Cypher query cache\n3. **KV Namespace**: Query result caching\n4. **Vectorize**: Optional vector similarity search\n\n## Environment Configurations\n- `wrangler.jsonc` - Base configuration\n- Environment-specific via `--env` flag\n\n## Acceptance Criteria\n- [ ] wrangler.jsonc created\n- [ ] Durable Object classes defined\n- [ ] D1 database binding configured\n- [ ] KV namespace configured\n- [ ] Local development works with `wrangler dev`\n- [ ] Deployment works with `wrangler deploy`","status":"open","priority":1,"issue_type":"task","created_at":"2026-01-05T06:36:10.658873-06:00","updated_at":"2026-01-05T06:36:10.658873-06:00"}
{"id":"neo4j-d0c","title":"GREEN: Implement rxTx.commit() method","description":"## Overview\nImplement rxTx.commit() to make all RED tests pass.\n\n## Implementation Requirements\n\n### Method Signature\n```typescript\ninterface RxTransaction {\n  commit(): Observable\u003cvoid\u003e\n}\n```\n\n### Implementation Details\n- Create Observable for commit process\n- Send COMMIT to database\n- Update session bookmarks\n- Mark transaction as closed\n- Handle commit errors\n\n### Observable Semantics\n- Cold observable (lazy commit)\n- Complete on success\n- Error on failure\n- Prevent multiple commits\n\n## Acceptance Criteria\n- All RED tests now pass (GREEN phase)\n- Changes persisted correctly\n- Bookmarks updated\n- Transaction state managed","status":"open","priority":2,"issue_type":"task","created_at":"2026-01-05T06:39:15.374871-06:00","updated_at":"2026-01-05T06:39:15.374871-06:00"}
{"id":"neo4j-d6n","title":"REFACTOR: HttpSession class optimization","description":"## Test-Driven Development: REFACTOR Phase\n\n### Component\nHTTP Client SDK - HttpSession Class\n\n### Refactoring Goals\n\n1. **Bookmark management**\n   - Extract BookmarkManager class\n   - Support bookmark chaining across sessions\n\n2. **Transaction retry logic**\n   - Add configurable retry for transient errors\n   - Implement retry in executeRead/executeWrite\n\n3. **Result streaming preparation**\n   - Abstract result handling for future streaming\n   - Create ResultCursor interface\n\n4. **Database routing**\n   - Support multi-database configurations\n   - Handle database parameter consistently\n\n### Code Improvements\n\n```typescript\n// Extract bookmark management\nexport class BookmarkManager {\n  private bookmarks: Set\u003cstring\u003e = new Set()\n\n  add(bookmarks: string[]): void {\n    bookmarks.forEach(b =\u003e this.bookmarks.add(b))\n  }\n\n  get(): string[] {\n    return [...this.bookmarks]\n  }\n\n  clear(): void {\n    this.bookmarks.clear()\n  }\n}\n\n// Improved session with retry\nexport class HttpSession {\n  private bookmarkManager: BookmarkManager\n\n  async executeRead\u003cT\u003e(\n    work: (tx: HttpTransaction) =\u003e Promise\u003cT\u003e,\n    config?: TransactionConfig\n  ): Promise\u003cT\u003e {\n    return this.executeWithRetry(work, 'READ', config?.maxRetries ?? 3)\n  }\n\n  private async executeWithRetry\u003cT\u003e(\n    work: (tx: HttpTransaction) =\u003e Promise\u003cT\u003e,\n    accessMode: 'READ' | 'WRITE',\n    maxRetries: number\n  ): Promise\u003cT\u003e {\n    let lastError: Error | undefined\n    for (let attempt = 0; attempt \u003c= maxRetries; attempt++) {\n      try {\n        return await this.executeInTransaction(work, accessMode)\n      } catch (error) {\n        if (!this.isRetryable(error) || attempt === maxRetries) throw error\n        lastError = error as Error\n        await this.delay(Math.pow(2, attempt) * 100)\n      }\n    }\n    throw lastError\n  }\n}\n```\n\n### Acceptance Criteria\n- [ ] All existing tests still pass\n- [ ] BookmarkManager extracted\n- [ ] Retry logic implemented\n- [ ] Code is more modular and testable\n\n### Dependencies\n- GREEN: Implement HttpSession class\n\n### TDD Cycle\nThis completes the RED-\u003eGREEN-\u003eREFACTOR cycle for HttpSession.","status":"open","priority":2,"issue_type":"task","created_at":"2026-01-05T06:36:18.297315-06:00","updated_at":"2026-01-05T06:36:18.297315-06:00"}
{"id":"neo4j-d83","title":"RED: Transaction Class Core Operations Tests","description":"## Overview\nWrite comprehensive failing tests for Transaction class core operations: run(), commit(), rollback(), and isOpen().\n\n## Test Cases\n\n### Transaction.run() Tests\n```typescript\ndescribe('tx.run()', () =\u003e {\n  it('should execute Cypher query within transaction')\n  it('should execute query with parameters')\n  it('should return Result object')\n  it('should allow multiple queries in same transaction')\n  it('should see changes from previous queries in transaction')\n  it('should isolate changes from other transactions')\n  it('should throw on syntax errors')\n  it('should throw if transaction is closed')\n  it('should throw if transaction is rolled back')\n})\n```\n\n### Transaction.commit() Tests\n```typescript\ndescribe('tx.commit()', () =\u003e {\n  it('should commit all changes')\n  it('should make changes visible to other sessions')\n  it('should close the transaction')\n  it('should be idempotent')\n  it('should throw if already rolled back')\n  it('should throw on constraint violation')\n  it('should generate bookmark for session')\n  it('should release locks')\n})\n```\n\n### Transaction.rollback() Tests\n```typescript\ndescribe('tx.rollback()', () =\u003e {\n  it('should discard all changes')\n  it('should close the transaction')\n  it('should be idempotent')\n  it('should work after commit failure')\n  it('should not throw if already committed')\n  it('should release locks')\n  it('should not generate bookmark')\n})\n```\n\n### Transaction.isOpen() Tests\n```typescript\ndescribe('tx.isOpen()', () =\u003e {\n  it('should return true for new transaction')\n  it('should return false after commit')\n  it('should return false after rollback')\n  it('should return false after error')\n})\n```\n\n### Transaction Isolation Tests\n```typescript\ndescribe('Transaction Isolation', () =\u003e {\n  it('should isolate uncommitted reads')\n  it('should isolate uncommitted writes')\n  it('should handle concurrent transactions')\n  it('should detect write conflicts')\n})\n```\n\n## TDD Phase\n**RED** - All tests should fail initially.\n\n## Acceptance Criteria\n- [ ] All test cases written\n- [ ] ACID properties tested\n- [ ] Concurrent transaction tests included\n- [ ] Error scenarios covered","status":"open","priority":1,"issue_type":"task","created_at":"2026-01-05T06:38:08.804144-06:00","updated_at":"2026-01-05T06:38:08.804144-06:00"}
{"id":"neo4j-d9a","title":"GREEN: Implement rxSession.close() method","description":"## Overview\nImplement rxSession.close() to make all RED tests pass.\n\n## Implementation Requirements\n\n### Method Signature\n```typescript\ninterface RxSession {\n  close(): Observable\u003cvoid\u003e\n}\n```\n\n### Implementation Details\n- Create Observable for cleanup process\n- Rollback any active transaction\n- Release connection resources\n- Return connection to pool\n- Mark session as closed\n\n### Observable Semantics\n- Cold observable (cleanup on subscribe)\n- Complete on successful cleanup\n- Error on cleanup failure\n- Safe for multiple subscriptions\n\n## Acceptance Criteria\n- All RED tests now pass (GREEN phase)\n- Resources properly released\n- Active transactions handled\n- Observable semantics correct","status":"open","priority":2,"issue_type":"task","created_at":"2026-01-05T06:38:03.357946-06:00","updated_at":"2026-01-05T06:38:03.357946-06:00"}
{"id":"neo4j-da6","title":"RED: REST API endpoint handlers fail without implementation","description":"## Test-Driven Development: RED Phase\n\n### Component\nHTTP Client SDK - REST API Endpoints (Server-Side)\n\n### Test Cases to Write (Expected to FAIL)\n\n```typescript\nimport { describe, it, expect, beforeEach } from 'vitest'\nimport { createTestApp } from '../test-utils'\n\ndescribe('REST API Endpoints - RED', () =\u003e {\n  let app: ReturnType\u003ctypeof createTestApp\u003e\n\n  beforeEach(() =\u003e {\n    app = createTestApp()\n  })\n\n  describe('POST /query', () =\u003e {\n    it('should execute a single Cypher query', async () =\u003e {\n      const response = await app.request('/query', {\n        method: 'POST',\n        headers: { 'Content-Type': 'application/json' },\n        body: JSON.stringify({\n          query: 'RETURN 1 as n',\n          parameters: {}\n        })\n      })\n      \n      expect(response.status).toBe(200)\n      const data = await response.json()\n      expect(data.records).toHaveLength(1)\n      expect(data.records[0].n).toBe(1)\n    })\n\n    it('should handle query parameters', async () =\u003e {\n      const response = await app.request('/query', {\n        method: 'POST',\n        body: JSON.stringify({\n          query: 'RETURN $value as result',\n          parameters: { value: 'hello' }\n        })\n      })\n      \n      const data = await response.json()\n      expect(data.records[0].result).toBe('hello')\n    })\n  })\n\n  describe('POST /tx/begin', () =\u003e {\n    it('should start a new transaction', async () =\u003e {\n      const response = await app.request('/tx/begin', {\n        method: 'POST',\n        body: JSON.stringify({ database: 'neo4j' })\n      })\n      \n      expect(response.status).toBe(201)\n      const data = await response.json()\n      expect(data.id).toBeDefined()\n      expect(data.id).toMatch(/^tx-/)\n    })\n\n    it('should include access mode in response', async () =\u003e {\n      const response = await app.request('/tx/begin', {\n        method: 'POST',\n        body: JSON.stringify({ accessMode: 'READ' })\n      })\n      \n      const data = await response.json()\n      expect(data.accessMode).toBe('READ')\n    })\n  })\n\n  describe('POST /tx/{id}/run', () =\u003e {\n    it('should run query within transaction', async () =\u003e {\n      // First begin transaction\n      const beginRes = await app.request('/tx/begin', { method: 'POST' })\n      const { id } = await beginRes.json()\n      \n      // Then run query\n      const response = await app.request(`/tx/${id}/run`, {\n        method: 'POST',\n        body: JSON.stringify({ query: 'CREATE (n:Test) RETURN n' })\n      })\n      \n      expect(response.status).toBe(200)\n      const data = await response.json()\n      expect(data.records).toBeDefined()\n    })\n\n    it('should reject invalid transaction ID', async () =\u003e {\n      const response = await app.request('/tx/invalid-id/run', {\n        method: 'POST',\n        body: JSON.stringify({ query: 'RETURN 1' })\n      })\n      \n      expect(response.status).toBe(404)\n    })\n  })\n\n  describe('POST /tx/{id}/commit', () =\u003e {\n    it('should commit transaction', async () =\u003e {\n      const beginRes = await app.request('/tx/begin', { method: 'POST' })\n      const { id } = await beginRes.json()\n      \n      const response = await app.request(`/tx/${id}/commit`, { method: 'POST' })\n      \n      expect(response.status).toBe(200)\n      const data = await response.json()\n      expect(data.bookmarks).toBeDefined()\n    })\n  })\n\n  describe('POST /tx/{id}/rollback', () =\u003e {\n    it('should rollback transaction', async () =\u003e {\n      const beginRes = await app.request('/tx/begin', { method: 'POST' })\n      const { id } = await beginRes.json()\n      \n      const response = await app.request(`/tx/${id}/rollback`, { method: 'POST' })\n      \n      expect(response.status).toBe(200)\n    })\n  })\n\n  describe('GET /server-info', () =\u003e {\n    it('should return server metadata', async () =\u003e {\n      const response = await app.request('/server-info')\n      \n      expect(response.status).toBe(200)\n      const data = await response.json()\n      expect(data.address).toBeDefined()\n      expect(data.protocolVersion).toBeDefined()\n      expect(data.agent).toContain('neo4j.do')\n    })\n  })\n\n  describe('GET /databases', () =\u003e {\n    it('should list available databases', async () =\u003e {\n      const response = await app.request('/databases')\n      \n      expect(response.status).toBe(200)\n      const data = await response.json()\n      expect(Array.isArray(data.databases)).toBe(true)\n    })\n  })\n\n  describe('POST /databases', () =\u003e {\n    it('should create a new database', async () =\u003e {\n      const response = await app.request('/databases', {\n        method: 'POST',\n        body: JSON.stringify({ name: 'testdb' })\n      })\n      \n      expect(response.status).toBe(201)\n      const data = await response.json()\n      expect(data.name).toBe('testdb')\n    })\n\n    it('should reject invalid database name', async () =\u003e {\n      const response = await app.request('/databases', {\n        method: 'POST',\n        body: JSON.stringify({ name: 'invalid name!' })\n      })\n      \n      expect(response.status).toBe(400)\n    })\n  })\n})\n```\n\n### Acceptance Criteria\n- [ ] Test file created at `tests/api/rest-endpoints.test.ts`\n- [ ] All tests fail with 404 or not implemented\n- [ ] Tests cover all REST endpoints\n\n### TDD Cycle\nThis is the RED phase. Next: GREEN phase implementation.","status":"open","priority":2,"issue_type":"task","created_at":"2026-01-05T06:37:59.826168-06:00","updated_at":"2026-01-05T06:37:59.826168-06:00"}
{"id":"neo4j-dccl","title":"GREEN: Managed Transaction Auto-Retry Implementation","description":"## Overview\nImplement managed transaction auto-retry logic with exponential backoff to pass all RED phase tests.\n\n## Implementation Requirements\n\n### Retry Configuration\n```typescript\ninterface RetryConfig {\n  maxRetryTime: number      // Default: 30000ms\n  initialDelay: number      // Default: 1000ms\n  maxDelay: number          // Default: 5000ms\n  delayMultiplier: number   // Default: 2.0\n  jitterFactor: number      // Default: 0.2\n}\n\nconst DEFAULT_RETRY_CONFIG: RetryConfig = {\n  maxRetryTime: 30000,\n  initialDelay: 1000,\n  maxDelay: 5000,\n  delayMultiplier: 2.0,\n  jitterFactor: 0.2\n}\n```\n\n### Retry Logic\n```typescript\nasync function executeWithRetry\u003cT\u003e(\n  session: Session,\n  work: (tx: ManagedTransaction) =\u003e Promise\u003cT\u003e,\n  accessMode: AccessMode,\n  config: RetryConfig\n): Promise\u003cT\u003e {\n  const startTime = Date.now()\n  let delay = config.initialDelay\n  let lastError: Error | null = null\n\n  while (Date.now() - startTime \u003c config.maxRetryTime) {\n    const tx = new ManagedTransaction(session, accessMode)\n    \n    try {\n      const result = await work(tx)\n      await tx._commit()\n      return result\n    } catch (error) {\n      lastError = error\n      await tx._rollback()\n      \n      if (!isRetryableError(error)) {\n        throw error\n      }\n      \n      await sleep(addJitter(delay, config.jitterFactor))\n      delay = Math.min(delay * config.delayMultiplier, config.maxDelay)\n    }\n  }\n\n  throw new RetryExhausted('Transaction retry time exceeded', lastError)\n}\n```\n\n### Error Classification\n```typescript\nfunction isRetryableError(error: Error): boolean {\n  if (error instanceof Neo4jError) {\n    return error.code.startsWith('Neo.TransientError') ||\n           error.code === 'Neo.ClientError.Cluster.NotALeader' ||\n           error.code === 'ServiceUnavailable'\n  }\n  return error instanceof SessionExpired ||\n         error instanceof ConnectionError\n}\n```\n\n### Backoff Implementation\n```typescript\nfunction addJitter(delay: number, factor: number): number {\n  const jitter = delay * factor * (Math.random() * 2 - 1)\n  return Math.max(0, delay + jitter)\n}\n\nfunction sleep(ms: number): Promise\u003cvoid\u003e {\n  return new Promise(resolve =\u003e setTimeout(resolve, ms))\n}\n```\n\n## Files to Create/Modify\n- `src/transaction/retry.ts`\n- `src/transaction/managed-transaction.ts`\n- `src/errors/retry-exhausted.ts`\n- `src/errors/error-classifier.ts`\n\n## TDD Phase\n**GREEN** - Implement to pass tests.\n\n## Dependencies\n- Depends on: RED: Managed Transaction Auto-Retry Tests\n- Depends on: GREEN: Transaction Class Core Operations Implementation\n\n## Acceptance Criteria\n- [ ] All RED phase tests pass\n- [ ] Retry logic is correct\n- [ ] Backoff algorithm works\n- [ ] Error classification accurate","status":"open","priority":1,"issue_type":"task","created_at":"2026-01-05T06:39:27.172573-06:00","updated_at":"2026-01-05T06:39:27.172573-06:00"}
{"id":"neo4j-dda","title":"[RED] OpenCypher TCK Integration","description":"# [RED] OpenCypher TCK Integration\n\n## Overview\nIntegrate the OpenCypher Technology Compatibility Kit (TCK) to validate Cypher language compliance.\n\n## What is OpenCypher TCK?\nThe TCK is a set of Cucumber/Gherkin feature files that define the expected behavior of a Cypher implementation. It covers:\n- Query syntax\n- Operators\n- Functions\n- Pattern matching\n- Aggregations\n- And more\n\n## Integration Steps\n\n### 1. Fetch TCK Feature Files\n```bash\n# Clone or download OpenCypher TCK\ngit clone https://github.com/opencypher/openCypher.git\n# Feature files are in: tck/features/\n```\n\n### 2. Setup Cucumber Test Runner\n```typescript\n// tests/tck/cucumber.config.ts\nimport { setWorldConstructor, World } from '@cucumber/cucumber'\n\nclass Neo4jDoWorld extends World {\n  driver: Driver\n  session: Session\n  result: Result\n\n  async connect() {\n    this.driver = neo4jDo.driver('bolt://localhost')\n    this.session = this.driver.session()\n  }\n\n  async query(cypher: string, params?: Record\u003cstring, any\u003e) {\n    this.result = await this.session.run(cypher, params)\n  }\n\n  async cleanup() {\n    await this.session.close()\n    await this.driver.close()\n  }\n}\n\nsetWorldConstructor(Neo4jDoWorld)\n```\n\n### 3. Implement Step Definitions\n```typescript\n// tests/tck/steps/common.steps.ts\nimport { Given, When, Then } from '@cucumber/cucumber'\n\nGiven('an empty graph', async function() {\n  await this.query('MATCH (n) DETACH DELETE n')\n})\n\nGiven('having executed:', async function(cypher: string) {\n  await this.query(cypher)\n})\n\nWhen('executing query:', async function(cypher: string) {\n  await this.query(cypher)\n})\n\nThen('the result should be:', async function(expected: DataTable) {\n  // Compare this.result with expected\n})\n```\n\n### 4. TCK Categories to Test\n- **Expressions**: Literals, parameters, operators\n- **Match**: Pattern matching, optional match\n- **Return**: Projections, aliasing, ordering\n- **With**: Query chaining\n- **Create**: Node and relationship creation\n- **Merge**: Upsert operations\n- **Delete**: Deletion operations\n- **Set/Remove**: Property modifications\n- **Aggregation**: count, sum, avg, collect, etc.\n- **Functions**: String, math, list, temporal\n\n## Test Configuration\n```json\n{\n  \"scripts\": {\n    \"test:tck\": \"cucumber-js tests/tck/features --require tests/tck/steps\"\n  }\n}\n```\n\n## Tracking Compliance\nCreate a compliance matrix:\n```markdown\n| TCK Category | Total Tests | Passing | Failing | % |\n|--------------|-------------|---------|---------|---|\n| Expressions  | 150         | 0       | 150     | 0 |\n| Match        | 200         | 0       | 200     | 0 |\n| ...          | ...         | ...     | ...     |...|\n```\n\n## Acceptance Criteria\n- [ ] TCK feature files integrated\n- [ ] Cucumber test runner configured\n- [ ] Step definitions created\n- [ ] Initial test run completes (all failing)\n- [ ] Compliance tracking documented","status":"open","priority":2,"issue_type":"task","created_at":"2026-01-05T06:38:33.844046-06:00","updated_at":"2026-01-05T06:38:33.844046-06:00"}
{"id":"neo4j-ddr","title":"[RED] Integer Type - Write Failing Tests","description":"## Overview\nWrite comprehensive failing tests for the Neo4j Integer type before implementation.\n\n## TDD Phase: RED (Write Failing Tests)\n\n### Test Cases to Write\n\n#### Factory Functions\n- `neo4j.int(value)` creates Integer from number\n- `neo4j.int(value)` creates Integer from string\n- `neo4j.int(value)` creates Integer from another Integer\n- `neo4j.integer(value)` alias works identically\n\n#### Safe Range Checking\n- `neo4j.integer.inSafeRange(int)` returns true for safe integers\n- `neo4j.integer.inSafeRange(int)` returns false for unsafe integers\n- `Integer.inSafeRange()` instance method\n\n#### Conversion Methods\n- `Integer.toNumber()` returns JavaScript number\n- `Integer.toNumber()` throws for unsafe integers (or returns approximate)\n- `Integer.toString()` returns string representation\n- `Integer.toString(radix)` supports different bases\n- `Integer.toInt()` returns 32-bit integer\n- `Integer.toBigInt()` returns BigInt\n\n#### Arithmetic Operations\n- `Integer.add(other)` addition\n- `Integer.subtract(other)` subtraction\n- `Integer.multiply(other)` multiplication\n- `Integer.divide(other)` integer division\n- `Integer.modulo(other)` remainder\n- `Integer.negate()` negation\n\n#### Comparison Operations\n- `Integer.equals(other)` equality\n- `Integer.lessThan(other)` less than\n- `Integer.lessThanOrEqual(other)` less than or equal\n- `Integer.greaterThan(other)` greater than\n- `Integer.greaterThanOrEqual(other)` greater than or equal\n- `Integer.compare(other)` returns -1, 0, or 1\n\n#### Bitwise Operations\n- `Integer.and(other)` bitwise AND\n- `Integer.or(other)` bitwise OR\n- `Integer.xor(other)` bitwise XOR\n- `Integer.not()` bitwise NOT\n- `Integer.shiftLeft(bits)` left shift\n- `Integer.shiftRight(bits)` right shift\n\n#### Edge Cases\n- Maximum 64-bit integer (2^63 - 1)\n- Minimum 64-bit integer (-2^63)\n- Zero handling\n- Overflow behavior\n- Division by zero\n\n#### Type Guards\n- `neo4j.isInt(value)` returns true for Integer\n- `neo4j.isInt(value)` returns false for number\n\n### Acceptance Criteria\n- [ ] All tests written and failing (RED state)\n- [ ] Tests match neo4j-driver API exactly\n- [ ] Edge cases covered\n- [ ] Tests are isolated and independent\n- [ ] Test file created at `src/types/integer.test.ts`\n\n### References\n- [neo4j-driver Integer API](https://neo4j.com/docs/api/javascript-driver/current/class/lib6/integer.js~Integer.html)","status":"open","priority":1,"issue_type":"task","created_at":"2026-01-05T06:34:35.620699-06:00","updated_at":"2026-01-05T06:34:35.620699-06:00"}
{"id":"neo4j-e12","title":"GREEN: Implement rxSession.run() method","description":"## Overview\nImplement `rxSession.run()` to make all RED tests pass.\n\n## Implementation Requirements\n\n### Method Signature\n```typescript\ninterface RxSession {\n  run(cypher: string, params?: Record\u003cstring, any\u003e): RxResult\n}\n```\n\n### Implementation Details\n- Create RxResult wrapper around query execution\n- Ensure lazy execution (cold observable)\n- Handle parameter serialization\n- Wire up to underlying session/connection\n- Proper error propagation\n\n### Observable Semantics\n- Query executes on first subscription\n- Each subscription creates new execution\n- Support unsubscription/cancellation\n\n## Acceptance Criteria\n- [ ] All RED tests now pass (GREEN phase)\n- [ ] Returns proper RxResult instance\n- [ ] Observable semantics correct\n- [ ] Parameter handling works","status":"open","priority":2,"issue_type":"task","created_at":"2026-01-05T06:35:11.770194-06:00","updated_at":"2026-01-05T06:35:11.770194-06:00"}
{"id":"neo4j-e2j","title":"[REFACTOR] Vector Type - Optimize and Add Math Operations","description":"## Overview\nRefactor Vector type for performance and add mathematical operations.\n\n## TDD Phase: REFACTOR (Improve While Green)\n\n### Refactoring Goals\n\n#### Mathematical Operations\n- [ ] `vector.dot(other)` - dot product\n- [ ] `vector.magnitude()` - L2 norm\n- [ ] `vector.normalize()` - unit vector\n- [ ] `vector.add(other)` - element-wise addition\n- [ ] `vector.subtract(other)` - element-wise subtraction\n- [ ] `vector.scale(factor)` - scalar multiplication\n\n#### Similarity Functions\n- [ ] `vector.cosineSimilarity(other)`\n- [ ] `vector.euclideanDistance(other)`\n\n#### Performance Optimizations\n- [ ] SIMD operations where available\n- [ ] Lazy magnitude calculation (cache)\n- [ ] Zero-copy slicing with ArrayBuffer views\n- [ ] Efficient serialization (base64 for binary)\n\n#### Edge Case Hardening\n- [ ] Dimension mismatch errors\n- [ ] Zero vector handling (normalize)\n- [ ] Overflow in integer vectors\n- [ ] Precision loss warnings\n\n#### Code Quality\n- [ ] Comprehensive JSDoc\n- [ ] Better error messages\n- [ ] Type narrowing helpers\n\n#### Additional Tests\n- [ ] Mathematical property tests (dot product commutativity, etc.)\n- [ ] Large vector performance benchmarks\n- [ ] Serialization round-trip tests\n- [ ] Memory usage tests\n\n### Integration Considerations\n- [ ] How vectors map to Cypher VECTOR type\n- [ ] Integration with vector search queries\n- [ ] Batch operations for multiple vectors\n\n### Acceptance Criteria\n- [ ] All existing tests still pass\n- [ ] Math operations tested and accurate\n- [ ] Performance benchmarks documented\n- [ ] 100% test coverage\n\n### Dependencies\n- Depends on: [GREEN] Vector Type - Implement to Pass Tests","status":"open","priority":2,"issue_type":"task","created_at":"2026-01-05T06:38:29.465263-06:00","updated_at":"2026-01-05T06:38:29.465263-06:00"}
{"id":"neo4j-e3h","title":"ESLint + Prettier setup","description":"# ESLint + Prettier Setup\n\n## Overview\nConfigure ESLint and Prettier for consistent code style and quality in the neo4j.do project.\n\n## ESLint Configuration\n- TypeScript ESLint plugin\n- Strict type-checking rules\n- Import sorting\n- No unused variables\n- Consistent return types\n\n## Prettier Configuration\n```json\n{\n  \"semi\": false,\n  \"singleQuote\": true,\n  \"tabWidth\": 2,\n  \"trailingComma\": \"es5\",\n  \"printWidth\": 100,\n  \"arrowParens\": \"avoid\"\n}\n```\n\n## ESLint Config (eslint.config.js)\n```javascript\nimport eslint from '@eslint/js'\nimport tseslint from 'typescript-eslint'\nimport prettierConfig from 'eslint-config-prettier'\n\nexport default tseslint.config(\n  eslint.configs.recommended,\n  ...tseslint.configs.strictTypeChecked,\n  prettierConfig,\n  {\n    languageOptions: {\n      parserOptions: {\n        project: true,\n        tsconfigRootDir: import.meta.dirname\n      }\n    },\n    rules: {\n      '@typescript-eslint/no-unused-vars': ['error', { argsIgnorePattern: '^_' }],\n      '@typescript-eslint/explicit-function-return-type': 'warn',\n      '@typescript-eslint/no-explicit-any': 'error'\n    }\n  },\n  {\n    ignores: ['dist/**', 'node_modules/**', '*.config.*']\n  }\n)\n```\n\n## Files to Create\n- `eslint.config.js`\n- `.prettierrc`\n- `.prettierignore`\n- `.editorconfig`\n\n## Acceptance Criteria\n- [ ] ESLint configured with TypeScript support\n- [ ] Prettier configured\n- [ ] No conflicts between ESLint and Prettier\n- [ ] Lint command works: `npm run lint`\n- [ ] Format command works: `npm run format`\n- [ ] Pre-commit hook consideration documented","status":"open","priority":1,"issue_type":"task","created_at":"2026-01-05T06:35:36.477707-06:00","updated_at":"2026-01-05T06:35:36.477707-06:00"}
{"id":"neo4j-ecj","title":"[REFACTOR] In-Memory Graph - Optimize memory usage and performance","description":"## Overview\nRefactor in-memory graph for better performance and memory efficiency.\n\n## Refactoring Tasks\n\n### Memory Optimization\n- Use typed arrays where beneficial\n- Implement property deduplication\n- Consider flyweight pattern for common values\n- Add memory usage monitoring\n\n### Performance Optimization\n- Batch index updates\n- Implement lazy index rebuilding\n- Add caching for frequent queries\n- Optimize adjacency list iteration\n\n### API Improvements\n```typescript\n// Add iterator support\ngraph.nodes(): IterableIterator\u003cNode\u003e\ngraph.relationships(): IterableIterator\u003cRelationship\u003e\n\n// Add bulk operations\ngraph.createNodes(nodes: NodeInput[]): Node[]\ngraph.createRelationships(rels: RelInput[]): Relationship[]\n```\n\n### Code Quality\n- Extract common index logic\n- Add generics for type safety\n- Implement proper error handling\n- Add performance benchmarks\n\n### Testing Improvements\n- Add property-based tests\n- Add stress tests for large graphs\n- Add memory leak tests\n- Benchmark against baseline\n\n## Acceptance Criteria\n- [ ] All tests still pass\n- [ ] Memory usage reduced\n- [ ] Query performance improved\n- [ ] Code is cleaner and well-typed\n- [ ] Benchmarks documented\n\n## TDD Phase\n**REFACTOR** - Improve without changing behavior","status":"open","priority":2,"issue_type":"task","created_at":"2026-01-05T06:35:32.490103-06:00","updated_at":"2026-01-05T06:35:32.490103-06:00"}
{"id":"neo4j-ei9","title":"[REFACTOR] Relationship Operations - Optimize traversal and add batch operations","description":"## Overview\nRefactor relationship operations for better traversal performance.\n\n## Refactoring Tasks\n\n### Query Optimization\n```typescript\n// Add compound index for common queries\nCREATE INDEX idx_rel_start_type ON relationships(start_node_id, type);\nCREATE INDEX idx_rel_end_type ON relationships(end_node_id, type);\n\n// Optimized traversal query\ngetRelationshipsForNode(nodeId: number, direction: Direction, type?: string): Relationship[] {\n  if (direction === 'BOTH') {\n    return [\n      ...this.getRelationshipsForNode(nodeId, 'OUTGOING', type),\n      ...this.getRelationshipsForNode(nodeId, 'INCOMING', type)\n    ];\n  }\n  // Use appropriate index based on direction\n}\n```\n\n### Batch Operations\n```typescript\ncreateRelationships(rels: RelationshipInput[]): Relationship[] {\n  return this.sql.transaction(() =\u003e {\n    return rels.map(r =\u003e this.createRelationship(r.type, r.startNodeId, r.endNodeId, r.properties));\n  });\n}\n\ndeleteRelationships(ids: number[]): number {\n  return this.sql.transaction(() =\u003e {\n    let deleted = 0;\n    for (const id of ids) {\n      if (this.deleteRelationship(id)) deleted++;\n    }\n    return deleted;\n  });\n}\n```\n\n### Traversal Helpers\n```typescript\n// Get connected nodes directly\ngetConnectedNodes(nodeId: number, direction: Direction, relType?: string): Node[] {\n  // Efficient join query\n}\n\n// Expand multiple levels\nexpand(nodeId: number, depth: number, direction: Direction): { nodes: Node[], relationships: Relationship[] } {\n  // BFS or DFS expansion\n}\n```\n\n### Code Quality\n- Extract query builders\n- Add relationship validation\n- Implement cascade delete option\n- Add traversal statistics\n\n## Acceptance Criteria\n- [ ] All tests still pass\n- [ ] Traversal performance improved\n- [ ] Batch operations available\n- [ ] Helper methods added\n- [ ] Code well-documented\n\n## TDD Phase\n**REFACTOR** - Improve without changing behavior","status":"open","priority":2,"issue_type":"task","created_at":"2026-01-05T06:37:51.551682-06:00","updated_at":"2026-01-05T06:37:51.551682-06:00"}
{"id":"neo4j-eiy","title":"[GREEN] Vector Type - Implement to Pass Tests","description":"## Overview\nImplement the Vector type to pass all failing tests.\n\n## TDD Phase: GREEN (Make Tests Pass)\n\n### Implementation Requirements\n\n#### TypedArray Types\n```typescript\ntype VectorDType = \n  | 'int8' \n  | 'int16' \n  | 'int32' \n  | 'int64'   // BigInt64Array\n  | 'float32' \n  | 'float64';\n\ntype TypedArrayMap = {\n  int8: Int8Array;\n  int16: Int16Array;\n  int32: Int32Array;\n  int64: BigInt64Array;\n  float32: Float32Array;\n  float64: Float64Array;\n};\n```\n\n#### Vector Class\n```typescript\nexport class Vector\u003cT extends VectorDType = 'float32'\u003e {\n  readonly #data: TypedArrayMap[T];\n  readonly dtype: T;\n  \n  constructor(data: TypedArrayMap[T], dtype: T);\n  \n  // Properties\n  get dimensions(): number;\n  get byteLength(): number;\n  \n  // Element access\n  at(index: number): number | bigint;\n  \n  // Conversion\n  asTypedArray(): TypedArrayMap[T];\n  toArray(): (number | bigint)[];\n  \n  // Iteration\n  [Symbol.iterator](): Iterator\u003cnumber | bigint\u003e;\n  \n  // Slicing\n  slice(start?: number, end?: number): Vector\u003cT\u003e;\n  \n  // Serialization\n  toString(): string;\n  toJSON(): VectorJSON;\n  static fromJSON(json: VectorJSON): Vector;\n}\n```\n\n#### Factory Function\n```typescript\nfunction vector(\n  data: ArrayLike\u003cnumber\u003e | TypedArray,\n  dtype?: VectorDType\n): Vector {\n  // Infer dtype from TypedArray if not specified\n  // Default to float32 for regular arrays\n}\n```\n\n#### Type Guard\n```typescript\nfunction isVector(value: unknown): value is Vector {\n  return value instanceof Vector;\n}\n```\n\n### Implementation Notes\n- Store data as TypedArray internally for efficiency\n- Support BigInt64Array for int64 (needed for some embeddings)\n- Efficient serialization for network transfer\n- Consider ArrayBuffer sharing for slices\n\n### File Structure\n```\nsrc/types/\n  vector.ts\n  vector.test.ts\n```\n\n### Acceptance Criteria\n- [ ] All RED phase tests passing\n- [ ] All dtype variants working\n- [ ] Efficient memory usage\n- [ ] Proper TypeScript generics\n- [ ] Exported from `src/types/index.ts`\n\n### Dependencies\n- Depends on: [RED] Vector Type - Write Failing Tests","status":"open","priority":2,"issue_type":"task","created_at":"2026-01-05T06:38:12.993171-06:00","updated_at":"2026-01-05T06:38:12.993171-06:00"}
{"id":"neo4j-fij","title":"[GREEN] AST: Implement Visitor Pattern","description":"## Overview\nImplement the AST visitor pattern.\n\n## Implementation Tasks\n\n### Visitor Interface (src/parser/ast/visitor.ts)\n```typescript\nexport interface ASTVisitor\u003cT = void\u003e {\n  // Queries\n  visitQuery?(node: Query): T\n  visitUnion?(node: Union): T\n  \n  // Clauses\n  visitMatchClause?(node: MatchClause): T\n  visitReturnClause?(node: ReturnClause): T\n  visitWithClause?(node: WithClause): T\n  visitCreateClause?(node: CreateClause): T\n  visitMergeClause?(node: MergeClause): T\n  visitDeleteClause?(node: DeleteClause): T\n  visitSetClause?(node: SetClause): T\n  visitRemoveClause?(node: RemoveClause): T\n  visitUnwindClause?(node: UnwindClause): T\n  \n  // Patterns\n  visitNodePattern?(node: NodePattern): T\n  visitRelationshipPattern?(node: RelationshipPattern): T\n  \n  // Expressions\n  visitBinaryExpression?(node: BinaryExpression): T\n  visitUnaryExpression?(node: UnaryExpression): T\n  visitFunctionCall?(node: FunctionCall): T\n  visitPropertyAccess?(node: PropertyAccess): T\n  visitIdentifier?(node: Identifier): T\n  visitLiteral?(node: Literal): T\n  \n  // Fallback\n  visit?(node: ASTNode): T\n}\n```\n\n### Walk Function\n```typescript\nexport function walk\u003cT\u003e(\n  node: ASTNode,\n  visitor: ASTVisitor\u003cT\u003e,\n  context?: any\n): T | undefined {\n  const method = `visit${node.type}` as keyof ASTVisitor\u003cT\u003e\n  if (visitor[method]) {\n    return (visitor[method] as Function)(node, context)\n  }\n  return visitor.visit?.(node, context)\n}\n```\n\n### Recursive Walker\n```typescript\nexport function walkAll(node: ASTNode, visitor: ASTVisitor): void {\n  // Walk this node\n  // Walk all children recursively\n}\n```\n\n## Acceptance Criteria\n- [ ] All visitor tests pass\n- [ ] Dispatch to correct method\n- [ ] Fallback behavior works\n- [ ] Recursive walking complete\n\n## TDD Phase: GREEN\n## Depends On: neo4j-070","status":"open","priority":1,"issue_type":"task","created_at":"2026-01-05T06:39:07.125814-06:00","updated_at":"2026-01-05T06:39:07.125814-06:00"}
{"id":"neo4j-fra","title":"REFACTOR: Improve rxTx.run() implementation","description":"## Overview\nRefactor rxTx.run() for better code quality.\n\n## Refactoring Tasks\n\n### Code Quality\n- Share code with rxSession.run()\n- Extract common query execution\n- Improve type definitions\n- Better error messages\n\n### Transaction Integration\n- Ensure proper transaction binding\n- Handle transaction state checks\n- Optimize for multiple queries\n\n### Performance\n- Minimize Observable overhead\n- Efficient parameter handling\n- Consider query batching\n\n## Acceptance Criteria\n- All tests still pass\n- DRY code with session.run\n- Clean transaction integration\n- Efficient implementation","status":"open","priority":2,"issue_type":"task","created_at":"2026-01-05T06:38:51.833819-06:00","updated_at":"2026-01-05T06:38:51.833819-06:00"}
{"id":"neo4j-gahj","title":"[REFACTOR] Graph Types - Optimize and Add Utilities","description":"## Overview\nRefactor Graph types for performance, utilities, and code quality.\n\n## TDD Phase: REFACTOR (Improve While Green)\n\n### Refactoring Goals\n\n#### Node Utilities\n- [ ] `node.hasLabel(label)` - check for label\n- [ ] `node.getProperty(key, default)` - safe property access\n- [ ] `Node.create(labels, properties)` - factory without ID (for local use)\n\n#### Relationship Utilities\n- [ ] `rel.connectsTo(node)` - check if connects to node\n- [ ] `rel.isDirectedFrom(node)` - check direction\n- [ ] `Relationship.create(type, properties)` - factory without IDs\n\n#### Path Utilities\n- [ ] `path.nodes()` - all nodes in path\n- [ ] `path.relationships()` - all relationships in path\n- [ ] `path.contains(node)` - check if node in path\n- [ ] `path.reverse()` - reversed path\n\n#### Performance Optimizations\n- [ ] Lazy property freezing\n- [ ] Cache common operations\n- [ ] Efficient iteration for paths\n\n#### Code Quality\n- [ ] Add comprehensive JSDoc\n- [ ] Better toString() formatting\n- [ ] Consistent error messages\n- [ ] Extract shared validation logic\n\n#### Additional Tests\n- [ ] Complex path traversal tests\n- [ ] Large graph structure tests\n- [ ] Serialization round-trip tests\n- [ ] Type narrowing with generics tests\n\n#### Integration Considerations\n- [ ] How to handle UNWIND results\n- [ ] Aggregation result handling\n- [ ] Projection results\n\n### Acceptance Criteria\n- [ ] All existing tests still pass\n- [ ] Utility methods tested\n- [ ] 100% test coverage\n- [ ] JSDoc complete\n- [ ] Performance benchmarks\n\n### Dependencies\n- Depends on: [GREEN] Graph Types (Node, Relationship, Path) - Implement to Pass Tests","status":"open","priority":1,"issue_type":"task","created_at":"2026-01-05T06:39:34.258582-06:00","updated_at":"2026-01-05T06:39:34.258582-06:00"}
{"id":"neo4j-gfq","title":"GREEN: Auto Vector Embeddings - Implement automatic embedding generation","description":"## Overview\nImplement automatic vector embedding generation to make all RED tests pass.\n\n## Implementation Requirements\n\n### Core Components\n\n#### 1. Embedding Configuration Store\n```typescript\ninterface EmbeddingConfig {\n  indexName: string;\n  label?: string;\n  relType?: string;\n  sourceField: string | string[];\n  targetField: string;\n  model: string;\n  dimensions: number;\n  separator?: string;\n}\n\nclass EmbeddingConfigStore {\n  async configure(config: EmbeddingConfig): Promise\u003cvoid\u003e;\n  async getConfigsForLabel(label: string): Promise\u003cEmbeddingConfig[]\u003e;\n  async getConfigsForRelType(relType: string): Promise\u003cEmbeddingConfig[]\u003e;\n}\n```\n\n#### 2. Workers AI Embedding Service\n```typescript\nclass WorkersAIEmbeddingService {\n  constructor(private ai: Ai) {}\n  \n  async embed(text: string, model: string): Promise\u003cnumber[]\u003e;\n  async embedBatch(texts: string[], model: string): Promise\u003cnumber[][]\u003e;\n}\n```\n\n#### 3. Auto-Embedding Interceptor\n```typescript\nclass AutoEmbeddingInterceptor {\n  async beforeNodeCreate(label: string, properties: Record\u003cstring, any\u003e): Promise\u003cRecord\u003cstring, any\u003e\u003e;\n  async beforeNodeUpdate(label: string, oldProps: Record\u003cstring, any\u003e, newProps: Record\u003cstring, any\u003e): Promise\u003cRecord\u003cstring, any\u003e\u003e;\n  async beforeRelationshipCreate(type: string, properties: Record\u003cstring, any\u003e): Promise\u003cRecord\u003cstring, any\u003e\u003e;\n}\n```\n\n#### 4. Batch Embedding Processor\n```typescript\nclass BatchEmbeddingProcessor {\n  private queue: EmbeddingJob[] = [];\n  private batchSize = 50;\n  \n  async queueEmbedding(job: EmbeddingJob): Promise\u003cvoid\u003e;\n  async flush(): Promise\u003cvoid\u003e;\n  async processExisting(label: string, field: string, options: BatchOptions): Promise\u003cBatchResult\u003e;\n}\n```\n\n### SQL Schema Additions\n```sql\nCREATE TABLE embedding_configs (\n  id TEXT PRIMARY KEY,\n  index_name TEXT NOT NULL UNIQUE,\n  entity_type TEXT NOT NULL CHECK (entity_type IN ('node', 'relationship')),\n  label_or_type TEXT NOT NULL,\n  source_fields TEXT NOT NULL, -- JSON array\n  target_field TEXT NOT NULL,\n  model TEXT NOT NULL DEFAULT '@cf/baai/bge-m3',\n  dimensions INTEGER NOT NULL DEFAULT 1024,\n  separator TEXT DEFAULT ' ',\n  created_at TEXT DEFAULT (datetime('now')),\n  updated_at TEXT DEFAULT (datetime('now'))\n);\n\nCREATE INDEX idx_embedding_configs_label ON embedding_configs(label_or_type) WHERE entity_type = 'node';\nCREATE INDEX idx_embedding_configs_reltype ON embedding_configs(label_or_type) WHERE entity_type = 'relationship';\n```\n\n### Procedures to Implement\n- `CALL db.index.vector.configure(indexName, options)`\n- `CALL db.embeddings.bulkGenerate(label, field, options)`\n- `CALL db.embeddings.status()` - show embedding queue status\n\n## Acceptance Criteria\n- [ ] All RED phase tests passing\n- [ ] Workers AI integration working\n- [ ] Batch processing efficient (\u003c 5s for 100 nodes)\n- [ ] Configuration persisted across restarts\n- [ ] Error handling for AI failures\n\n## Dependencies\n- RED: Auto Vector Embeddings tests\n- Vectorize binding\n\n## Tags\nsuperset, embeddings, workers-ai, tdd-green","status":"open","priority":2,"issue_type":"task","created_at":"2026-01-05T06:35:07.052411-06:00","updated_at":"2026-01-05T06:35:07.052411-06:00"}
{"id":"neo4j-ght","title":"[RED] Node Operations - Write failing tests for CRUD operations","description":"## Overview\nWrite failing tests for all node CRUD operations before implementation.\n\n## Test Cases to Write\n\n### createNode Tests\n- `test_create_node_returns_node_with_id`\n- `test_create_node_with_single_label`\n- `test_create_node_with_multiple_labels`\n- `test_create_node_with_properties`\n- `test_create_node_with_empty_properties`\n- `test_create_node_generates_unique_ids`\n- `test_create_node_sets_created_at_timestamp`\n\n### getNode Tests\n- `test_get_node_returns_existing_node`\n- `test_get_node_returns_null_for_missing`\n- `test_get_node_includes_all_properties`\n- `test_get_node_includes_labels`\n- `test_get_node_with_invalid_id_type`\n\n### updateNode Tests\n- `test_update_node_changes_properties`\n- `test_update_node_merges_properties`\n- `test_update_node_can_remove_property_with_null`\n- `test_update_node_updates_timestamp`\n- `test_update_nonexistent_node_throws`\n\n### deleteNode Tests\n- `test_delete_node_removes_from_storage`\n- `test_delete_node_with_relationships_throws`\n- `test_delete_nonexistent_node_returns_false`\n- `test_delete_node_removes_from_indexes`\n\n### getNodesByLabel Tests\n- `test_get_nodes_by_label_returns_matching`\n- `test_get_nodes_by_label_empty_for_unknown`\n- `test_get_nodes_by_label_multiple_results`\n\n### getAllNodes Tests\n- `test_get_all_nodes_returns_all`\n- `test_get_all_nodes_empty_graph`\n- `test_get_all_nodes_with_pagination`\n\n## Acceptance Criteria\n- [ ] All tests written and failing\n- [ ] Edge cases covered\n- [ ] Error conditions tested\n- [ ] Return types validated\n\n## TDD Phase\n**RED** - Write failing tests first","status":"open","priority":1,"issue_type":"task","created_at":"2026-01-05T06:36:49.442195-06:00","updated_at":"2026-01-05T06:36:49.442195-06:00"}
{"id":"neo4j-giy","title":"REFACTOR: Improve rxSession.beginTransaction() implementation","description":"## Overview\nRefactor rxSession.beginTransaction() for better code quality.\n\n## Refactoring Tasks\n\n### Code Quality\n- Extract transaction initialization logic\n- Improve error handling\n- Add proper TypeScript types\n- Document transaction lifecycle\n\n### Resource Management\n- Ensure proper cleanup on errors\n- Handle unsubscription correctly\n- Manage connection resources\n\n### Integration\n- Align with sync session.beginTransaction()\n- Share common transaction creation code\n- Consistent logging\n\n## Acceptance Criteria\n- All tests still pass\n- Clean separation of concerns\n- Proper resource management\n- Well-documented code","status":"open","priority":2,"issue_type":"task","created_at":"2026-01-05T06:37:08.912131-06:00","updated_at":"2026-01-05T06:37:08.912131-06:00"}
{"id":"neo4j-gjj","title":"RED: Record.length - Write failing tests for number of columns","description":"## Overview\nWrite failing tests for the Record.length property that returns number of columns.\n\n## Test Cases to Write\n\n```typescript\ndescribe('Record.length', () =\u003e {\n  it('should return number of columns', () =\u003e {\n    const record = new Record(['name', 'age', 'city'], ['Alice', 30, 'NYC']);\n    expect(record.length).toBe(3);\n  });\n\n  it('should return 0 for empty record', () =\u003e {\n    const record = new Record([], []);\n    expect(record.length).toBe(0);\n  });\n\n  it('should return 1 for single column', () =\u003e {\n    const record = new Record(['name'], ['Alice']);\n    expect(record.length).toBe(1);\n  });\n\n  it('should be read-only', () =\u003e {\n    const record = new Record(['name'], ['Alice']);\n    expect(() =\u003e {\n      (record as any).length = 5;\n    }).toThrow();\n  });\n});\n```\n\n## Acceptance Criteria\n- [ ] All tests written and failing (RED phase)\n- [ ] Tests verify correct count\n- [ ] Tests verify read-only nature\n- [ ] Test file created at src/result/__tests__/record-length.test.ts\n\n## TDD Phase\nRED - Tests should fail because length property does not exist yet","status":"open","priority":1,"issue_type":"task","created_at":"2026-01-05T06:38:19.294313-06:00","updated_at":"2026-01-05T06:38:19.294313-06:00"}
{"id":"neo4j-gkn","title":"REFACTOR: Improve rxSession.run() implementation","description":"## Overview\nRefactor `rxSession.run()` for better code quality and performance.\n\n## Refactoring Tasks\n\n### Code Quality\n- Extract query execution logic\n- Improve parameter validation\n- Add comprehensive type definitions\n- Ensure consistent error handling\n\n### Observable Optimization\n- Optimize cold observable creation\n- Consider shareReplay for repeated access\n- Review subscription management\n\n### Integration\n- Align with sync session.run() where appropriate\n- Share common query execution code\n- Consistent logging/tracing\n\n## Acceptance Criteria\n- [ ] All tests still pass\n- [ ] Clean, maintainable code\n- [ ] Proper TypeScript types\n- [ ] Good performance characteristics","status":"open","priority":2,"issue_type":"task","created_at":"2026-01-05T06:35:18.063497-06:00","updated_at":"2026-01-05T06:35:18.063497-06:00"}
{"id":"neo4j-gqv","title":"RED: Neo4jHttpDriver class instantiation fails without implementation","description":"## Test-Driven Development: RED Phase\n\n### Component\nHTTP Client SDK - Neo4jHttpDriver Class\n\n### Test Cases to Write (Expected to FAIL)\n\n```typescript\nimport { describe, it, expect } from 'vitest'\nimport { Neo4jHttpDriver } from '../src/client/http-driver'\n\ndescribe('Neo4jHttpDriver - RED', () =\u003e {\n  it('should create driver with baseUrl', () =\u003e {\n    const driver = new Neo4jHttpDriver('https://neo4j.do/db/mydb')\n    expect(driver).toBeInstanceOf(Neo4jHttpDriver)\n    expect(driver.baseUrl).toBe('https://neo4j.do/db/mydb')\n  })\n\n  it('should create driver with auth credentials', () =\u003e {\n    const driver = new Neo4jHttpDriver('https://neo4j.do/db/mydb', {\n      auth: { username: 'neo4j', password: 'password' }\n    })\n    expect(driver.isAuthenticated).toBe(true)\n  })\n\n  it('should return HttpSession from session()', () =\u003e {\n    const driver = new Neo4jHttpDriver('https://neo4j.do/db/mydb')\n    const session = driver.session()\n    expect(session).toBeInstanceOf(HttpSession)\n  })\n\n  it('should execute query via HTTP', async () =\u003e {\n    const driver = new Neo4jHttpDriver('https://neo4j.do/db/mydb')\n    const result = await driver.executeQuery('RETURN 1 as n')\n    expect(result.records).toHaveLength(1)\n    expect(result.records[0].get('n')).toBe(1)\n  })\n\n  it('should get server info via HTTP', async () =\u003e {\n    const driver = new Neo4jHttpDriver('https://neo4j.do/db/mydb')\n    const info = await driver.getServerInfo()\n    expect(info.address).toBeDefined()\n    expect(info.protocolVersion).toBeDefined()\n  })\n\n  it('should close driver and cleanup resources', async () =\u003e {\n    const driver = new Neo4jHttpDriver('https://neo4j.do/db/mydb')\n    await driver.close()\n    expect(driver.isClosed).toBe(true)\n  })\n\n  it('should support optional connection pooling', () =\u003e {\n    const driver = new Neo4jHttpDriver('https://neo4j.do/db/mydb', {\n      maxConnectionPoolSize: 10\n    })\n    expect(driver.config.maxConnectionPoolSize).toBe(10)\n  })\n})\n```\n\n### Acceptance Criteria\n- [ ] Test file created at `tests/client/http-driver.test.ts`\n- [ ] All tests fail with `module not found` or `class not defined`\n- [ ] Tests cover: instantiation, session creation, query execution, server info, close, pooling\n\n### TDD Cycle\nThis is the RED phase. Next: GREEN phase implementation.","status":"open","priority":2,"issue_type":"task","created_at":"2026-01-05T06:34:28.34202-06:00","updated_at":"2026-01-05T06:34:28.34202-06:00"}
{"id":"neo4j-ha2","title":"RED: Record.toObject() - Write failing tests for converting to plain object","description":"## Overview\nWrite failing tests for the Record.toObject() method that converts a record to a plain JavaScript object.\n\n## Test Cases to Write\n\n```typescript\ndescribe('Record.toObject()', () =\u003e {\n  it('should convert record to plain object', () =\u003e {\n    const record = new Record(['name', 'age'], ['Alice', 30]);\n    expect(record.toObject()).toEqual({ name: 'Alice', age: 30 });\n  });\n\n  it('should handle empty record', () =\u003e {\n    const record = new Record([], []);\n    expect(record.toObject()).toEqual({});\n  });\n\n  it('should preserve null values', () =\u003e {\n    const record = new Record(['name', 'email'], ['Alice', null]);\n    expect(record.toObject()).toEqual({ name: 'Alice', email: null });\n  });\n\n  it('should preserve complex Neo4j types', () =\u003e {\n    const node = new Node(1, ['Person'], { name: 'Alice' });\n    const record = new Record(['person'], [node]);\n    const obj = record.toObject();\n    expect(obj.person).toBe(node);\n  });\n\n  it('should return a new object each time', () =\u003e {\n    const record = new Record(['name'], ['Alice']);\n    const obj1 = record.toObject();\n    const obj2 = record.toObject();\n    expect(obj1).not.toBe(obj2);\n    expect(obj1).toEqual(obj2);\n  });\n});\n```\n\n## Acceptance Criteria\n- [ ] All tests written and failing (RED phase)\n- [ ] Tests cover object conversion scenarios\n- [ ] Tests verify immutability\n- [ ] Test file created at src/result/__tests__/record-to-object.test.ts\n\n## TDD Phase\nRED - Tests should fail because toObject method does not exist yet","status":"open","priority":1,"issue_type":"task","created_at":"2026-01-05T06:36:48.53671-06:00","updated_at":"2026-01-05T06:36:48.53671-06:00"}
{"id":"neo4j-hupw","title":"REFACTOR: Record.has(key) - Document and verify performance","description":"## Overview\nRefactor the Record.has(key) method with documentation and performance verification.\n\n## Refactoring Tasks\n\n1. **Documentation**\n   - Add JSDoc comments\n   - Document O(1) lookup guarantee\n\n2. **Performance**\n   - Verify Map.has is optimal\n   - Add performance test\n\n## Acceptance Criteria\n- [ ] All tests still pass after refactoring\n- [ ] Code is well-documented\n- [ ] Performance characteristics documented\n\n## TDD Phase\nREFACTOR - Improve code without changing behavior\n\n## Dependencies\n- neo4j-0yo (GREEN phase implementation)","status":"open","priority":1,"issue_type":"task","created_at":"2026-01-05T06:39:21.187762-06:00","updated_at":"2026-01-05T06:39:21.187762-06:00"}
{"id":"neo4j-hzo","title":"GREEN: Pattern to JOIN Translation - Single Node Pattern","description":"## Overview\nImplement single node pattern translation to make RED tests pass.\n\n## Implementation Tasks\n\n### 1. Create PatternTranslator Class\n```typescript\nclass PatternTranslator {\n  translateNodePattern(node: NodePattern): SQLFragment {\n    // Generate SELECT from nodes table\n    // Handle variable binding\n    // Generate label WHERE clause\n    // Generate property WHERE clauses\n  }\n}\n```\n\n### 2. Implement Label Filtering\n```typescript\nprivate translateLabelFilter(labels: string[]): string {\n  // Single label: label = 'Person'\n  // Multiple labels: label IN ('Person', 'Employee') or AND\n}\n```\n\n### 3. Implement Property Filtering\n```typescript\nprivate translatePropertyFilter(props: Map\u003cstring, any\u003e): string {\n  // json_extract(properties, '$.name') = 'Alice'\n}\n```\n\n### 4. Variable Binding Registry\n```typescript\nclass VariableRegistry {\n  bind(name: string, tableAlias: string): void;\n  resolve(name: string): string;\n}\n```\n\n## Files to Create/Modify\n- `src/cypher/translator/pattern-translator.ts`\n- `src/cypher/translator/variable-registry.ts`\n- `src/cypher/translator/sql-fragment.ts`\n\n## Acceptance Criteria\n- [ ] All RED phase tests pass\n- [ ] Minimal implementation (no over-engineering)\n- [ ] Code compiles without errors\n\n## TDD Phase\nGREEN - Make tests pass with minimal code\n\n## Dependencies\n- Depends on: RED: Pattern to JOIN Translation - Single Node Pattern","status":"open","priority":1,"issue_type":"task","created_at":"2026-01-05T06:34:45.630881-06:00","updated_at":"2026-01-05T06:34:45.630881-06:00"}
{"id":"neo4j-i2k","title":"RED: Record.get(key) - Write failing tests for getting value by column name","description":"## Overview\nWrite failing tests for the Record.get(key) method that retrieves values by column name.\n\n## Test Cases to Write\n\n```typescript\ndescribe('Record.get(key)', () =\u003e {\n  it('should return value for existing column name', () =\u003e {\n    const record = new Record(['name', 'age'], ['Alice', 30]);\n    expect(record.get('name')).toBe('Alice');\n    expect(record.get('age')).toBe(30);\n  });\n\n  it('should return undefined for non-existent column', () =\u003e {\n    const record = new Record(['name'], ['Alice']);\n    expect(record.get('missing')).toBeUndefined();\n  });\n\n  it('should handle null values', () =\u003e {\n    const record = new Record(['name', 'email'], ['Alice', null]);\n    expect(record.get('email')).toBeNull();\n  });\n\n  it('should handle complex types (Node, Relationship, etc.)', () =\u003e {\n    const node = new Node(1, ['Person'], { name: 'Alice' });\n    const record = new Record(['person'], [node]);\n    expect(record.get('person')).toBe(node);\n  });\n\n  it('should be case-sensitive for column names', () =\u003e {\n    const record = new Record(['Name', 'name'], ['Alice', 'Bob']);\n    expect(record.get('Name')).toBe('Alice');\n    expect(record.get('name')).toBe('Bob');\n  });\n});\n```\n\n## Acceptance Criteria\n- [ ] All tests written and failing (RED phase)\n- [ ] Tests cover happy path and edge cases\n- [ ] Tests follow Neo4j driver API behavior\n- [ ] Test file created at `src/result/__tests__/record-get-key.test.ts`\n\n## TDD Phase\nRED - Tests should fail because Record class doesn't exist yet","status":"open","priority":1,"issue_type":"task","created_at":"2026-01-05T06:34:26.829198-06:00","updated_at":"2026-01-05T06:34:26.829198-06:00"}
{"id":"neo4j-i82","title":"GREEN: Driver Class Factory \u0026 URI Parsing Implementation","description":"## Overview\nImplement the Driver class factory function and URI parsing to pass all RED phase tests.\n\n## Implementation Requirements\n\n### Factory Function\n```typescript\n// Main entry point matching neo4j-driver API\nexport function driver(\n  uri: string,\n  authToken?: AuthToken,\n  config?: DriverConfig\n): Driver\n\n// Type definitions\ninterface Driver {\n  session(config?: SessionConfig): Session\n  rxSession(config?: SessionConfig): RxSession\n  executeQuery\u003cT\u003e(cypher: string, params?: Record\u003cstring, any\u003e, config?: QueryConfig): Promise\u003cEagerResult\u003cT\u003e\u003e\n  getServerInfo(): Promise\u003cServerInfo\u003e\n  close(): Promise\u003cvoid\u003e\n  verifyConnectivity(): Promise\u003cServerInfo\u003e\n}\n\ninterface DriverConfig {\n  maxTransactionRetryTime?: number\n  connectionTimeout?: number\n  maxConnectionPoolSize?: number\n  connectionAcquisitionTimeout?: number\n  logging?: LoggingConfig\n  encrypted?: boolean\n  trust?: TrustStrategy\n}\n```\n\n### URI Parser\n```typescript\ninterface ParsedUri {\n  scheme: 'neo4j' | 'neo4j+s' | 'bolt' | 'bolt+s'\n  host: string\n  port: number\n  encrypted: boolean\n  routing: boolean\n  params: Record\u003cstring, string\u003e\n}\n\nfunction parseUri(uri: string): ParsedUri\n```\n\n### Auth Tokens\n```typescript\nexport const auth = {\n  basic(username: string, password: string, realm?: string): AuthToken,\n  bearer(token: string): AuthToken,\n  custom(principal: string, credentials: string, realm: string, scheme: string, parameters?: Record\u003cstring, any\u003e): AuthToken\n}\n```\n\n## Files to Create/Modify\n- `src/driver/driver.ts` - Main Driver class\n- `src/driver/uri-parser.ts` - URI parsing logic\n- `src/driver/auth.ts` - Authentication token factories\n- `src/driver/config.ts` - Configuration handling\n- `src/driver/index.ts` - Public exports\n\n## TDD Phase\n**GREEN** - Implement minimum code to pass all tests from RED phase.\n\n## Dependencies\n- Depends on: RED: Driver Class Factory \u0026 URI Parsing Tests\n\n## Acceptance Criteria\n- [ ] All RED phase tests pass\n- [ ] API matches neo4j-driver exactly\n- [ ] TypeScript types are complete\n- [ ] Works in Cloudflare Workers environment","status":"open","priority":1,"issue_type":"task","created_at":"2026-01-05T06:34:48.176119-06:00","updated_at":"2026-01-05T06:34:48.176119-06:00"}
{"id":"neo4j-ijp","title":"[GREEN] AST: Implement Core Node Type Interfaces","description":"## Overview\nImplement all AST node type interfaces.\n\n## Implementation Tasks\n\n### Base Types (src/parser/ast/base.ts)\n```typescript\nexport interface ASTNode {\n  type: string\n  loc: SourceLocation\n}\n\nexport interface SourceLocation {\n  start: Position\n  end: Position\n  source?: string\n}\n\nexport interface Position {\n  line: number\n  column: number\n  offset: number\n}\n```\n\n### Query Types (src/parser/ast/query.ts)\n```typescript\nexport interface Query extends ASTNode {\n  type: 'Query'\n  clauses: Clause[]\n}\n\nexport interface Union extends ASTNode {\n  type: 'Union'\n  left: Query\n  right: Query\n  all: boolean\n}\n```\n\n### Clause Types (src/parser/ast/clauses.ts)\n```typescript\nexport type Clause =\n  | MatchClause\n  | CreateClause\n  | MergeClause\n  | DeleteClause\n  | SetClause\n  | RemoveClause\n  | ReturnClause\n  | WithClause\n  | UnwindClause\n  | CallClause\n\n// Individual clause interfaces...\n```\n\n### Type Guards (src/parser/ast/guards.ts)\n```typescript\nexport function isMatchClause(node: ASTNode): node is MatchClause\nexport function isExpression(node: ASTNode): node is Expression\n```\n\n## Acceptance Criteria\n- [ ] All AST type tests pass\n- [ ] Types are properly discriminated\n- [ ] Type guards work correctly\n- [ ] All types exported from index\n\n## TDD Phase: GREEN\n## Depends On: neo4j-u43","status":"open","priority":1,"issue_type":"task","created_at":"2026-01-05T06:37:34.65022-06:00","updated_at":"2026-01-05T06:37:34.65022-06:00"}
{"id":"neo4j-j4p","title":"REFACTOR: Clean up rxSession.executeRead() implementation","description":"## Overview\nRefactor `rxSession.executeRead()` for maintainability and performance.\n\n## Refactoring Tasks\n\n### Code Quality\n- Extract common transaction management logic\n- Share code with executeWrite where possible\n- Improve type safety\n- Better error messages\n\n### Retry Logic\n- Extract retry operator composition\n- Make retry strategy configurable\n- Add jitter to retry delays\n\n### Testing\n- Ensure testability with dependency injection\n- Support test scheduler injection\n\n## Acceptance Criteria\n- [ ] All tests still pass\n- [ ] DRY code with executeWrite\n- [ ] Configurable retry behavior\n- [ ] Clean, documented code","status":"open","priority":2,"issue_type":"task","created_at":"2026-01-05T06:35:52.910074-06:00","updated_at":"2026-01-05T06:35:52.910074-06:00"}
{"id":"neo4j-jee","title":"[GREEN] AST: Implement Pattern Node Types","description":"## Overview\nImplement all pattern AST node types.\n\n## Implementation Tasks\n\n### Pattern Types (src/parser/ast/patterns.ts)\n```typescript\nexport interface Pattern extends ASTNode {\n  type: 'Pattern'\n  elements: PatternElement[]\n}\n\nexport interface NodePattern extends ASTNode {\n  type: 'NodePattern'\n  variable?: Identifier\n  labels: string[]\n  properties?: MapLiteral | Parameter\n}\n\nexport interface RelationshipPattern extends ASTNode {\n  type: 'RelationshipPattern'\n  variable?: Identifier\n  types: string[]\n  properties?: MapLiteral | Parameter\n  direction: RelationshipDirection\n  length?: RelationshipLength\n}\n\nexport type RelationshipDirection = \n  | 'outgoing'   // --\u003e\n  | 'incoming'   // \u003c--\n  | 'both'       // \u003c--\u003e\n  | 'none'       // --\n\nexport interface RelationshipLength {\n  type: 'RelationshipLength'\n  min?: number\n  max?: number\n}\n```\n\n### Named Path\n```typescript\nexport interface NamedPath extends ASTNode {\n  type: 'NamedPath'\n  variable: Identifier\n  pattern: PatternElement[]\n}\n```\n\n### PatternElement Union\n```typescript\nexport type PatternElement = \n  | NodePattern \n  | RelationshipPattern \n  | PatternChain\n\nexport interface PatternChain extends ASTNode {\n  type: 'PatternChain'\n  elements: (NodePattern | RelationshipPattern)[]\n}\n```\n\n## Acceptance Criteria\n- [ ] All pattern type tests pass\n- [ ] Types support all Cypher patterns\n- [ ] Direction enum complete\n- [ ] Variable-length type correct\n\n## TDD Phase: GREEN\n## Depends On: neo4j-5i2","status":"open","priority":1,"issue_type":"task","created_at":"2026-01-05T06:38:37.109643-06:00","updated_at":"2026-01-05T06:38:37.109643-06:00"}
{"id":"neo4j-jpn","title":"GREEN: Implement rxSession.beginTransaction() method","description":"## Overview\nImplement rxSession.beginTransaction() to make all RED tests pass.\n\n## Implementation Requirements\n\n### Method Signature\n```typescript\ninterface RxSession {\n  beginTransaction(config?: TransactionConfig): Observable\u003cRxTransaction\u003e\n}\n```\n\n### Implementation Details\n- Create Observable that emits RxTransaction\n- Initialize transaction on subscription\n- Track active transaction in session\n- Apply configuration options\n- Handle connection setup\n\n### Observable Semantics\n- Cold observable (lazy creation)\n- Single emission then complete\n- Error propagation on failure\n\n## Acceptance Criteria\n- All RED tests now pass (GREEN phase)\n- Returns Observable of RxTransaction\n- Transaction properly initialized\n- Configuration applied correctly","status":"open","priority":2,"issue_type":"task","created_at":"2026-01-05T06:37:02.848295-06:00","updated_at":"2026-01-05T06:37:02.848295-06:00"}
{"id":"neo4j-k04","title":"RED: Managed Transaction Auto-Retry Tests","description":"## Overview\nWrite comprehensive failing tests for managed transaction auto-retry logic with exponential backoff.\n\n## Test Cases\n\n### Auto-Retry Tests\n```typescript\ndescribe('Managed Transaction Retry', () =\u003e {\n  it('should retry on TransientError')\n  it('should retry on ServiceUnavailable')\n  it('should retry on SessionExpired')\n  it('should retry on DeadlockDetected')\n  it('should not retry on ClientError')\n  it('should not retry on ConstraintViolation')\n  it('should not retry on AuthenticationError')\n  it('should respect maxTransactionRetryTime')\n  it('should use exponential backoff')\n  it('should jitter backoff to prevent thundering herd')\n})\n```\n\n### Retry Configuration Tests\n```typescript\ndescribe('Retry Configuration', () =\u003e {\n  it('should use driver maxTransactionRetryTime')\n  it('should override with session config')\n  it('should override with transaction config')\n  it('should default to 30 seconds')\n  it('should handle zero retry time (no retries)')\n})\n```\n\n### Exponential Backoff Tests\n```typescript\ndescribe('Exponential Backoff', () =\u003e {\n  it('should start with initial delay of 1 second')\n  it('should double delay on each retry')\n  it('should cap delay at max delay')\n  it('should add jitter within 20% range')\n  it('should stop retrying when time exceeded')\n})\n```\n\n### Work Function Tests\n```typescript\ndescribe('Transaction Work Function', () =\u003e {\n  it('should receive fresh transaction on each retry')\n  it('should rollback failed transaction before retry')\n  it('should preserve work function return value')\n  it('should propagate non-retryable errors immediately')\n  it('should clean up resources on final failure')\n})\n```\n\n### Error Classification Tests\n```typescript\ndescribe('Error Classification', () =\u003e {\n  it('should classify Neo4jError.TransientError as retryable')\n  it('should classify connection errors as retryable')\n  it('should classify timeout as retryable')\n  it('should classify syntax error as fatal')\n  it('should classify auth error as fatal')\n  it('should classify constraint error as fatal')\n})\n```\n\n## TDD Phase\n**RED** - All tests should fail initially.\n\n## Acceptance Criteria\n- [ ] All retry scenarios tested\n- [ ] Backoff algorithm verified\n- [ ] Error classification complete\n- [ ] Resource cleanup tested","status":"open","priority":1,"issue_type":"task","created_at":"2026-01-05T06:39:04.188086-06:00","updated_at":"2026-01-05T06:39:04.188086-06:00"}
{"id":"neo4j-k3e","title":"RED: CREATE/MERGE Translation","description":"## Overview\nWrite failing tests for CREATE and MERGE clause translation to INSERT statements.\n\n## Test Cases to Write\n\n### Test 1: CREATE Node\n- CREATE (n:Person {name: 'Alice'}) -\u003e INSERT into nodes\n\n### Test 2: CREATE Node with ID\n- Handle id generation (UUID or auto-increment)\n\n### Test 3: CREATE Relationship\n- CREATE (a)-[r:KNOWS]-\u003e(b) -\u003e INSERT into relationships\n\n### Test 4: CREATE with Existing Variables\n- Use existing node IDs from previous MATCH\n\n### Test 5: MERGE Node (Insert or Match)\n- MERGE (n:Person {name: 'Alice'}) -\u003e INSERT OR IGNORE + SELECT\n\n### Test 6: MERGE Relationship\n- Upsert pattern for relationships\n\n### Test 7: ON CREATE SET\n- SET properties only when creating new\n\n### Test 8: ON MATCH SET\n- SET properties only when matching existing\n\n### Test 9: CREATE Multiple Nodes\n- Batch insert optimization\n\n## Acceptance Criteria\n- All tests written and failing\n- MERGE upsert pattern correct\n- ON CREATE/ON MATCH handled\n\n## TDD Phase\nRED - Write failing tests first","status":"open","priority":1,"issue_type":"task","created_at":"2026-01-05T06:38:25.089482-06:00","updated_at":"2026-01-05T06:38:25.089482-06:00"}
{"id":"neo4j-kdy","title":"[RED] Lexer: Define Token Types and Basic Tokenization Tests","description":"## Overview\nWrite failing tests for the Cypher lexer's token type definitions and basic tokenization.\n\n## Test Cases to Write\n\n### Token Type Definitions\n- Test that all Cypher keywords are recognized (MATCH, CREATE, RETURN, WHERE, etc.)\n- Test identifier tokens (variable names, labels, property names)\n- Test operator tokens (+, -, *, /, =, \u003c\u003e, \u003c, \u003e, \u003c=, \u003e=, etc.)\n- Test punctuation tokens ((, ), [, ], {, }, :, ., ,, |, etc.)\n- Test special tokens (parameter $param, property access)\n\n### Basic Tokenization\n- Test tokenizing simple query: `MATCH (n) RETURN n`\n- Test tokenizing with whitespace preservation awareness\n- Test token position tracking (line, column)\n- Test token span tracking (start, end offsets)\n\n## Acceptance Criteria\n- [ ] All tests written and failing (RED phase)\n- [ ] Tests cover all token type categories\n- [ ] Tests include edge cases (empty input, single token)\n- [ ] Test file created at `src/parser/__tests__/lexer-tokens.test.ts`\n\n## TDD Phase: RED","status":"open","priority":1,"issue_type":"task","created_at":"2026-01-05T06:34:24.922099-06:00","updated_at":"2026-01-05T06:34:24.922099-06:00"}
{"id":"neo4j-krk","title":"RED: Write failing tests for rxTx.commit() method","description":"## Overview\nWrite failing tests for rxTx.commit() transaction commit method.\n\n## Test Cases to Write\n\n### Basic Commit Tests\n- commit() returns Observable of void\n- Changes persisted after commit\n- Transaction closed after commit\n- Bookmarks updated after commit\n\n### Observable Behavior Tests\n- Cold observable (commit on subscribe)\n- Completes on successful commit\n- Error emission on commit failure\n- Single emission semantics\n\n### State Tests\n- Transaction marked as closed after commit\n- Cannot run queries after commit\n- Cannot commit twice (error)\n- Cannot rollback after commit\n\n### Error Scenarios\n- Constraint violation during commit\n- Connection lost during commit\n- Timeout during commit\n\n## Acceptance Criteria\n- All tests written and failing (RED phase)\n- Tests verify commit behavior\n- Tests cover Observable semantics\n- Tests cover error scenarios","status":"open","priority":2,"issue_type":"task","created_at":"2026-01-05T06:39:08.718894-06:00","updated_at":"2026-01-05T06:39:08.718894-06:00"}
{"id":"neo4j-l2k","title":"[GREEN] ID Generation - Implement ID encoding and decoding to pass tests","description":"## Overview\nImplement ID generation system to make all tests pass.\n\n## Implementation Requirements\n\n### Element ID Format\nNeo4j element IDs follow this format: `\u003ctype\u003e:\u003cdatabase-uuid\u003e:\u003cinternal-id\u003e`\n- Type 4: Node\n- Type 5: Relationship\n\nExample: `4:c47f4a0a-9f8a-4e3c-b5d4-123456789abc:42`\n\n### ID Generator Class\n```typescript\nconst ELEMENT_ID_REGEX = /^([45]):([a-f0-9-]+):(\\d+)$/;\n\nclass IdGenerator {\n  constructor(private databaseUuid: string) {}\n\n  encodeNodeId(internalId: number): string {\n    return `4:${this.databaseUuid}:${internalId}`;\n  }\n\n  encodeRelationshipId(internalId: number): string {\n    return `5:${this.databaseUuid}:${internalId}`;\n  }\n\n  decodeElementId(elementId: string): {\n    type: 'node' | 'relationship';\n    databaseUuid: string;\n    internalId: number;\n  } {\n    const match = elementId.match(ELEMENT_ID_REGEX);\n    if (\\!match) {\n      throw new Error('Invalid element ID format');\n    }\n    \n    const [, typeCode, uuid, id] = match;\n    return {\n      type: typeCode === '4' ? 'node' : 'relationship',\n      databaseUuid: uuid,\n      internalId: parseInt(id, 10)\n    };\n  }\n\n  extractInternalId(elementId: string): number {\n    return this.decodeElementId(elementId).internalId;\n  }\n\n  validateElementId(elementId: string): boolean {\n    try {\n      const decoded = this.decodeElementId(elementId);\n      return decoded.databaseUuid === this.databaseUuid;\n    } catch {\n      return false;\n    }\n  }\n}\n```\n\n### Database UUID Generation\n```typescript\n// Generate once per Durable Object and store\nasync function getOrCreateDatabaseUuid(storage: DurableObjectStorage): Promise\u003cstring\u003e {\n  let uuid = await storage.get\u003cstring\u003e('database_uuid');\n  if (\\!uuid) {\n    uuid = crypto.randomUUID();\n    await storage.put('database_uuid', uuid);\n  }\n  return uuid;\n}\n```\n\n## Files to Create\n- `src/storage/id-generator.ts`\n\n## Acceptance Criteria\n- [ ] All RED phase tests pass\n- [ ] Element ID format matches Neo4j\n- [ ] Encoding/decoding works correctly\n- [ ] UUID persists across restarts\n\n## TDD Phase\n**GREEN** - Minimum code to pass tests","status":"open","priority":1,"issue_type":"task","created_at":"2026-01-05T06:38:40.292107-06:00","updated_at":"2026-01-05T06:38:40.292107-06:00"}
{"id":"neo4j-l41","title":"[RED] Neo4j Driver API Surface Comparison Tests","description":"# [RED] Neo4j Driver API Surface Comparison Tests\n\n## Overview\nCreate tests that verify neo4j.do exposes the same API surface as the official neo4j-driver package.\n\n## Test Strategy\nRun the same test code against both neo4j-driver and neo4j.do to ensure API compatibility.\n\n## API Surface to Test\n\n### Driver Level\n```typescript\ndescribe('Driver API Surface', () =\u003e {\n  it('should export driver function', () =\u003e {\n    expect(typeof driver).toBe('function')\n  })\n\n  it('should create driver with URI and auth', () =\u003e {\n    const d = driver('bolt://localhost', auth.basic('user', 'pass'))\n    expect(d).toBeDefined()\n    expect(typeof d.session).toBe('function')\n    expect(typeof d.close).toBe('function')\n  })\n\n  it('should support all auth methods', () =\u003e {\n    expect(typeof auth.basic).toBe('function')\n    expect(typeof auth.bearer).toBe('function')\n    expect(typeof auth.kerberos).toBe('function')\n    expect(typeof auth.custom).toBe('function')\n  })\n})\n```\n\n### Session Level\n```typescript\ndescribe('Session API Surface', () =\u003e {\n  it('should have run method', () =\u003e {\n    const session = driver.session()\n    expect(typeof session.run).toBe('function')\n  })\n\n  it('should have transaction methods', () =\u003e {\n    const session = driver.session()\n    expect(typeof session.beginTransaction).toBe('function')\n    expect(typeof session.readTransaction).toBe('function')\n    expect(typeof session.writeTransaction).toBe('function')\n    expect(typeof session.executeRead).toBe('function')\n    expect(typeof session.executeWrite).toBe('function')\n  })\n\n  it('should support session config', () =\u003e {\n    const session = driver.session({\n      database: 'neo4j',\n      defaultAccessMode: 'READ',\n      bookmarks: []\n    })\n    expect(session).toBeDefined()\n  })\n})\n```\n\n### Result Level\n```typescript\ndescribe('Result API Surface', () =\u003e {\n  it('should return Result from run', async () =\u003e {\n    const result = await session.run('RETURN 1')\n    expect(result.records).toBeDefined()\n    expect(result.summary).toBeDefined()\n  })\n\n  it('should support streaming', async () =\u003e {\n    const result = session.run('RETURN 1')\n    const records = []\n    for await (const record of result) {\n      records.push(record)\n    }\n    expect(records.length).toBeGreaterThan(0)\n  })\n})\n```\n\n## Test File Structure\n```\ntests/compatibility/\n├── api-surface.test.ts\n├── driver-api.test.ts\n├── session-api.test.ts\n├── result-api.test.ts\n├── types-api.test.ts\n└── helpers/\n    └── dual-driver.ts  # Helper to run tests against both drivers\n```\n\n## Acceptance Criteria\n- [ ] Tests written for all public API methods\n- [ ] Tests fail initially (RED phase)\n- [ ] Test helper created for dual-driver testing\n- [ ] API coverage documented","status":"open","priority":2,"issue_type":"task","created_at":"2026-01-05T06:37:02.476773-06:00","updated_at":"2026-01-05T06:37:02.476773-06:00"}
{"id":"neo4j-lhv","title":"RED: AI Functions in Cypher - Write failing tests for AI-powered functions","description":"## Overview\nWrite failing tests for AI-powered functions integrated into Cypher queries.\n\n## Test Cases\n\n```typescript\ndescribe('AI Functions in Cypher', () =\u003e {\n  describe('$ai.embed()', () =\u003e {\n    it('should generate embedding for text', async () =\u003e {\n      const result = await session.run(\n        'RETURN $ai.embed(\"Hello world\") as embedding'\n      );\n      \n      const embedding = result.records[0].get('embedding');\n      expect(Array.isArray(embedding)).toBe(true);\n      expect(embedding).toHaveLength(1024); // BGE-M3 dimension\n      expect(embedding.every(v =\u003e typeof v === 'number')).toBe(true);\n    });\n\n    it('should embed with custom model', async () =\u003e {\n      const result = await session.run(\n        'RETURN $ai.embed(\"Hello\", { model: \"@cf/baai/bge-small-en-v1.5\" }) as embedding'\n      );\n      \n      expect(result.records[0].get('embedding')).toHaveLength(384);\n    });\n\n    it('should use embedding in WHERE clause for similarity', async () =\u003e {\n      await session.run('CREATE (:Doc {text: \"Graph databases are powerful\", embedding: $e})', \n        { e: graphEmbedding });\n      \n      const result = await session.run(`\n        MATCH (d:Doc)\n        WHERE $ai.similarity(d.embedding, $ai.embed(\"database technology\")) \u003e 0.7\n        RETURN d.text\n      `);\n      \n      expect(result.records.length).toBeGreaterThan(0);\n    });\n  });\n\n  describe('$ai.generate()', () =\u003e {\n    it('should generate text from prompt', async () =\u003e {\n      const result = await session.run(\n        'RETURN $ai.generate(\"What is a graph database? Answer in one sentence.\") as response'\n      );\n      \n      const response = result.records[0].get('response');\n      expect(typeof response).toBe('string');\n      expect(response.length).toBeGreaterThan(10);\n    });\n\n    it('should generate with context from query', async () =\u003e {\n      const result = await session.run(`\n        MATCH (p:Person)-[:WORKS_AT]-\u003e(c:Company)\n        WITH collect(p.name + \" works at \" + c.name) as facts\n        RETURN $ai.generate(\"Summarize these employment relationships: \" + facts) as summary\n      `);\n      \n      expect(result.records[0].get('summary')).toBeDefined();\n    });\n\n    it('should support model configuration', async () =\u003e {\n      const result = await session.run(\n        'RETURN $ai.generate(\"Hello\", { model: \"@cf/meta/llama-3-8b-instruct\", maxTokens: 50 }) as response'\n      );\n      \n      expect(result.records[0].get('response')).toBeDefined();\n    });\n  });\n\n  describe('$ai.classify()', () =\u003e {\n    it('should classify text into categories', async () =\u003e {\n      const result = await session.run(\n        'RETURN $ai.classify(\"This product is amazing!\", [\"positive\", \"negative\", \"neutral\"]) as classification'\n      );\n      \n      const classification = result.records[0].get('classification');\n      expect(classification.label).toBe('positive');\n      expect(classification.score).toBeGreaterThan(0.5);\n    });\n\n    it('should classify node properties', async () =\u003e {\n      await session.run('CREATE (:Review {text: \"Terrible experience, would not recommend\"})');\n      \n      const result = await session.run(`\n        MATCH (r:Review)\n        RETURN r.text, $ai.classify(r.text, [\"positive\", \"negative\"]) as sentiment\n      `);\n      \n      expect(result.records[0].get('sentiment').label).toBe('negative');\n    });\n\n    it('should support batch classification', async () =\u003e {\n      const result = await session.run(`\n        MATCH (r:Review)\n        RETURN r.text, $ai.classify(r.text, [\"positive\", \"negative\"]) as sentiment\n        LIMIT 100\n      `);\n      \n      // Should batch API calls for efficiency\n    });\n  });\n\n  describe('$ai.extract()', () =\u003e {\n    it('should extract structured data from text', async () =\u003e {\n      const result = await session.run(`\n        RETURN $ai.extract(\n          \"John Smith (john@example.com) is the CEO of Acme Corp. He can be reached at 555-1234.\",\n          { name: \"string\", email: \"string\", company: \"string\", phone: \"string\", role: \"string\" }\n        ) as extracted\n      `);\n      \n      const extracted = result.records[0].get('extracted');\n      expect(extracted.name).toBe('John Smith');\n      expect(extracted.email).toBe('john@example.com');\n      expect(extracted.company).toBe('Acme Corp');\n    });\n\n    it('should extract and create nodes', async () =\u003e {\n      const result = await session.run(`\n        WITH \"Alice works at TechCo as an Engineer\" as text\n        WITH $ai.extract(text, { name: \"string\", company: \"string\", role: \"string\" }) as data\n        CREATE (p:Person {name: data.name})\n        CREATE (c:Company {name: data.company})\n        CREATE (p)-[:WORKS_AT {role: data.role}]-\u003e(c)\n        RETURN p, c\n      `);\n      \n      expect(result.records[0].get('p').properties.name).toBe('Alice');\n    });\n\n    it('should handle extraction from multiple nodes', async () =\u003e {\n      const result = await session.run(`\n        MATCH (e:Email)\n        RETURN e.subject, $ai.extract(e.body, { \n          action_items: \"string[]\",\n          mentioned_people: \"string[]\",\n          deadline: \"string?\"\n        }) as extracted\n      `);\n    });\n  });\n\n  describe('$ai.similarity()', () =\u003e {\n    it('should compute cosine similarity between vectors', async () =\u003e {\n      const result = await session.run(\n        'RETURN $ai.similarity([1,0,0], [1,0,0]) as score'\n      );\n      expect(result.records[0].get('score')).toBe(1.0);\n    });\n\n    it('should compute similarity between embeddings', async () =\u003e {\n      const result = await session.run(`\n        RETURN $ai.similarity(\n          $ai.embed(\"dog\"),\n          $ai.embed(\"puppy\")\n        ) as score\n      `);\n      \n      expect(result.records[0].get('score')).toBeGreaterThan(0.7);\n    });\n  });\n\n  describe('Error Handling', () =\u003e {\n    it('should handle rate limiting gracefully', async () =\u003e {\n      // Test rate limit behavior\n    });\n\n    it('should provide meaningful errors for invalid inputs', async () =\u003e {\n      await expect(session.run(\n        'RETURN $ai.classify(\"text\", []) as result'\n      )).rejects.toThrow(/categories cannot be empty/);\n    });\n\n    it('should timeout long-running AI calls', async () =\u003e {\n      // Test timeout behavior\n    });\n  });\n});\n```\n\n## Acceptance Criteria\n- [ ] All test cases written and failing\n- [ ] Mock Workers AI infrastructure\n- [ ] Test fixtures for various AI scenarios\n\n## Tags\nsuperset, ai-functions, workers-ai, cypher, tdd-red","status":"open","priority":2,"issue_type":"task","created_at":"2026-01-05T06:38:33.06851-06:00","updated_at":"2026-01-05T06:38:33.06851-06:00"}
{"id":"neo4j-lo8","title":"[REFACTOR] Lexer: Optimize Token Types and Tokenization","description":"## Overview\nRefactor the lexer implementation for performance and maintainability.\n\n## Refactoring Tasks\n\n### Performance Optimizations\n- Use lookup tables for keyword recognition instead of switch/if-else chains\n- Implement lazy tokenization (generator/iterator pattern)\n- Consider string interning for common tokens\n- Benchmark and optimize hot paths\n\n### Code Quality\n- Extract token matchers into composable functions\n- Add comprehensive JSDoc documentation\n- Ensure consistent error handling\n- Add debug mode for token stream inspection\n\n### Type Safety\n- Narrow token types for better TypeScript inference\n- Create branded types for different identifier categories\n- Add type guards for token type checking\n\n## Acceptance Criteria\n- [ ] All tests still pass\n- [ ] Performance improved or maintained\n- [ ] Code is well-documented\n- [ ] No code duplication\n\n## TDD Phase: REFACTOR\n## Depends On: neo4j-nzr","status":"open","priority":1,"issue_type":"task","created_at":"2026-01-05T06:34:57.338424-06:00","updated_at":"2026-01-05T06:34:57.338424-06:00"}
{"id":"neo4j-lpm","title":"RED: Write failing tests for rxSession.run() returning RxResult","description":"## Overview\nWrite failing tests for `rxSession.run()` method that executes Cypher queries and returns RxResult.\n\n## Test Cases to Write\n\n### Basic Execution Tests\n- `rxSession.run(cypher)` returns RxResult\n- `rxSession.run(cypher, params)` accepts parameters\n- Returns Observable-based result\n- Query is not executed until subscribed (cold observable)\n\n### Parameter Tests\n- Handles string parameters\n- Handles number parameters\n- Handles boolean parameters\n- Handles array parameters\n- Handles object/map parameters\n- Handles null parameters\n- Handles Date parameters\n\n### Observable Behavior Tests\n- Result is cold observable (lazy execution)\n- Multiple subscriptions create multiple executions\n- Unsubscription cancels pending query\n- Proper completion signaling\n\n### Error Tests\n- Invalid Cypher syntax emits error\n- Connection errors propagate to subscriber\n- Parameter type errors handled appropriately\n\n## Acceptance Criteria\n- [ ] All tests written and failing (RED phase)\n- [ ] Tests verify RxResult interface\n- [ ] Tests verify Observable semantics\n- [ ] Tests cover parameter handling","status":"open","priority":2,"issue_type":"task","created_at":"2026-01-05T06:35:05.039547-06:00","updated_at":"2026-01-05T06:35:05.039547-06:00"}
{"id":"neo4j-lps","title":"GREEN: Session Bookmarks \u0026 Lifecycle Implementation","description":"## Overview\nImplement Session bookmarks, causal consistency, and lifecycle management to pass all RED phase tests.\n\n## Implementation Requirements\n\n### Bookmark Management\n```typescript\nclass Session {\n  private bookmarks: string[] = []\n  private lastBookmark_: string | null = null\n\n  lastBookmark(): string | null {\n    return this.lastBookmark_\n  }\n\n  lastBookmarks(): string[] {\n    return [...this.bookmarks]\n  }\n\n  // Internal method to update bookmarks after write\n  _updateBookmarks(newBookmark: string): void {\n    this.lastBookmark_ = newBookmark\n    this.bookmarks = [newBookmark]\n  }\n}\n```\n\n### Bookmark Format\n```typescript\ninterface Bookmark {\n  database: string\n  txId: number\n  timestamp: number\n}\n\nfunction generateBookmark(database: string, txId: number): string {\n  // Format: neo4j:bookmark:v1:tx{txId}\n  return `neo4j:bookmark:v1:tx${txId}`\n}\n\nfunction parseBookmark(bookmark: string): Bookmark | null {\n  // Parse and validate bookmark format\n}\n```\n\n### Session Lifecycle\n```typescript\nclass Session {\n  async close(): Promise\u003cvoid\u003e {\n    if (this.closed) return\n    \n    // Rollback any open transaction\n    if (this.currentTransaction?.isOpen()) {\n      await this.currentTransaction.rollback()\n    }\n    \n    // Wait for in-flight queries\n    await this.waitForQueries()\n    \n    this.closed = true\n    this.driver._removeSession(this)\n  }\n\n  private ensureOpen(): void {\n    if (this.closed) {\n      throw new SessionExpired('Session has been closed')\n    }\n  }\n}\n```\n\n### Causal Consistency\n```typescript\n// When creating session with bookmarks\nprivate async waitForBookmarks(): Promise\u003cvoid\u003e {\n  if (this.config.bookmarks?.length) {\n    // Verify bookmarks are reachable\n    // This ensures causal consistency\n  }\n}\n```\n\n## Files to Create/Modify\n- `src/session/session.ts`\n- `src/session/bookmarks.ts`\n- `src/session/types.ts`\n- `src/errors/session-expired.ts`\n\n## TDD Phase\n**GREEN** - Implement to pass tests.\n\n## Dependencies\n- Depends on: RED: Session Bookmarks \u0026 Lifecycle Tests\n- Depends on: GREEN: Session Class Query Execution Implementation\n\n## Acceptance Criteria\n- [ ] All RED phase tests pass\n- [ ] Bookmarks correctly track transaction history\n- [ ] Causal consistency maintained\n- [ ] Clean session lifecycle","status":"open","priority":1,"issue_type":"task","created_at":"2026-01-05T06:37:33.462955-06:00","updated_at":"2026-01-05T06:37:33.462955-06:00"}
{"id":"neo4j-m20","title":"[GREEN] In-Memory Graph - Implement storage structures to pass tests","description":"## Overview\nImplement in-memory graph storage to make all tests pass.\n\n## Implementation Requirements\n\n### Core Data Structures\n```typescript\ninterface InMemoryGraph {\n  nodes: Map\u003cnumber, Node\u003e;\n  relationships: Map\u003cnumber, Relationship\u003e;\n  \n  // Adjacency lists\n  outgoing: Map\u003cnumber, Set\u003cnumber\u003e\u003e; // nodeId -\u003e relationshipIds\n  incoming: Map\u003cnumber, Set\u003cnumber\u003e\u003e; // nodeId -\u003e relationshipIds\n  \n  // Indexes\n  labelIndex: Map\u003cstring, Set\u003cnumber\u003e\u003e; // label -\u003e nodeIds\n  typeIndex: Map\u003cstring, Set\u003cnumber\u003e\u003e;  // type -\u003e relationshipIds\n}\n```\n\n### Node Operations\n```typescript\nclass InMemoryNodeStore {\n  private nodes = new Map\u003cnumber, Node\u003e();\n  private labelIndex = new Map\u003cstring, Set\u003cnumber\u003e\u003e();\n  \n  create(labels: string[], properties: object): Node;\n  get(id: number): Node | null;\n  update(id: number, properties: object): void;\n  delete(id: number): boolean;\n  getByLabel(label: string): Node[];\n}\n```\n\n### Relationship Operations\n```typescript\nclass InMemoryRelationshipStore {\n  private relationships = new Map\u003cnumber, Relationship\u003e();\n  private typeIndex = new Map\u003cstring, Set\u003cnumber\u003e\u003e();\n  private outgoing = new Map\u003cnumber, Set\u003cnumber\u003e\u003e();\n  private incoming = new Map\u003cnumber, Set\u003cnumber\u003e\u003e();\n  \n  create(type: string, startId: number, endId: number, properties: object): Relationship;\n  get(id: number): Relationship | null;\n  getByType(type: string): Relationship[];\n  getForNode(nodeId: number, direction: 'in' | 'out' | 'both'): Relationship[];\n}\n```\n\n## Files to Create\n- `src/storage/memory/graph.ts`\n- `src/storage/memory/node-store.ts`\n- `src/storage/memory/relationship-store.ts`\n- `src/storage/memory/indexes.ts`\n\n## Acceptance Criteria\n- [ ] All RED phase tests pass\n- [ ] O(1) node/relationship lookup\n- [ ] Indexes maintained automatically\n- [ ] Memory-efficient implementation\n\n## TDD Phase\n**GREEN** - Minimum code to pass tests","status":"open","priority":1,"issue_type":"task","created_at":"2026-01-05T06:35:25.543649-06:00","updated_at":"2026-01-05T06:35:25.543649-06:00"}
{"id":"neo4j-m40","title":"REFACTOR: Session Class Query Execution Optimization","description":"## Overview\nRefactor Session class query execution for performance, reliability, and edge cases.\n\n## Refactoring Goals\n\n### Performance Optimizations\n- Query result streaming\n- Batch parameter processing\n- Connection pooling integration\n- Result caching for repeated queries\n\n### Reliability Improvements\n- Better error classification\n- Improved retry strategies\n- Deadlock detection\n- Query timeout handling\n\n### Edge Cases\n```typescript\ndescribe('Session Query Edge Cases', () =\u003e {\n  it('should handle very long queries')\n  it('should handle many parameters')\n  it('should handle concurrent runs')\n  it('should handle run during executeRead')\n  it('should handle session timeout during query')\n  it('should handle result consumption after session close')\n  it('should handle streaming large results')\n  it('should handle queries returning no columns')\n  it('should handle queries with null parameters')\n})\n```\n\n### Code Quality\n- Extract retry logic into separate component\n- Create query builder for internal queries\n- Add query logging middleware\n- Improve error messages with query context\n\n## TDD Phase\n**REFACTOR** - Improve without breaking tests.\n\n## Dependencies\n- Depends on: GREEN: Session Class Query Execution Implementation\n\n## Acceptance Criteria\n- [ ] All tests pass\n- [ ] Performance benchmarks improved\n- [ ] Edge cases handled gracefully\n- [ ] Code is maintainable","status":"open","priority":2,"issue_type":"task","created_at":"2026-01-05T06:36:53.210323-06:00","updated_at":"2026-01-05T06:36:53.210323-06:00"}
{"id":"neo4j-mga","title":"RED: Auto Vector Embeddings - Write failing tests for automatic embedding generation","description":"## Overview\nWrite failing tests for automatic vector embedding generation on node/relationship creation.\n\n## Test Cases\n\n### Embedding Generation Tests\n```typescript\ndescribe('Auto Vector Embeddings', () =\u003e {\n  describe('Node Creation Embedding', () =\u003e {\n    it('should auto-generate embedding when node has configured text field', async () =\u003e {\n      // Configure embedding for Person.bio field\n      await session.run('CALL db.index.vector.create(\"person_bio\", \"Person\", \"bioEmbedding\", 1024, \"cosine\")');\n      await session.run('CALL db.index.vector.configure(\"person_bio\", { sourceField: \"bio\", model: \"@cf/baai/bge-m3\" })');\n      \n      const result = await session.run(\n        'CREATE (p:Person {name: \"Alice\", bio: \"Software engineer passionate about graphs\"}) RETURN p'\n      );\n      \n      const node = result.records[0].get('p');\n      expect(node.properties.bioEmbedding).toBeDefined();\n      expect(node.properties.bioEmbedding).toHaveLength(1024);\n    });\n\n    it('should not generate embedding when source field is missing', async () =\u003e {\n      const result = await session.run(\n        'CREATE (p:Person {name: \"Bob\"}) RETURN p'\n      );\n      expect(result.records[0].get('p').properties.bioEmbedding).toBeUndefined();\n    });\n\n    it('should regenerate embedding when source field is updated', async () =\u003e {\n      const create = await session.run(\n        'CREATE (p:Person {name: \"Carol\", bio: \"Original bio\"}) RETURN p, id(p) as id'\n      );\n      const originalEmbedding = create.records[0].get('p').properties.bioEmbedding;\n      \n      await session.run(\n        'MATCH (p:Person {name: \"Carol\"}) SET p.bio = \"Updated bio about data science\" RETURN p'\n      );\n      \n      const updated = await session.run('MATCH (p:Person {name: \"Carol\"}) RETURN p');\n      const newEmbedding = updated.records[0].get('p').properties.bioEmbedding;\n      \n      expect(newEmbedding).not.toEqual(originalEmbedding);\n    });\n  });\n\n  describe('Configurable Embedding Fields', () =\u003e {\n    it('should support multiple embedding fields per label', async () =\u003e {\n      await session.run('CALL db.index.vector.configure(\"article_title\", { sourceField: \"title\", targetField: \"titleEmbedding\" })');\n      await session.run('CALL db.index.vector.configure(\"article_content\", { sourceField: \"content\", targetField: \"contentEmbedding\" })');\n      \n      const result = await session.run(\n        'CREATE (a:Article {title: \"Graph Databases\", content: \"Long article content...\"}) RETURN a'\n      );\n      \n      const node = result.records[0].get('a');\n      expect(node.properties.titleEmbedding).toBeDefined();\n      expect(node.properties.contentEmbedding).toBeDefined();\n    });\n\n    it('should support composite field embedding', async () =\u003e {\n      await session.run('CALL db.index.vector.configure(\"person_full\", { sourceFields: [\"name\", \"bio\", \"skills\"], separator: \" | \" })');\n      \n      const result = await session.run(\n        'CREATE (p:Person {name: \"Dan\", bio: \"Engineer\", skills: \"TypeScript, Neo4j\"}) RETURN p'\n      );\n      \n      expect(result.records[0].get('p').properties.fullEmbedding).toBeDefined();\n    });\n  });\n\n  describe('Workers AI Integration', () =\u003e {\n    it('should use configured embedding model', async () =\u003e {\n      await session.run('CALL db.index.vector.configure(\"test\", { model: \"@cf/baai/bge-m3\" })');\n      // Verify model is called with correct parameters\n    });\n\n    it('should handle rate limiting gracefully', async () =\u003e {\n      // Simulate rate limit scenario\n    });\n\n    it('should retry on transient failures', async () =\u003e {\n      // Verify retry logic\n    });\n  });\n\n  describe('Batch Embedding', () =\u003e {\n    it('should batch embed multiple nodes efficiently', async () =\u003e {\n      const nodes = Array.from({ length: 100 }, (_, i) =\u003e \n        `CREATE (:Article {title: \"Article ${i}\", content: \"Content ${i}\"})`\n      ).join(' ');\n      \n      const start = Date.now();\n      await session.run(nodes);\n      const duration = Date.now() - start;\n      \n      // Should batch API calls, not 100 individual calls\n      expect(duration).toBeLessThan(5000);\n    });\n\n    it('should support bulk import with embeddings', async () =\u003e {\n      await session.run('CALL db.embeddings.bulkGenerate(\"Person\", \"bio\", { batchSize: 50 })');\n      \n      const result = await session.run('MATCH (p:Person) WHERE p.bioEmbedding IS NULL RETURN count(p) as missing');\n      expect(result.records[0].get('missing').toNumber()).toBe(0);\n    });\n  });\n\n  describe('Relationship Embeddings', () =\u003e {\n    it('should auto-embed relationship properties', async () =\u003e {\n      await session.run('CALL db.index.vector.configure(\"review_text\", { type: \"relationship\", relType: \"REVIEWED\", sourceField: \"text\" })');\n      \n      const result = await session.run(\n        'CREATE (u:User)-[r:REVIEWED {text: \"Great product\\!\"}]-\u003e(p:Product) RETURN r'\n      );\n      \n      expect(result.records[0].get('r').properties.textEmbedding).toBeDefined();\n    });\n  });\n});\n```\n\n## Acceptance Criteria\n- [ ] All test cases written and failing\n- [ ] Test infrastructure for mocking Workers AI\n- [ ] Test fixtures for various embedding scenarios\n- [ ] Performance benchmarks defined\n\n## Dependencies\n- Workers AI binding setup\n- Vector storage schema\n\n## Tags\nsuperset, embeddings, workers-ai, tdd-red","status":"open","priority":2,"issue_type":"task","created_at":"2026-01-05T06:34:42.604016-06:00","updated_at":"2026-01-05T06:34:42.604016-06:00"}
{"id":"neo4j-mkq","title":"GREEN: Implement rxSession.lastBookmarks() method","description":"## Overview\nImplement rxSession.lastBookmarks() to make all RED tests pass.\n\n## Implementation Requirements\n\n### Method Signature\n```typescript\ninterface RxSession {\n  lastBookmarks(): string[]\n}\n```\n\n### Implementation Details\n- Return current session bookmarks\n- Track bookmark updates from transactions\n- Initialize from session config\n- Synchronous access to current state\n\n### Bookmark Management\n- Update bookmarks on transaction commit\n- Preserve bookmarks on rollback\n- Handle multiple bookmark sources\n\n## Acceptance Criteria\n- All RED tests now pass (GREEN phase)\n- Returns correct bookmark array\n- Bookmarks properly tracked\n- Synchronous access works","status":"open","priority":2,"issue_type":"task","created_at":"2026-01-05T06:37:34.340573-06:00","updated_at":"2026-01-05T06:37:34.340573-06:00"}
{"id":"neo4j-mmc","title":"REFACTOR: Pattern to JOIN Translation - Relationship Patterns","description":"## Overview\nRefactor relationship pattern translation for maintainability.\n\n## Refactoring Tasks\n\n### 1. Unified Pattern Visitor\n```typescript\ninterface PatternVisitor\u003cT\u003e {\n  visitNodePattern(node: NodePattern): T;\n  visitRelationshipPattern(rel: RelationshipPattern): T;\n  visitPathPattern(path: PathPattern): T;\n}\n\nclass SQLPatternVisitor implements PatternVisitor\u003cSQLFragment\u003e { }\n```\n\n### 2. JOIN Builder Abstraction\n```typescript\nclass JoinBuilder {\n  innerJoin(table: string, alias: string): JoinClause;\n  leftJoin(table: string, alias: string): JoinClause;\n  on(condition: string): this;\n  build(): string;\n}\n```\n\n### 3. Direction Strategy\n```typescript\ninterface DirectionStrategy {\n  getStartNodeColumn(): string;\n  getEndNodeColumn(): string;\n  needsBidirectional(): boolean;\n}\n```\n\n### 4. Optimize Generated SQL\n- Reduce unnecessary parentheses\n- Use table aliases consistently\n- Minimize subqueries where possible\n\n## Quality Improvements\n- [ ] Consistent visitor pattern throughout\n- [ ] Reusable JOIN builder\n- [ ] Clean separation of concerns\n- [ ] Comprehensive type definitions\n\n## Acceptance Criteria\n- [ ] All tests still pass\n- [ ] Code is more readable and maintainable\n- [ ] Performance not degraded\n\n## TDD Phase\nREFACTOR - Improve code quality while keeping tests green\n\n## Dependencies\n- Depends on: GREEN: Pattern to JOIN Translation - Relationship Patterns","status":"open","priority":1,"issue_type":"task","created_at":"2026-01-05T06:35:55.956703-06:00","updated_at":"2026-01-05T06:35:55.956703-06:00"}
{"id":"neo4j-mnp","title":"GREEN: Full-Text Search - Implement FTS5 procedures","description":"## Overview\nImplement full-text search using SQLite FTS5 to make all RED tests pass.\n\n## Implementation Requirements\n\n### Core Components\n\n#### 1. FTS5 Schema Management\n```sql\n-- FTS5 virtual table per index\nCREATE VIRTUAL TABLE fts_{indexName} USING fts5(\n  entity_id,\n  {columns...},\n  content='',  -- External content mode\n  tokenize='porter unicode61'\n);\n\n-- Index metadata\nCREATE TABLE fulltext_indexes (\n  id TEXT PRIMARY KEY,\n  name TEXT NOT NULL UNIQUE,\n  entity_type TEXT NOT NULL CHECK (entity_type IN ('node', 'relationship')),\n  labels TEXT,  -- JSON array for nodes\n  rel_types TEXT,  -- JSON array for relationships  \n  properties TEXT NOT NULL,  -- JSON array of indexed properties\n  tokenizer TEXT DEFAULT 'porter unicode61',\n  created_at TEXT DEFAULT (datetime('now'))\n);\n\n-- Triggers for auto-indexing\nCREATE TRIGGER fts_{indexName}_insert AFTER INSERT ON nodes\nWHEN NEW.labels LIKE '%{label}%'\nBEGIN\n  INSERT INTO fts_{indexName}(entity_id, {columns}) \n  VALUES (NEW.id, {property_extractions});\nEND;\n```\n\n#### 2. Fulltext Index Manager\n```typescript\ninterface FulltextIndexConfig {\n  name: string;\n  entityType: 'node' | 'relationship';\n  labels?: string[];\n  relTypes?: string[];\n  properties: string[];\n  tokenizer?: 'porter' | 'unicode61' | 'trigram';\n}\n\nclass FulltextIndexManager {\n  async createIndex(config: FulltextIndexConfig): Promise\u003cvoid\u003e;\n  async dropIndex(name: string): Promise\u003cvoid\u003e;\n  async listIndexes(): Promise\u003cFulltextIndexConfig[]\u003e;\n  async rebuildIndex(name: string): Promise\u003cvoid\u003e;\n}\n```\n\n#### 3. Fulltext Search Service\n```typescript\ninterface FulltextSearchOptions {\n  limit?: number;\n  offset?: number;\n  highlight?: boolean;\n  snippetLength?: number;\n}\n\ninterface FulltextSearchResult {\n  entityId: string;\n  score: number;\n  highlights?: Record\u003cstring, string\u003e;\n}\n\nclass FulltextSearchService {\n  async queryNodes(\n    indexName: string,\n    query: string,\n    options?: FulltextSearchOptions\n  ): Promise\u003cFulltextSearchResult[]\u003e;\n\n  async queryRelationships(\n    indexName: string,\n    query: string,\n    options?: FulltextSearchOptions\n  ): Promise\u003cFulltextSearchResult[]\u003e;\n}\n```\n\n#### 4. Query Parser\n```typescript\nclass FTS5QueryParser {\n  // Convert user-friendly syntax to FTS5 syntax\n  parse(query: string): string;\n  \n  // Handle:\n  // - Phrase search: \"exact phrase\"\n  // - Boolean: AND, OR, NOT\n  // - Prefix: word*\n  // - Fuzzy: word~ (convert to NEAR or similar)\n  // - Field-specific: title:word\n}\n```\n\n### Procedures to Implement\n```typescript\n// db.index.fulltext.create\nasync function createFulltextIndex(\n  indexName: string,\n  labels: string[],\n  properties: string[],\n  options?: { entityType?: string; relTypes?: string[] }\n): Promise\u003cvoid\u003e;\n\n// db.index.fulltext.drop\nasync function dropFulltextIndex(indexName: string): Promise\u003cvoid\u003e;\n\n// db.index.fulltext.list\nasync function* listFulltextIndexes(): AsyncGenerator\u003cFulltextIndexInfo\u003e;\n\n// db.index.fulltext.queryNodes\nasync function* queryNodes(\n  indexName: string,\n  query: string\n): AsyncGenerator\u003c{ node: Node; score: number }\u003e;\n\n// db.index.fulltext.queryRelationships  \nasync function* queryRelationships(\n  indexName: string,\n  query: string\n): AsyncGenerator\u003c{ relationship: Relationship; score: number }\u003e;\n```\n\n### FTS5 Features to Support\n- BM25 ranking (default in FTS5)\n- Porter stemming\n- Unicode tokenization\n- Phrase queries\n- Boolean operators (AND, OR, NOT)\n- Prefix queries (word*)\n- Column filtering\n- Highlight/snippet functions\n\n## Acceptance Criteria\n- [ ] All RED phase tests passing\n- [ ] FTS5 indexes created correctly\n- [ ] Auto-indexing on node/relationship changes\n- [ ] Relevance scoring working\n- [ ] Fuzzy matching via trigram fallback\n\n## Dependencies\n- RED: Full-Text Search tests\n- D1 database binding\n\n## Tags\nsuperset, fulltext-search, fts5, sqlite, tdd-green","status":"open","priority":2,"issue_type":"task","created_at":"2026-01-05T06:37:40.400323-06:00","updated_at":"2026-01-05T06:37:40.400323-06:00"}
{"id":"neo4j-n0r","title":"REFACTOR: Clean up driver.rxSession() factory implementation","description":"## Overview\nRefactor the `driver.rxSession()` factory implementation for better code quality.\n\n## Refactoring Tasks\n\n### Code Quality\n- Extract common session creation logic\n- Ensure consistent config handling with sync sessions\n- Add proper TypeScript types and generics\n- Improve error messages\n\n### Documentation\n- Add JSDoc comments\n- Document config options\n- Add usage examples in comments\n\n### Performance\n- Optimize instance creation\n- Consider lazy initialization patterns\n- Review memory allocation\n\n## Acceptance Criteria\n- [ ] All tests still pass after refactoring\n- [ ] Code follows project style guidelines\n- [ ] No code duplication with sync session factory\n- [ ] Clear separation of concerns","status":"open","priority":2,"issue_type":"task","created_at":"2026-01-05T06:34:45.912732-06:00","updated_at":"2026-01-05T06:34:45.912732-06:00"}
{"id":"neo4j-n3u","title":"GREEN: Session Class Query Execution Implementation","description":"## Overview\nImplement Session class query execution methods to pass all RED phase tests.\n\n## Implementation Requirements\n\n### Session Class\n```typescript\nclass Session {\n  private driver: Driver\n  private config: SessionConfig\n  private currentTransaction: Transaction | null = null\n  private lastBookmarks: string[] = []\n  private closed: boolean = false\n\n  constructor(driver: Driver, config?: SessionConfig) {\n    this.driver = driver\n    this.config = {\n      database: config?.database ?? 'neo4j',\n      defaultAccessMode: config?.defaultAccessMode ?? 'WRITE',\n      bookmarks: normalizeBookmarks(config?.bookmarks),\n      fetchSize: config?.fetchSize ?? 1000,\n      impersonatedUser: config?.impersonatedUser\n    }\n  }\n}\n```\n\n### run() Method\n```typescript\nasync run(cypher: string, params?: Record\u003cstring, any\u003e): Promise\u003cResult\u003e {\n  this.ensureOpen()\n  this.ensureNoTransaction()\n  \n  const result = await this.executeAutoCommit(cypher, params)\n  return result\n}\n```\n\n### executeRead() / executeWrite() Methods\n```typescript\nasync executeRead\u003cT\u003e(\n  work: (tx: ManagedTransaction) =\u003e Promise\u003cT\u003e,\n  config?: TransactionConfig\n): Promise\u003cT\u003e {\n  return this.executeInTransaction(work, 'READ', config)\n}\n\nasync executeWrite\u003cT\u003e(\n  work: (tx: ManagedTransaction) =\u003e Promise\u003cT\u003e,\n  config?: TransactionConfig\n): Promise\u003cT\u003e {\n  return this.executeInTransaction(work, 'WRITE', config)\n}\n\nprivate async executeInTransaction\u003cT\u003e(\n  work: (tx: ManagedTransaction) =\u003e Promise\u003cT\u003e,\n  accessMode: AccessMode,\n  config?: TransactionConfig\n): Promise\u003cT\u003e {\n  // Implement retry logic\n}\n```\n\n### beginTransaction() Method\n```typescript\nbeginTransaction(config?: TransactionConfig): Transaction {\n  this.ensureOpen()\n  this.ensureNoTransaction()\n  \n  this.currentTransaction = new Transaction(this, config)\n  return this.currentTransaction\n}\n```\n\n## Files to Create/Modify\n- `src/session/session.ts`\n- `src/session/result.ts`\n- `src/transaction/transaction.ts` (stub)\n- `src/session/types.ts`\n\n## TDD Phase\n**GREEN** - Implement to pass tests.\n\n## Dependencies\n- Depends on: RED: Session Class Query Execution Tests\n- Depends on: GREEN: Driver Lifecycle Methods Implementation\n\n## Acceptance Criteria\n- [ ] All RED phase tests pass\n- [ ] Query execution works with graph engine\n- [ ] Transaction modes are respected\n- [ ] Error handling is correct","status":"open","priority":1,"issue_type":"task","created_at":"2026-01-05T06:36:35.940921-06:00","updated_at":"2026-01-05T06:36:35.940921-06:00"}
{"id":"neo4j-n7a0","title":"REFACTOR: AI Functions in Cypher - Optimize AI calls and add caching","description":"## Overview\nRefactor AI functions for production performance and reliability.\n\n## Refactoring Goals\n\n### 1. Performance Optimization\n- Implement embedding cache with content hashing\n- Batch API calls within transactions\n- Request deduplication across concurrent queries\n- Lazy evaluation for unused AI results\n\n### 2. Caching Strategy\n```typescript\ninterface AICacheConfig {\n  embed: {\n    enabled: boolean;\n    ttl: number; // seconds\n    maxSize: number; // entries\n  };\n  generate: {\n    enabled: boolean;\n    ttl: number;\n    keyFn: (prompt: string, options: any) =\u003e string;\n  };\n}\n\nclass AICacheService {\n  private cache: KVNamespace;\n  \n  async getCachedEmbedding(text: string, model: string): Promise\u003cnumber[] | null\u003e;\n  async cacheEmbedding(text: string, model: string, embedding: number[]): Promise\u003cvoid\u003e;\n  \n  // Content-based cache key\n  private hashContent(text: string, model: string): string {\n    return crypto.subtle.digest('SHA-256', text + model);\n  }\n}\n```\n\n### 3. Reliability Improvements\n- Circuit breaker for AI service failures\n- Fallback models for unavailable primary models\n- Request timeout configuration\n- Retry with exponential backoff\n\n### 4. Cost Optimization\n- Track token/embedding usage\n- Implement usage quotas per tenant\n- Cost estimation before execution\n- Usage analytics dashboard\n\n### 5. Advanced Features\n```typescript\n// Streaming generation\nasync function* streamGenerate(prompt: string): AsyncGenerator\u003cstring\u003e;\n\n// Structured output with validation\nasync function generateStructured\u003cT\u003e(prompt: string, schema: JSONSchema): Promise\u003cT\u003e;\n\n// Chain of thought\nasync function reasonAndAnswer(question: string, context: string): Promise\u003c{\n  reasoning: string;\n  answer: string;\n}\u003e;\n```\n\n### 6. Observability\n- AI function call metrics\n- Latency percentiles by function\n- Cache hit rates\n- Error rates by model\n\n## Tasks\n- [ ] Implement content-hash embedding cache\n- [ ] Add circuit breaker pattern\n- [ ] Build usage tracking\n- [ ] Create streaming generation\n- [ ] Add structured output validation\n- [ ] Implement fallback models\n- [ ] Add comprehensive metrics\n\n## Acceptance Criteria\n- [ ] All tests still passing\n- [ ] 80%+ cache hit rate for repeated embeddings\n- [ ] \u003c 100ms p99 for cached operations\n- [ ] Graceful degradation on AI failures\n\n## Tags\nsuperset, ai-functions, workers-ai, tdd-refactor, performance, caching","status":"open","priority":3,"issue_type":"task","created_at":"2026-01-05T06:39:25.750687-06:00","updated_at":"2026-01-05T06:39:25.750687-06:00"}
{"id":"neo4j-na4","title":"GREEN: Record.toObject() - Implement conversion to plain object","description":"## Overview\nImplement the Record.toObject() method to make all RED phase tests pass.\n\n## Implementation\n\n```typescript\ntoObject(): Record\u003cstring, any\u003e {\n  const obj: Record\u003cstring, any\u003e = {};\n  for (let i = 0; i \u003c this._keys.length; i++) {\n    obj[this._keys[i]] = this._values[i];\n  }\n  return obj;\n}\n```\n\n## Acceptance Criteria\n- [ ] All RED phase tests now pass (GREEN phase)\n- [ ] Returns new object each call\n- [ ] Preserves all value types including Neo4j types\n- [ ] Implementation is minimal\n\n## TDD Phase\nGREEN - Minimal implementation to pass tests\n\n## Dependencies\n- neo4j-ha2 (RED phase tests)","status":"open","priority":1,"issue_type":"task","created_at":"2026-01-05T06:37:02.776985-06:00","updated_at":"2026-01-05T06:37:02.776985-06:00"}
{"id":"neo4j-naf","title":"RED: Write failing tests for driver.rxSession() factory method","description":"## Overview\nWrite failing tests for the `driver.rxSession()` factory method that creates reactive sessions.\n\n## Test Cases to Write\n\n### Basic Factory Tests\n- `driver.rxSession()` returns RxSession instance\n- `driver.rxSession(config)` accepts session configuration\n- Factory method is available on Driver instance\n- Returns new RxSession for each call\n\n### Configuration Tests\n- Accepts `database` option\n- Accepts `defaultAccessMode` option (READ/WRITE)\n- Accepts `bookmarks` option\n- Accepts `fetchSize` option\n- Invalid config throws appropriate error\n\n### Type Tests\n- RxSession has correct interface methods\n- Return type is RxSession (not Session)\n- Config type matches RxSessionConfig interface\n\n## Acceptance Criteria\n- [ ] All tests written and failing (RED phase)\n- [ ] Tests cover happy path and edge cases\n- [ ] Tests are properly isolated\n- [ ] Test file created at appropriate location\n- [ ] Tests follow project conventions","status":"open","priority":2,"issue_type":"task","created_at":"2026-01-05T06:34:32.926885-06:00","updated_at":"2026-01-05T06:34:32.926885-06:00"}
{"id":"neo4j-nzr","title":"[GREEN] Lexer: Implement Token Types and Basic Tokenization","description":"## Overview\nImplement the lexer to make all token type tests pass.\n\n## Implementation Tasks\n\n### Token Type Enum/Union\n```typescript\ntype TokenType =\n  | 'KEYWORD'      // MATCH, CREATE, RETURN, etc.\n  | 'IDENTIFIER'   // variable names, unquoted\n  | 'STRING'       // 'string' or \"string\"\n  | 'INTEGER'      // 123\n  | 'FLOAT'        // 1.23\n  | 'BOOLEAN'      // true, false\n  | 'NULL'         // null\n  | 'OPERATOR'     // +, -, *, /, =, \u003c\u003e, etc.\n  | 'PUNCTUATION'  // (, ), [, ], {, }, :, etc.\n  | 'PARAMETER'    // $param\n  | 'COMMENT'      // // or /* */\n  | 'WHITESPACE'   // spaces, tabs, newlines\n  | 'EOF'          // end of input\n```\n\n### Token Interface\n```typescript\ninterface Token {\n  type: TokenType\n  value: string\n  line: number\n  column: number\n  start: number\n  end: number\n}\n```\n\n### Lexer Class\n- `tokenize(input: string): Token[]`\n- Cursor management (position, line, column)\n- Peek and advance methods\n\n## Acceptance Criteria\n- [ ] All RED phase tests pass\n- [ ] Lexer correctly identifies all token types\n- [ ] Position tracking is accurate\n- [ ] File: `src/parser/lexer.ts`\n\n## TDD Phase: GREEN\n## Depends On: neo4j-kdy","status":"open","priority":1,"issue_type":"task","created_at":"2026-01-05T06:34:42.446931-06:00","updated_at":"2026-01-05T06:34:42.446931-06:00"}
{"id":"neo4j-o0v","title":"RED: Vector Search - Write failing tests for vector query procedures","description":"## Overview\nWrite failing tests for vector search capabilities using Vectorize integration.\n\n## Test Cases\n\n### Node Vector Search\n```typescript\ndescribe('Vector Search', () =\u003e {\n  beforeAll(async () =\u003e {\n    // Create test data with embeddings\n    await session.run('CALL db.index.vector.create(\"articles\", \"Article\", \"embedding\", 1024, \"cosine\")');\n    await session.run(`\n      CREATE (:Article {title: \"Graph Databases\", embedding: $e1})\n      CREATE (:Article {title: \"SQL Optimization\", embedding: $e2})\n      CREATE (:Article {title: \"Neo4j Tutorial\", embedding: $e3})\n    `, { e1: graphEmbedding, e2: sqlEmbedding, e3: neo4jEmbedding });\n  });\n\n  describe('queryNodes Procedure', () =\u003e {\n    it('should return k nearest neighbors', async () =\u003e {\n      const result = await session.run(\n        'CALL db.index.vector.queryNodes(\"articles\", 2, $queryVector) YIELD node, score RETURN node.title, score',\n        { queryVector: graphQueryVector }\n      );\n      \n      expect(result.records).toHaveLength(2);\n      expect(result.records[0].get('node.title')).toBe('Graph Databases');\n      expect(result.records[0].get('score')).toBeGreaterThan(0.9);\n    });\n\n    it('should support distance metrics', async () =\u003e {\n      const cosine = await session.run(\n        'CALL db.index.vector.queryNodes(\"articles\", 5, $v, { metric: \"cosine\" }) YIELD score RETURN score',\n        { v: queryVector }\n      );\n      \n      const euclidean = await session.run(\n        'CALL db.index.vector.queryNodes(\"articles_euclidean\", 5, $v, { metric: \"euclidean\" }) YIELD score RETURN score',\n        { v: queryVector }\n      );\n      \n      // Scores should differ based on metric\n      expect(cosine.records[0].get('score')).not.toEqual(euclidean.records[0].get('score'));\n    });\n\n    it('should return empty results for no matches above threshold', async () =\u003e {\n      const result = await session.run(\n        'CALL db.index.vector.queryNodes(\"articles\", 5, $v, { minScore: 0.99 }) YIELD node RETURN node',\n        { v: unrelatedVector }\n      );\n      \n      expect(result.records).toHaveLength(0);\n    });\n  });\n\n  describe('queryRelationships Procedure', () =\u003e {\n    it('should search relationship embeddings', async () =\u003e {\n      await session.run('CALL db.index.vector.create(\"reviews\", \"REVIEWED\", \"embedding\", 1024, \"cosine\")');\n      await session.run(`\n        CREATE (u:User)-[:REVIEWED {text: \"Excellent product\", embedding: $e}]-\u003e(p:Product)\n      `, { e: reviewEmbedding });\n      \n      const result = await session.run(\n        'CALL db.index.vector.queryRelationships(\"reviews\", 5, $v) YIELD relationship, score RETURN relationship.text, score',\n        { v: positiveReviewQuery }\n      );\n      \n      expect(result.records[0].get('relationship.text')).toBe('Excellent product');\n    });\n  });\n\n  describe('Hybrid Search', () =\u003e {\n    it('should combine vector search with graph filters', async () =\u003e {\n      const result = await session.run(`\n        CALL db.index.vector.queryNodes(\"articles\", 10, $v) YIELD node, score\n        WHERE node.published = true AND node.category = \"technology\"\n        RETURN node.title, score\n        ORDER BY score DESC\n        LIMIT 5\n      `, { v: queryVector });\n      \n      result.records.forEach(r =\u003e {\n        // All results should match filter criteria\n      });\n    });\n\n    it('should support pre-filtering for efficiency', async () =\u003e {\n      const result = await session.run(`\n        CALL db.index.vector.queryNodes(\"articles\", 5, $v, { \n          filter: { category: \"technology\", published: true }\n        }) YIELD node, score\n        RETURN node.title, score\n      `, { v: queryVector });\n      \n      // Pre-filtering should be more efficient than post-filtering\n    });\n\n    it('should combine with graph traversal', async () =\u003e {\n      const result = await session.run(`\n        CALL db.index.vector.queryNodes(\"articles\", 3, $v) YIELD node as article, score\n        MATCH (article)\u003c-[:WROTE]-(author:Author)\n        MATCH (author)-[:WROTE]-\u003e(other:Article)\n        WHERE other \u003c\u003e article\n        RETURN article.title, author.name, collect(other.title) as otherArticles, score\n      `, { v: queryVector });\n      \n      expect(result.records[0].get('otherArticles')).toBeDefined();\n    });\n  });\n\n  describe('Text-to-Vector Search', () =\u003e {\n    it('should auto-embed search query text', async () =\u003e {\n      const result = await session.run(\n        'CALL db.index.vector.searchText(\"articles\", \"graph database concepts\", 5) YIELD node, score RETURN node.title, score'\n      );\n      \n      expect(result.records[0].get('node.title')).toContain('Graph');\n    });\n  });\n\n  describe('Vectorize Integration', () =\u003e {\n    it('should use Vectorize index for efficient search', async () =\u003e {\n      // Verify Vectorize is being used, not brute force\n    });\n\n    it('should handle index not found gracefully', async () =\u003e {\n      await expect(session.run(\n        'CALL db.index.vector.queryNodes(\"nonexistent\", 5, $v) YIELD node RETURN node',\n        { v: queryVector }\n      )).rejects.toThrow(/Index .* not found/);\n    });\n  });\n});\n```\n\n## Acceptance Criteria\n- [ ] All test cases written and failing\n- [ ] Vectorize mock infrastructure\n- [ ] Test vectors with known similarity scores\n- [ ] Performance benchmarks defined\n\n## Tags\nsuperset, vector-search, vectorize, tdd-red","status":"open","priority":2,"issue_type":"task","created_at":"2026-01-05T06:35:56.349855-06:00","updated_at":"2026-01-05T06:35:56.349855-06:00"}
{"id":"neo4j-o66","title":"RED: Session Class Query Execution Tests","description":"## Overview\nWrite comprehensive failing tests for Session class query execution: run(), executeRead(), executeWrite(), and beginTransaction().\n\n## Test Cases\n\n### Session.run() Tests\n```typescript\ndescribe('session.run()', () =\u003e {\n  it('should execute Cypher query')\n  it('should execute query with parameters')\n  it('should return Result object')\n  it('should allow iteration over records')\n  it('should provide result summary')\n  it('should handle empty results')\n  it('should handle large result sets')\n  it('should throw on syntax errors')\n  it('should throw on constraint violations')\n  it('should auto-commit single statements')\n  it('should track query execution time')\n})\n```\n\n### Session.executeRead() Tests\n```typescript\ndescribe('session.executeRead()', () =\u003e {\n  it('should execute work function in read transaction')\n  it('should pass transaction to work function')\n  it('should auto-commit on success')\n  it('should auto-rollback on error')\n  it('should retry on transient errors')\n  it('should respect maxTransactionRetryTime')\n  it('should not retry on fatal errors')\n  it('should return work function result')\n  it('should use READ access mode')\n})\n```\n\n### Session.executeWrite() Tests\n```typescript\ndescribe('session.executeWrite()', () =\u003e {\n  it('should execute work function in write transaction')\n  it('should pass transaction to work function')\n  it('should auto-commit on success')\n  it('should auto-rollback on error')\n  it('should retry on transient errors')\n  it('should not retry after max retries')\n  it('should return work function result')\n  it('should use WRITE access mode')\n  it('should generate bookmark on success')\n})\n```\n\n### Session.beginTransaction() Tests\n```typescript\ndescribe('session.beginTransaction()', () =\u003e {\n  it('should create explicit transaction')\n  it('should return Transaction object')\n  it('should accept transaction metadata')\n  it('should accept timeout configuration')\n  it('should throw if transaction already open')\n  it('should respect session access mode')\n})\n```\n\n## TDD Phase\n**RED** - All tests should fail initially.\n\n## Acceptance Criteria\n- [ ] All test cases written with clear assertions\n- [ ] Tests cover auto-commit and explicit transaction modes\n- [ ] Tests verify retry behavior\n- [ ] Tests check error handling","status":"open","priority":1,"issue_type":"task","created_at":"2026-01-05T06:36:17.296801-06:00","updated_at":"2026-01-05T06:36:17.296801-06:00"}
{"id":"neo4j-o9n","title":"TypeScript configuration (tsconfig.json)","description":"# TypeScript Configuration\n\n## Overview\nConfigure TypeScript for the neo4j.do project with strict settings appropriate for a library targeting Cloudflare Workers.\n\n## Configuration Requirements\n- Target: ES2022\n- Module: ESNext\n- Module Resolution: Bundler\n- Strict mode enabled\n- Declaration files generation\n- Source maps for debugging\n- Cloudflare Workers types integration\n\n## Compiler Options\n```json\n{\n  \"compilerOptions\": {\n    \"target\": \"ES2022\",\n    \"module\": \"ESNext\",\n    \"moduleResolution\": \"bundler\",\n    \"lib\": [\"ES2022\"],\n    \"types\": [\"@cloudflare/workers-types\"],\n    \"strict\": true,\n    \"noEmit\": true,\n    \"declaration\": true,\n    \"declarationMap\": true,\n    \"sourceMap\": true,\n    \"esModuleInterop\": true,\n    \"skipLibCheck\": true,\n    \"forceConsistentCasingInFileNames\": true,\n    \"resolveJsonModule\": true,\n    \"isolatedModules\": true,\n    \"noUnusedLocals\": true,\n    \"noUnusedParameters\": true,\n    \"noFallthroughCasesInSwitch\": true\n  },\n  \"include\": [\"src/**/*\"],\n  \"exclude\": [\"node_modules\", \"dist\"]\n}\n```\n\n## Acceptance Criteria\n- [ ] tsconfig.json created and validated\n- [ ] Types compile without errors\n- [ ] Cloudflare Workers types are recognized\n- [ ] IDE intellisense works correctly","status":"open","priority":1,"issue_type":"task","created_at":"2026-01-05T06:34:41.116154-06:00","updated_at":"2026-01-05T06:34:41.116154-06:00"}
{"id":"neo4j-ocf","title":"[REFACTOR] Node Operations - Optimize queries and add validation","description":"## Overview\nRefactor node operations for better performance and robustness.\n\n## Refactoring Tasks\n\n### Query Optimization\n- Use prepared statements\n- Optimize label queries with proper indexing\n- Add query result caching\n- Batch operations support\n\n```typescript\n// Optimized label query using JSON index\nthis.sql.exec(`\n  SELECT n.* FROM nodes n, json_each(n.labels) AS l\n  WHERE l.value = ?\n`, label);\n```\n\n### Input Validation\n```typescript\nfunction validateNodeInput(labels: string[], properties: object): void {\n  if (\\!Array.isArray(labels)) {\n    throw new ValidationError('Labels must be an array');\n  }\n  labels.forEach(label =\u003e {\n    if (typeof label \\!== 'string' || \\!label.match(/^[A-Za-z_][A-Za-z0-9_]*$/)) {\n      throw new ValidationError('Invalid label format');\n    }\n  });\n  validateProperties(properties);\n}\n```\n\n### Batch Operations\n```typescript\ncreateNodes(nodes: NodeInput[]): Node[] {\n  return this.sql.transaction(() =\u003e {\n    return nodes.map(n =\u003e this.createNode(n.labels, n.properties));\n  });\n}\n\ndeleteNodes(ids: number[]): number {\n  // Validate no relationships exist\n  return this.sql.transaction(() =\u003e {\n    let deleted = 0;\n    for (const id of ids) {\n      if (this.deleteNode(id)) deleted++;\n    }\n    return deleted;\n  });\n}\n```\n\n### Code Quality\n- Extract SQL queries to constants\n- Add comprehensive JSDoc\n- Implement result type helpers\n- Add performance logging\n\n## Acceptance Criteria\n- [ ] All tests still pass\n- [ ] Queries are optimized\n- [ ] Input validation is thorough\n- [ ] Batch operations available\n- [ ] Code is clean and documented\n\n## TDD Phase\n**REFACTOR** - Improve without changing behavior","status":"open","priority":2,"issue_type":"task","created_at":"2026-01-05T06:37:02.489567-06:00","updated_at":"2026-01-05T06:37:02.489567-06:00"}
{"id":"neo4j-pm6","title":"RED: Pattern to JOIN Translation - Single Node Pattern","description":"## Overview\nWrite failing tests for single node pattern translation to SELECT statements.\n\n## Test Cases to Write\n\n### Test 1: Basic Node Pattern\n```typescript\ntest('translates (n) to SELECT * FROM nodes', () =\u003e {\n  const ast = parse('MATCH (n) RETURN n');\n  const sql = translate(ast);\n  expect(sql).toContain('SELECT');\n  expect(sql).toContain('FROM nodes');\n});\n```\n\n### Test 2: Node with Variable Binding\n```typescript\ntest('binds node variable for later reference', () =\u003e {\n  const ast = parse('MATCH (person) RETURN person.name');\n  const sql = translate(ast);\n  expect(sql).toContain('json_extract');\n  expect(sql).toContain('person');\n});\n```\n\n### Test 3: Node with Label Filter\n```typescript\ntest('translates (n:Person) to WHERE with label check', () =\u003e {\n  const ast = parse('MATCH (n:Person) RETURN n');\n  const sql = translate(ast);\n  expect(sql).toMatch(/WHERE.*label.*=.*'Person'/);\n});\n```\n\n### Test 4: Node with Multiple Labels\n```typescript\ntest('translates (n:Person:Employee) to AND conditions', () =\u003e {\n  const ast = parse('MATCH (n:Person:Employee) RETURN n');\n  const sql = translate(ast);\n  expect(sql).toContain('Person');\n  expect(sql).toContain('Employee');\n});\n```\n\n### Test 5: Node with Properties\n```typescript\ntest('translates (n {name: \"Alice\"}) to property WHERE', () =\u003e {\n  const ast = parse('MATCH (n {name: \"Alice\"}) RETURN n');\n  const sql = translate(ast);\n  expect(sql).toContain('json_extract');\n  expect(sql).toContain('name');\n  expect(sql).toContain('Alice');\n});\n```\n\n### Test 6: Anonymous Node\n```typescript\ntest('handles anonymous node pattern ()', () =\u003e {\n  const ast = parse('MATCH () RETURN count(*)');\n  const sql = translate(ast);\n  expect(sql).toContain('COUNT(*)');\n  expect(sql).toContain('FROM nodes');\n});\n```\n\n## Acceptance Criteria\n- [ ] All tests written and failing\n- [ ] Tests cover edge cases (empty labels, null properties)\n- [ ] Test file created at `src/cypher/translator/__tests__/pattern-to-join.test.ts`\n\n## TDD Phase\nRED - Write failing tests first","status":"open","priority":1,"issue_type":"task","created_at":"2026-01-05T06:34:30.048383-06:00","updated_at":"2026-01-05T06:34:30.048383-06:00"}
{"id":"neo4j-pni","title":"[GREEN] Lexer: Implement Comments and Parameters","description":"## Overview\nImplement comment and parameter tokenization.\n\n## Implementation Tasks\n\n### Single-Line Comment Scanner\n```typescript\nprivate scanSingleLineComment(): Token {\n  // Skip //\n  // Scan until newline or EOF\n  // Return COMMENT token\n}\n```\n\n### Multi-Line Comment Scanner\n```typescript\nprivate scanMultiLineComment(): Token {\n  // Skip /*\n  // Scan until */\n  // Track newlines for line counting\n  // Error if unclosed\n  // Return COMMENT token\n}\n```\n\n### Parameter Scanner\n```typescript\nprivate scanParameter(): Token {\n  // Skip $\n  // Scan identifier characters\n  // Return PARAMETER token with name\n}\n```\n\n## Acceptance Criteria\n- [ ] All comment tests pass\n- [ ] All parameter tests pass\n- [ ] Line counting accurate through comments\n- [ ] Proper errors for malformed input\n\n## TDD Phase: GREEN\n## Depends On: neo4j-rih","status":"open","priority":1,"issue_type":"task","created_at":"2026-01-05T06:37:01.05857-06:00","updated_at":"2026-01-05T06:37:01.05857-06:00"}
{"id":"neo4j-pt0","title":"RED: Full-Text Search - Write failing tests for FTS5 integration","description":"## Overview\nWrite failing tests for full-text search using SQLite FTS5 integration.\n\n## Test Cases\n\n```typescript\ndescribe('Full-Text Search', () =\u003e {\n  beforeAll(async () =\u003e {\n    await session.run('CALL db.index.fulltext.create(\"articles\", [\"Article\"], [\"title\", \"content\"])');\n    await session.run(`\n      CREATE (:Article {title: \"Introduction to Graph Databases\", content: \"Graph databases store data as nodes and relationships...\"})\n      CREATE (:Article {title: \"SQL Performance Tuning\", content: \"Optimizing SQL queries requires understanding indexes...\"})\n      CREATE (:Article {title: \"Neo4j Best Practices\", content: \"When working with Neo4j, consider these graph patterns...\"})\n    `);\n  });\n\n  describe('queryNodes Procedure', () =\u003e {\n    it('should search across configured fields', async () =\u003e {\n      const result = await session.run(\n        'CALL db.index.fulltext.queryNodes(\"articles\", \"graph databases\") YIELD node, score RETURN node.title, score'\n      );\n      \n      expect(result.records).toHaveLength(2);\n      expect(result.records[0].get('node.title')).toBe('Introduction to Graph Databases');\n    });\n\n    it('should support phrase search', async () =\u003e {\n      const result = await session.run(\n        'CALL db.index.fulltext.queryNodes(\"articles\", \"\\\"graph patterns\\\"\") YIELD node RETURN node.title'\n      );\n      \n      expect(result.records).toHaveLength(1);\n      expect(result.records[0].get('node.title')).toBe('Neo4j Best Practices');\n    });\n\n    it('should support boolean operators', async () =\u003e {\n      const result = await session.run(\n        'CALL db.index.fulltext.queryNodes(\"articles\", \"graph AND NOT sql\") YIELD node RETURN node.title'\n      );\n      \n      // Should exclude SQL article\n    });\n\n    it('should return relevance scores', async () =\u003e {\n      const result = await session.run(\n        'CALL db.index.fulltext.queryNodes(\"articles\", \"graph\") YIELD node, score RETURN node.title, score ORDER BY score DESC'\n      );\n      \n      // First result should have higher score\n      const score1 = result.records[0].get('score');\n      const score2 = result.records[1].get('score');\n      expect(score1).toBeGreaterThan(score2);\n    });\n\n    it('should limit results with LIMIT clause', async () =\u003e {\n      const result = await session.run(\n        'CALL db.index.fulltext.queryNodes(\"articles\", \"database\") YIELD node RETURN node LIMIT 1'\n      );\n      \n      expect(result.records).toHaveLength(1);\n    });\n  });\n\n  describe('queryRelationships Procedure', () =\u003e {\n    it('should search relationship properties', async () =\u003e {\n      await session.run('CALL db.index.fulltext.create(\"reviews\", [], [\"text\"], { entityType: \"relationship\", relTypes: [\"REVIEWED\"] })');\n      await session.run(`\n        CREATE (u:User)-[:REVIEWED {text: \"Excellent documentation and great performance\"}]-\u003e(p:Product)\n      `);\n      \n      const result = await session.run(\n        'CALL db.index.fulltext.queryRelationships(\"reviews\", \"excellent\") YIELD relationship RETURN relationship.text'\n      );\n      \n      expect(result.records[0].get('relationship.text')).toContain('Excellent');\n    });\n  });\n\n  describe('Fuzzy Matching', () =\u003e {\n    it('should find fuzzy matches', async () =\u003e {\n      const result = await session.run(\n        'CALL db.index.fulltext.queryNodes(\"articles\", \"databse~\") YIELD node RETURN node.title'\n      );\n      \n      // Should find \"database\" despite typo\n      expect(result.records.length).toBeGreaterThan(0);\n    });\n\n    it('should support configurable edit distance', async () =\u003e {\n      const result = await session.run(\n        'CALL db.index.fulltext.queryNodes(\"articles\", \"grph~2\") YIELD node RETURN node.title'\n      );\n      \n      // Should find \"graph\" with edit distance 2\n    });\n  });\n\n  describe('Prefix Search', () =\u003e {\n    it('should support prefix matching', async () =\u003e {\n      const result = await session.run(\n        'CALL db.index.fulltext.queryNodes(\"articles\", \"optim*\") YIELD node RETURN node.title'\n      );\n      \n      // Should find \"optimization\", \"optimizing\", etc.\n    });\n  });\n\n  describe('Index Management', () =\u003e {\n    it('should create index on multiple labels', async () =\u003e {\n      await session.run('CALL db.index.fulltext.create(\"content\", [\"Article\", \"Post\", \"Comment\"], [\"text\", \"body\"])');\n      // Index should cover all labels\n    });\n\n    it('should list all fulltext indexes', async () =\u003e {\n      const result = await session.run('CALL db.index.fulltext.list() YIELD name, labels, properties RETURN *');\n      expect(result.records.length).toBeGreaterThan(0);\n    });\n\n    it('should drop index', async () =\u003e {\n      await session.run('CALL db.index.fulltext.create(\"temp\", [\"Temp\"], [\"text\"])');\n      await session.run('CALL db.index.fulltext.drop(\"temp\")');\n      \n      await expect(session.run(\n        'CALL db.index.fulltext.queryNodes(\"temp\", \"test\") YIELD node RETURN node'\n      )).rejects.toThrow(/Index .* not found/);\n    });\n  });\n\n  describe('Auto-indexing', () =\u003e {\n    it('should automatically index new nodes', async () =\u003e {\n      await session.run('CREATE (:Article {title: \"New Article\", content: \"Fresh content about testing\"})');\n      \n      const result = await session.run(\n        'CALL db.index.fulltext.queryNodes(\"articles\", \"fresh testing\") YIELD node RETURN node.title'\n      );\n      \n      expect(result.records[0].get('node.title')).toBe('New Article');\n    });\n\n    it('should update index on property changes', async () =\u003e {\n      await session.run('MATCH (a:Article {title: \"New Article\"}) SET a.content = \"Updated content about changes\"');\n      \n      const result = await session.run(\n        'CALL db.index.fulltext.queryNodes(\"articles\", \"updated changes\") YIELD node RETURN node.title'\n      );\n      \n      expect(result.records[0].get('node.title')).toBe('New Article');\n    });\n  });\n});\n```\n\n## Acceptance Criteria\n- [ ] All test cases written and failing\n- [ ] FTS5 test infrastructure ready\n- [ ] Test fixtures with known relevance scores\n\n## Tags\nsuperset, fulltext-search, fts5, sqlite, tdd-red","status":"open","priority":2,"issue_type":"task","created_at":"2026-01-05T06:37:12.506609-06:00","updated_at":"2026-01-05T06:37:12.506609-06:00"}
{"id":"neo4j-q9p","title":"RED: Driver Lifecycle Methods Tests","description":"## Overview\nWrite comprehensive failing tests for Driver lifecycle methods: session creation, executeQuery, getServerInfo, close, and verifyConnectivity.\n\n## Test Cases\n\n### Session Creation Tests\n```typescript\ndescribe('driver.session()', () =\u003e {\n  it('should create session with default config')\n  it('should create session with database specified')\n  it('should create session with defaultAccessMode READ')\n  it('should create session with defaultAccessMode WRITE')\n  it('should create session with bookmarks')\n  it('should create session with fetchSize')\n  it('should create session with impersonatedUser')\n  it('should throw after driver is closed')\n  it('should track active sessions')\n})\n\ndescribe('driver.rxSession()', () =\u003e {\n  it('should create reactive session')\n  it('should return RxSession instance')\n  it('should accept same config as regular session')\n})\n```\n\n### Execute Query Tests\n```typescript\ndescribe('driver.executeQuery()', () =\u003e {\n  it('should execute simple query')\n  it('should execute query with parameters')\n  it('should return EagerResult with records')\n  it('should return summary information')\n  it('should return keys from result')\n  it('should use READ routing by default')\n  it('should respect routing configuration')\n  it('should respect database configuration')\n  it('should handle query errors')\n  it('should auto-retry transient errors')\n})\n```\n\n### Server Info Tests\n```typescript\ndescribe('driver.getServerInfo()', () =\u003e {\n  it('should return server address')\n  it('should return server agent')\n  it('should return protocol version')\n  it('should throw on connection failure')\n})\n\ndescribe('driver.verifyConnectivity()', () =\u003e {\n  it('should return ServerInfo on success')\n  it('should throw on failure')\n  it('should work as alias for getServerInfo')\n})\n```\n\n### Close Tests\n```typescript\ndescribe('driver.close()', () =\u003e {\n  it('should close all active sessions')\n  it('should release all resources')\n  it('should be idempotent')\n  it('should reject new session creation after close')\n  it('should wait for in-flight transactions')\n  it('should resolve when all cleanup complete')\n})\n```\n\n## TDD Phase\n**RED** - All tests should fail initially.\n\n## Acceptance Criteria\n- [ ] All test cases written\n- [ ] Tests cover success and error paths\n- [ ] Async behavior properly tested\n- [ ] Resource cleanup verified","status":"open","priority":1,"issue_type":"task","created_at":"2026-01-05T06:35:27.354116-06:00","updated_at":"2026-01-05T06:35:27.354116-06:00"}
{"id":"neo4j-qsk","title":"[RED] SQLite Schema Design - Write failing tests for nodes table schema","description":"## Overview\nWrite failing tests for the nodes table schema design before implementation.\n\n## Test Cases to Write\n\n### Schema Structure Tests\n- `test_nodes_table_exists` - Verify nodes table is created\n- `test_nodes_table_has_id_column` - INTEGER PRIMARY KEY AUTOINCREMENT\n- `test_nodes_table_has_labels_column` - TEXT (JSON array)\n- `test_nodes_table_has_properties_column` - TEXT (JSON object)\n- `test_nodes_table_has_created_at_column` - DATETIME with default\n- `test_nodes_table_has_updated_at_column` - DATETIME with default\n\n### Relationships Table Tests\n- `test_relationships_table_exists`\n- `test_relationships_table_has_id_column` - INTEGER PRIMARY KEY\n- `test_relationships_table_has_type_column` - TEXT NOT NULL\n- `test_relationships_table_has_start_node_id_column` - INTEGER REFERENCES nodes(id)\n- `test_relationships_table_has_end_node_id_column` - INTEGER REFERENCES nodes(id)\n- `test_relationships_table_has_properties_column` - TEXT (JSON)\n- `test_relationships_table_has_created_at_column`\n\n### Index Tests\n- `test_labels_index_exists` - Index on labels column\n- `test_relationship_type_index_exists`\n- `test_start_node_index_exists`\n- `test_end_node_index_exists`\n\n### Schema Version Tests\n- `test_schema_version_table_exists`\n- `test_schema_version_has_version_column`\n- `test_schema_version_has_applied_at_column`\n\n## Acceptance Criteria\n- [ ] All tests written and failing (RED state)\n- [ ] Tests cover all table structures\n- [ ] Tests verify column types and constraints\n- [ ] Tests check index existence\n- [ ] Schema versioning tests included\n\n## TDD Phase\n**RED** - Write failing tests first","status":"open","priority":1,"issue_type":"task","created_at":"2026-01-05T06:34:37.404124-06:00","updated_at":"2026-01-05T06:34:37.404124-06:00"}
{"id":"neo4j-qzj","title":"[GREEN] Node Operations - Implement CRUD operations to pass tests","description":"## Overview\nImplement node CRUD operations to make all tests pass.\n\n## Implementation Requirements\n\n### Node Interface\n```typescript\ninterface Node {\n  id: number;\n  elementId: string;\n  labels: string[];\n  properties: Record\u003cstring, unknown\u003e;\n}\n```\n\n### NodeOperations Class\n```typescript\nclass NodeOperations {\n  constructor(private sql: SqlStorage) {}\n\n  createNode(labels: string[], properties: Record\u003cstring, unknown\u003e): Node {\n    const result = this.sql.exec(\n      'INSERT INTO nodes (labels, properties) VALUES (?, ?) RETURNING *',\n      JSON.stringify(labels),\n      JSON.stringify(properties)\n    );\n    return this.rowToNode(result.one());\n  }\n\n  getNode(id: number): Node | null {\n    const result = this.sql.exec('SELECT * FROM nodes WHERE id = ?', id);\n    const row = result.one();\n    return row ? this.rowToNode(row) : null;\n  }\n\n  updateNode(id: number, properties: Record\u003cstring, unknown\u003e): Node {\n    // Merge with existing properties\n    const existing = this.getNode(id);\n    if (\\!existing) throw new Error('Node not found');\n    \n    const merged = { ...existing.properties, ...properties };\n    // Remove null values\n    Object.keys(merged).forEach(k =\u003e merged[k] === null \u0026\u0026 delete merged[k]);\n    \n    this.sql.exec(\n      'UPDATE nodes SET properties = ?, updated_at = CURRENT_TIMESTAMP WHERE id = ?',\n      JSON.stringify(merged), id\n    );\n    return this.getNode(id)\\!;\n  }\n\n  deleteNode(id: number): boolean {\n    // Check for relationships\n    const rels = this.sql.exec(\n      'SELECT COUNT(*) as count FROM relationships WHERE start_node_id = ? OR end_node_id = ?',\n      id, id\n    );\n    if (rels.one().count \u003e 0) {\n      throw new Error('Cannot delete node with relationships');\n    }\n    \n    const result = this.sql.exec('DELETE FROM nodes WHERE id = ?', id);\n    return result.rowsWritten \u003e 0;\n  }\n\n  getNodesByLabel(label: string): Node[] {\n    const result = this.sql.exec(\n      \"SELECT * FROM nodes WHERE json_each.value = ? FROM json_each(labels)\",\n      label\n    );\n    return result.toArray().map(this.rowToNode);\n  }\n\n  getAllNodes(limit?: number, offset?: number): Node[] {\n    let query = 'SELECT * FROM nodes';\n    if (limit) query += ' LIMIT ' + limit;\n    if (offset) query += ' OFFSET ' + offset;\n    return this.sql.exec(query).toArray().map(this.rowToNode);\n  }\n}\n```\n\n## Files to Create\n- `src/storage/operations/node-operations.ts`\n- `src/storage/types/node.ts`\n\n## Acceptance Criteria\n- [ ] All RED phase tests pass\n- [ ] CRUD operations work correctly\n- [ ] Error handling implemented\n- [ ] Timestamps managed properly\n\n## TDD Phase\n**GREEN** - Minimum code to pass tests","status":"open","priority":1,"issue_type":"task","created_at":"2026-01-05T06:36:55.960347-06:00","updated_at":"2026-01-05T06:36:55.960347-06:00"}
{"id":"neo4j-rih","title":"[RED] Lexer: Comments and Parameters Tests","description":"## Overview\nWrite failing tests for comment and parameter tokenization.\n\n## Test Cases to Write\n\n### Single-Line Comments\n- Simple: `// comment`\n- At end of line: `MATCH (n) // find nodes`\n- Empty: `//`\n- With special chars: `// TODO: fix this!`\n\n### Multi-Line Comments\n- Simple: `/* comment */`\n- Multi-line: `/* line1\\nline2 */`\n- Nested (if supported): `/* outer /* inner */ outer */`\n- Empty: `/**/`\n- Unclosed (error case)\n\n### Parameter Placeholders\n- Simple: `$param`\n- With numbers: `$param1`, `$1`\n- With underscores: `$my_param`\n- In query: `MATCH (n {id: $id}) RETURN n`\n\n### Edge Cases\n- Comment at start of input\n- Comment at end of input\n- Multiple consecutive comments\n- Parameter followed by operator\n\n## Acceptance Criteria\n- [ ] All tests written and failing\n- [ ] Both comment styles tested\n- [ ] Parameter syntax tested\n- [ ] Error cases for unclosed comments\n\n## TDD Phase: RED","status":"open","priority":1,"issue_type":"task","created_at":"2026-01-05T06:36:46.911652-06:00","updated_at":"2026-01-05T06:36:46.911652-06:00"}
{"id":"neo4j-s00","title":"RED: HttpSession class methods fail without implementation","description":"## Test-Driven Development: RED Phase\n\n### Component\nHTTP Client SDK - HttpSession Class\n\n### Test Cases to Write (Expected to FAIL)\n\n```typescript\nimport { describe, it, expect, vi, beforeEach } from 'vitest'\nimport { HttpSession } from '../src/client/http-session'\nimport { Neo4jHttpDriver } from '../src/client/http-driver'\n\ndescribe('HttpSession - RED', () =\u003e {\n  let driver: Neo4jHttpDriver\n  let session: HttpSession\n\n  beforeEach(() =\u003e {\n    driver = new Neo4jHttpDriver('https://neo4j.do/db/mydb')\n    session = driver.session()\n  })\n\n  describe('run()', () =\u003e {\n    it('should execute query via POST /query', async () =\u003e {\n      const mockFetch = vi.fn().mockResolvedValue({\n        ok: true,\n        json: () =\u003e Promise.resolve({ records: [{ n: 1 }] })\n      })\n      driver = new Neo4jHttpDriver('https://neo4j.do/db/mydb', { fetch: mockFetch })\n      session = driver.session()\n      \n      const result = await session.run('RETURN 1 as n')\n      \n      expect(mockFetch).toHaveBeenCalledWith(\n        'https://neo4j.do/db/mydb/query',\n        expect.objectContaining({ method: 'POST' })\n      )\n      expect(result.records[0].get('n')).toBe(1)\n    })\n\n    it('should include parameters in request body', async () =\u003e {\n      const mockFetch = vi.fn().mockResolvedValue({\n        ok: true,\n        json: () =\u003e Promise.resolve({ records: [] })\n      })\n      driver = new Neo4jHttpDriver('https://neo4j.do/db/mydb', { fetch: mockFetch })\n      session = driver.session()\n      \n      await session.run('MATCH (n) WHERE n.id = $id RETURN n', { id: 123 })\n      \n      const body = JSON.parse(mockFetch.mock.calls[0][1].body)\n      expect(body.query).toBe('MATCH (n) WHERE n.id = $id RETURN n')\n      expect(body.parameters).toEqual({ id: 123 })\n    })\n  })\n\n  describe('executeRead()', () =\u003e {\n    it('should execute with read access mode', async () =\u003e {\n      const result = await session.executeRead(async tx =\u003e {\n        return tx.run('MATCH (n) RETURN n')\n      })\n      expect(result).toBeDefined()\n    })\n\n    it('should send read routing hint to server', async () =\u003e {\n      const mockFetch = vi.fn().mockResolvedValue({\n        ok: true,\n        json: () =\u003e Promise.resolve({ records: [] })\n      })\n      driver = new Neo4jHttpDriver('https://neo4j.do/db/mydb', { fetch: mockFetch })\n      session = driver.session()\n      \n      await session.executeRead(tx =\u003e tx.run('MATCH (n) RETURN n'))\n      \n      const body = JSON.parse(mockFetch.mock.calls[0][1].body)\n      expect(body.accessMode).toBe('READ')\n    })\n  })\n\n  describe('executeWrite()', () =\u003e {\n    it('should execute with write access mode', async () =\u003e {\n      const result = await session.executeWrite(async tx =\u003e {\n        return tx.run('CREATE (n:Test) RETURN n')\n      })\n      expect(result).toBeDefined()\n    })\n\n    it('should send write routing hint to server', async () =\u003e {\n      const mockFetch = vi.fn().mockResolvedValue({\n        ok: true,\n        json: () =\u003e Promise.resolve({ records: [] })\n      })\n      driver = new Neo4jHttpDriver('https://neo4j.do/db/mydb', { fetch: mockFetch })\n      session = driver.session()\n      \n      await session.executeWrite(tx =\u003e tx.run('CREATE (n) RETURN n'))\n      \n      const body = JSON.parse(mockFetch.mock.calls[0][1].body)\n      expect(body.accessMode).toBe('WRITE')\n    })\n  })\n\n  describe('beginTransaction()', () =\u003e {\n    it('should start transaction via POST /tx/begin', async () =\u003e {\n      const tx = await session.beginTransaction()\n      expect(tx).toBeInstanceOf(HttpTransaction)\n      expect(tx.id).toBeDefined()\n    })\n  })\n\n  describe('close()', () =\u003e {\n    it('should close session and release resources', async () =\u003e {\n      await session.close()\n      expect(session.isClosed).toBe(true)\n    })\n\n    it('should reject operations after close', async () =\u003e {\n      await session.close()\n      await expect(session.run('RETURN 1')).rejects.toThrow('Session is closed')\n    })\n  })\n})\n```\n\n### Acceptance Criteria\n- [ ] Test file created at `tests/client/http-session.test.ts`\n- [ ] All tests fail with expected errors\n- [ ] Tests cover: run, executeRead, executeWrite, beginTransaction, close\n\n### TDD Cycle\nThis is the RED phase. Next: GREEN phase implementation.","status":"open","priority":2,"issue_type":"task","created_at":"2026-01-05T06:35:34.603033-06:00","updated_at":"2026-01-05T06:35:34.603033-06:00"}
{"id":"neo4j-s8z1","title":"[RED] AST: Pretty-Print Tests","description":"## Overview\nWrite failing tests for AST pretty-printing functionality.\n\n## Test Cases to Write\n\n### Simple Pretty-Print\n```typescript\n// Input AST for: MATCH (n) RETURN n\nconst ast = { type: 'Query', clauses: [...] }\nexpect(prettyPrint(ast)).toBe('MATCH (n) RETURN n')\n```\n\n### Formatted Output\n- Test indentation for nested structures\n- Test line breaks for long queries\n- Test alignment options\n\n### Round-Trip Tests\n```typescript\n// Parse -\u003e Pretty-Print -\u003e Parse should yield equivalent AST\nconst query = 'MATCH (n:Person)-[:KNOWS]-\u003e(m) WHERE n.age \u003e 21 RETURN n.name'\nconst ast1 = parse(query)\nconst printed = prettyPrint(ast1)\nconst ast2 = parse(printed)\nexpect(ast1).toEqual(ast2)\n```\n\n### Options\n```typescript\ninterface PrettyPrintOptions {\n  indent?: string       // default '  '\n  lineWidth?: number    // default 80\n  uppercase?: boolean   // keywords uppercase\n  minify?: boolean      // single line, minimal spaces\n}\n```\n\n## Acceptance Criteria\n- [ ] All pretty-print tests written\n- [ ] Round-trip tests for all node types\n- [ ] Format options tested\n- [ ] Edge cases covered\n\n## TDD Phase: RED","status":"open","priority":1,"issue_type":"task","created_at":"2026-01-05T06:39:24.244006-06:00","updated_at":"2026-01-05T06:39:24.244006-06:00"}
{"id":"neo4j-sgw","title":"RED: Record.get(index) - Write failing tests for getting value by position","description":"## Overview\nWrite failing tests for the Record.get(index) method that retrieves values by numeric position.\n\n## Test Cases to Write\n\n```typescript\ndescribe('Record.get(index)', () =\u003e {\n  it('should return value at valid index', () =\u003e {\n    const record = new Record(['name', 'age'], ['Alice', 30]);\n    expect(record.get(0)).toBe('Alice');\n    expect(record.get(1)).toBe(30);\n  });\n\n  it('should return undefined for out-of-bounds index', () =\u003e {\n    const record = new Record(['name'], ['Alice']);\n    expect(record.get(5)).toBeUndefined();\n    expect(record.get(-1)).toBeUndefined();\n  });\n\n  it('should handle index 0 correctly', () =\u003e {\n    const record = new Record(['first'], ['value']);\n    expect(record.get(0)).toBe('value');\n  });\n\n  it('should distinguish between string key and numeric index', () =\u003e {\n    const record = new Record(['0', 'name'], ['zero-key', 'Alice']);\n    expect(record.get('0')).toBe('zero-key');\n    expect(record.get(0)).toBe('zero-key'); // Same because '0' is at index 0\n  });\n});\n```\n\n## Acceptance Criteria\n- [ ] All tests written and failing (RED phase)\n- [ ] Tests cover index access edge cases\n- [ ] Tests handle boundary conditions\n- [ ] Test file updated at `src/result/__tests__/record-get-index.test.ts`\n\n## TDD Phase\nRED - Tests should fail because index-based get doesn't exist yet","status":"open","priority":1,"issue_type":"task","created_at":"2026-01-05T06:35:13.549083-06:00","updated_at":"2026-01-05T06:35:13.549083-06:00"}
{"id":"neo4j-snk","title":"[RED] Graph Types (Node, Relationship, Path) - Write Failing Tests","description":"## Overview\nWrite comprehensive failing tests for Neo4j Graph types before implementation.\n\n## TDD Phase: RED (Write Failing Tests)\n\n### Types to Test\n\n#### 1. Node\n```typescript\n// Properties\nnode.identity       // Integer - unique node ID\nnode.labels         // string[] - node labels\nnode.properties     // Record\u003cstring, any\u003e - node properties\nnode.elementId      // string - element ID (Neo4j 5.x)\n\n// Type guard\nneo4j.isNode(node)\n```\n\n#### 2. Relationship\n```typescript\n// Properties\nrel.identity        // Integer - unique relationship ID\nrel.type            // string - relationship type\nrel.properties      // Record\u003cstring, any\u003e - relationship properties\nrel.start           // Integer - start node ID\nrel.end             // Integer - end node ID\nrel.startNodeElementId  // string - start node element ID\nrel.endNodeElementId    // string - end node element ID\nrel.elementId       // string - element ID\n\n// Type guard\nneo4j.isRelationship(rel)\n```\n\n#### 3. Path\n```typescript\n// Properties\npath.start          // Node - start node\npath.end            // Node - end node\npath.segments       // PathSegment[] - path segments\npath.length         // number - number of relationships\n\n// Type guard\nneo4j.isPath(path)\n```\n\n#### 4. PathSegment\n```typescript\n// Properties\nsegment.start       // Node - start node of segment\nsegment.relationship // Relationship - the relationship\nsegment.end         // Node - end node of segment\n\n// Type guard\nneo4j.isPathSegment(segment)\n```\n\n### Test Categories\n\n#### Construction Tests\n- Create Node with labels and properties\n- Create Relationship with type and properties\n- Create Path from nodes and relationships\n- Create PathSegment\n\n#### Property Access Tests\n- All properties readable\n- Properties are the correct types\n- Integer IDs work correctly\n- Element IDs are strings\n\n#### Immutability Tests\n- Properties cannot be modified\n- Labels array cannot be modified\n- Attempting to modify throws/fails\n\n#### Serialization Tests\n- JSON.stringify works\n- Can reconstruct from JSON\n- Properties serialize correctly\n- Integer IDs serialize as expected\n\n#### Type Guards\n- `neo4j.isNode()` returns true for Node\n- `neo4j.isNode()` returns false for plain objects with same shape\n- Same for isRelationship, isPath, isPathSegment\n- Type guards narrow types correctly\n\n#### Edge Cases\n- Empty labels array\n- Empty properties object\n- Self-referential relationships (start === end)\n- Very long paths\n- Unicode in labels/types/properties\n- Null/undefined property values\n\n### Test File Structure\n```\nsrc/types/graph/\n  node.test.ts\n  relationship.test.ts\n  path.test.ts\n  path-segment.test.ts\n```\n\n### Acceptance Criteria\n- [ ] All tests written and failing (RED state)\n- [ ] Tests match neo4j-driver API exactly\n- [ ] All graph types covered\n- [ ] Edge cases documented\n\n### References\n- [neo4j-driver Graph Types](https://neo4j.com/docs/api/javascript-driver/current/)","status":"open","priority":1,"issue_type":"task","created_at":"2026-01-05T06:38:54.963103-06:00","updated_at":"2026-01-05T06:38:54.963103-06:00"}
{"id":"neo4j-snw","title":"GREEN: Implement rxTx.run() method","description":"## Overview\nImplement rxTx.run() to make all RED tests pass.\n\n## Implementation Requirements\n\n### Method Signature\n```typescript\ninterface RxTransaction {\n  run(cypher: string, params?: Record\u003cstring, any\u003e): RxResult\n}\n```\n\n### Implementation Details\n- Execute query within transaction context\n- Create RxResult for query results\n- Handle parameter serialization\n- Ensure transaction isolation\n- Support query cancellation\n\n### Observable Semantics\n- Cold observable for lazy execution\n- Proper error propagation\n- Unsubscription handling\n\n## Acceptance Criteria\n- All RED tests now pass (GREEN phase)\n- Query runs in transaction context\n- Returns proper RxResult\n- Parameters handled correctly","status":"open","priority":2,"issue_type":"task","created_at":"2026-01-05T06:38:44.820376-06:00","updated_at":"2026-01-05T06:38:44.820376-06:00"}
{"id":"neo4j-srl9","title":"GREEN: UPDATE Translation (SET/REMOVE)","description":"## Overview\nImplement SET and REMOVE clause translation to make RED tests pass.\n\n## Implementation Tasks\n\n### 1. SetClauseTranslator\n- translateSetProperty(): json_set for single property\n- translateSetMultiple(): Chain json_set calls\n- translateSetReplace(): Full property replacement\n- translateSetMerge(): json_patch for += operation\n\n### 2. RemoveClauseTranslator\n- translateRemoveProperty(): json_remove\n- translateRemoveLabel(): Array manipulation on labels\n\n### 3. Expression Evaluator for SET\n- Handle computed expressions (n.age + 1)\n- Resolve property references\n\n### 4. Label Array Manipulation\n- Add label: json_insert\n- Remove label: Array filter\n\n## Files to Create/Modify\n- src/cypher/translator/set-clause-translator.ts\n- src/cypher/translator/remove-clause-translator.ts\n- src/cypher/translator/json-operations.ts\n\n## Acceptance Criteria\n- All RED phase tests pass\n- JSON functions used correctly\n- Labels as arrays handled\n\n## TDD Phase\nGREEN - Make tests pass with minimal code\n\n## Dependencies\n- Depends on: RED: UPDATE Translation (SET/REMOVE)","status":"open","priority":1,"issue_type":"task","created_at":"2026-01-05T06:39:28.106412-06:00","updated_at":"2026-01-05T06:39:28.106412-06:00"}
{"id":"neo4j-ttx","title":"GREEN: Record.get(index) - Implement get value by position","description":"## Overview\nImplement the Record.get(index) method to support numeric index access.\n\n## Implementation\n\n```typescript\nget(keyOrIndex: string | number): any {\n  if (typeof keyOrIndex === 'number') {\n    if (keyOrIndex \u003c 0 || keyOrIndex \u003e= this._values.length) {\n      return undefined;\n    }\n    return this._values[keyOrIndex];\n  }\n  \n  const index = this._fieldLookup.get(keyOrIndex);\n  if (index === undefined) {\n    return undefined;\n  }\n  return this._values[index];\n}\n```\n\n## Acceptance Criteria\n- [ ] All RED phase tests now pass (GREEN phase)\n- [ ] Both string key and numeric index work\n- [ ] Boundary conditions handled correctly\n- [ ] Previous tests still pass\n\n## TDD Phase\nGREEN - Minimal implementation to pass tests\n\n## Dependencies\n- neo4j-sgw (RED phase tests)","status":"open","priority":1,"issue_type":"task","created_at":"2026-01-05T06:35:27.644722-06:00","updated_at":"2026-01-05T06:35:27.644722-06:00"}
{"id":"neo4j-u43","title":"[RED] AST: Define Core Node Type Interfaces","description":"## Overview\nWrite failing tests for AST node type definitions.\n\n## Test Cases to Write\n\n### Base Node Types\n```typescript\ninterface ASTNode {\n  type: string\n  loc: SourceLocation\n}\n\ninterface SourceLocation {\n  start: Position\n  end: Position\n}\n\ninterface Position {\n  line: number\n  column: number\n  offset: number\n}\n```\n\n### Query Nodes\n- Test Query node structure (clauses array)\n- Test Union node (left, right, all flag)\n\n### Clause Nodes\n- Test MatchClause (pattern, where, optional)\n- Test ReturnClause (items, distinct, orderBy, skip, limit)\n- Test WithClause (items, where, distinct, orderBy, skip, limit)\n- Test CreateClause (pattern)\n- Test MergeClause (pattern, onMatch, onCreate)\n- Test DeleteClause (expressions, detach)\n- Test SetClause (items)\n- Test RemoveClause (items)\n- Test UnwindClause (expression, alias)\n\n### Type Guards\n- Test isMatchClause(node)\n- Test isExpression(node)\n- Test isPattern(node)\n\n## Acceptance Criteria\n- [ ] All interface tests written\n- [ ] Tests verify required properties\n- [ ] Tests verify type discriminators\n- [ ] File: `src/parser/__tests__/ast-types.test.ts`\n\n## TDD Phase: RED","status":"open","priority":1,"issue_type":"task","created_at":"2026-01-05T06:37:21.170007-06:00","updated_at":"2026-01-05T06:37:21.170007-06:00"}
{"id":"neo4j-ucp","title":"[RED] AST: Expression Node Types Tests","description":"## Overview\nWrite failing tests for expression AST node types.\n\n## Test Cases to Write\n\n### Literal Expressions\n```typescript\ninterface StringLiteral { type: 'StringLiteral', value: string }\ninterface IntegerLiteral { type: 'IntegerLiteral', value: number }\ninterface FloatLiteral { type: 'FloatLiteral', value: number }\ninterface BooleanLiteral { type: 'BooleanLiteral', value: boolean }\ninterface NullLiteral { type: 'NullLiteral' }\ninterface ListLiteral { type: 'ListLiteral', elements: Expression[] }\ninterface MapLiteral { type: 'MapLiteral', entries: MapEntry[] }\n```\n\n### Identifier Expressions\n```typescript\ninterface Identifier { type: 'Identifier', name: string }\ninterface Parameter { type: 'Parameter', name: string }\n```\n\n### Property Access\n```typescript\ninterface PropertyAccess { type: 'PropertyAccess', object: Expression, property: string }\ninterface DynamicPropertyAccess { type: 'DynamicPropertyAccess', object: Expression, property: Expression }\n```\n\n### Operators\n```typescript\ninterface BinaryExpression { type: 'BinaryExpression', operator: BinaryOperator, left: Expression, right: Expression }\ninterface UnaryExpression { type: 'UnaryExpression', operator: UnaryOperator, argument: Expression }\n```\n\n### Function Calls\n```typescript\ninterface FunctionCall { type: 'FunctionCall', name: string, args: Expression[], distinct?: boolean }\n```\n\n## Acceptance Criteria\n- [ ] All expression type tests written\n- [ ] Tests verify required properties\n- [ ] Tests verify discriminator values\n- [ ] Complete expression type coverage\n\n## TDD Phase: RED","status":"open","priority":1,"issue_type":"task","created_at":"2026-01-05T06:37:49.066724-06:00","updated_at":"2026-01-05T06:37:49.066724-06:00"}
{"id":"neo4j-vsy","title":"REFACTOR: Record.toObject() - Optimize object conversion","description":"## Overview\nRefactor the Record.toObject() implementation for better type safety.\n\n## Refactoring Tasks\n\n1. **Type Safety**\n   - Add proper return type generics\n   - Consider typed record definitions\n\n2. **Performance**\n   - Consider Object.fromEntries alternative\n   - Benchmark different approaches\n\n## Acceptance Criteria\n- [ ] All tests still pass after refactoring\n- [ ] Code is clean and well-documented\n- [ ] TypeScript types properly defined\n\n## TDD Phase\nREFACTOR - Improve code without changing behavior\n\n## Dependencies\n- neo4j-na4 (GREEN phase implementation)","status":"open","priority":1,"issue_type":"task","created_at":"2026-01-05T06:37:17.175661-06:00","updated_at":"2026-01-05T06:37:17.175661-06:00"}
{"id":"neo4j-w5n","title":"RED: Record.has(key) - Write failing tests for column existence check","description":"## Overview\nWrite failing tests for the Record.has(key) method that checks if a column exists.\n\n## Test Cases to Write\n\n```typescript\ndescribe('Record.has(key)', () =\u003e {\n  it('should return true for existing column', () =\u003e {\n    const record = new Record(['name', 'age'], ['Alice', 30]);\n    expect(record.has('name')).toBe(true);\n    expect(record.has('age')).toBe(true);\n  });\n\n  it('should return false for non-existent column', () =\u003e {\n    const record = new Record(['name'], ['Alice']);\n    expect(record.has('email')).toBe(false);\n    expect(record.has('missing')).toBe(false);\n  });\n\n  it('should be case-sensitive', () =\u003e {\n    const record = new Record(['Name'], ['Alice']);\n    expect(record.has('Name')).toBe(true);\n    expect(record.has('name')).toBe(false);\n  });\n\n  it('should return true even if value is null', () =\u003e {\n    const record = new Record(['email'], [null]);\n    expect(record.has('email')).toBe(true);\n  });\n\n  it('should return true even if value is undefined', () =\u003e {\n    const record = new Record(['value'], [undefined]);\n    expect(record.has('value')).toBe(true);\n  });\n\n  it('should handle empty string key', () =\u003e {\n    const record = new Record(['', 'name'], ['empty', 'Alice']);\n    expect(record.has('')).toBe(true);\n  });\n});\n```\n\n## Acceptance Criteria\n- [ ] All tests written and failing (RED phase)\n- [ ] Tests cover existence checks with various values\n- [ ] Tests verify case sensitivity\n- [ ] Test file created at src/result/__tests__/record-has.test.ts\n\n## TDD Phase\nRED - Tests should fail because has method does not exist yet","status":"open","priority":1,"issue_type":"task","created_at":"2026-01-05T06:38:57.175041-06:00","updated_at":"2026-01-05T06:38:57.175041-06:00"}
{"id":"neo4j-wef","title":"GREEN: Variable-Length Path Translation - Recursive CTEs","description":"## Overview\nImplement variable-length path translation using recursive CTEs.\n\n## Implementation Tasks\n\n### 1. Recursive CTE Generator\n```typescript\nclass RecursiveCTEGenerator {\n  generate(pattern: VariableLengthPattern): string {\n    const { minHops, maxHops, relType, direction } = pattern;\n    \n    return `\n      WITH RECURSIVE path_cte AS (\n        -- Base case: starting nodes\n        SELECT id, id as current, 0 as depth, \n               JSON_ARRAY(id) as visited,\n               JSON_ARRAY(id) as path_nodes\n        FROM nodes\n        WHERE ${startCondition}\n        \n        UNION ALL\n        \n        -- Recursive case: follow relationships\n        SELECT p.id, r.end_node_id, p.depth + 1,\n               JSON_INSERT(p.visited, '$[#]', r.end_node_id),\n               JSON_INSERT(p.path_nodes, '$[#]', r.end_node_id)\n        FROM path_cte p\n        JOIN relationships r ON p.current = r.start_node_id\n        WHERE p.depth \u003c ${maxHops}\n          AND NOT JSON_CONTAINS(p.visited, r.end_node_id)\n          ${typeFilter}\n      )\n    `;\n  }\n}\n```\n\n### 2. Depth Bound Handler\n```typescript\nclass DepthBoundHandler {\n  getDepthCondition(min?: number, max?: number): string {\n    if (min \u0026\u0026 max) return `depth \u003e= ${min} AND depth \u003c= ${max}`;\n    if (min) return `depth \u003e= ${min}`;\n    if (max) return `depth \u003c= ${max}`;\n    return 'TRUE'; // Unlimited (with reasonable default limit)\n  }\n}\n```\n\n### 3. Cycle Detection\n```typescript\nclass CycleDetector {\n  getVisitedCheck(visitedColumn: string, newNodeId: string): string {\n    return `NOT EXISTS (\n      SELECT 1 FROM JSON_EACH(${visitedColumn}) \n      WHERE value = ${newNodeId}\n    )`;\n  }\n}\n```\n\n### 4. Exact Depth Optimizer\n```typescript\n// For exact depths, use chained JOINs instead of CTE\nclass ExactDepthTranslator {\n  translate(depth: number): string {\n    // Generate n-level JOINs for better performance\n  }\n}\n```\n\n## Files to Create/Modify\n- `src/cypher/translator/recursive-cte-generator.ts`\n- `src/cypher/translator/depth-bound-handler.ts`\n- `src/cypher/translator/cycle-detector.ts`\n\n## Acceptance Criteria\n- [ ] All RED phase tests pass\n- [ ] Cycle detection prevents infinite loops\n- [ ] Bounded paths optimized\n\n## TDD Phase\nGREEN - Make tests pass with minimal code\n\n## Dependencies\n- Depends on: RED: Variable-Length Path Translation - Recursive CTEs","status":"open","priority":2,"issue_type":"task","created_at":"2026-01-05T06:36:39.287449-06:00","updated_at":"2026-01-05T06:36:39.287449-06:00"}
{"id":"neo4j-wjo6","title":"[REFACTOR] Label Management - Optimize indexing strategies","description":"## Overview\nRefactor label management for better query performance.\n\n## Refactoring Tasks\n\n### Label Index Table\n```sql\n-- Dedicated index table for faster label queries\nCREATE TABLE IF NOT EXISTS label_index (\n  label TEXT NOT NULL,\n  node_id INTEGER NOT NULL REFERENCES nodes(id) ON DELETE CASCADE,\n  PRIMARY KEY (label, node_id)\n);\n\nCREATE INDEX idx_label_index_label ON label_index(label);\nCREATE INDEX idx_label_index_node ON label_index(node_id);\n```\n\n### Synchronized Updates\n```typescript\naddLabel(nodeId: number, label: string): void {\n  this.sql.transaction(() =\u003e {\n    // Update JSON array\n    this.updateLabelArray(nodeId, label, 'add');\n    // Update index table\n    this.sql.exec(\n      'INSERT OR IGNORE INTO label_index (label, node_id) VALUES (?, ?)',\n      label, nodeId\n    );\n  });\n}\n\nremoveLabel(nodeId: number, label: string): void {\n  this.sql.transaction(() =\u003e {\n    this.updateLabelArray(nodeId, label, 'remove');\n    this.sql.exec(\n      'DELETE FROM label_index WHERE label = ? AND node_id = ?',\n      label, nodeId\n    );\n  });\n}\n```\n\n### Optimized Queries\n```typescript\n// Fast label-based node lookup\ngetNodesByLabel(label: string): Node[] {\n  return this.sql.exec(`\n    SELECT n.* FROM nodes n\n    JOIN label_index li ON n.id = li.node_id\n    WHERE li.label = ?\n  `, label).toArray().map(this.rowToNode);\n}\n\n// Multi-label queries\ngetNodesByLabels(labels: string[], mode: 'all' | 'any'): Node[] {\n  if (mode === 'all') {\n    // Nodes with ALL specified labels\n    return this.sql.exec(`\n      SELECT n.* FROM nodes n\n      WHERE (SELECT COUNT(DISTINCT label) FROM label_index WHERE node_id = n.id AND label IN (${labels.map(() =\u003e '?').join(',')})) = ?\n    `, ...labels, labels.length).toArray().map(this.rowToNode);\n  }\n  // Nodes with ANY specified labels\n}\n```\n\n### Code Quality\n- Add index maintenance utilities\n- Create index consistency checker\n- Add label statistics gathering\n- Implement label cardinality estimation\n\n## Acceptance Criteria\n- [ ] All tests still pass\n- [ ] Label queries are fast\n- [ ] Index maintained consistently\n- [ ] Multi-label queries supported\n- [ ] Code well-documented\n\n## TDD Phase\n**REFACTOR** - Improve without changing behavior","status":"open","priority":2,"issue_type":"task","created_at":"2026-01-05T06:39:32.258025-06:00","updated_at":"2026-01-05T06:39:32.258025-06:00"}
{"id":"neo4j-xb7","title":"[RED] Temporal Types - Write Failing Tests","description":"## Overview\nWrite comprehensive failing tests for all Neo4j Temporal types before implementation.\n\n## TDD Phase: RED (Write Failing Tests)\n\n### Types to Test\n\n#### 1. Date (date without time)\n```typescript\n// Construction\nnew Date(year, month, day)\nDate.fromStandardDate(standardDate)\n\n// Properties\ndate.year, date.month, date.day\n\n// Methods\ndate.toString() // ISO format: 'YYYY-MM-DD'\ndate.toStandardDate()\n```\n\n#### 2. Time (time with timezone offset)\n```typescript\n// Construction\nnew Time(hour, minute, second, nanosecond, timeZoneOffsetSeconds)\nTime.fromStandardDate(standardDate)\n\n// Properties\ntime.hour, time.minute, time.second\ntime.nanosecond, time.timeZoneOffsetSeconds\n\n// Methods\ntime.toString() // ISO format: 'HH:MM:SS.nnnnnnnnn+HH:MM'\n```\n\n#### 3. LocalTime (time without timezone)\n```typescript\n// Construction\nnew LocalTime(hour, minute, second, nanosecond)\nLocalTime.fromStandardDate(standardDate)\n\n// Properties\nlocalTime.hour, localTime.minute, localTime.second, localTime.nanosecond\n\n// Methods\nlocalTime.toString() // ISO format: 'HH:MM:SS.nnnnnnnnn'\n```\n\n#### 4. DateTime (date + time + timezone)\n```typescript\n// Construction\nnew DateTime(year, month, day, hour, minute, second, nanosecond, timeZoneOffsetSeconds, timeZoneId?)\nDateTime.fromStandardDate(standardDate)\n\n// Properties\nAll date + time properties plus timeZoneId\n\n// Methods\ndateTime.toString() // ISO 8601 format\ndateTime.toStandardDate()\n```\n\n#### 5. LocalDateTime (date + time without timezone)\n```typescript\n// Construction\nnew LocalDateTime(year, month, day, hour, minute, second, nanosecond)\nLocalDateTime.fromStandardDate(standardDate)\n\n// Properties\nAll date + time properties (no timezone)\n\n// Methods\nlocalDateTime.toString()\nlocalDateTime.toStandardDate()\n```\n\n#### 6. Duration (time span)\n```typescript\n// Construction\nnew Duration(months, days, seconds, nanoseconds)\n\n// Properties\nduration.months, duration.days, duration.seconds, duration.nanoseconds\n\n// Methods\nduration.toString() // ISO 8601 duration format\n```\n\n### Test Categories for Each Type\n\n1. **Construction Tests**\n   - From components\n   - From ISO string\n   - From JavaScript Date\n   - Invalid input handling\n\n2. **Property Access Tests**\n   - All properties readable\n   - Properties are readonly\n   - Correct types\n\n3. **Serialization Tests**\n   - toString() format matches Neo4j\n   - JSON serialization\n   - Round-trip parsing\n\n4. **Edge Cases**\n   - Leap years\n   - Month boundaries\n   - Nanosecond precision\n   - Timezone edge cases (DST, etc.)\n\n5. **Type Guards**\n   - `neo4j.isDate()`\n   - `neo4j.isTime()`\n   - `neo4j.isLocalTime()`\n   - `neo4j.isDateTime()`\n   - `neo4j.isLocalDateTime()`\n   - `neo4j.isDuration()`\n\n### Acceptance Criteria\n- [ ] All tests written and failing (RED state)\n- [ ] Tests match neo4j-driver API exactly\n- [ ] Edge cases covered for each type\n- [ ] Test files at `src/types/temporal/*.test.ts`\n\n### References\n- [neo4j-driver Temporal Types](https://neo4j.com/docs/api/javascript-driver/current/)","status":"open","priority":1,"issue_type":"task","created_at":"2026-01-05T06:35:39.293002-06:00","updated_at":"2026-01-05T06:35:39.293002-06:00"}
{"id":"neo4j-xm9","title":"GREEN: Implement rxSession.executeRead() method","description":"## Overview\nImplement `rxSession.executeRead()` to make all RED tests pass.\n\n## Implementation Requirements\n\n### Method Signature\n```typescript\ninterface RxSession {\n  executeRead\u003cT\u003e(\n    work: (tx: RxManagedTransaction) =\u003e Observable\u003cT\u003e\n  ): Observable\u003cT\u003e\n}\n```\n\n### Implementation Details\n- Create managed transaction with READ mode\n- Execute work function with transaction\n- Auto-commit on successful completion\n- Auto-rollback on error\n- Handle retry logic for transient errors\n\n### Observable Chain\n- Wrap transaction lifecycle in Observable\n- Chain work function result\n- Proper error handling and propagation\n\n## Acceptance Criteria\n- [ ] All RED tests now pass (GREEN phase)\n- [ ] Transaction lifecycle correct\n- [ ] Retry logic works\n- [ ] Observable semantics proper","status":"open","priority":2,"issue_type":"task","created_at":"2026-01-05T06:35:45.824171-06:00","updated_at":"2026-01-05T06:35:45.824171-06:00"}
{"id":"neo4j-xt0","title":"CI/CD pipeline (GitHub Actions)","description":"# CI/CD Pipeline with GitHub Actions\n\n## Overview\nSet up GitHub Actions workflows for continuous integration and deployment of the neo4j.do project.\n\n## Workflows to Create\n\n### 1. CI Workflow (.github/workflows/ci.yml)\nTriggers: push to main, pull requests\n\nJobs:\n- **lint**: Run ESLint and Prettier checks\n- **typecheck**: Run TypeScript type checking\n- **test**: Run test suite with coverage\n- **build**: Build the package\n\n```yaml\nname: CI\n\non:\n  push:\n    branches: [main]\n  pull_request:\n    branches: [main]\n\njobs:\n  lint:\n    runs-on: ubuntu-latest\n    steps:\n      - uses: actions/checkout@v4\n      - uses: actions/setup-node@v4\n        with:\n          node-version: '20'\n          cache: 'npm'\n      - run: npm ci\n      - run: npm run lint\n      - run: npm run format:check\n\n  typecheck:\n    runs-on: ubuntu-latest\n    steps:\n      - uses: actions/checkout@v4\n      - uses: actions/setup-node@v4\n        with:\n          node-version: '20'\n          cache: 'npm'\n      - run: npm ci\n      - run: npm run typecheck\n\n  test:\n    runs-on: ubuntu-latest\n    steps:\n      - uses: actions/checkout@v4\n      - uses: actions/setup-node@v4\n        with:\n          node-version: '20'\n          cache: 'npm'\n      - run: npm ci\n      - run: npm run test:coverage\n      - uses: codecov/codecov-action@v3\n\n  build:\n    runs-on: ubuntu-latest\n    needs: [lint, typecheck, test]\n    steps:\n      - uses: actions/checkout@v4\n      - uses: actions/setup-node@v4\n        with:\n          node-version: '20'\n          cache: 'npm'\n      - run: npm ci\n      - run: npm run build\n```\n\n### 2. Release Workflow (.github/workflows/release.yml)\nTriggers: version tags (v*)\n\n- Build package\n- Publish to npm\n- Deploy to Cloudflare Workers\n- Create GitHub release\n\n### 3. Compatibility Test Workflow\n- Run against real Neo4j instance\n- Run OpenCypher TCK tests\n\n## Acceptance Criteria\n- [ ] CI workflow runs on all PRs\n- [ ] Tests must pass before merge\n- [ ] Coverage reports uploaded\n- [ ] Build artifacts verified\n- [ ] Release workflow documented","status":"open","priority":1,"issue_type":"task","created_at":"2026-01-05T06:35:53.015174-06:00","updated_at":"2026-01-05T06:35:53.015174-06:00"}
{"id":"neo4j-xv2","title":"GREEN: AI Functions in Cypher - Implement Workers AI integration","description":"## Overview\nImplement AI-powered functions in Cypher using Workers AI.\n\n## Implementation Requirements\n\n### Core Components\n\n#### 1. AI Function Registry\n```typescript\ninterface AIFunction {\n  name: string;\n  handler: (args: any[], options: Record\u003cstring, any\u003e) =\u003e Promise\u003cany\u003e;\n  schema: {\n    args: JSONSchema[];\n    options?: JSONSchema;\n    returns: JSONSchema;\n  };\n}\n\nclass AIFunctionRegistry {\n  private functions = new Map\u003cstring, AIFunction\u003e();\n  \n  register(fn: AIFunction): void;\n  get(name: string): AIFunction | undefined;\n  execute(name: string, args: any[], options?: Record\u003cstring, any\u003e): Promise\u003cany\u003e;\n}\n```\n\n#### 2. Workers AI Service\n```typescript\nclass WorkersAIService {\n  constructor(private ai: Ai) {}\n\n  async embed(text: string, model?: string): Promise\u003cnumber[]\u003e {\n    const result = await this.ai.run(model ?? '@cf/baai/bge-m3', {\n      text: [text]\n    });\n    return result.data[0];\n  }\n\n  async embedBatch(texts: string[], model?: string): Promise\u003cnumber[][]\u003e {\n    const result = await this.ai.run(model ?? '@cf/baai/bge-m3', {\n      text: texts\n    });\n    return result.data;\n  }\n\n  async generate(prompt: string, options?: GenerateOptions): Promise\u003cstring\u003e {\n    const result = await this.ai.run(options?.model ?? '@cf/meta/llama-3.1-8b-instruct', {\n      prompt,\n      max_tokens: options?.maxTokens ?? 256,\n      temperature: options?.temperature ?? 0.7\n    });\n    return result.response;\n  }\n\n  async classify(text: string, categories: string[]): Promise\u003cClassifyResult\u003e {\n    // Use text generation with constrained output\n    // or dedicated classification model\n  }\n\n  async extract(text: string, schema: Record\u003cstring, string\u003e): Promise\u003cRecord\u003cstring, any\u003e\u003e {\n    // Use structured generation\n  }\n}\n```\n\n#### 3. Function Implementations\n```typescript\n// $ai.embed(text, options?)\nconst embedFunction: AIFunction = {\n  name: 'embed',\n  async handler([text], options) {\n    return aiService.embed(text, options?.model);\n  },\n  schema: {\n    args: [{ type: 'string' }],\n    options: { \n      type: 'object',\n      properties: { model: { type: 'string' } }\n    },\n    returns: { type: 'array', items: { type: 'number' } }\n  }\n};\n\n// $ai.generate(prompt, options?)\nconst generateFunction: AIFunction = {\n  name: 'generate',\n  async handler([prompt], options) {\n    return aiService.generate(prompt, options);\n  },\n  schema: {\n    args: [{ type: 'string' }],\n    options: {\n      type: 'object',\n      properties: {\n        model: { type: 'string' },\n        maxTokens: { type: 'number' },\n        temperature: { type: 'number' }\n      }\n    },\n    returns: { type: 'string' }\n  }\n};\n\n// $ai.classify(text, categories)\nconst classifyFunction: AIFunction = {\n  name: 'classify',\n  async handler([text, categories]) {\n    return aiService.classify(text, categories);\n  },\n  schema: {\n    args: [\n      { type: 'string' },\n      { type: 'array', items: { type: 'string' } }\n    ],\n    returns: {\n      type: 'object',\n      properties: {\n        label: { type: 'string' },\n        score: { type: 'number' }\n      }\n    }\n  }\n};\n\n// $ai.extract(text, schema)\nconst extractFunction: AIFunction = {\n  name: 'extract',\n  async handler([text, schema]) {\n    return aiService.extract(text, schema);\n  },\n  schema: {\n    args: [\n      { type: 'string' },\n      { type: 'object' }\n    ],\n    returns: { type: 'object' }\n  }\n};\n\n// $ai.similarity(vec1, vec2)\nconst similarityFunction: AIFunction = {\n  name: 'similarity',\n  async handler([vec1, vec2]) {\n    return cosineSimilarity(vec1, vec2);\n  },\n  schema: {\n    args: [\n      { type: 'array', items: { type: 'number' } },\n      { type: 'array', items: { type: 'number' } }\n    ],\n    returns: { type: 'number' }\n  }\n};\n```\n\n#### 4. Cypher Integration\n```typescript\n// In Cypher executor, detect $ai.xxx calls and execute\nclass CypherAIInterceptor {\n  async processExpression(expr: Expression): Promise\u003cany\u003e {\n    if (expr.type === 'FunctionCall' \u0026\u0026 expr.name.startsWith('$ai.')) {\n      const fnName = expr.name.slice(4); // Remove '$ai.'\n      const args = await Promise.all(expr.args.map(a =\u003e this.evaluate(a)));\n      const options = expr.options ? await this.evaluate(expr.options) : undefined;\n      return this.registry.execute(fnName, args, options);\n    }\n    // ... normal processing\n  }\n}\n```\n\n### Batching Optimization\n```typescript\nclass AIBatchProcessor {\n  private embedQueue: Map\u003cstring, Promise\u003cnumber[]\u003e\u003e = new Map();\n  \n  async embedWithDedup(text: string): Promise\u003cnumber[]\u003e {\n    if (this.embedQueue.has(text)) {\n      return this.embedQueue.get(text)\\!;\n    }\n    \n    const promise = this.processBatch(text);\n    this.embedQueue.set(text, promise);\n    return promise;\n  }\n}\n```\n\n## Acceptance Criteria\n- [ ] All RED phase tests passing\n- [ ] All AI functions implemented\n- [ ] Batching working for efficiency\n- [ ] Error handling comprehensive\n\n## Dependencies\n- RED: AI Functions tests\n- Workers AI binding\n\n## Tags\nsuperset, ai-functions, workers-ai, cypher, tdd-green","status":"open","priority":2,"issue_type":"task","created_at":"2026-01-05T06:39:00.997758-06:00","updated_at":"2026-01-05T06:39:00.997758-06:00"}
{"id":"neo4j-yi6","title":"GREEN: Transaction Class Core Operations Implementation","description":"## Overview\nImplement Transaction class core operations to pass all RED phase tests.\n\n## Implementation Requirements\n\n### Transaction Class\n```typescript\nclass Transaction {\n  private session: Session\n  private state: TransactionState = 'OPEN'\n  private txId: number\n  private queries: QueryHandle[] = []\n\n  constructor(session: Session, config?: TransactionConfig) {\n    this.session = session\n    this.txId = generateTransactionId()\n  }\n\n  isOpen(): boolean {\n    return this.state === 'OPEN'\n  }\n}\n\ntype TransactionState = 'OPEN' | 'COMMITTED' | 'ROLLED_BACK' | 'FAILED'\n```\n\n### run() Method\n```typescript\nasync run(cypher: string, params?: Record\u003cstring, any\u003e): Promise\u003cResult\u003e {\n  this.ensureOpen()\n  \n  const result = await this.session._executeInTransaction(\n    this.txId,\n    cypher,\n    params\n  )\n  \n  return result\n}\n\nprivate ensureOpen(): void {\n  if (this.state \\!== 'OPEN') {\n    throw new TransactionClosed(`Transaction is ${this.state.toLowerCase()}`)\n  }\n}\n```\n\n### commit() Method\n```typescript\nasync commit(): Promise\u003cvoid\u003e {\n  if (this.state === 'COMMITTED') return\n  \n  if (this.state \\!== 'OPEN') {\n    throw new TransactionClosed('Cannot commit: transaction is not open')\n  }\n\n  try {\n    await this.session._commitTransaction(this.txId)\n    this.state = 'COMMITTED'\n    // Generate and update bookmark\n    const bookmark = generateBookmark(this.session.database, this.txId)\n    this.session._updateBookmarks(bookmark)\n  } catch (error) {\n    this.state = 'FAILED'\n    throw error\n  }\n}\n```\n\n### rollback() Method\n```typescript\nasync rollback(): Promise\u003cvoid\u003e {\n  if (this.state === 'ROLLED_BACK' || this.state === 'COMMITTED') return\n  \n  try {\n    await this.session._rollbackTransaction(this.txId)\n  } finally {\n    this.state = 'ROLLED_BACK'\n  }\n}\n```\n\n## Files to Create/Modify\n- `src/transaction/transaction.ts`\n- `src/transaction/types.ts`\n- `src/errors/transaction-closed.ts`\n\n## TDD Phase\n**GREEN** - Implement to pass tests.\n\n## Dependencies\n- Depends on: RED: Transaction Class Core Operations Tests\n- Depends on: GREEN: Session Bookmarks \u0026 Lifecycle Implementation\n\n## Acceptance Criteria\n- [ ] All RED phase tests pass\n- [ ] ACID properties maintained\n- [ ] State transitions are correct\n- [ ] Proper error handling","status":"open","priority":1,"issue_type":"task","created_at":"2026-01-05T06:38:28.895111-06:00","updated_at":"2026-01-05T06:38:28.895111-06:00"}
{"id":"neo4j-yxe","title":"[RED] Spatial Types (Point) - Write Failing Tests","description":"## Overview\nWrite comprehensive failing tests for the Neo4j Point spatial type before implementation.\n\n## TDD Phase: RED (Write Failing Tests)\n\n### Test Cases to Write\n\n#### Point Construction\n```typescript\n// 2D Cartesian point\nnew Point(7203, x, y)\n\n// 3D Cartesian point\nnew Point(9157, x, y, z)\n\n// 2D Geographic point (WGS 84)\nnew Point(4326, longitude, latitude)\n\n// 3D Geographic point (WGS 84 + height)\nnew Point(4979, longitude, latitude, height)\n```\n\n#### SRID Constants\n- `SRID.CARTESIAN_2D = 7203`\n- `SRID.CARTESIAN_3D = 9157`\n- `SRID.WGS84_2D = 4326`\n- `SRID.WGS84_3D = 4979`\n\n#### Property Access\n```typescript\npoint.srid        // Spatial Reference ID\npoint.x           // X coordinate / Longitude\npoint.y           // Y coordinate / Latitude\npoint.z           // Z coordinate / Height (undefined for 2D)\n```\n\n#### Type Guard\n```typescript\nneo4j.isPoint(point)  // true for Point instances\nneo4j.isPoint({})     // false for plain objects\nneo4j.isPoint(null)   // false for null\n```\n\n#### Serialization\n```typescript\npoint.toString()      // String representation\nJSON.stringify(point) // JSON serialization\n```\n\n#### Factory Function\n```typescript\nneo4j.types.Point     // Point class export\n```\n\n### Edge Cases to Test\n- [ ] Invalid SRID values\n- [ ] Missing required coordinates\n- [ ] Z coordinate for 2D points (should be undefined)\n- [ ] Coordinate boundary values\n- [ ] NaN and Infinity coordinates\n- [ ] Geographic coordinate ranges (-180 to 180, -90 to 90)\n\n### Test File Structure\n```\nsrc/types/spatial/\n  point.test.ts\n  srid.test.ts\n```\n\n### Acceptance Criteria\n- [ ] All tests written and failing (RED state)\n- [ ] Tests match neo4j-driver Point API\n- [ ] All SRID types covered\n- [ ] Both 2D and 3D variants tested\n- [ ] Edge cases documented\n\n### References\n- [Neo4j Spatial Types](https://neo4j.com/docs/cypher-manual/current/syntax/spatial/)","status":"open","priority":1,"issue_type":"task","created_at":"2026-01-05T06:36:53.218634-06:00","updated_at":"2026-01-05T06:36:53.218634-06:00"}
{"id":"neo4j-zgu","title":"REFACTOR: Vector Search - Optimize search performance and add advanced features","description":"## Overview\nRefactor vector search implementation for optimal performance and enhanced features.\n\n## Refactoring Goals\n\n### 1. Performance Optimization\n- Implement approximate nearest neighbor (ANN) tuning\n- Add query result caching with TTL\n- Optimize metadata filtering in Vectorize\n- Batch vector upserts for bulk operations\n\n### 2. Advanced Query Features\n```typescript\ninterface AdvancedSearchOptions {\n  // Re-ranking with cross-encoder\n  rerank?: {\n    enabled: boolean;\n    model?: string;\n    topK?: number; // Re-rank top K from initial results\n  };\n  \n  // Diversity sampling\n  diversity?: {\n    enabled: boolean;\n    lambda?: number; // MMR lambda parameter\n  };\n  \n  // Fusion with keyword search\n  fusion?: {\n    enabled: boolean;\n    keywordWeight?: number;\n    vectorWeight?: number;\n  };\n}\n```\n\n### 3. Index Management\n- Background index rebuilding\n- Index statistics and health checks\n- Automatic dimension inference\n- Index migration utilities\n\n### 4. Monitoring \u0026 Observability\n- Search latency metrics\n- Index size tracking\n- Query analytics (popular queries, zero-result queries)\n- Vectorize quota monitoring\n\n### 5. Code Quality\n- Extract search strategy pattern\n- Add comprehensive error types\n- Implement retry logic for Vectorize calls\n- Add structured logging\n\n## Tasks\n- [ ] Implement query result caching\n- [ ] Add re-ranking support\n- [ ] Create MMR diversity sampling\n- [ ] Build hybrid fusion search\n- [ ] Add index health monitoring\n- [ ] Create migration utilities\n- [ ] Performance benchmark suite\n\n## Acceptance Criteria\n- [ ] All tests still passing\n- [ ] \u003c 50ms p99 latency for cached queries\n- [ ] Re-ranking improving relevance metrics\n- [ ] Comprehensive monitoring dashboard\n\n## Tags\nsuperset, vector-search, vectorize, tdd-refactor, performance","status":"open","priority":3,"issue_type":"task","created_at":"2026-01-05T06:36:42.054881-06:00","updated_at":"2026-01-05T06:36:42.054881-06:00"}
{"id":"neo4j-zofo","title":"[RED] Cypher Query Result Validation Tests","description":"# [RED] Cypher Query Result Validation Tests\n\n## Overview\nCreate comprehensive tests for validating that Cypher query results are correctly structured and contain accurate data.\n\n## Result Structure Tests\n\n### Record Structure\n```typescript\ndescribe('Record Structure Validation', () =\u003e {\n  it('should return records with correct field access', async () =\u003e {\n    const result = await session.run('RETURN 1 AS num, \"hello\" AS str')\n    const record = result.records[0]\n    \n    // Named access\n    expect(record.get('num')).toBeDefined()\n    expect(record.get('str')).toBeDefined()\n    \n    // Index access\n    expect(record.get(0)).toBeDefined()\n    expect(record.get(1)).toBeDefined()\n    \n    // Keys\n    expect(record.keys).toEqual(['num', 'str'])\n    \n    // Values\n    expect(record.values()).toHaveLength(2)\n    \n    // toObject\n    expect(record.toObject()).toEqual({ num: expect.any(Object), str: 'hello' })\n  })\n\n  it('should handle missing field access', async () =\u003e {\n    const result = await session.run('RETURN 1 AS num')\n    const record = result.records[0]\n    \n    expect(() =\u003e record.get('nonexistent')).toThrow()\n    expect(record.has('num')).toBe(true)\n    expect(record.has('nonexistent')).toBe(false)\n  })\n})\n```\n\n### Node Result Validation\n```typescript\ndescribe('Node Result Validation', () =\u003e {\n  it('should return node with all properties', async () =\u003e {\n    await session.run('CREATE (n:Person {name: \"Alice\", age: 30})')\n    const result = await session.run('MATCH (n:Person {name: \"Alice\"}) RETURN n')\n    const node = result.records[0].get('n')\n    \n    expect(node.labels).toContain('Person')\n    expect(node.properties.name).toBe('Alice')\n    expect(node.properties.age.toInt()).toBe(30)\n    expect(node.identity).toBeDefined()\n    expect(node.elementId).toBeDefined()\n  })\n\n  it('should handle multi-label nodes', async () =\u003e {\n    await session.run('CREATE (n:Person:Employee {name: \"Bob\"})')\n    const result = await session.run('MATCH (n:Person:Employee) RETURN n')\n    const node = result.records[0].get('n')\n    \n    expect(node.labels).toContain('Person')\n    expect(node.labels).toContain('Employee')\n  })\n})\n```\n\n### Relationship Result Validation\n```typescript\ndescribe('Relationship Result Validation', () =\u003e {\n  it('should return relationship with all properties', async () =\u003e {\n    await session.run(`\n      CREATE (a:Person {name: \"Alice\"})-[r:KNOWS {since: 2020}]-\u003e(b:Person {name: \"Bob\"})\n    `)\n    const result = await session.run('MATCH ()-[r:KNOWS]-\u003e() RETURN r')\n    const rel = result.records[0].get('r')\n    \n    expect(rel.type).toBe('KNOWS')\n    expect(rel.properties.since.toInt()).toBe(2020)\n    expect(rel.start).toBeDefined()\n    expect(rel.end).toBeDefined()\n    expect(rel.identity).toBeDefined()\n    expect(rel.elementId).toBeDefined()\n  })\n})\n```\n\n### Path Result Validation\n```typescript\ndescribe('Path Result Validation', () =\u003e {\n  it('should return path with segments', async () =\u003e {\n    await session.run(`\n      CREATE (a:Person {name: \"A\"})-[:KNOWS]-\u003e(b:Person {name: \"B\"})-[:KNOWS]-\u003e(c:Person {name: \"C\"})\n    `)\n    const result = await session.run('MATCH p=(a)-[*]-\u003e(c) WHERE a.name = \"A\" RETURN p')\n    const path = result.records[0].get('p')\n    \n    expect(path.start).toBeDefined()\n    expect(path.end).toBeDefined()\n    expect(path.segments).toHaveLength(2)\n    expect(path.length).toBe(2)\n  })\n})\n```\n\n### Aggregation Result Validation\n```typescript\ndescribe('Aggregation Result Validation', () =\u003e {\n  beforeEach(async () =\u003e {\n    await session.run(`\n      CREATE (:Product {price: 10}),\n             (:Product {price: 20}),\n             (:Product {price: 30})\n    `)\n  })\n\n  it('should validate count results', async () =\u003e {\n    const result = await session.run('MATCH (p:Product) RETURN count(p) AS count')\n    expect(result.records[0].get('count').toInt()).toBe(3)\n  })\n\n  it('should validate sum results', async () =\u003e {\n    const result = await session.run('MATCH (p:Product) RETURN sum(p.price) AS total')\n    expect(result.records[0].get('total').toInt()).toBe(60)\n  })\n\n  it('should validate collect results', async () =\u003e {\n    const result = await session.run('MATCH (p:Product) RETURN collect(p.price) AS prices')\n    const prices = result.records[0].get('prices').map((p: any) =\u003e p.toInt())\n    expect(prices).toHaveLength(3)\n    expect(prices).toContain(10)\n    expect(prices).toContain(20)\n    expect(prices).toContain(30)\n  })\n})\n```\n\n## Summary Validation\n```typescript\ndescribe('Result Summary Validation', () =\u003e {\n  it('should include query statistics', async () =\u003e {\n    const result = await session.run('CREATE (n:Test) RETURN n')\n    \n    expect(result.summary.counters.nodesCreated()).toBe(1)\n    expect(result.summary.counters.labelsAdded()).toBe(1)\n    expect(result.summary.query.text).toBe('CREATE (n:Test) RETURN n')\n  })\n\n  it('should include timing information', async () =\u003e {\n    const result = await session.run('MATCH (n) RETURN n LIMIT 10')\n    \n    expect(result.summary.resultAvailableAfter).toBeDefined()\n    expect(result.summary.resultConsumedAfter).toBeDefined()\n  })\n\n  it('should include plan when profiled', async () =\u003e {\n    const result = await session.run('PROFILE MATCH (n) RETURN n')\n    \n    expect(result.summary.plan).toBeDefined()\n    expect(result.summary.profile).toBeDefined()\n  })\n})\n```\n\n## Acceptance Criteria\n- [ ] Record structure tests written\n- [ ] Node validation tests written\n- [ ] Relationship validation tests written\n- [ ] Path validation tests written\n- [ ] Aggregation validation tests written\n- [ ] Summary validation tests written\n- [ ] Tests fail initially (RED phase)","status":"open","priority":2,"issue_type":"task","created_at":"2026-01-05T06:39:27.493941-06:00","updated_at":"2026-01-05T06:39:27.493941-06:00"}
