/**
 * Neo4j Transaction
 * Compatible with neo4j-driver npm package
 */

import { Result, Record as Neo4jRecord } from '../result'
import { ResultSummary as ResultSummaryImpl } from '../result/result-summary'
import type { TransactionConfig, RecordShape } from '../types'

export type TransactionState = 'open' | 'committed' | 'rolled_back' | 'failed'

type QueryParameters = { [key: string]: unknown }
type QueryResultData = { keys: string[]; records: unknown[][]; summary: ResultSummaryImpl }

/**
 * Base Transaction interface for managed transactions
 * This provides a subset of Transaction methods for use in executeRead/executeWrite
 */
export interface ManagedTransaction {
  run<T extends RecordShape = RecordShape>(query: string, parameters?: QueryParameters): Result<T>
}

/**
 * Neo4j Transaction - represents a database transaction
 */
export class Transaction implements ManagedTransaction {
  private _state: TransactionState = 'open'
  private readonly _config: TransactionConfig
  private readonly _database: string
  private readonly _bookmarks: string[]
  private _lastBookmark: string | null = null
  private readonly _executeQuery: (
    query: string,
    parameters?: QueryParameters
  ) => Promise<QueryResultData>
  private readonly _commitFn: () => Promise<string | null>
  private readonly _rollbackFn: () => Promise<void>

  constructor(
    database: string,
    bookmarks: string[],
    config: TransactionConfig,
    executeQuery: (
      query: string,
      parameters?: QueryParameters
    ) => Promise<QueryResultData>,
    commitFn: () => Promise<string | null>,
    rollbackFn: () => Promise<void>
  ) {
    this._database = database
    this._bookmarks = bookmarks
    this._config = config
    this._executeQuery = executeQuery
    this._commitFn = commitFn
    this._rollbackFn = rollbackFn
  }

  /**
   * Run a Cypher query within this transaction
   */
  run<T extends RecordShape = RecordShape>(query: string, parameters?: QueryParameters): Result<T> {
    if (this._state !== 'open') {
      const result = new Result<T>()
      result._setError(
        new Error(`Cannot run query on transaction with state "${this._state}"`)
      )
      return result
    }

    const result = new Result<T>()

    // Execute query asynchronously
    this._executeQuery(query, parameters)
      .then(({ keys, records, summary }) => {
        result._setKeys(keys)
        for (const values of records) {
          result._pushRecord(new Neo4jRecord<T>(keys, values))
        }
        result._setSummary(summary)
      })
      .catch((error) => {
        this._state = 'failed'
        result._setError(error instanceof Error ? error : new Error(String(error)))
      })

    return result
  }

  /**
   * Commit this transaction
   */
  async commit(): Promise<void> {
    if (this._state !== 'open') {
      throw new Error(`Cannot commit transaction with state "${this._state}"`)
    }

    try {
      this._lastBookmark = await this._commitFn()
      this._state = 'committed'
    } catch (error) {
      this._state = 'failed'
      throw error
    }
  }

  /**
   * Rollback this transaction
   */
  async rollback(): Promise<void> {
    if (this._state !== 'open') {
      throw new Error(`Cannot rollback transaction with state "${this._state}"`)
    }

    try {
      await this._rollbackFn()
      this._state = 'rolled_back'
    } catch (error) {
      this._state = 'failed'
      throw error
    }
  }

  /**
   * Check if this transaction is still open
   */
  isOpen(): boolean {
    return this._state === 'open'
  }

  /**
   * Close this transaction (rollback if still open)
   */
  async close(): Promise<void> {
    if (this._state === 'open') {
      await this.rollback()
    }
  }

  /**
   * Get the database this transaction operates on
   */
  get database(): string {
    return this._database
  }

  /**
   * Get the bookmarks used to start this transaction
   */
  get bookmarks(): string[] {
    return [...this._bookmarks]
  }

  /**
   * Get the bookmark generated by this transaction (after commit)
   */
  get lastBookmark(): string | null {
    return this._lastBookmark
  }

  /**
   * Get the current state of this transaction
   */
  get state(): TransactionState {
    return this._state
  }

  /**
   * Get the transaction configuration
   */
  get config(): TransactionConfig {
    return this._config
  }
}
